{"translation": {"code": "public static PlaneNormal3D_F64 convert ( Se3_F64 planeToWorld , PlaneNormal3D_F64 output ) { if ( output == null ) output = new PlaneNormal3D_F64 ( ) ; // the value of input is a vector normal to the plane and a point on the plane. output . n . x = planeToWorld . R . unsafe_get ( 0 , 2 ) ; output . n . y = planeToWorld . R . unsafe_get ( 1 , 2 ) ; output . n . z = planeToWorld . R . unsafe_get ( 2 , 2 ) ; output . p . set ( planeToWorld . T . x , planeToWorld . T . y , planeToWorld . T . z ) ; return output ; }", "nl": "Defines a plane using a 3D rigid body transform . + z is the 3rd column the rotation matrix . The plane s point is the translation . The plane reference frame is the x - y plane ."}}
{"translation": {"code": "public double getSideLength ( int index ) { Point2D_F64 a = vertexes . get ( index ) ; Point2D_F64 b = vertexes . get ( ( index + 1 ) % vertexes . size ) ; return ( double ) a . distance ( b ) ; }", "nl": "Resturns the length of the specified side that is composed of point index and index + 1"}}
{"translation": {"code": "public static double circleRadiusSq ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 ) { // points that lie on line a and b double xa = ( x0 . x + x1 . x ) / 2.0 ; double ya = ( x0 . y + x1 . y ) / 2.0 ; double xb = ( x1 . x + x2 . x ) / 2.0 ; double yb = ( x1 . y + x2 . y ) / 2.0 ; // slopes of lines a and b double m2 = x0 . x - x1 . x ; double m1 = x1 . y - x0 . y ; double n2 = x2 . x - x1 . x ; double n1 = x1 . y - x2 . y ; // find the intersection of the lines double bottom = m2 * n1 - n2 * m1 ; if ( bottom == 0 ) return Double . NaN ; double alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; double dx = xb + n1 * alpha - x0 . x ; double dy = yb + n2 * alpha - x0 . y ; return dx * dx + dy * dy ; }", "nl": "Radius squares of the circle that passes through these three points ."}}
{"translation": {"code": "public static LineParametric2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineParametric2D_F64 ret ) { if ( ret == null ) ret = new LineParametric2D_F64 ( ) ; ret . p . set ( a ) ; ret . slope . x = b . x - a . x ; ret . slope . y = b . y - a . y ; return ret ; }", "nl": "Converts a line segment into a line in parametric format . It will point from a to b . Point a and b must be unique ."}}
{"translation": {"code": "public boolean hasUncountable ( ) { return UtilEjml . isUncountable ( A ) || UtilEjml . isUncountable ( C ) || UtilEjml . isUncountable ( D ) || UtilEjml . isUncountable ( E ) || UtilEjml . isUncountable ( F ) ; }", "nl": "Returns true if any of its parameters have an uncountable number"}}
{"translation": {"code": "public static ConicGeneral_F64 convert ( ParabolaGeneral_F64 src , ConicGeneral_F64 dst ) { if ( dst == null ) dst = new ConicGeneral_F64 ( ) ; dst . A = src . A * src . A ; dst . B = src . A * src . C * 2.0 ; dst . C = src . C * src . C ; dst . D = src . D ; dst . E = src . E ; dst . F = src . F ; return dst ; }", "nl": "Converts the parabola into a conic ."}}
{"translation": {"code": "public static boolean isConvex ( Polygon2D_I32 poly ) { // if the cross product of all consecutive triples is positive or negative then it is convex final int N = poly . size ( ) ; int numPositive = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int j = ( i + 1 ) % N ; int k = ( i + 2 ) % N ; Point2D_I32 a = poly . vertexes . data [ i ] ; Point2D_I32 b = poly . vertexes . data [ j ] ; Point2D_I32 c = poly . vertexes . data [ k ] ; int dx0 = a . x - b . x ; int dy0 = a . y - b . y ; int dx1 = c . x - b . x ; int dy1 = c . y - b . y ; int z = dx0 * dy1 - dy0 * dx1 ; if ( z > 0 ) numPositive ++ ; // z can be zero if there are duplicate points. // not sure if it should throw an exception if its \"bad\" or not } return ( numPositive == 0 || numPositive == N ) ; }", "nl": "Determines if the polugon is convex or concave ."}}
{"translation": {"code": "public static List < Point3D_F64 > random ( Point3D_F64 mean , double minX , double maxX , double minY , double maxY , double minZ , double maxZ , int num , Random rand ) { List < Point3D_F64 > ret = new ArrayList <> ( ) ; for ( int i = 0 ; i < num ; i ++ ) { Point3D_F64 p = new Point3D_F64 ( ) ; p . x = mean . x + rand . nextDouble ( ) * ( maxX - minX ) + minX ; p . y = mean . y + rand . nextDouble ( ) * ( maxY - minY ) + minY ; p . z = mean . z + rand . nextDouble ( ) * ( maxZ - minZ ) + minZ ; ret . add ( p ) ; } return ret ; }", "nl": "Creates a list of random points from a uniform distribution along each axis"}}
{"translation": {"code": "public static boolean isIdentical ( Se3_F64 a , Se3_F64 b , double tolT , double tolR ) { if ( Math . abs ( a . T . x - b . T . x ) > tolT ) return false ; if ( Math . abs ( a . T . y - b . T . y ) > tolT ) return false ; if ( Math . abs ( a . T . z - b . T . z ) > tolT ) return false ; DMatrixRMaj D = new DMatrixRMaj ( 3 , 3 ) ; CommonOps_DDRM . multTransA ( a . R , b . R , D ) ; Rodrigues_F64 rod = new Rodrigues_F64 ( ) ; ConvertRotation3D_F64 . matrixToRodrigues ( D , rod ) ; return rod . theta <= tolR ; }", "nl": "Can be used to see if two transforms are identical to within tolerance"}}
{"translation": {"code": "public static List < Point3D_F64 > random ( PlaneNormal3D_F64 plane , double max , int num , Random rand ) { List < Point3D_F64 > ret = new ArrayList <> ( ) ; Vector3D_F64 axisX = new Vector3D_F64 ( ) ; Vector3D_F64 axisY = new Vector3D_F64 ( ) ; UtilPlane3D_F64 . selectAxis2D ( plane . n , axisX , axisY ) ; for ( int i = 0 ; i < num ; i ++ ) { double x = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; double y = 2 * max * ( rand . nextDouble ( ) - 0.5 ) ; Point3D_F64 p = new Point3D_F64 ( ) ; p . x = plane . p . x + axisX . x * x + axisY . x * y ; p . y = plane . p . y + axisX . y * x + axisY . y * y ; p . z = plane . p . z + axisX . z * x + axisY . z * y ; ret . add ( p ) ; } return ret ; }", "nl": "Randomly generates a set of points on the plane centered at the plane s origin using a uniform distribution ."}}
{"translation": {"code": "public double maxAbs ( ) { double absX = Math . abs ( x ) ; double absY = Math . abs ( y ) ; double absZ = Math . abs ( z ) ; double absW = Math . abs ( w ) ; double found = Math . max ( absX , absY ) ; if ( found < absZ ) found = absZ ; if ( found < absW ) found = absW ; return found ; }", "nl": "Returns the absolute value of the component with the largest absolute value"}}
{"translation": {"code": "public static boolean isInfiniteH ( Point4D_F64 p , double tol ) { double n = Math . sqrt ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return Math . abs ( p . w ) <= n * tol ; }", "nl": "Checks to see if the homogenous 3D point lies on the plane at infinity"}}
{"translation": {"code": "public static Point3D_F64 h_to_e ( Point4D_F64 p ) { Point3D_F64 out = new Point3D_F64 ( ) ; h_to_e ( p , out ) ; return out ; }", "nl": "Converts a point from homogenous coordinates into Euclidean"}}
{"translation": {"code": "public static List < Point4D_F64 > randomN ( Point3D_F64 center , double w , double stdev , int num , Random rand ) { List < Point4D_F64 > ret = new ArrayList <> ( ) ; for ( int i = 0 ; i < num ; i ++ ) { Point4D_F64 p = new Point4D_F64 ( ) ; p . x = center . x + rand . nextGaussian ( ) * stdev ; p . y = center . y + rand . nextGaussian ( ) * stdev ; p . z = center . z + rand . nextGaussian ( ) * stdev ; p . w = w ; ret . add ( p ) ; } return ret ; }", "nl": "Normally distributed homogenous 3D point . w is fixed"}}
{"translation": {"code": "public static DMatrixRMaj convert ( ConicGeneral_F64 src , DMatrixRMaj dst ) { if ( dst == null ) dst = new DMatrixRMaj ( 3 , 3 ) ; else dst . reshape ( 3 , 3 ) ; double B = src . B / 2.0 ; double D = src . D / 2.0 ; double E = src . E / 2.0 ; dst . data [ 0 ] = src . A ; dst . data [ 1 ] = B ; dst . data [ 2 ] = D ; dst . data [ 3 ] = B ; dst . data [ 4 ] = src . C ; dst . data [ 5 ] = E ; dst . data [ 6 ] = D ; dst . data [ 7 ] = E ; dst . data [ 8 ] = src . F ; return dst ; }", "nl": "Converts symmetric 3x3 matrix back into a conic ."}}
{"translation": {"code": "public boolean process ( double [ ] data , int offset , int length , PolynomialCurve_F64 output ) { int N = length / 2 ; int numCoefs = output . size ( ) ; A . reshape ( N , numCoefs ) ; b . reshape ( N , 1 ) ; x . reshape ( numCoefs , 1 ) ; int end = offset + length ; for ( int i = offset , idxA = 0 ; i < end ; i += 2 ) { double x = data [ i ] ; double y = data [ i + 1 ] ; double pow = 1.0 ; for ( int j = 0 ; j < numCoefs ; j ++ ) { A . data [ idxA ++ ] = pow ; pow *= x ; } b . data [ i / 2 ] = y ; } if ( ! solver . setA ( A ) ) return false ; solver . solve ( b , x ) ; for ( int i = 0 ; i < numCoefs ; i ++ ) { output . set ( i , x . data [ i ] ) ; } return true ; }", "nl": "Fits the polynomial curve to the data ."}}