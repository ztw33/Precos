{"translation": {"code": "public static double distance ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 ) { double x = l0 . p . x - l1 . p . x ; double y = l0 . p . y - l1 . p . y ; double z = l0 . p . z - l1 . p . z ; // this solution is from: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/ double dv01v1 = MiscOps . dot ( x , y , z , l1 . slope ) ; double dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; double dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; double bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; double t0 ; if ( bottom == 0 ) { // handle parallel lines t0 = 0 ; } else { t0 = ( dv01v1 * dv1v0 - MiscOps . dot ( x , y , z , l0 . slope ) * dv1v1 ) / bottom ; } // ( d1343 + mua d4321 ) / d4343 double t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; double dx = ( l0 . p . x + t0 * l0 . slope . x ) - ( l1 . p . x + t1 * l1 . slope . x ) ; double dy = ( l0 . p . y + t0 * l0 . slope . y ) - ( l1 . p . y + t1 * l1 . slope . y ) ; double dz = ( l0 . p . z + t0 * l0 . slope . z ) - ( l1 . p . z + t1 * l1 . slope . z ) ; // round off error can make distanceSq go negative when it is very close to zero double distanceSq = dx * dx + dy * dy + dz * dz ; if ( distanceSq < 0 ) return 0 ; else return Math . sqrt ( distanceSq ) ; }", "nl": "Distance of the closest point between two lines . Parallel lines are correctly handled ."}}
{"translation": {"code": "public boolean isIdentical ( T t , double tol ) { if ( t . getDimension ( ) != getDimension ( ) ) return false ; int N = getDimension ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double diff = Math . abs ( getIdx ( i ) - t . getIdx ( i ) ) ; if ( diff > tol ) return false ; } return true ; }", "nl": "Checks to see if the two GeoTuple have values which are nearly the same . False is always returned if the dimension is different ."}}
{"translation": {"code": "public static Point3D_F64 closestPoint ( LineParametric3D_F64 l0 , LineParametric3D_F64 l1 , Point3D_F64 ret ) { if ( ret == null ) { ret = new Point3D_F64 ( ) ; } ret . x = l0 . p . x - l1 . p . x ; ret . y = l0 . p . y - l1 . p . y ; ret . z = l0 . p . z - l1 . p . z ; // this solution is from: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/ double dv01v1 = MiscOps . dot ( ret , l1 . slope ) ; double dv1v0 = MiscOps . dot ( l1 . slope , l0 . slope ) ; double dv1v1 = MiscOps . dot ( l1 . slope , l1 . slope ) ; double t0 = dv01v1 * dv1v0 - MiscOps . dot ( ret , l0 . slope ) * dv1v1 ; double bottom = MiscOps . dot ( l0 . slope , l0 . slope ) * dv1v1 - dv1v0 * dv1v0 ; if ( bottom == 0 ) return null ; t0 /= bottom ; // ( d1343 + mua d4321 ) / d4343 double t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1 ; ret . x = ( double ) 0.5 * ( ( l0 . p . x + t0 * l0 . slope . x ) + ( l1 . p . x + t1 * l1 . slope . x ) ) ; ret . y = ( double ) 0.5 * ( ( l0 . p . y + t0 * l0 . slope . y ) + ( l1 . p . y + t1 * l1 . slope . y ) ) ; ret . z = ( double ) 0.5 * ( ( l0 . p . z + t0 * l0 . slope . z ) + ( l1 . p . z + t1 * l1 . slope . z ) ) ; return ret ; }", "nl": "Returns the point which minimizes the distance between the two lines in 3D . If the two lines are parallel the result is undefined ."}}
{"translation": {"code": "public static Point3D_F64 closestPoint ( LineParametric3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { if ( ret == null ) { ret = new Point3D_F64 ( ) ; } double dx = pt . x - line . p . x ; double dy = pt . y - line . p . y ; double dz = pt . z - line . p . z ; double n2 = line . slope . normSq ( ) ; double d = ( line . slope . x * dx + line . slope . y * dy + line . slope . z * dz ) ; ret . x = line . p . x + d * line . slope . x / n2 ; ret . y = line . p . y + d * line . slope . y / n2 ; ret . z = line . p . z + d * line . slope . z / n2 ; return ret ; }", "nl": "Finds the closest point on a line to the specified point ."}}
{"translation": {"code": "public static Point2D_F64 transform ( Se2_F64 se , Point2D_F64 orig , Point2D_F64 result ) { if ( result == null ) { result = new Point2D_F64 ( ) ; } final double c = se . getCosineYaw ( ) ; final double s = se . getSineYaw ( ) ; // copy the values so that no errors happen if orig and result are the same instance double x = orig . x ; double y = orig . y ; result . x = se . getX ( ) + x * c - y * s ; result . y = se . getY ( ) + x * s + y * c ; return result ; }", "nl": "Applies a 2D special euclidean transform to the point and stores the results in another variable ."}}
{"translation": {"code": "public static void transform ( Se2_F64 se , Point2D_F64 points [ ] , int length ) { double tranX = se . getX ( ) ; double tranY = se . getY ( ) ; final double c = se . getCosineYaw ( ) ; final double s = se . getSineYaw ( ) ; for ( int i = 0 ; i < length ; i ++ ) { Point2D_F64 pt = points [ i ] ; double x = pt . x ; double y = pt . y ; pt . x = tranX + x * c - y * s ; pt . y = tranY + x * s + y * c ; } }", "nl": "Applies a 2D special euclidean transform to an array of points ."}}
{"translation": {"code": "public static void setToNoMotion ( Se3_F64 se ) { CommonOps_DDRM . setIdentity ( se . getR ( ) ) ; se . getT ( ) . set ( 0 , 0 , 0 ) ; }", "nl": "Sets the provided transform so that it does not transform any points ."}}
{"translation": {"code": "public static Point3D_F64 mean ( List < Point3D_F64 > points , Point3D_F64 mean ) { if ( mean == null ) mean = new Point3D_F64 ( ) ; double x = 0 , y = 0 , z = 0 ; for ( Point3D_F64 p : points ) { x += p . x ; y += p . y ; z += p . z ; } mean . x = x / points . size ( ) ; mean . y = y / points . size ( ) ; mean . z = z / points . size ( ) ; return mean ; }", "nl": "Computes the mean of the list of points ."}}
{"translation": {"code": "private void extractQuaternionFromQ ( SimpleMatrix q ) { SimpleEVD < SimpleMatrix > evd = q . eig ( ) ; int indexMax = evd . getIndexMax ( ) ; SimpleMatrix v_max = evd . getEigenVector ( indexMax ) ; quat . w = ( double ) v_max . get ( 0 ) ; quat . x = ( double ) v_max . get ( 1 ) ; quat . y = ( double ) v_max . get ( 2 ) ; quat . z = ( double ) v_max . get ( 3 ) ; quat . normalize ( ) ; ConvertRotation3D_F64 . quaternionToMatrix ( quat , motion . getR ( ) ) ; }", "nl": "The unit eigenvector corresponding to the maximum eigenvalue of Q is the rotation parameterized as a quaternion ."}}
{"translation": {"code": "public static DMatrixRMaj toHomogeneous ( Se2_F64 se , DMatrixRMaj ret ) { if ( ret == null ) ret = new DMatrixRMaj ( 3 , 3 ) ; else { ret . set ( 2 , 0 , 0 ) ; ret . set ( 2 , 1 , 0 ) ; } final double c = se . getCosineYaw ( ) ; final double s = se . getSineYaw ( ) ; ret . set ( 0 , 0 , c ) ; ret . set ( 0 , 1 , - s ) ; ret . set ( 1 , 0 , s ) ; ret . set ( 1 , 1 , c ) ; ret . set ( 0 , 2 , se . getX ( ) ) ; ret . set ( 1 , 2 , se . getY ( ) ) ; ret . set ( 2 , 2 , 1 ) ; return ret ; }", "nl": "Converts it into a 3 by 3 homogeneous matrix ."}}
{"translation": {"code": "@ Override public T copy ( ) { T ret = createNewInstance ( ) ; int N = getDimension ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ret . setIdx ( i , getIdx ( i ) ) ; } return ret ; }", "nl": "Generic copy routine . It is recommended that this be overridden with a faster implementation ."}}
{"translation": {"code": "public static DMatrixRMaj toHomogeneous ( Se3_F64 se , DMatrixRMaj ret ) { if ( ret == null ) ret = new DMatrixRMaj ( 4 , 4 ) ; else { ret . set ( 3 , 0 , 0 ) ; ret . set ( 3 , 1 , 0 ) ; ret . set ( 3 , 2 , 0 ) ; } CommonOps_DDRM . insert ( se . getR ( ) , ret , 0 , 0 ) ; Vector3D_F64 T = se . getT ( ) ; ret . set ( 0 , 3 , T . x ) ; ret . set ( 1 , 3 , T . y ) ; ret . set ( 2 , 3 , T . z ) ; ret . set ( 3 , 3 , 1 ) ; return ret ; }", "nl": "Converts it into a 4 by 4 homogeneous matrix ."}}
{"translation": {"code": "public static double distanceSq ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { // intersection of the two lines relative to A double slopeAX = segmentA . slopeX ( ) ; double slopeAY = segmentA . slopeY ( ) ; double slopeBX = segmentB . slopeX ( ) ; double slopeBY = segmentB . slopeY ( ) ; double ta = slopeBX * ( segmentA . a . y - segmentB . a . y ) - slopeBY * ( segmentA . a . x - segmentB . a . x ) ; double bottom = slopeBY * slopeAX - slopeAY * slopeBX ; // see they intersect if ( bottom != 0 ) { // see if the intersection is inside of lineA ta /= bottom ; if ( ta >= 0 && ta <= 1.0 ) { // see if the intersection is inside of lineB double tb = slopeAX * ( segmentB . a . y - segmentA . a . y ) - slopeAY * ( segmentB . a . x - segmentA . a . x ) ; tb /= slopeAY * slopeBX - slopeBY * slopeAX ; if ( tb >= 0 && tb <= 1.0 ) return 0 ; } } double closest = Double . MAX_VALUE ; closest = Math . min ( closest , distanceSq ( segmentA , segmentB . a ) ) ; closest = Math . min ( closest , distanceSq ( segmentA , segmentB . b ) ) ; closest = Math . min ( closest , distanceSq ( segmentB , segmentA . a ) ) ; closest = Math . min ( closest , distanceSq ( segmentB , segmentA . b ) ) ; return closest ; }", "nl": "Finds the distance squared between the two line segments"}}
{"translation": {"code": "public double normSq ( ) { double total = 0 ; int N = getDimension ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double a = getIdx ( i ) ; total += a * a ; } return total ; }", "nl": "Computes the square of the Euclidean norm ."}}
{"translation": {"code": "public static double distance ( LineParametric3D_F64 l , Point3D_F64 p ) { double x = l . p . x - p . x ; double y = l . p . y - p . y ; double z = l . p . z - p . z ; double cc = x * x + y * y + z * z ; // could avoid a square root here by computing b*b directly // however that is most likely more prone to numerical overflow since the numerator will need to be squared // before division can reduce its \"power\" double b = MiscOps . dot ( x , y , z , l . slope ) / l . slope . norm ( ) ; double distanceSq = cc - b * b ; // round off error can make distanceSq go negative when it is very close to zero if ( distanceSq < 0 ) { return 0 ; } else { return Math . sqrt ( distanceSq ) ; } }", "nl": "Distance from the point to the closest point on the line ."}}
{"translation": {"code": "public void addTransform ( boolean forward , T tran ) { path . add ( new Node < T > ( tran , forward ) ) ; }", "nl": "Adds the next transform in the sequence ."}}
{"translation": {"code": "public static Vector3D_F64 createRandom ( double min , double max , Random rand ) { double range = max - min ; Vector3D_F64 a = new Vector3D_F64 ( ) ; a . x = range * rand . nextDouble ( ) + min ; a . y = range * rand . nextDouble ( ) + min ; a . z = range * rand . nextDouble ( ) + min ; return a ; }", "nl": "Creates a random vector where each axis is selected from a uniform distribution ."}}
{"translation": {"code": "public static boolean isIdentical ( Vector3D_F64 a , Vector3D_F64 b , double tol ) { if ( Math . abs ( a . x - b . x ) > tol ) return false ; if ( Math . abs ( a . y - b . y ) > tol ) return false ; return Math . abs ( a . z - b . z ) <= tol ; }", "nl": "Checks to see if the two vectors are identical to within tolerance . Each axis is checked individually ."}}
{"translation": {"code": "public static Point2D_F64 intersection ( LineParametric2D_F64 a , LineParametric2D_F64 b , Point2D_F64 ret ) { double t_b = a . getSlopeX ( ) * ( b . getY ( ) - a . getY ( ) ) - a . getSlopeY ( ) * ( b . getX ( ) - a . getX ( ) ) ; double bottom = a . getSlopeY ( ) * b . getSlopeX ( ) - b . getSlopeY ( ) * a . getSlopeX ( ) ; if ( bottom == 0 ) return null ; t_b /= bottom ; double x = b . getSlopeX ( ) * t_b + b . getX ( ) ; double y = b . getSlopeY ( ) * t_b + b . getY ( ) ; if ( ret == null ) ret = new Point2D_F64 ( ) ; ret . set ( x , y ) ; return ret ; }", "nl": "Finds the point of intersection between two lines and returns the point ."}}
{"translation": {"code": "public static Point2D_F64 intersection ( LineSegment2D_F64 l_0 , LineSegment2D_F64 l_1 , Point2D_F64 ret ) { double a0 = l_0 . b . x - l_0 . a . x ; double b0 = l_0 . b . y - l_0 . a . y ; double a1 = l_1 . b . x - l_1 . a . x ; double b1 = l_1 . b . y - l_1 . a . y ; double top = b0 * ( l_1 . a . x - l_0 . a . x ) + a0 * ( l_0 . a . y - l_1 . a . y ) ; double bottom = a0 * b1 - b0 * a1 ; if ( bottom == 0 ) return null ; double t_1 = top / bottom ; // does not intersect along the second line segment if ( t_1 < 0 || t_1 > 1 ) return null ; top = b1 * ( l_0 . a . x - l_1 . a . x ) + a1 * ( l_1 . a . y - l_0 . a . y ) ; bottom = a1 * b0 - b1 * a0 ; double t_0 = top / bottom ; // does not intersect along the first line segment if ( t_0 < 0 || t_0 > 1 ) return null ; if ( ret == null ) { ret = new Point2D_F64 ( ) ; } ret . set ( l_1 . a . x + a1 * t_1 , l_1 . a . y + b1 * t_1 ) ; return ret ; }", "nl": "Finds the point of intersection between two lines segments ."}}
{"translation": {"code": "public static void normalize ( Vector3D_F64 v ) { double a = v . norm ( ) ; v . x /= a ; v . y /= a ; v . z /= a ; }", "nl": "Rescales the vector such that its normal is equal to one ."}}
{"translation": {"code": "public static double intersection ( LineParametric2D_F64 target , LineSegment2D_F64 l ) { double a1 = l . b . x - l . a . x ; double b1 = l . b . y - l . a . y ; double top = target . slope . y * ( l . a . x - target . p . x ) + target . slope . x * ( target . p . y - l . a . y ) ; double bottom = target . slope . x * b1 - target . slope . y * a1 ; if ( bottom == 0 ) return Double . NaN ; double t_1 = top / bottom ; // does not intersect along the second line segment if ( t_1 < 0 || t_1 > 1 ) return Double . NaN ; top = b1 * ( target . p . x - l . a . x ) + a1 * ( l . a . y - target . p . y ) ; bottom = a1 * target . slope . y - b1 * target . slope . x ; return top / bottom ; }", "nl": "Finds the point of intersection between a line and a line segment . The point of intersection is specified as the distance along the parametric line . If no intersection is found then Double . NaN is returned ."}}
{"translation": {"code": "public static DMatrixRMaj createMatrix ( DMatrixRMaj R , Vector3D_F64 ... v ) { if ( R == null ) { R = new DMatrixRMaj ( 3 , v . length ) ; } for ( int i = 0 ; i < v . length ; i ++ ) { R . set ( 0 , i , v [ i ] . x ) ; R . set ( 1 , i , v [ i ] . y ) ; R . set ( 2 , i , v [ i ] . z ) ; } return R ; }", "nl": "Creates a matrix from the set of column vectors . Each vector is a column in the new matrix ."}}
{"translation": {"code": "public static Vector3D_F64 convert ( DMatrixRMaj m ) { Vector3D_F64 v = new Vector3D_F64 ( ) ; v . x = ( double ) m . data [ 0 ] ; v . y = ( double ) m . data [ 1 ] ; v . z = ( double ) m . data [ 2 ] ; return v ; }", "nl": "Converts matrices into vectors . All matrices must be vectors with 3 elements ."}}
{"translation": {"code": "public void normalize ( ) { double n = Math . sqrt ( w * w + x * x + y * y + z * z ) ; w /= n ; x /= n ; y /= n ; z /= n ; }", "nl": "Converts the quaternion into a unit quaternion ."}}
{"translation": {"code": "public void setAngle ( double angle ) { slope . set ( Math . cos ( angle ) , Math . sin ( angle ) ) ; }", "nl": "Sets the slope to the unit vector specified by the provided angle ."}}
{"translation": {"code": "public static double distHalf ( double angA , double angB ) { double a = Math . abs ( angA - angB ) ; if ( a <= Math . PI / 2 ) return a ; else return Math . PI - a ; }", "nl": "Angular distance between two half circle angles ."}}
{"translation": {"code": "public static LineParametric2D_F64 convert ( LineSegment2D_F64 src , LineParametric2D_F64 ret ) { if ( ret == null ) ret = new LineParametric2D_F64 ( ) ; ret . p . set ( src . a ) ; ret . slope . set ( src . slopeX ( ) , src . slopeY ( ) ) ; return ret ; }", "nl": "Converts a line segment into a parametric line . The start point will be src . a and the direction will be in the direction of src . b - src . a"}}
{"translation": {"code": "public static LineParametric2D_F64 convert ( LinePolar2D_F64 src , LineParametric2D_F64 ret ) { if ( ret == null ) ret = new LineParametric2D_F64 ( ) ; double c = ( double ) Math . cos ( src . angle ) ; double s = ( double ) Math . sin ( src . angle ) ; ret . p . set ( c * src . distance , s * src . distance ) ; ret . slope . set ( - s , c ) ; return ret ; }", "nl": "Converts a line from polar form to parametric ."}}
{"translation": {"code": "public static LinePolar2D_F64 convert ( LineParametric2D_F64 src , LinePolar2D_F64 ret ) { if ( ret == null ) ret = new LinePolar2D_F64 ( ) ; double top = src . slope . y * src . p . x - src . slope . x * src . p . y ; ret . distance = top / src . slope . norm ( ) ; ret . angle = Math . atan2 ( - src . slope . x , src . slope . y ) ; if ( ret . distance < 0 ) { ret . distance = - ret . distance ; ret . angle = UtilAngle . bound ( ret . angle + Math . PI ) ; } return ret ; }", "nl": "Converts a line from parametric to polar ."}}
{"translation": {"code": "public static Point3D_F64 mean ( List < Point3D_F64 > points , int num , Point3D_F64 mean ) { if ( mean == null ) mean = new Point3D_F64 ( ) ; double x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < num ; i ++ ) { Point3D_F64 p = points . get ( i ) ; x += p . x ; y += p . y ; z += p . z ; } mean . x = x / num ; mean . y = y / num ; mean . z = z / num ; return mean ; }", "nl": "Computes the mean of the list of points up to element num ."}}
{"translation": {"code": "public void setParamVector ( double x , double y , double z ) { double ax = Math . abs ( x ) ; double ay = Math . abs ( y ) ; double az = Math . abs ( z ) ; double max = Math . max ( ax , ay ) ; max = Math . max ( max , az ) ; if ( max == 0 ) { theta = 0 ; unitAxisRotation . set ( 1 , 0 , 0 ) ; } else { x /= max ; y /= max ; z /= max ; theta = Math . sqrt ( x * x + y * y + z * z ) ; unitAxisRotation . x = x / theta ; unitAxisRotation . y = y / theta ; unitAxisRotation . z = z / theta ; theta *= max ; } }", "nl": "Assign the Rodrigues coordinates using a 3 element vector . Theta is the vector s magnitude and the axis of rotation is the unit vector ."}}
{"translation": {"code": "public static void normalize ( GeoTuple3D_F64 p ) { double n = p . norm ( ) ; p . x /= n ; p . y /= n ; p . z /= n ; }", "nl": "Normalizes the point such that the Frobenius norm is 1 ."}}
{"translation": {"code": "public static LineParametric2D_F64 convert ( LineGeneral2D_F64 src , LineParametric2D_F64 ret ) { if ( ret == null ) { ret = new LineParametric2D_F64 ( ) ; } ret . slope . x = src . B ; ret . slope . y = - src . A ; // find a point on the line if ( Math . abs ( src . B ) > Math . abs ( src . A ) ) { ret . p . y = - src . C / src . B ; ret . p . x = 0 ; } else { ret . p . x = - src . C / src . A ; ret . p . y = 0 ; } return ret ; }", "nl": "Converts a line from general to parametric"}}
{"translation": {"code": "public static LineGeneral2D_F64 convert ( LineParametric2D_F64 src , LineGeneral2D_F64 ret ) { if ( ret == null ) { ret = new LineGeneral2D_F64 ( ) ; } ret . A = - src . slope . y ; ret . B = src . slope . x ; ret . C = - ret . A * src . p . x - ret . B * src . p . y ; return ret ; }", "nl": "Converts a line from parametric to general"}}
{"translation": {"code": "private static DMatrixRMaj rotationAboutAxis ( int axis , double angle , DMatrixRMaj R ) { switch ( axis ) { case 0 : return ConvertRotation3D_F64 . rotX ( angle , R ) ; case 1 : return ConvertRotation3D_F64 . rotY ( angle , R ) ; case 2 : return ConvertRotation3D_F64 . rotZ ( angle , R ) ; default : throw new IllegalArgumentException ( \"Unknown which\" ) ; } }", "nl": "Creates a rotation matrix about the specified axis ."}}
{"translation": {"code": "public static void setRotZ ( double ang , DMatrixRMaj r ) { double c = Math . cos ( ang ) ; double s = Math . sin ( ang ) ; r . set ( 0 , 0 , c ) ; r . set ( 0 , 1 , - s ) ; r . set ( 1 , 0 , s ) ; r . set ( 1 , 1 , c ) ; r . set ( 2 , 2 , 1 ) ; }", "nl": "Sets the values in the specified matrix to a rotation matrix about the z - axis ."}}
{"translation": {"code": "public static void setRotX ( double ang , DMatrixRMaj R ) { double c = Math . cos ( ang ) ; double s = Math . sin ( ang ) ; R . set ( 0 , 0 , 1 ) ; R . set ( 1 , 1 , c ) ; R . set ( 1 , 2 , - s ) ; R . set ( 2 , 1 , s ) ; R . set ( 2 , 2 , c ) ; }", "nl": "Sets the values in the specified matrix to a rotation matrix about the x - axis ."}}
{"translation": {"code": "public static DMatrixRMaj rotY ( double ang , DMatrixRMaj R ) { R = checkDeclare3x3 ( R ) ; setRotY ( ang , R ) ; return R ; }", "nl": "Creates a rotation matrix about the y - axis ."}}
{"translation": {"code": "public void set ( Se3_F64 se ) { R . set ( se . getR ( ) ) ; T . set ( se . getT ( ) ) ; }", "nl": "Set s this Se3_F64 to be identical to the provided transform ."}}
{"translation": {"code": "public static DMatrixRMaj rotZ ( double ang , DMatrixRMaj R ) { R = checkDeclare3x3 ( R ) ; setRotZ ( ang , R ) ; return R ; }", "nl": "Creates a rotation matrix about the z - axis ."}}
{"translation": {"code": "public static DMatrixRMaj eulerToMatrix ( EulerType type , double rotA , double rotB , double rotC , DMatrixRMaj R ) { R = checkDeclare3x3 ( R ) ; DMatrixRMaj R_a = rotationAboutAxis ( type . getAxisA ( ) , rotA , null ) ; DMatrixRMaj R_b = rotationAboutAxis ( type . getAxisB ( ) , rotB , null ) ; DMatrixRMaj R_c = rotationAboutAxis ( type . getAxisC ( ) , rotC , null ) ; DMatrixRMaj A = new DMatrixRMaj ( 3 , 3 ) ; CommonOps_DDRM . mult ( R_b , R_a , A ) ; CommonOps_DDRM . mult ( R_c , A , R ) ; return R ; }", "nl": "Converts an Euler coordinate into a rotation matrix . Different type of Euler coordinates are accepted ."}}
{"translation": {"code": "public static Quaternion_F64 matrixToQuaternion ( DMatrixRMaj R , Quaternion_F64 quat ) { if ( quat == null ) quat = new Quaternion_F64 ( ) ; // algorithm from: // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/ // // Designed to minimize numerical error by not dividing by very small numbers double m00 = R . unsafe_get ( 0 , 0 ) ; double m01 = R . unsafe_get ( 0 , 1 ) ; double m02 = R . unsafe_get ( 0 , 2 ) ; double m10 = R . unsafe_get ( 1 , 0 ) ; double m11 = R . unsafe_get ( 1 , 1 ) ; double m12 = R . unsafe_get ( 1 , 2 ) ; double m20 = R . unsafe_get ( 2 , 0 ) ; double m21 = R . unsafe_get ( 2 , 1 ) ; double m22 = R . unsafe_get ( 2 , 2 ) ; double trace = m00 + m11 + m22 ; if ( trace > 0 ) { double S = Math . sqrt ( trace + 1.0 ) * 2 ; // S=4*qw quat . w = 0.25 * S ; quat . x = ( m21 - m12 ) / S ; quat . y = ( m02 - m20 ) / S ; quat . z = ( m10 - m01 ) / S ; } else if ( ( m00 > m11 ) & ( m00 > m22 ) ) { double S = Math . sqrt ( 1.0 + m00 - m11 - m22 ) * 2 ; // S=4*qx quat . w = ( m21 - m12 ) / S ; quat . x = 0.25 * S ; quat . y = ( m01 + m10 ) / S ; quat . z = ( m02 + m20 ) / S ; } else if ( m11 > m22 ) { double S = Math . sqrt ( 1.0 + m11 - m00 - m22 ) * 2 ; // S=4*qy quat . w = ( m02 - m20 ) / S ; quat . x = ( m01 + m10 ) / S ; quat . y = 0.25 * S ; quat . z = ( m12 + m21 ) / S ; } else { double S = Math . sqrt ( 1.0 + m22 - m00 - m11 ) * 2 ; // S=4*qz quat . w = ( m10 - m01 ) / S ; quat . x = ( m02 + m20 ) / S ; quat . y = ( m12 + m21 ) / S ; quat . z = 0.25 * S ; } return quat ; }", "nl": "Extracts quaternions from the provided rotation matrix ."}}
{"translation": {"code": "public static DMatrixRMaj rotX ( double ang , DMatrixRMaj R ) { if ( R == null ) R = new DMatrixRMaj ( 3 , 3 ) ; setRotX ( ang , R ) ; return R ; }", "nl": "Creates a rotation matrix about the x - axis ."}}
{"translation": {"code": "public static double triangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c ) { double inner = a . x * ( b . y - c . y ) + b . x * ( c . y - a . y ) + c . x * ( a . y - b . y ) ; return Math . abs ( inner / 2.0 ) ; }", "nl": "Computes the area of an arbitrary triangle from 3 - vertices ."}}
{"translation": {"code": "public static double distanceSq ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { double dx = x1 - x0 ; double dy = y1 - y0 ; double dz = z1 - z0 ; return dx * dx + dy * dy + dz * dz ; }", "nl": "Euclidean distance squared between the two specified points"}}
{"translation": {"code": "public static double distance ( double x0 , double y0 , double z0 , double x1 , double y1 , double z1 ) { return norm ( x1 - x0 , y1 - y0 , z1 - z0 ) ; }", "nl": "Euclidean distance between the two specified points"}}
{"translation": {"code": "public static double acuteAngle ( LineSegment2D_I32 line0 , LineSegment2D_I32 line1 ) { int dx0 = line0 . b . x - line0 . a . x ; int dy0 = line0 . b . y - line0 . a . y ; int dx1 = line1 . b . x - line1 . a . x ; int dy1 = line1 . b . y - line1 . a . y ; double bottom = Math . sqrt ( dx0 * dx0 + dy0 * dy0 ) * Math . sqrt ( dx1 * dx1 + dy1 * dy1 ) ; return Math . acos ( ( dx0 * dx1 + dy0 * dy1 ) / bottom ) ; }", "nl": "Computes the acute angle between the two lines . Does not check for intersection"}}
{"translation": {"code": "public static EllipseQuadratic_F64 convert ( EllipseRotated_F64 input , EllipseQuadratic_F64 output ) { if ( output == null ) output = new EllipseQuadratic_F64 ( ) ; double x0 = input . center . x ; double y0 = input . center . y ; double a = input . a ; double b = input . b ; double phi = input . phi ; double cphi = Math . cos ( phi ) ; double sphi = Math . sin ( phi ) ; double cphi2 = cphi * cphi ; double sphi2 = sphi * sphi ; double a2 = a * a ; double b2 = b * b ; double x02 = x0 * x0 ; double y02 = y0 * y0 ; // TODO simplfy using more trig identities output . A = cphi2 / a2 + sphi2 / b2 ; output . B = sphi * cphi / a2 - sphi * cphi / b2 ; output . C = sphi2 / a2 + cphi2 / b2 ; output . D = - x0 * cphi2 / a2 - y0 * sphi * cphi / a2 - x0 * sphi2 / b2 + y0 * sphi * cphi / b2 ; output . E = - x0 * sphi * cphi / a2 - y0 * sphi2 / a2 + x0 * sphi * cphi / b2 - y0 * cphi2 / b2 ; output . F = x02 * cphi2 / a2 + 2 * x0 * y0 * sphi * cphi / a2 + y02 * sphi2 / a2 + x02 * sphi2 / b2 - 2 * x0 * y0 * sphi * cphi / b2 + y02 * cphi2 / b2 - 1 ; return output ; }", "nl": "Convert from rotated to quadratic ."}}
{"translation": {"code": "public static Point2D_F64 computePoint ( double t , EllipseRotated_F64 ellipse , Point2D_F64 output ) { if ( output == null ) output = new Point2D_F64 ( ) ; double ct = Math . cos ( t ) ; double st = Math . sin ( t ) ; double cphi = Math . cos ( ellipse . phi ) ; double sphi = Math . sin ( ellipse . phi ) ; // coordinate in ellipse frame double x = ellipse . a * ct ; double y = ellipse . b * st ; // put into global frame output . x = ellipse . center . x + x * cphi - y * sphi ; output . y = ellipse . center . y + x * sphi + y * cphi ; return output ; }", "nl": "Computes the point on the ellipse at location t where t is an angle in radians"}}
{"translation": {"code": "public static Point2D_F64 closestPoint ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { ClosestPointEllipseAngle_F64 alg = new ClosestPointEllipseAngle_F64 ( GrlConstants . TEST_F64 , 30 ) ; alg . setEllipse ( ellipse ) ; alg . process ( p ) ; return alg . getClosest ( ) ; }", "nl": "Computes the closest point on an ellipse to the provided point . If there are multiple solutions then one is arbitrarily chosen ."}}
{"translation": {"code": "public void setEllipse ( EllipseRotated_F64 ellipse ) { this . ellipse = ellipse ; ce = Math . cos ( ellipse . phi ) ; se = Math . sin ( ellipse . phi ) ; }", "nl": "Specifies the ellipse which point distance is going to be found from"}}
{"translation": {"code": "public static double computeAngle ( Point2D_F64 p , EllipseRotated_F64 ellipse ) { // put point into ellipse's reference frame double ce = Math . cos ( ellipse . phi ) ; double se = Math . sin ( ellipse . phi ) ; // world into ellipse frame double xc = p . x - ellipse . center . x ; double yc = p . y - ellipse . center . y ; double x = ce * xc + se * yc ; double y = - se * xc + ce * yc ; return Math . atan2 ( y / ellipse . b , x / ellipse . a ) ; }", "nl": "Computes the value of t used to specify a point s location"}}
{"translation": {"code": "public static PlaneGeneral3D_F64 convert ( PlaneNormal3D_F64 input , PlaneGeneral3D_F64 output ) { if ( output == null ) output = new PlaneGeneral3D_F64 ( ) ; Vector3D_F64 n = input . n ; Point3D_F64 p = input . p ; output . A = n . x ; output . B = n . y ; output . C = n . z ; output . D = n . x * p . x + n . y * p . y + n . z * p . z ; return output ; }", "nl": "Converts a plane in normal form into a general equation"}}
{"translation": {"code": "public static PlaneNormal3D_F64 convert ( PlaneTangent3D_F64 input , PlaneNormal3D_F64 output ) { if ( output == null ) output = new PlaneNormal3D_F64 ( ) ; // the value of input is a vector normal to the plane and a point on the plane. output . n . x = input . x ; output . n . y = input . y ; output . n . z = input . z ; output . p . set ( input ) ; return output ; }", "nl": "Converts a plane in tangent form into a plane in normal form"}}
{"translation": {"code": "public static void toTuple3D ( DMatrixRMaj in , GeoTuple3D_F64 out ) { out . x = ( double ) in . get ( 0 ) ; out . y = ( double ) in . get ( 1 ) ; out . z = ( double ) in . get ( 2 ) ; }", "nl": "Converts a DMatrixRMaj into GeoTuple3D_F64"}}
{"translation": {"code": "public static DMatrixRMaj toMatrix ( GeoTuple3D_F64 in , DMatrixRMaj out ) { if ( out == null ) out = new DMatrixRMaj ( 3 , 1 ) ; else if ( out . getNumElements ( ) != 3 ) throw new IllegalArgumentException ( \"Vector with 3 elements expected\" ) ; out . data [ 0 ] = in . x ; out . data [ 1 ] = in . y ; out . data [ 2 ] = in . z ; return out ; }", "nl": "Converts a GeoTuple3D_F64 into DMatrixRMaj"}}
{"translation": {"code": "public static double distance ( PlaneGeneral3D_F64 plane , Point3D_F64 point ) { double top = plane . A * point . x + plane . B * point . y + plane . C * point . z - plane . D ; return top / Math . sqrt ( plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ) ; }", "nl": "Distance between a plane and a point . A signed distance is returned where a positive value is returned if the point is on the same side of the plane as the normal and the opposite if it s on the other ."}}
{"translation": {"code": "public static boolean intersect ( PlaneGeneral3D_F64 a , PlaneGeneral3D_F64 b , LineParametric3D_F64 line ) { // Line's slope is the cross product of the two normal vectors GeometryMath_F64 . cross ( a . A , a . B , a . C , b . A , b . B , b . C , line . slope ) ; if ( line . slope . normSq ( ) == 0 ) return false ; // Closest point on plane 'a' to origin (0,0,0) double n2 = a . A * a . A + a . B * a . B + a . C * a . C ; double closestX = a . A * a . D / n2 ; double closestY = a . B * a . D / n2 ; double closestZ = a . C * a . D / n2 ; // Cross product between normal of 'a' and the line's slope.  This points towards the intersection double slopeX = a . B * line . slope . z - a . C * line . slope . y ; double slopeY = a . C * line . slope . x - a . A * line . slope . z ; double slopeZ = a . A * line . slope . y - a . B * line . slope . x ; // Now find the intersection of the plane and a line containing point 'closest' and pointing towards the // the intersection. double top = b . D - b . A * closestX - b . B * closestY - b . C * closestZ ; double bottom = b . A * slopeX + b . B * slopeY + b . C * slopeZ ; double d = top / bottom ; line . p . x = closestX + d * slopeX ; line . p . y = closestY + d * slopeY ; line . p . z = closestZ + d * slopeZ ; return true ; }", "nl": "Finds the line which is the intersection between the two planes . For a valid solution to be returned the planes must not be parallel to each other . If the planes are parallel then the slope of the returned line will have a value of zero for each element ."}}
{"translation": {"code": "public static void bounding ( Quadrilateral_F64 quad , Rectangle2D_F64 rectangle ) { rectangle . p0 . x = Math . min ( quad . a . x , quad . b . x ) ; rectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . c . x ) ; rectangle . p0 . x = Math . min ( rectangle . p0 . x , quad . d . x ) ; rectangle . p0 . y = Math . min ( quad . a . y , quad . b . y ) ; rectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . c . y ) ; rectangle . p0 . y = Math . min ( rectangle . p0 . y , quad . d . y ) ; rectangle . p1 . x = Math . max ( quad . a . x , quad . b . x ) ; rectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . c . x ) ; rectangle . p1 . x = Math . max ( rectangle . p1 . x , quad . d . x ) ; rectangle . p1 . y = Math . max ( quad . a . y , quad . b . y ) ; rectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . c . y ) ; rectangle . p1 . y = Math . max ( rectangle . p1 . y , quad . d . y ) ; }", "nl": "Finds the minimum area bounding rectangle around the quadrilateral ."}}
{"translation": {"code": "public boolean solvePoint ( List < Point3D_F64 > points , Point3D_F64 pointOnPlane , Vector3D_F64 outputNormal ) { final int N = points . size ( ) ; // construct the matrix A . reshape ( N , 3 ) ; int index = 0 ; for ( int i = 0 ; i < N ; i ++ ) { Point3D_F64 p = points . get ( i ) ; A . data [ index ++ ] = p . x - pointOnPlane . x ; A . data [ index ++ ] = p . y - pointOnPlane . y ; A . data [ index ++ ] = p . z - pointOnPlane . z ; } // decompose and find the singular value if ( ! solverNull . process ( A , 1 , nullspace ) ) return false ; // the normal is the singular vector outputNormal . x = ( double ) nullspace . unsafe_get ( 0 , 0 ) ; outputNormal . y = ( double ) nullspace . unsafe_get ( 1 , 0 ) ; outputNormal . z = ( double ) nullspace . unsafe_get ( 2 , 0 ) ; return true ; }", "nl": "SVD based method for fitting a plane to a set of points and a known point on the plane . The plane s equation is returned as a point on the plane and the normal vector ."}}
{"translation": {"code": "public boolean svd ( List < Point3D_F64 > points , Point3D_F64 outputCenter , Vector3D_F64 outputNormal ) { final int N = points . size ( ) ; // find the centroid outputCenter . set ( 0 , 0 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { Point3D_F64 p = points . get ( i ) ; outputCenter . x += p . x ; outputCenter . y += p . y ; outputCenter . z += p . z ; } outputCenter . x /= N ; outputCenter . y /= N ; outputCenter . z /= N ; return solvePoint ( points , outputCenter , outputNormal ) ; }", "nl": "SVD based method for fitting a plane to a set of points . The plane s equation is returned as a point on the plane and the normal vector ."}}
{"translation": {"code": "public static double distance ( Cylinder3D_F64 cylinder , Point3D_F64 point ) { double r = Distance3D_F64 . distance ( cylinder . line , point ) ; return r - cylinder . radius ; }", "nl": "Returns the signed distance a point is from the cylinder s surface . If the point is outside of the cylinder it s distance will be positive . If it is inside it will be negative ."}}
{"translation": {"code": "public static double distance ( LineSegment3D_F64 l , Point3D_F64 p ) { double dx = p . x - l . a . x ; double dy = p . y - l . a . y ; double dz = p . z - l . a . z ; double cc = dx * dx + dy * dy + dz * dz ; double slope_x = l . b . x - l . a . x ; double slope_y = l . b . y - l . a . y ; double slope_z = l . b . z - l . a . z ; double n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; // check end points if ( d <= 0 ) return p . distance ( l . a ) ; else if ( d >= n ) return p . distance ( l . b ) ; double distanceSq = cc - d * d ; // round off error can make distanceSq go negative when it is very close to zero if ( distanceSq < 0 ) { return 0 ; } else { return Math . sqrt ( distanceSq ) ; } }", "nl": "Distance from the point to the closest point on the line segment ."}}
{"translation": {"code": "public static Point3D_F64 closestPoint ( LineSegment3D_F64 line , Point3D_F64 pt , Point3D_F64 ret ) { if ( ret == null ) { ret = new Point3D_F64 ( ) ; } double dx = pt . x - line . a . x ; double dy = pt . y - line . a . y ; double dz = pt . z - line . a . z ; double slope_x = line . b . x - line . a . x ; double slope_y = line . b . y - line . a . y ; double slope_z = line . b . z - line . a . z ; double n = ( double ) Math . sqrt ( slope_x * slope_x + slope_y * slope_y + slope_z * slope_z ) ; double d = ( slope_x * dx + slope_y * dy + slope_z * dz ) / n ; // if it is past the end points just return one of the end points if ( d <= 0 ) { ret . set ( line . a ) ; } else if ( d >= n ) { ret . set ( line . b ) ; } else { ret . x = line . a . x + d * slope_x / n ; ret . y = line . a . y + d * slope_y / n ; ret . z = line . a . z + d * slope_z / n ; } return ret ; }", "nl": "Finds the closest point on a line segment to the specified point ."}}
{"translation": {"code": "public static double computeT ( LineParametric3D_F64 line , Point3D_F64 pointOnLine ) { double dx = pointOnLine . x - line . p . x ; double dy = pointOnLine . y - line . p . y ; double dz = pointOnLine . z - line . p . z ; double adx = Math . abs ( dx ) ; double ady = Math . abs ( dy ) ; double adz = Math . abs ( dz ) ; double t ; if ( adx > ady ) { if ( adx > adz ) { t = dx / line . slope . x ; } else { t = dz / line . slope . z ; } } else if ( ady > adz ) { t = dy / line . slope . y ; } else { t = dz / line . slope . z ; } return t ; }", "nl": "Computes the value of T for a point on the parametric line"}}
{"translation": {"code": "public void closestPoint ( Point3D_F64 P , Point3D_F64 closestPt ) { // D = B-P GeometryMath_F64 . sub ( B , P , D ) ; a = E0 . dot ( E0 ) ; b = E0 . dot ( E1 ) ; c = E1 . dot ( E1 ) ; d = E0 . dot ( D ) ; e = E1 . dot ( D ) ; double det = a * c - b * b ; s = b * e - c * d ; t = b * d - a * e ; if ( s + t <= det ) { if ( s < 0 ) { if ( t < 0 ) { region4 ( ) ; } else { region3 ( ) ; } } else if ( t < 0 ) { region5 ( ) ; } else { region0 ( det ) ; } } else { if ( s < 0 ) { region2 ( ) ; } else if ( t < 0 ) { region6 ( ) ; } else { region1 ( ) ; } } closestPt . x = B . x + s * E0 . x + t * E1 . x ; closestPt . y = B . y + s * E0 . y + t * E1 . y ; closestPt . z = B . z + s * E0 . z + t * E1 . z ; }", "nl": "Find the closest point on the triangle to P ."}}
{"translation": {"code": "public static Point3D_F64 closestPoint ( Point3D_F64 vertexA , Point3D_F64 vertexB , Point3D_F64 vertexC , Point3D_F64 point , Point3D_F64 ret ) { if ( ret == null ) { ret = new Point3D_F64 ( ) ; } DistancePointTriangle3D_F64 alg = new DistancePointTriangle3D_F64 ( ) ; alg . setTriangle ( vertexA , vertexB , vertexC ) ; alg . closestPoint ( point , ret ) ; return ret ; }", "nl": "Closest point from a 3D triangle to a point ."}}
{"translation": {"code": "public double sign ( Point3D_F64 P ) { GeometryMath_F64 . cross ( E1 , E0 , N ) ; // dot product of double d = N . x * ( P . x - B . x ) + N . y * ( P . y - B . y ) + N . z * ( P . z - B . z ) ; return Math . signum ( d ) ; }", "nl": "Returns the signed of the vector . If its in front it will be positive and negative if behind . In front is defined as being on the same side as the cross product of p2 - p0 and p1 - p0 ."}}
{"translation": {"code": "public static boolean contained ( Box3D_I32 boxA , Box3D_I32 boxB ) { return ( boxA . p0 . x <= boxB . p0 . x && boxA . p1 . x >= boxB . p1 . x && boxA . p0 . y <= boxB . p0 . y && boxA . p1 . y >= boxB . p1 . y && boxA . p0 . z <= boxB . p0 . z && boxA . p1 . z >= boxB . p1 . z ) ; }", "nl": "Returns true if boxB is contained inside of or is identical to boxA ."}}
{"translation": {"code": "public Point3D_F64 center ( Point3D_F64 storage ) { if ( storage == null ) storage = new Point3D_F64 ( ) ; storage . x = ( p0 . x + p1 . x ) / 2.0 ; storage . y = ( p0 . y + p1 . y ) / 2.0 ; storage . z = ( p0 . z + p1 . z ) / 2.0 ; return storage ; }", "nl": "Computes and return the center of the cube ."}}
{"translation": {"code": "public static Point2D_F64 closestPoint ( LineSegment2D_F64 line , Point2D_F64 p , Point2D_F64 output ) { if ( output == null ) output = new Point2D_F64 ( ) ; double slopeX = line . b . x - line . a . x ; double slopeY = line . b . y - line . a . y ; double t = slopeX * ( p . x - line . a . x ) + slopeY * ( p . y - line . a . y ) ; t /= slopeX * slopeX + slopeY * slopeY ; if ( t < 0 ) t = 0 ; else if ( t > 1 ) t = 1 ; output . x = line . a . x + slopeX * t ; output . y = line . a . y + slopeY * t ; return output ; }", "nl": "Finds the closest point on the line segment to the provided point p ."}}
{"translation": {"code": "private static boolean containedPlane ( Point3D_F64 T_v0 , Point3D_F64 output , Vector3D_F64 u , Vector3D_F64 v , Vector3D_F64 w0 ) { double uu , uv , vv , wu , wv , D ; uu = u . dot ( u ) ; uv = u . dot ( v ) ; vv = v . dot ( v ) ; w0 . minus ( output , T_v0 ) ; wu = w0 . dot ( u ) ; wv = w0 . dot ( v ) ; D = uv * uv - uu * vv ; // get and test parametric coords double s , t ; s = ( uv * wv - vv * wu ) / D ; if ( s < 0.0 || s > 1.0 ) // I is outside T return false ; t = ( uv * wu - uu * wv ) / D ; return ! ( t < 0.0 ) && ! ( ( s + t ) > 1.0 ) ; // I is outside T }", "nl": "Determines if the point on the same plane as T is contained inside of T ."}}
{"translation": {"code": "public void setTransforms ( Se3_F64 initial , Se3_F64 end ) { this . initial . set ( initial ) ; translation . x = end . T . x - initial . T . x ; translation . y = end . T . y - initial . T . y ; translation . z = end . T . z - initial . T . z ; CommonOps_DDRM . multTransA ( initial . getR ( ) , end . getR ( ) , R ) ; ConvertRotation3D_F64 . matrixToRodrigues ( R , rotation ) ; rotMagnitude = rotation . theta ; }", "nl": "Specify the two transforms which values are to be interpolated between"}}
{"translation": {"code": "public void interpolate ( double where , Se3_F64 output ) { rotation . setTheta ( where * rotMagnitude ) ; ConvertRotation3D_F64 . rodriguesToMatrix ( rotation , R ) ; output . T . x = initial . T . x + where * translation . x ; output . T . y = initial . T . y + where * translation . y ; output . T . z = initial . T . z + where * translation . z ; CommonOps_DDRM . mult ( initial . R , R , output . R ) ; }", "nl": "Interpolates a value between the first and second transform . A value close to 0 will be more similar to the initial and 1 more similar to the end ."}}
{"translation": {"code": "public void set ( RectangleLength2D_I32 r ) { this . x0 = r . x0 ; this . y0 = r . y0 ; this . width = r . width ; this . height = r . height ; }", "nl": "Sets this rectangle to be equal to the passed in rectangle ."}}
{"translation": {"code": "public static Se3_F64 planeToWorld ( PlaneGeneral3D_F64 plane , Se3_F64 planeToWorld ) { if ( planeToWorld == null ) planeToWorld = new Se3_F64 ( ) ; Vector3D_F64 axisZ = new Vector3D_F64 ( plane . A , plane . B , plane . C ) ; axisZ . normalize ( ) ; Vector3D_F64 axisX = new Vector3D_F64 ( ) ; Vector3D_F64 axisY = new Vector3D_F64 ( ) ; UtilPlane3D_F64 . selectAxis2D ( axisZ , axisX , axisY ) ; return planeToWorld ( plane , axisX , axisY , axisZ , planeToWorld ) ; }", "nl": "Creates a transform from the plane s reference frame into world s reference frame . The z - axis is set to the plane s normal and the x - axis and y - axis are arbitrarily choosen . Points which lie along the plane will lie along its x - y plane ."}}
{"translation": {"code": "public static Point3D_F64 closestPointOrigin ( PlaneGeneral3D_F64 plane , Point3D_F64 found ) { if ( found == null ) found = new Point3D_F64 ( ) ; double n2 = plane . A * plane . A + plane . B * plane . B + plane . C * plane . C ; found . x = plane . A * plane . D / n2 ; found . y = plane . B * plane . D / n2 ; found . z = plane . C * plane . D / n2 ; return found ; }", "nl": "Finds the closest point on the plane to the origin ."}}
{"translation": {"code": "public static LineGeneral2D_F64 convert ( LineSegment2D_F64 src , LineGeneral2D_F64 ret ) { return convert ( src . a , src . b , ret ) ; }", "nl": "Converts a line segment into a general line ."}}
{"translation": {"code": "public static LineGeneral2D_F64 convert ( Point2D_F64 a , Point2D_F64 b , LineGeneral2D_F64 ret ) { if ( ret == null ) ret = new LineGeneral2D_F64 ( ) ; ret . A = a . y - b . y ; ret . B = b . x - a . x ; ret . C = - ( ret . A * a . x + ret . B * a . y ) ; return ret ; }", "nl": "Converts a line segment into a general line . Line segment is defined by two points ."}}
{"translation": {"code": "public static LinePolar2D_F64 convert ( LineGeneral2D_F64 src , LinePolar2D_F64 ret ) { if ( ret == null ) ret = new LinePolar2D_F64 ( ) ; double r = Math . sqrt ( src . A * src . A + src . B * src . B ) ; double sign = src . C < 0 ? - 1 : 1 ; ret . angle = Math . atan2 ( - sign * src . B / r , - sign * src . A / r ) ; ret . distance = sign * src . C / r ; return ret ; }", "nl": "Converts a line from general to polar ."}}
{"translation": {"code": "public static List < Point2D_F64 > orderCCW ( List < Point2D_F64 > points ) { Point2D_F64 center = mean ( points , null ) ; double angles [ ] = new double [ points . size ( ) ] ; for ( int i = 0 ; i < angles . length ; i ++ ) { Point2D_F64 p = points . get ( i ) ; double dx = p . x - center . x ; double dy = p . y - center . y ; angles [ i ] = Math . atan2 ( dy , dx ) ; } int order [ ] = new int [ points . size ( ) ] ; QuickSort_F64 sorter = new QuickSort_F64 ( ) ; sorter . sort ( angles , 0 , points . size ( ) , order ) ; List < Point2D_F64 > out = new ArrayList < Point2D_F64 > ( points . size ( ) ) ; for ( int i = 0 ; i < points . size ( ) ; i ++ ) { out . add ( points . get ( order [ i ] ) ) ; } return out ; }", "nl": "Puts the points into counter - clockwise order around their center ."}}
{"translation": {"code": "public static double acuteAngle ( LineGeneral2D_F64 a , LineGeneral2D_F64 b ) { double la = Math . sqrt ( a . A * a . A + a . B * a . B ) ; double lb = Math . sqrt ( b . A * b . A + b . B * b . B ) ; // numerical round off error can cause it to be barely greater than 1, which is outside the allowed // domain of acos() double value = ( a . A * b . A + a . B * b . B ) / ( la * lb ) ; if ( value < - 1.0 ) value = - 1.0 ; else if ( value > 1.0 ) value = 1.0 ; return Math . acos ( value ) ; }", "nl": "Returns the acute angle between the slope of two lines . Lines do not need to ever intersect . Found using the dot product ."}}
{"translation": {"code": "public static double quadrilateral ( Quadrilateral_F64 quad ) { double bx = quad . b . x - quad . a . x ; double by = quad . b . y - quad . a . y ; double cx = quad . c . x - quad . a . x ; double cy = quad . c . y - quad . a . y ; double dx = quad . d . x - quad . a . x ; double dy = quad . d . y - quad . a . y ; if ( ( bx * cy - by * cx >= 0 ) == ( cx * dy - cy * dx >= 0 ) ) { return triangle ( quad . a , quad . b , quad . c ) + triangle ( quad . a , quad . c , quad . d ) ; } else { return triangle ( quad . a , quad . b , quad . d ) + triangle ( quad . b , quad . c , quad . d ) ; } }", "nl": "Area of a quadrilateral computed from two triangles ."}}
{"translation": {"code": "public static void interpolate ( Se2_F64 a , Se2_F64 b , double where , Se2_F64 output ) { double w0 = 1.0 - where ; output . T . x = a . T . x * w0 + b . T . x * where ; output . T . y = a . T . y * w0 + b . T . y * where ; // interpolating rotation is more difficult // This only works well if the difference between the two angles is small double yaw0 = a . getYaw ( ) ; double yaw1 = b . getYaw ( ) ; double cw = UtilAngle . distanceCW ( yaw0 , yaw1 ) ; double ccw = UtilAngle . distanceCCW ( yaw0 , yaw1 ) ; double yaw ; if ( cw > ccw ) { yaw = yaw0 + ccw * where ; } else { yaw = yaw0 - cw * where ; } output . setYaw ( yaw ) ; }", "nl": "Perform linear interpolation"}}
{"translation": {"code": "public static Point2D_F64 center ( Quadrilateral_F64 quad , Point2D_F64 center ) { if ( center == null ) center = new Point2D_F64 ( ) ; center . x = quad . a . x + quad . b . x + quad . c . x + quad . d . x ; center . y = quad . a . y + quad . b . y + quad . c . y + quad . d . y ; center . x /= 4.0 ; center . y /= 4.0 ; return center ; }", "nl": "Computes the center or average point in the quadrilateral ."}}
{"translation": {"code": "public static double distance ( LineSegment2D_F64 segmentA , LineSegment2D_F64 segmentB ) { return Math . sqrt ( distanceSq ( segmentA , segmentB ) ) ; }", "nl": "Finds the distance between the two line segments"}}
{"translation": {"code": "public static double distance ( Quadrilateral_F64 quad , Point2D_F64 p ) { return Math . sqrt ( distanceSq ( quad , p ) ) ; }", "nl": "Returns the Euclidean distance of the closest point on the quadrilateral to the provided point ."}}
{"translation": {"code": "public static double distanceSq ( Quadrilateral_F64 quad , Point2D_F64 p ) { LineSegment2D_F64 seg = LineSegment2D_F64 . wrap ( quad . a , quad . b ) ; double a = distanceSq ( seg , p ) ; seg . a = quad . b ; seg . b = quad . c ; a = Math . min ( a , distanceSq ( seg , p ) ) ; seg . a = quad . c ; seg . b = quad . d ; a = Math . min ( a , distanceSq ( seg , p ) ) ; seg . a = quad . d ; seg . b = quad . a ; return Math . min ( a , distanceSq ( seg , p ) ) ; }", "nl": "Returns the Euclidean distance squared of the closest point on the quadrilateral to the provided point ."}}
{"translation": {"code": "public boolean isEquals ( Quadrilateral_F64 quad , double tol ) { tol *= tol ; if ( a . distance2 ( quad . a ) > tol ) return false ; if ( b . distance2 ( quad . b ) > tol ) return false ; if ( c . distance2 ( quad . c ) > tol ) return false ; return d . distance2 ( quad . d ) <= tol ; }", "nl": "Returns true if the two quadrilaterals are equal to each other to within tolerance . Equality is defined by seeing if the distance between two equivalent vertexes is within tolerance ."}}
{"translation": {"code": "public static double distanceSq ( Polygon2D_F64 poly , Point2D_F64 p , LineSegment2D_F64 storage ) { if ( storage == null ) storage = LineSegment2D_F64 . wrap ( null , null ) ; double minimum = Double . MAX_VALUE ; for ( int i = 0 ; i < poly . size ( ) ; i ++ ) { int j = ( i + 1 ) % poly . size ( ) ; storage . a = poly . vertexes . data [ i ] ; storage . b = poly . vertexes . data [ j ] ; double d = distanceSq ( storage , p ) ; if ( d < minimum ) minimum = d ; } return minimum ; }", "nl": "Returns the Euclidean distance squared of the closest point on the Polygon to the provided point ."}}
{"translation": {"code": "public static double distance ( Polygon2D_F64 poly , Point2D_F64 p ) { return Math . sqrt ( distanceSq ( poly , p , null ) ) ; }", "nl": "Returns the Euclidean distance of the closest point on the Polygon to the provided point ."}}
{"translation": {"code": "public static void vertexAverage ( Polygon2D_F64 input , Point2D_F64 average ) { average . setIdx ( 0 , 0 ) ; for ( int i = 0 ; i < input . size ( ) ; i ++ ) { Point2D_F64 v = input . vertexes . data [ i ] ; average . x += v . x ; average . y += v . y ; } average . x /= input . size ( ) ; average . y /= input . size ( ) ; }", "nl": "Computes the average of all the vertexes"}}
{"translation": {"code": "public static double polygonSimple ( Polygon2D_F64 poly ) { double total = 0 ; Point2D_F64 v0 = poly . get ( 0 ) ; Point2D_F64 v1 = poly . get ( 1 ) ; for ( int i = 2 ; i < poly . size ( ) ; i ++ ) { Point2D_F64 v2 = poly . get ( i ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; } Point2D_F64 v2 = poly . get ( 0 ) ; total += v1 . x * ( v2 . y - v0 . y ) ; v0 = v1 ; v1 = v2 ; v2 = poly . get ( 1 ) ; total += v1 . x * ( v2 . y - v0 . y ) ; return Math . abs ( total / 2.0 ) ; }", "nl": "Area of a simple polygon . Meaning it can be concave or convex but can t have self intersections"}}
{"translation": {"code": "public boolean isInside ( Point2D_F64 p ) { if ( isConvex ( ) ) { return Intersection2D_F64 . containConvex ( this , p ) ; } else { return Intersection2D_F64 . containConcave ( this , p ) ; } }", "nl": "Returns true if the point is inside the polygon . Points along the border are ambiguously considered inside or outside ."}}
{"translation": {"code": "public static void convert ( Polygon2D_F64 input , Quadrilateral_F64 output ) { if ( input . size ( ) != 4 ) throw new IllegalArgumentException ( \"Expected 4-sided polygon as input\" ) ; output . a . set ( input . get ( 0 ) ) ; output . b . set ( input . get ( 1 ) ) ; output . c . set ( input . get ( 2 ) ) ; output . d . set ( input . get ( 3 ) ) ; }", "nl": "Converts a polygon into a quadrilateral"}}
{"translation": {"code": "public static void convert ( Rectangle2D_F64 input , Polygon2D_F64 output ) { if ( output . size ( ) != 4 ) throw new IllegalArgumentException ( \"polygon of order 4 expected\" ) ; output . get ( 0 ) . set ( input . p0 . x , input . p0 . y ) ; output . get ( 1 ) . set ( input . p1 . x , input . p0 . y ) ; output . get ( 2 ) . set ( input . p1 . x , input . p1 . y ) ; output . get ( 3 ) . set ( input . p0 . x , input . p1 . y ) ; }", "nl": "Converts a rectangle into a polygon"}}
{"translation": {"code": "public static Vector2D_F64 minus ( Point2D_F64 a , Point2D_F64 b , Vector2D_F64 output ) { if ( output == null ) output = new Vector2D_F64 ( ) ; output . x = a . x - b . x ; output . y = a . y - b . y ; return output ; }", "nl": "Sets the vector equal to a - b ."}}
{"translation": {"code": "public static boolean containTriangle ( Point2D_F64 a , Point2D_F64 b , Point2D_F64 c , Point2D_F64 pt ) { boolean ret = false ; if ( ( ( a . y > pt . y ) != ( b . y > pt . y ) ) && ( pt . x < ( b . x - a . x ) * ( pt . y - a . y ) / ( b . y - a . y ) + a . x ) ) ret = true ; if ( ( ( b . y > pt . y ) != ( c . y > pt . y ) ) && ( pt . x < ( c . x - b . x ) * ( pt . y - b . y ) / ( c . y - b . y ) + b . x ) ) ret = ! ret ; if ( ( ( c . y > pt . y ) != ( a . y > pt . y ) ) && ( pt . x < ( a . x - c . x ) * ( pt . y - c . y ) / ( a . y - c . y ) + c . x ) ) ret = ! ret ; return ret ; }", "nl": "Returns true of the the point is inside the triangle ."}}
{"translation": {"code": "public static double intersectionArea ( Rectangle2D_F64 a , Rectangle2D_F64 b ) { if ( ! intersects ( a , b ) ) return 0 ; double x0 = Math . max ( a . p0 . x , b . p0 . x ) ; double x1 = Math . min ( a . p1 . x , b . p1 . x ) ; double y0 = Math . max ( a . p0 . y , b . p0 . y ) ; double y1 = Math . min ( a . p1 . y , b . p1 . y ) ; return ( x1 - x0 ) * ( y1 - y0 ) ; }", "nl": "Returns the area of the intersection of two rectangles ."}}
{"translation": {"code": "public double distance ( double x , double y ) { double dx = x - this . x ; double dy = y - this . y ; return Math . sqrt ( dx * dx + dy * dy ) ; }", "nl": "Euclidean distance from the point"}}
{"translation": {"code": "public static boolean contains ( Quadrilateral_F64 quad , Point2D_F64 pt ) { return containTriangle ( quad . a , quad . b , quad . d , pt ) || containTriangle ( quad . b , quad . c , quad . d , pt ) ; }", "nl": "True if the point is contained inside the quadrilateral ."}}
{"translation": {"code": "public static void convexHull ( List < Point2D_F64 > points , Polygon2D_F64 hull ) { Point2D_F64 [ ] array = new Point2D_F64 [ points . size ( ) ] ; for ( int i = 0 ; i < points . size ( ) ; i ++ ) { array [ i ] = points . get ( i ) ; } AndrewMonotoneConvexHull_F64 andrew = new AndrewMonotoneConvexHull_F64 ( ) ; andrew . process ( array , array . length , hull ) ; }", "nl": "Computes the convex hull of the set of points ."}}
{"translation": {"code": "public void process ( Point2D_F64 [ ] input , int length , Polygon2D_F64 hull ) { // ahdnle special cases if ( length == 2 ) { hull . vertexes . resize ( length ) ; for ( int i = 0 ; i < length ; i ++ ) { hull . get ( i ) . set ( input [ i ] ) ; } return ; } sorter . sort ( input , length ) ; work . reset ( ) ; // construct the lower hull for ( int i = 0 ; i < length ; i ++ ) { Point2D_F64 p = input [ i ] ; //Contains at least 2 points and the last two points and 'p' do not make a counter-clockwise turn while ( work . size ( ) >= 2 && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { // remove the last points from the hull work . removeTail ( ) ; } // append p to the end work . add ( p ) ; } work . removeTail ( ) ; int minSize = work . size + 2 ; // construct upper hull for ( int i = length - 1 ; i >= 0 ; i -- ) // Finding top layer from hull { //Contains at least 2 points and the last two points and 'p' do not make a counter-clockwise turn Point2D_F64 p = input [ i ] ; while ( work . size ( ) >= minSize && subtractThenCross ( p , work . getTail ( 0 ) , work . getTail ( 1 ) ) >= 0 ) { work . removeTail ( ) ; } // append p to the end work . add ( p ) ; } work . removeTail ( ) ; // create a copy for the output // the work buffer contains references to the input points, but to be safe the output should have its // own instances hull . vertexes . resize ( work . size ) ; for ( int i = 0 ; i < work . size ( ) ; i ++ ) { hull . vertexes . data [ i ] . set ( work . get ( i ) ) ; } }", "nl": "Computes the convex hull . The output will be in counter - clockwise order ."}}
{"translation": {"code": "public static Point2D_F64 mean ( Point2D_F64 [ ] list , int offset , int length , Point2D_F64 mean ) { if ( mean == null ) mean = new Point2D_F64 ( ) ; double x = 0 ; double y = 0 ; for ( int i = 0 ; i < length ; i ++ ) { Point2D_F64 p = list [ offset + i ] ; x += p . getX ( ) ; y += p . getY ( ) ; } x /= length ; y /= length ; mean . set ( x , y ) ; return mean ; }", "nl": "Finds the point which has the mean location of all the points in the array . This is also known as the centroid ."}}
{"translation": {"code": "public static double distanceOrigin ( LineParametric2D_F64 line ) { double top = line . slope . y * line . p . x - line . slope . x * line . p . y ; return Math . abs ( top ) / line . slope . norm ( ) ; }", "nl": "Returns the distance of the closest point on the line from the origin"}}
{"translation": {"code": "private static double get ( DMatrixRMaj M , int index ) { if ( index < 0 ) { return - M . data [ - index - 1 ] ; } else { return M . data [ index - 1 ] ; } }", "nl": "If the index is negative it returns the negative of the value at - index . Starts at 0"}}
{"translation": {"code": "public static boolean contains ( EllipseRotated_F64 ellipse , double x , double y ) { return ( UtilEllipse_F64 . evaluate ( x , y , ellipse ) <= 1.0 ) ; }", "nl": "Tests to see if the provided point lies on or is contained inside the ellipse"}}
{"translation": {"code": "public static double distance2 ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { // put point into ellipse's reference frame double cphi = Math . cos ( ellipse . phi ) ; double sphi = Math . sin ( ellipse . phi ) ; double xc = p . x - ellipse . center . x ; double yc = p . y - ellipse . center . y ; double r = Math . sqrt ( xc * xc + yc * yc ) ; double x = cphi * xc + sphi * yc ; double y = - sphi * xc + cphi * yc ; double ct = x / r ; double st = y / r ; x = ellipse . center . x + ellipse . a * ct * cphi - ellipse . b * st * sphi ; y = ellipse . center . y + ellipse . a * ct * sphi + ellipse . b * st * cphi ; return p . distance2 ( x , y ) ; }", "nl": "Euclidean distance squared of closest point on ellipse to point p ."}}
{"translation": {"code": "public static double distance ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { return Math . sqrt ( distance2 ( ellipse , p ) ) ; }", "nl": "Euclidean distance of closest point on ellipse to point p ."}}
{"translation": {"code": "public static Vector2D_F64 computeTangent ( double t , EllipseRotated_F64 ellipse , Vector2D_F64 output ) { if ( output == null ) output = new Vector2D_F64 ( ) ; double ct = Math . cos ( t ) ; double st = Math . sin ( t ) ; double cphi = Math . cos ( ellipse . phi ) ; double sphi = Math . sin ( ellipse . phi ) ; // point in ellipse frame multiplied by b^2 and a^2 double x = ellipse . a * ct * ellipse . b * ellipse . b ; double y = ellipse . b * st * ellipse . a * ellipse . a ; // rotate vector normal into world frame double rx = x * cphi - y * sphi ; double ry = x * sphi + y * cphi ; // normalize and change into tangent double r = Math . sqrt ( rx * rx + ry * ry ) ; output . x = - ry / r ; output . y = rx / r ; return output ; }", "nl": "Computes the tangent to the ellipse at the specified location"}}
{"translation": {"code": "boolean selectTangent ( Point2D_F64 a , Point2D_F64 previousTangent , EllipseRotated_F64 ellipse , Point2D_F64 tangent , boolean cross ) { if ( ! tangentLines ( a , ellipse , temp0 , temp1 ) ) return false ; tempLine . a = a ; tempLine . b = temp0 ; boolean crossed0 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; tempLine . b = temp1 ; boolean crossed1 = Intersection2D_F64 . intersection ( centerLine , tempLine , junk ) != null ; if ( crossed0 == crossed1 ) throw new RuntimeException ( \"Well this didn't work\" ) ; if ( cross == crossed0 ) { sumDifference += previousTangent . distance2 ( temp0 ) ; tangent . set ( temp0 ) ; } else { sumDifference += previousTangent . distance2 ( temp1 ) ; tangent . set ( temp1 ) ; } return true ; }", "nl": "Selects a tangent point on the ellipse which is closest to the original source point of A ."}}
{"translation": {"code": "public static boolean identicalSign ( double xa , double ya , double xb , double yb , double tol ) { double dx0 = xb - xa ; double dy0 = yb - ya ; double dx1 = xb + xa ; double dy1 = yb + ya ; double error0 = dx0 * dx0 + dy0 * dy0 ; double error1 = dx1 * dx1 + dy1 * dy1 ; if ( error0 < error1 ) { return error0 <= tol * tol ; } else { return error1 <= tol * tol ; } }", "nl": "Tests to see if the two vectors are identical up to a sign difference"}}
{"translation": {"code": "public static < T extends GeoTuple3D_F64 < T > > T latlonToUnitVector ( double lat , double lon , T vector ) { if ( vector == null ) vector = ( T ) new Vector3D_F64 ( ) ; vector . x = Math . cos ( lat ) * Math . cos ( lon ) ; vector . y = Math . cos ( lat ) * Math . sin ( lon ) ; vector . z = - Math . sin ( lat ) ; return vector ; }", "nl": "Converts latitude and longitude coordinates into a unit vector"}}
{"translation": {"code": "public static boolean intersect ( LineParametric3D_F64 line , Sphere3D_F64 sphere , Point3D_F64 a , Point3D_F64 b ) { // this equation was found by solving for l: // ||(P + V*l) - X0|| == r double r2 = sphere . radius * sphere . radius ; double PP = GeometryMath_F64 . dot ( line . p , line . p ) ; double PV = GeometryMath_F64 . dot ( line . p , line . slope ) ; double PX = GeometryMath_F64 . dot ( line . p , sphere . center ) ; double VV = GeometryMath_F64 . dot ( line . slope , line . slope ) ; double VX = GeometryMath_F64 . dot ( line . slope , sphere . center ) ; double XX = GeometryMath_F64 . dot ( sphere . center , sphere . center ) ; // Coefficients in the quadratic equation double A = VV ; double B = 2.0 * ( PV - VX ) ; double C = PP + XX - 2.0 * PX - r2 ; // solve for the quadratic equation double inner = B * B - 4.0 * A * C ; if ( inner < 0 ) return false ; double sqrt = Math . sqrt ( inner ) ; double t0 = ( - B + sqrt ) / ( 2.0 * A ) ; double t1 = ( - B - sqrt ) / ( 2.0 * A ) ; line . setPointOnLine ( t0 , a ) ; line . setPointOnLine ( t1 , b ) ; return true ; }", "nl": "Finds the intersection of a line and sphere . There can be 0 1 or 2 intersections . If there is 1 intersection the same point is returned twice ."}}
{"translation": {"code": "public static void removeAlmostParallel ( Polygon2D_F64 polygon , double tol ) { for ( int i = 0 ; i < polygon . vertexes . size ( ) ; ) { int j = ( i + 1 ) % polygon . vertexes . size ( ) ; int k = ( i + 2 ) % polygon . vertexes . size ( ) ; Point2D_F64 p0 = polygon . vertexes . get ( i ) ; Point2D_F64 p1 = polygon . vertexes . get ( j ) ; Point2D_F64 p2 = polygon . vertexes . get ( k ) ; double angle = UtilVector2D_F64 . acute ( p1 . x - p0 . x , p1 . y - p0 . y , p2 . x - p1 . x , p2 . y - p1 . y ) ; if ( angle <= tol ) { polygon . vertexes . remove ( j ) ; if ( j < i ) i = polygon . vertexes . size ( ) - 1 ; } else { i ++ ; } } }", "nl": "Removes a node from a polygon if the two lines its attached two are almost parallel"}}
{"translation": {"code": "public static TwistCoordinate_F64 twist ( Se3_F64 motion , TwistCoordinate_F64 twist ) { if ( twist == null ) twist = new TwistCoordinate_F64 ( ) ; if ( MatrixFeatures_DDRM . isIdentity ( motion . R , GrlConstants . TEST_F64 ) ) { twist . w . set ( 0 , 0 , 0 ) ; twist . v . set ( motion . T ) ; } else { Rodrigues_F64 rod = new Rodrigues_F64 ( ) ; ConvertRotation3D_F64 . matrixToRodrigues ( motion . R , rod ) ; twist . w . set ( rod . unitAxisRotation ) ; double theta = rod . theta ; // A = (I-SO)*hat(w) + w*w'*theta DMatrixRMaj A = CommonOps_DDRM . identity ( 3 ) ; CommonOps_DDRM . subtract ( A , motion . R , A ) ; DMatrixRMaj w_hat = GeometryMath_F64 . crossMatrix ( twist . w , null ) ; DMatrixRMaj tmp = A . copy ( ) ; CommonOps_DDRM . mult ( tmp , w_hat , A ) ; Vector3D_F64 w = twist . w ; A . data [ 0 ] += w . x * w . x * theta ; A . data [ 1 ] += w . x * w . y * theta ; A . data [ 2 ] += w . x * w . z * theta ; A . data [ 3 ] += w . y * w . x * theta ; A . data [ 4 ] += w . y * w . y * theta ; A . data [ 5 ] += w . y * w . z * theta ; A . data [ 6 ] += w . z * w . x * theta ; A . data [ 7 ] += w . z * w . y * theta ; A . data [ 8 ] += w . z * w . z * theta ; DMatrixRMaj y = new DMatrixRMaj ( 3 , 1 ) ; y . data [ 0 ] = motion . T . x ; y . data [ 1 ] = motion . T . y ; y . data [ 2 ] = motion . T . z ; DMatrixRMaj x = new DMatrixRMaj ( 3 , 1 ) ; CommonOps_DDRM . solve ( A , y , x ) ; twist . w . scale ( rod . theta ) ; twist . v . x = ( double ) x . data [ 0 ] ; twist . v . y = ( double ) x . data [ 1 ] ; twist . v . z = ( double ) x . data [ 2 ] ; twist . v . scale ( rod . theta ) ; } return twist ; }", "nl": "Converts a rigid body motion into a twist coordinate . The value of theta used to generate the motion is assumed to be one ."}}
{"translation": {"code": "public static void divide ( GeoTuple3D_F64 p , double v ) { p . x /= v ; p . y /= v ; p . z /= v ; }", "nl": "Divides each element by v"}}
{"translation": {"code": "public static Vector3D_F64 perpendicularCanonical ( Vector3D_F64 A , Vector3D_F64 output ) { if ( output == null ) output = new Vector3D_F64 ( ) ; // normalize for scaling double scale = Math . abs ( A . x ) + Math . abs ( A . y ) + Math . abs ( A . z ) ; if ( scale == 0 ) { output . set ( 0 , 0 , 0 ) ; } else { double x = A . x / scale ; double y = A . y / scale ; double z = A . z / scale ; // For numerical stability ensure that the largest variable is swapped if ( Math . abs ( x ) > Math . abs ( y ) ) { output . set ( z , 0 , - x ) ; } else { output . set ( 0 , z , - y ) ; } } return output ; }", "nl": "Selects a vector which will be perpendicular ."}}
{"translation": {"code": "public static void point2Dto3D ( Point3D_F64 origin , Vector3D_F64 axisX , Vector3D_F64 axisY , Point2D_F64 A , Point3D_F64 output ) { output . x = origin . x + axisX . x * A . x + axisY . y * A . y ; output . y = origin . y + axisX . y * A . x + axisY . y * A . y ; output . z = origin . z + axisX . z * A . x + axisY . y * A . y ; }", "nl": "Given a point on the plane s 2D coordinate system convert it back into a 3D point ."}}