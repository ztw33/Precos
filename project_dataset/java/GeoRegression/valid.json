{"translation": {"code": "public static Point2D_F64 intersection ( Point2D_F64 lineA0 , Point2D_F64 lineA1 , Point2D_F64 lineB0 , Point2D_F64 lineB1 , Point2D_F64 output ) { if ( output == null ) output = new Point2D_F64 ( ) ; double slopeAx = lineA1 . x - lineA0 . x ; double slopeAy = lineA1 . y - lineA0 . y ; double slopeBx = lineB1 . x - lineB0 . x ; double slopeBy = lineB1 . y - lineB0 . y ; double top = slopeAy * ( lineB0 . x - lineA0 . x ) + slopeAx * ( lineA0 . y - lineB0 . y ) ; double bottom = slopeAx * slopeBy - slopeAy * slopeBx ; if ( bottom == 0 ) return null ; double t = top / bottom ; output . x = lineB0 . x + t * slopeBx ; output . y = lineB0 . y + t * slopeBy ; return output ; }", "nl": "Finds the point of intersection between the two lines defined by the set sets of points passed in ."}}
{"translation": {"code": "public static boolean circle ( Point2D_F64 x0 , Point2D_F64 x1 , Point2D_F64 x2 , Circle2D_F64 circle ) { // points that lie on line a and b double xa = ( x0 . x + x1 . x ) / 2.0 ; double ya = ( x0 . y + x1 . y ) / 2.0 ; double xb = ( x1 . x + x2 . x ) / 2.0 ; double yb = ( x1 . y + x2 . y ) / 2.0 ; // slopes of lines a and b double m2 = x0 . x - x1 . x ; double m1 = x1 . y - x0 . y ; double n2 = x2 . x - x1 . x ; double n1 = x1 . y - x2 . y ; // find the intersection of the lines double bottom = m2 * n1 - n2 * m1 ; if ( bottom == 0 ) return false ; double alpha = ( - m2 * ( xb - xa ) + m1 * ( yb - ya ) ) / bottom ; circle . center . x = xb + n1 * alpha ; circle . center . y = yb + n2 * alpha ; circle . radius = circle . center . distance ( x0 ) ; return true ; }", "nl": "Given three points find the circle that intersects all three . If false is returned that means the points all lie along a line and there is no circle ."}}
{"translation": {"code": "public static double averageOfClosestPointError ( Polygon2D_F64 model , Polygon2D_F64 target , int numberOfSamples ) { LineSegment2D_F64 line = new LineSegment2D_F64 ( ) ; double cornerLocationsB [ ] = new double [ target . size ( ) + 1 ] ; double totalLength = 0 ; for ( int i = 0 ; i < target . size ( ) ; i ++ ) { Point2D_F64 b0 = target . get ( i % target . size ( ) ) ; Point2D_F64 b1 = target . get ( ( i + 1 ) % target . size ( ) ) ; cornerLocationsB [ i ] = totalLength ; totalLength += b0 . distance ( b1 ) ; } cornerLocationsB [ target . size ( ) ] = totalLength ; Point2D_F64 pointOnB = new Point2D_F64 ( ) ; double error = 0 ; int cornerB = 0 ; for ( int k = 0 ; k < numberOfSamples ; k ++ ) { // Find the point on B to match to a point on A double location = totalLength * k / numberOfSamples ; while ( location > cornerLocationsB [ cornerB + 1 ] ) { cornerB ++ ; } Point2D_F64 b0 = target . get ( cornerB ) ; Point2D_F64 b1 = target . get ( ( cornerB + 1 ) % target . size ( ) ) ; double locationCornerB = cornerLocationsB [ cornerB ] ; double fraction = ( location - locationCornerB ) / ( cornerLocationsB [ cornerB + 1 ] - locationCornerB ) ; pointOnB . x = ( b1 . x - b0 . x ) * fraction + b0 . x ; pointOnB . y = ( b1 . y - b0 . y ) * fraction + b0 . y ; // find the best fit point on A to the point in B double best = Double . MAX_VALUE ; for ( int i = 0 ; i < model . size ( ) + 1 ; i ++ ) { line . a = model . get ( i % model . size ( ) ) ; line . b = model . get ( ( i + 1 ) % model . size ( ) ) ; double d = Distance2D_F64 . distance ( line , pointOnB ) ; if ( d < best ) { best = d ; } } error += best ; } return error / numberOfSamples ; }", "nl": "Compute the error as a function of the distance between the model and target . The target is sampled at regular intervals and for each of these points the closest point on the model is found . The returned metric is the average of difference between paired points ."}}
{"translation": {"code": "public static void bounding ( Polygon2D_F64 polygon , Rectangle2D_F64 rectangle ) { rectangle . p0 . set ( polygon . get ( 0 ) ) ; rectangle . p1 . set ( polygon . get ( 0 ) ) ; for ( int i = 0 ; i < polygon . size ( ) ; i ++ ) { Point2D_F64 p = polygon . get ( i ) ; if ( p . x < rectangle . p0 . x ) { rectangle . p0 . x = p . x ; } else if ( p . x > rectangle . p1 . x ) { rectangle . p1 . x = p . x ; } if ( p . y < rectangle . p0 . y ) { rectangle . p0 . y = p . y ; } else if ( p . y > rectangle . p1 . y ) { rectangle . p1 . y = p . y ; } } }", "nl": "Finds the minimum area bounding rectangle around the quadrilateral that is aligned with coordinate system axises ."}}
{"translation": {"code": "public static double intersection ( Polygon2D_F64 a , Polygon2D_F64 b ) { AreaIntersectionPolygon2D_F64 alg = new AreaIntersectionPolygon2D_F64 ( ) ; return Math . abs ( alg . computeArea ( a , b ) ) ; }", "nl": "Finds the area of the intersection of two polygons ."}}
{"translation": {"code": "public double computeArea ( Polygon2D_F64 a , Polygon2D_F64 b ) { ssss = 0 ; sclx = 0 ; scly = 0 ; return inter ( a , b ) ; }", "nl": "Computes the area of the intersection between the two polygons ."}}
{"translation": {"code": "public Point3D_F64 getCorner ( int index , Point3D_F64 corner ) { if ( corner == null ) corner = new Point3D_F64 ( ) ; corner . set ( p ) ; if ( ( index & 0x01 ) != 0 ) { corner . x += lengthX ; } if ( ( index & 0x02 ) != 0 ) { corner . y += lengthY ; } if ( ( index & 0x04 ) != 0 ) { corner . z += lengthZ ; } return corner ; }", "nl": "Used to retrieve the corners of the box ."}}
{"translation": {"code": "public static ParabolaGeneral_F64 convert ( ConicGeneral_F64 src , ParabolaGeneral_F64 dst ) { if ( dst == null ) dst = new ParabolaGeneral_F64 ( ) ; // NOTE haven't put much through if this is the correct way to handle negative values of A or C dst . A = Math . signum ( src . A ) * Math . sqrt ( Math . abs ( src . A ) ) ; dst . C = Math . signum ( src . C ) * Math . sqrt ( Math . abs ( src . C ) ) ; dst . D = src . D ; dst . E = src . E ; dst . F = src . F ; return dst ; }", "nl": "Converts the conic into a parabola . If the conic isn t a parabola then it is converted into one by adjusting the value of B ."}}
{"translation": {"code": "public boolean isEquivalent ( ParabolaGeneral_F64 parabola , double tol ) { double scale = relativeScale ( parabola ) ; if ( Math . abs ( A * scale - parabola . A ) > tol ) return false ; if ( Math . abs ( C * scale - parabola . C ) > tol ) return false ; if ( Math . abs ( D * scale - parabola . D ) > tol ) return false ; if ( Math . abs ( E * scale - parabola . E ) > tol ) return false ; if ( Math . abs ( F * scale - parabola . F ) > tol ) return false ; return true ; }", "nl": "Determines if they are equivalent up to a scale factor"}}
{"translation": {"code": "public static List < Point3D_F64 > randomN ( Point3D_F64 mean , double stdX , double stdY , double stdZ , int num , Random rand ) { List < Point3D_F64 > ret = new ArrayList <> ( ) ; for ( int i = 0 ; i < num ; i ++ ) { Point3D_F64 p = new Point3D_F64 ( ) ; p . x = mean . x + rand . nextGaussian ( ) * stdX ; p . y = mean . y + rand . nextGaussian ( ) * stdY ; p . z = mean . z + rand . nextGaussian ( ) * stdZ ; ret . add ( p ) ; } return ret ; }", "nl": "Creates a list of random points from a normal distribution along each axis"}}
{"translation": {"code": "public void set ( double x , double y , double z , EulerType type , double rotA , double rotB , double rotC ) { T . set ( x , y , z ) ; ConvertRotation3D_F64 . eulerToMatrix ( type , rotA , rotB , rotC , R ) ; }", "nl": "Fully specify the transform using Euler angles"}}
{"translation": {"code": "public void timesIP ( double scalar ) { x *= scalar ; y *= scalar ; z *= scalar ; w *= scalar ; }", "nl": "In - place scalar multiplication"}}
{"translation": {"code": "public static Se3_F64 axisXyz ( double dx , double dy , double dz , double rotX , double rotY , double rotZ , Se3_F64 se ) { if ( se == null ) se = new Se3_F64 ( ) ; double theta = Math . sqrt ( rotX * rotX + rotY + rotY + rotZ * rotZ ) ; if ( theta == 0 ) { CommonOps_DDRM . setIdentity ( se . R ) ; } else { ConvertRotation3D_F64 . rodriguesToMatrix ( rotX / theta , rotY / theta , rotZ / theta , theta , se . getR ( ) ) ; } Vector3D_F64 T = se . getT ( ) ; T . x = dx ; T . y = dy ; T . z = dz ; return se ; }", "nl": "Create SE3 using axis - angle for rotation and XYZ tanslation"}}
{"translation": {"code": "public static DMatrix3x3 convert ( ConicGeneral_F64 src , DMatrix3x3 dst ) { if ( dst == null ) dst = new DMatrix3x3 ( ) ; double B = src . B / 2.0 ; double D = src . D / 2.0 ; double E = src . E / 2.0 ; dst . a11 = src . A ; dst . a12 = B ; dst . a13 = D ; dst . a21 = B ; dst . a22 = src . C ; dst . a23 = E ; dst . a31 = D ; dst . a32 = E ; dst . a33 = src . F ; return dst ; }", "nl": "Converts the conic into a symmetric 3x3 matrix"}}
{"translation": {"code": "public static void computeNormal ( List < Point2D_F64 > points , Point2D_F64 mean , DMatrix covariance ) { if ( covariance . getNumCols ( ) != 2 || covariance . getNumRows ( ) != 2 ) { if ( covariance instanceof ReshapeMatrix ) { ( ( ReshapeMatrix ) covariance ) . reshape ( 2 , 2 ) ; } else { throw new IllegalArgumentException ( \"Must be a 2x2 matrix\" ) ; } } mean ( points , mean ) ; double xx = 0 , xy = 0 , yy = 0 ; for ( int i = 0 ; i < points . size ( ) ; i ++ ) { Point2D_F64 p = points . get ( i ) ; double dx = p . x - mean . x ; double dy = p . y - mean . y ; xx += dx * dx ; xy += dx * dy ; yy += dy * dy ; } xx /= points . size ( ) ; xy /= points . size ( ) ; yy /= points . size ( ) ; covariance . unsafe_set ( 0 , 0 , xx ) ; covariance . unsafe_set ( 0 , 1 , xy ) ; covariance . unsafe_set ( 1 , 0 , xy ) ; covariance . unsafe_set ( 1 , 1 , yy ) ; }", "nl": "Computes the mean and covariance matrix from the set of points . This describes a normal distribution"}}