{"translation": {"code": "private void refreshAfterStatusChanged ( final boolean oldStatus , final boolean newStatus , final int formRow , final int formCol , final FacesCell cell , final boolean updateGui ) { if ( ! newStatus ) { cell . setErrormsg ( \"\" ) ; } cell . setInvalid ( newStatus ) ; if ( updateGui && ( oldStatus != newStatus ) && ( parent . getWebFormClientId ( ) != null ) ) { RequestContext . getCurrentInstance ( ) . update ( parent . getWebFormClientId ( ) + \":\" + ( formRow ) + \":group\" + ( formCol ) ) ; } }", "nl": "Refresh after status changed ."}}
{"translation": {"code": "private void clearWorkbook ( ) { parent . setFormulaEvaluator ( null ) ; parent . setDataFormatter ( null ) ; parent . setSheetConfigMap ( null ) ; parent . setTabs ( null ) ; parent . getSerialDataContext ( ) . setDataContext ( null ) ; parent . setPicturesMap ( null ) ; parent . setHeaderRows ( null ) ; parent . setBodyRows ( null ) ; parent . setWb ( null ) ; parent . getHeaderRows ( ) . clear ( ) ; parent . getBodyRows ( ) . clear ( ) ; parent . getCharsData ( ) . getChartsMap ( ) . clear ( ) ; parent . getCharsData ( ) . getChartDataMap ( ) . clear ( ) ; parent . getCharsData ( ) . getChartAnchorsMap ( ) . clear ( ) ; parent . getCharsData ( ) . getChartPositionMap ( ) . clear ( ) ; parent . getCellAttributesMap ( ) . clear ( ) ; }", "nl": "Clear workbook ."}}
{"translation": {"code": "public static int convertColToInt ( final String col ) { String name = col . toUpperCase ( ) ; int number = 0 ; int pow = 1 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { number += ( name . charAt ( i ) - ' ' + 1 ) * pow ; pow *= TieConstants . EXCEL_LETTER_NUMBERS ; } return number - 1 ; }", "nl": "Convert col to int ."}}
{"translation": {"code": "public static Cell getCellByReference ( final String cellRef , final Sheet sheet ) { Cell c = null ; try { CellReference ref = new CellReference ( cellRef ) ; Row r = sheet . getRow ( ref . getRow ( ) ) ; if ( r != null ) { c = r . getCell ( ref . getCol ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; } } catch ( Exception ex ) { // use log.debug because mostly it's expected\r LOG . log ( Level . SEVERE , \"WebForm WebFormHelper getCellByReference cellRef = \" + cellRef + \"; error = \" + ex . getLocalizedMessage ( ) , ex ) ; } return c ; }", "nl": "Gets the cell by reference ."}}
{"translation": {"code": "public static int heightUnits2Pixel ( final short heightUnits ) { int pixels = heightUnits / EXCEL_ROW_HEIGHT_FACTOR ; int offsetHeightUnits = heightUnits % EXCEL_ROW_HEIGHT_FACTOR ; pixels += Math . round ( ( float ) offsetHeightUnits / ( ( float ) EXCEL_COLUMN_WIDTH_FACTOR / UNIT_OFFSET_LENGTH / 2 ) ) ; pixels += ( Math . floor ( pixels / PIXEL_HEIGHT_ASPC_ADJUST ) + 1 ) * 4 ; return pixels ; }", "nl": "Height units 2 pixel ."}}
{"translation": {"code": "public boolean validateWithRowColInCurrentPage ( final int row , final int col , boolean updateGui ) { //until now passEmptyCheck has one to one relation to submitMode\r //e.g. when passEmptyCheck = false, then submitMode = true.\r boolean submitMode = parent . getSubmitMode ( ) ; boolean passEmptyCheck = ! submitMode ; int topRow = parent . getCurrent ( ) . getCurrentTopRow ( ) ; int leftCol = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; boolean pass = true ; FacesRow fRow = CellUtility . getFacesRowFromBodyRow ( row , parent . getBodyRows ( ) , topRow ) ; if ( fRow == null ) { return pass ; } FacesCell cell = CellUtility . getFacesCellFromBodyRow ( row , col , parent . getBodyRows ( ) , topRow , leftCol ) ; if ( cell == null ) { return pass ; } Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( row , col ) ; boolean oldStatus = cell . isInvalid ( ) ; String value = CellUtility . getCellValueWithoutFormat ( poiCell ) ; if ( value == null ) { value = \"\" ; } else { value = value . trim ( ) ; } if ( passEmptyCheck && value . isEmpty ( ) ) { refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; return pass ; } if ( ( ( parent . isOnlyValidateInSubmitMode ( ) && submitMode ) || ! parent . isOnlyValidateInSubmitMode ( ) ) && ! validateByTieWebSheetValidationBean ( poiCell , topRow , leftCol , cell , value , updateGui ) ) { return false ; } SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; List < CellFormAttributes > cellAttributes = CellControlsUtility . findCellValidateAttributes ( parent . getCellAttributesMap ( ) . getCellValidateAttributes ( ) , fRow . getOriginRowIndex ( ) , poiCell ) ; if ( parent . isAdvancedContext ( ) && parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) != null && ! checkErrorMessageFromObjectInContext ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , updateGui ) ) { return false ; } if ( cellAttributes != null ) { pass = validateAllRulesForSingleCell ( row - topRow , col - leftCol , cell , poiCell , value , sheetConfig , cellAttributes , updateGui ) ; } if ( pass ) { refreshAfterStatusChanged ( oldStatus , false , row - topRow , col - leftCol , cell , updateGui ) ; } return pass ; }", "nl": "Validate with row col in current page ."}}
{"translation": {"code": "private boolean validateAllRulesForSingleCell ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , final List < CellFormAttributes > cellAttributes , boolean updateGui ) { Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; for ( CellFormAttributes attr : cellAttributes ) { boolean pass = doValidation ( value , attr , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , sheet1 ) ; if ( ! pass ) { String errmsg = attr . getMessage ( ) ; if ( errmsg == null ) { errmsg = TieConstants . DEFALT_MSG_INVALID_INPUT ; } cell . setErrormsg ( errmsg ) ; LOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { poiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errmsg } ) ; refreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; return false ; } } return true ; }", "nl": "Validate all rules for single cell ."}}
{"translation": {"code": "private boolean doValidation ( final Object value , final CellFormAttributes attr , final int rowIndex , final int colIndex , final Sheet sheet ) { boolean pass ; String attrValue = attr . getValue ( ) ; attrValue = attrValue . replace ( \"$value\" , value . toString ( ) + \"\" ) . replace ( \"$rowIndex\" , rowIndex + \"\" ) . replace ( \"$colIndex\" , colIndex + \"\" ) . replace ( \"$sheetName\" , sheet . getSheetName ( ) ) ; attrValue = ConfigurationUtility . replaceExpressionWithCellValue ( attrValue , rowIndex , sheet ) ; if ( attrValue . contains ( TieConstants . EL_START ) ) { Object returnObj = FacesUtility . evaluateExpression ( attrValue , Object . class ) ; attrValue = returnObj . toString ( ) ; pass = Boolean . parseBoolean ( attrValue ) ; } else { pass = parent . getCellHelper ( ) . evalBoolExpression ( attrValue ) ; } return pass ; }", "nl": "Do validation ."}}
{"translation": {"code": "public final void loadWorkSheet ( final String tabName ) { prepareWorkShee ( tabName ) ; parent . getValidationHandler ( ) . validateCurrentPage ( ) ; createDynamicColumns ( tabName ) ; // reset datatable current page to 1\r setDataTablePage ( 0 ) ; parent . getCurrent ( ) . setCurrentDataContextName ( null ) ; saveObjs ( ) ; if ( ( RequestContext . getCurrentInstance ( ) != null ) && ( parent . getClientId ( ) != null ) ) { RequestContext . getCurrentInstance ( ) . update ( parent . getClientId ( ) + \":websheettab\" ) ; } }", "nl": "Load work sheet ."}}
{"translation": {"code": "public final boolean validateCell ( final UIComponent target ) { int [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( target ) ; int row = rowcol [ 0 ] ; int col = rowcol [ 1 ] ; return validateWithRowColInCurrentPage ( row , col , true ) ; }", "nl": "Validate cell ."}}
{"translation": {"code": "public String getTabStyle ( ) { String tabStyle = TieConstants . TAB_STYLE_VISIBLE ; int sheetId = webFormTabView . getActiveIndex ( ) ; if ( ( sheetId >= 0 ) && ( sheetId < tabs . size ( ) ) ) { tabStyle = TieConstants . TAB_STYLE_INVISIBLE ; } return tabStyle ; }", "nl": "get tab style ."}}
{"translation": {"code": "private void loadHeaderRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { int top = sheetConfig . getHeaderCellRange ( ) . getTopRow ( ) ; int bottom = sheetConfig . getHeaderCellRange ( ) . getBottomRow ( ) ; int left = sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) ; int right = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) ; String sheetName = sheetConfig . getSheetName ( ) ; Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; int totalWidth = CellStyleUtility . calcTotalWidth ( sheet1 , left , right , WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) + parent . getAddRowColumnWidth ( ) ) ) ; RangeBuildRef rangeBuildRef = new RangeBuildRef ( left , right , totalWidth , sheet1 ) ; if ( sheetConfig . isFixedWidthStyle ( ) ) { parent . setTableWidthStyle ( \"table-layout: fixed; width:\" + WebSheetUtility . widthUnits2Pixel ( totalWidth ) + \"px;\" ) ; } parent . setLineNumberColumnWidthStyle ( getWidthStyle ( WebSheetUtility . pixel2WidthUnits ( parent . getLineNumberColumnWidth ( ) ) , totalWidth ) ) ; parent . setAddRowColumnWidthStyle ( \"width:\" + parent . getAddRowColumnWidth ( ) + \"px;\" ) ; parent . getHeaderRows ( ) . clear ( ) ; if ( top < 0 ) { // this is blank configuration. set column letter as header\r parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , true ) ) ; // set showlinenumber to true as default\r parent . setShowLineNumber ( true ) ; } else { parent . getHeaderRows ( ) . add ( loadHeaderRowWithoutConfigurationTab ( rangeBuildRef , false ) ) ; for ( int i = top ; i <= bottom ; i ++ ) { parent . getHeaderRows ( ) . add ( loadHeaderRowWithConfigurationTab ( sheetConfig , rangeBuildRef , i , cellRangeMap , skippedRegionCells ) ) ; } // set showlinenumber to false as default\r parent . setShowLineNumber ( false ) ; } }", "nl": "Load header rows ."}}
{"translation": {"code": "private List < HeaderCell > loadHeaderRowWithoutConfigurationTab ( final RangeBuildRef rangeBuildRef , final boolean rendered ) { int firstCol = rangeBuildRef . getLeft ( ) ; int lastCol = rangeBuildRef . getRight ( ) ; double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; Sheet sheet1 = rangeBuildRef . getSheet ( ) ; List < HeaderCell > headercells = new ArrayList <> ( ) ; for ( int i = firstCol ; i <= lastCol ; i ++ ) { if ( ! sheet1 . isColumnHidden ( i ) ) { String style = getHeaderColumnStyle ( parent . getWb ( ) , null , sheet1 . getColumnWidth ( i ) , totalWidth ) ; headercells . add ( new HeaderCell ( \"1\" , \"1\" , style , style , WebSheetUtility . getExcelColumnName ( i ) , rendered , true ) ) ; } } fillToMaxColumns ( headercells ) ; return headercells ; }", "nl": "Load header row without configuration tab ."}}
{"translation": {"code": "private String getHeaderColumnStyle ( final Workbook wb , final Cell cell , final double colWidth , final double totalWidth ) { String columnstyle = \"\" ; if ( cell != null ) { columnstyle += CellStyleUtility . getCellStyle ( wb , cell , \"\" ) + CellStyleUtility . getCellFontStyle ( wb , cell ) ; // +\r } columnstyle = columnstyle + getWidthStyle ( colWidth , totalWidth ) ; return columnstyle ; }", "nl": "Gets the header column style ."}}
{"translation": {"code": "private String getWidthStyle ( final double colWidth , final double totalWidth ) { double percentage = FacesUtility . round ( TieConstants . CELL_FORMAT_PERCENTAGE_VALUE * colWidth / totalWidth , 2 ) ; return \"width:\" + percentage + TieConstants . CELL_FORMAT_PERCENTAGE_SYMBOL + \";\" ; }", "nl": "Gets the width style ."}}
{"translation": {"code": "private List < HeaderCell > loadHeaderRowWithConfigurationTab ( final SheetConfiguration sheetConfig , final RangeBuildRef rangeBuildRef , final int currentRow , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { Sheet sheet1 = rangeBuildRef . getSheet ( ) ; int left = rangeBuildRef . getLeft ( ) ; int right = rangeBuildRef . getRight ( ) ; double totalWidth = ( double ) rangeBuildRef . getTotalWidth ( ) ; Row row = sheet1 . getRow ( currentRow ) ; List < HeaderCell > headercells = new ArrayList <> ( ) ; for ( int cindex = left ; cindex <= right ; cindex ++ ) { String cellindex = CellUtility . getCellIndexNumberKey ( cindex , currentRow ) ; if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { Cell cell = null ; if ( row != null ) { cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; } int originRowIndex = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; if ( cell != null ) { FacesCell fcell = new FacesCell ( ) ; CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , originRowIndex , parent . getCellAttributesMap ( ) , null ) ; parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; fcell . setColumnStyle ( fcell . getColumnStyle ( ) + getColumnWidthStyle ( sheet1 , cellRangeMap , cellindex , cindex , totalWidth ) ) ; fcell . setColumnIndex ( cindex ) ; headercells . add ( new HeaderCell ( Integer . toString ( fcell . getRowspan ( ) ) , Integer . toString ( fcell . getColspan ( ) ) , fcell . getStyle ( ) , fcell . getColumnStyle ( ) , CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) , true , true ) ) ; } } } fillToMaxColumns ( headercells ) ; return headercells ; }", "nl": "Load header row with configuration tab ."}}
{"translation": {"code": "private void loadData ( ) { if ( parent . getSerialDataContext ( ) . getDataContext ( ) == null ) { // no data objects available.\r return ; } if ( parent . isAdvancedContext ( ) ) { parent . getSerialDataContext ( ) . getDataContext ( ) . put ( \"tiecells\" , new HashMap < String , TieCell > ( ) ) ; } for ( SheetConfiguration sheetConfig : parent . getSheetConfigMap ( ) . values ( ) ) { List < RowsMapping > currentRowsMappingList = null ; ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; int length = sheetConfig . getFormCommand ( ) . buildAt ( null , configBuildRef , sheetConfig . getFormCommand ( ) . getTopRow ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) , currentRowsMappingList ) ; sheetConfig . setShiftMap ( configBuildRef . getShiftMap ( ) ) ; sheetConfig . setCollectionObjNameMap ( configBuildRef . getCollectionObjNameMap ( ) ) ; sheetConfig . setCommandIndexMap ( configBuildRef . getCommandIndexMap ( ) ) ; sheetConfig . setWatchList ( configBuildRef . getWatchList ( ) ) ; sheetConfig . setBodyAllowAddRows ( configBuildRef . isBodyAllowAdd ( ) ) ; sheetConfig . getBodyCellRange ( ) . setBottomRow ( sheetConfig . getFormCommand ( ) . getTopRow ( ) + length - 1 ) ; sheetConfig . setBodyPopulated ( true ) ; } parent . getCellHelper ( ) . reCalc ( ) ; }", "nl": "load data process . unfinished ."}}
{"translation": {"code": "private void initTabs ( ) { parent . setTabs ( new ArrayList < TabModel > ( ) ) ; if ( parent . getSheetConfigMap ( ) != null ) { for ( String key : parent . getSheetConfigMap ( ) . keySet ( ) ) { parent . getTabs ( ) . add ( new TabModel ( \"form_\" + key , key , \"form\" ) ) ; } } }", "nl": "Inits the tabs ."}}
{"translation": {"code": "public final void setupFacesCellPictureCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { if ( parent . getPicturesMap ( ) != null ) { setupFacesCellPicture ( sheet1 , fcell , cell , fId ) ; } if ( parent . getCharsData ( ) . getChartsMap ( ) != null ) { setupFacesCellCharts ( sheet1 , fcell , cell , fId ) ; } }", "nl": "Setup faces cell picture charts ."}}
{"translation": {"code": "private void setupFacesCellPicture ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { try { Picture pic = parent . getPicturesMap ( ) . get ( fId ) ; if ( pic != null ) { fcell . setContainPic ( true ) ; fcell . setPictureId ( fId ) ; fcell . setPictureStyle ( PicturesUtility . generatePictureStyle ( sheet1 , fcell , cell , pic ) ) ; } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"setupFacesCell Picture error = \" + ex . getMessage ( ) , ex ) ; } }", "nl": "Setup faces cell picture ."}}
{"translation": {"code": "private String getColumnWidthStyle ( final Sheet sheet1 , final Map < String , CellRangeAddress > cellRangeMap , final String cellindex , final int cindex , final double totalWidth ) { CellRangeAddress caddress = cellRangeMap . get ( cellindex ) ; double colWidth ; // check whether the cell has rowspan or colspan\r if ( caddress != null ) { colWidth = CellStyleUtility . calcTotalWidth ( sheet1 , caddress . getFirstColumn ( ) , caddress . getLastColumn ( ) , 0 ) ; } else { colWidth = sheet1 . getColumnWidth ( cindex ) ; } return getWidthStyle ( colWidth , totalWidth ) ; }", "nl": "Gets the column width style ."}}
{"translation": {"code": "public final int findTabIndexWithName ( final String tabname ) { for ( int i = 0 ; i < parent . getTabs ( ) . size ( ) ; i ++ ) { if ( parent . getTabs ( ) . get ( i ) . getTitle ( ) . equalsIgnoreCase ( tabname ) ) { return i ; } } return - 1 ; }", "nl": "Find tab index with name ."}}
{"translation": {"code": "public final void prepareWorkShee ( final String tabName ) { int tabIndex = findTabIndexWithName ( tabName ) ; if ( parent . getWebFormTabView ( ) != null ) { parent . getWebFormTabView ( ) . setActiveIndex ( tabIndex ) ; } parent . getCurrent ( ) . setCurrentTabName ( tabName ) ; String sheetName = parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ; Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; parent . getWb ( ) . setActiveSheet ( parent . getWb ( ) . getSheetIndex ( sheet1 ) ) ; SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; parent . setMaxRowsPerPage ( parent . getSheetConfigMap ( ) . get ( tabName ) . getMaxRowPerPage ( ) ) ; parent . setBodyAllowAddRows ( parent . getSheetConfigMap ( ) . get ( tabName ) . isBodyAllowAddRows ( ) ) ; // populate repeat rows before setup cell range map\r Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet1 ) ; List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet1 ) ; loadHeaderRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; loadBodyRows ( sheetConfig , cellRangeMap , skippedRegionCells ) ; }", "nl": "prepare worksheet for loading . this only load at backend without refresh gui ."}}
{"translation": {"code": "public static String getExcelColumnName ( final int pnumber ) { StringBuilder converted = new StringBuilder ( ) ; // Repeatedly divide the number by 26 and convert the\r // remainder into the appropriate letter.\r int number = pnumber ; while ( number >= 0 ) { int remainder = number % TieConstants . EXCEL_LETTER_NUMBERS ; converted . insert ( 0 , ( char ) ( remainder + ' ' ) ) ; number = ( number / TieConstants . EXCEL_LETTER_NUMBERS ) - 1 ; } return converted . toString ( ) ; }", "nl": "Gets the excel column name ."}}
{"translation": {"code": "public String getTabType ( ) { int sheetId = webFormTabView . getActiveIndex ( ) ; if ( ( sheetId >= 0 ) && ( tabs != null ) ) { if ( sheetId >= tabs . size ( ) ) { sheetId = 0 ; } tabType = tabs . get ( sheetId ) . type . toLowerCase ( ) ; } else { tabType = TieConstants . TAB_TYPE_NONE ; } return tabType ; }", "nl": "get tab type ."}}
{"translation": {"code": "private void loadBodyRows ( final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; int bottom = CellUtility . getBodyBottomFromConfig ( sheetConfig ) ; int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; String sheetName = sheetConfig . getSheetName ( ) ; Sheet sheet1 = parent . getWb ( ) . getSheet ( sheetName ) ; parent . getBodyRows ( ) . clear ( ) ; clearCache ( ) ; for ( int i = top ; i <= bottom ; i ++ ) { parent . getBodyRows ( ) . add ( assembleFacesBodyRow ( i , sheet1 , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; } sheetConfig . setBodyPopulated ( true ) ; parent . getCurrent ( ) . setCurrentTopRow ( top ) ; parent . getCurrent ( ) . setCurrentLeftColumn ( left ) ; }", "nl": "Load body rows ."}}
{"translation": {"code": "private void setupRowInfo ( final FacesRow facesRow , final Sheet sheet1 , final Row row , final int rowIndex , final boolean allowAdd ) { facesRow . setAllowAdd ( allowAdd ) ; if ( row != null ) { facesRow . setRendered ( ! row . getZeroHeight ( ) ) ; facesRow . setRowheight ( row . getHeight ( ) ) ; int rowNum = ConfigurationUtility . getOriginalRowNumInHiddenColumn ( row ) ; facesRow . setOriginRowIndex ( rowNum ) ; } else { facesRow . setRendered ( true ) ; facesRow . setRowheight ( sheet1 . getDefaultRowHeight ( ) ) ; facesRow . setOriginRowIndex ( rowIndex ) ; } }", "nl": "Setup row info ."}}
{"translation": {"code": "private void saveObjs ( ) { try { if ( FacesContext . getCurrentInstance ( ) != null ) { Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; viewMap . put ( \"currentTabName\" , parent . getCurrent ( ) . getCurrentTabName ( ) ) ; viewMap . put ( TieConstants . SUBMITMODE , parent . getSubmitMode ( ) ) ; } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"saveobjs in viewMap error = \" + ex . getMessage ( ) , ex ) ; } }", "nl": "Save objs ."}}
{"translation": {"code": "private void createDynamicColumns ( final String tabName ) { SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( tabName ) ; int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; parent . getColumns ( ) . clear ( ) ; for ( int i = left ; i <= right ; i ++ ) { parent . getColumns ( ) . add ( \"column\" + ( i - left ) ) ; } }", "nl": "Creates the dynamic columns ."}}
{"translation": {"code": "private void setDataTablePage ( final int first ) { if ( parent . getWebFormClientId ( ) != null ) { final DataTable d = ( DataTable ) FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . findComponent ( parent . getWebFormClientId ( ) ) ; if ( d != null ) { d . setFirst ( first ) ; } } }", "nl": "Sets the data table page ."}}
{"translation": {"code": "public XSSFEvaluationWorkbook getWbWrapper ( ) { if ( ( this . wbWrapper == null ) && ( this . getWb ( ) != null ) ) { this . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) this . getWb ( ) ) ; } return wbWrapper ; }", "nl": "Return evaluation wrapper if needed ."}}
{"translation": {"code": "public FormulaEvaluator getFormulaEvaluator ( ) { if ( ( this . formulaEvaluator == null ) && ( this . getWb ( ) != null ) ) { this . formulaEvaluator = this . getWb ( ) . getCreationHelper ( ) . createFormulaEvaluator ( ) ; } return formulaEvaluator ; }", "nl": "get formulaevaluator ."}}
{"translation": {"code": "public final void addRepeatRow ( final int rowIndex ) { try { SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; Sheet sheet = parent . getWb ( ) . getSheet ( sheetConfig . getSheetName ( ) ) ; ConfigBuildRef configBuildRef = new ConfigBuildRef ( parent . getWbWrapper ( ) , sheet , parent . getExpEngine ( ) , parent . getCellHelper ( ) , sheetConfig . getCachedCells ( ) , parent . getCellAttributesMap ( ) , sheetConfig . getFinalCommentMap ( ) ) ; // set add mode\r configBuildRef . setAddMode ( true ) ; configBuildRef . setCollectionObjNameMap ( sheetConfig . getCollectionObjNameMap ( ) ) ; configBuildRef . setCommandIndexMap ( sheetConfig . getCommandIndexMap ( ) ) ; configBuildRef . setShiftMap ( sheetConfig . getShiftMap ( ) ) ; configBuildRef . setWatchList ( sheetConfig . getWatchList ( ) ) ; int length = CommandUtility . addRow ( configBuildRef , rowIndex , parent . getSerialDataContext ( ) . getDataContext ( ) ) ; refreshBodyRowsInRange ( configBuildRef . getInsertPosition ( ) , length , sheet , sheetConfig ) ; parent . getCellHelper ( ) . reCalc ( ) ; } catch ( AddRowException e ) { FacesContext . getCurrentInstance ( ) . addMessage ( null , new FacesMessage ( FacesMessage . SEVERITY_ERROR , \"Add Row Error\" , e . getMessage ( ) ) ) ; LOG . log ( Level . SEVERE , \"Add row error = \" + e . getLocalizedMessage ( ) , e ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"Add row error = \" + ex . getLocalizedMessage ( ) , ex ) ; } }", "nl": "Adds the repeat row ."}}
{"translation": {"code": "private FacesRow assembleFacesBodyRow ( final int rowIndex , final Sheet sheet1 , final int left , final int right , final SheetConfiguration sheetConfig , final Map < String , CellRangeAddress > cellRangeMap , final List < String > skippedRegionCells ) { FacesRow facesRow = new FacesRow ( rowIndex ) ; Row row = sheet1 . getRow ( rowIndex ) ; setupRowInfo ( facesRow , sheet1 , row , rowIndex , CommandUtility . isRowAllowAdd ( row , sheetConfig ) ) ; String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( row ) ; List < FacesCell > bodycells = new ArrayList <> ( ) ; for ( int cindex = left ; cindex <= right ; cindex ++ ) { String cellindex = CellUtility . getCellIndexNumberKey ( cindex , rowIndex ) ; if ( ! skippedRegionCells . contains ( cellindex ) && ! sheet1 . isColumnHidden ( cindex ) ) { Cell cell = null ; if ( row != null ) { cell = row . getCell ( cindex , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; } if ( cell != null ) { FacesCell fcell = new FacesCell ( ) ; CellUtility . convertCell ( sheetConfig , fcell , cell , cellRangeMap , facesRow . getOriginRowIndex ( ) , parent . getCellAttributesMap ( ) , saveAttrList ) ; parent . getPicHelper ( ) . setupFacesCellPictureCharts ( sheet1 , fcell , cell , WebSheetUtility . getFullCellRefName ( sheet1 , cell ) ) ; CellStyleUtility . setupCellStyle ( parent . getWb ( ) , fcell , cell , row . getHeightInPoints ( ) ) ; fcell . setColumnIndex ( cindex ) ; bodycells . add ( fcell ) ; addCache ( cell ) ; } else { bodycells . add ( null ) ; } } else { bodycells . add ( null ) ; } } facesRow . setCells ( bodycells ) ; return facesRow ; }", "nl": "Assemble faces body row ."}}
{"translation": {"code": "public int loadWebSheet ( final InputStream inputStream , final Map < String , Object > pDataContext ) { return this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkbook ( inputStream , pDataContext ) ; }", "nl": "load web sheet from inputStream file with data object ."}}
{"translation": {"code": "private String loadPicture ( final int rowIndex , final int colIndex ) { FacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; if ( facesCell != null && facesCell . isContainPic ( ) ) { FacesContext context = FacesContext . getCurrentInstance ( ) ; String pictureId = facesCell . getPictureId ( ) ; String pictureViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + pictureId ; Map < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; if ( sessionMap . get ( pictureViewId ) == null ) { sessionMap . put ( pictureViewId , parent . getPicturesMap ( ) . get ( pictureId ) . getPictureData ( ) ) ; } return pictureViewId ; } else { return null ; } }", "nl": "Put picture image to session map and return the key to web ."}}
{"translation": {"code": "public void doSubmit ( ) { this . setSubmitMde ( true ) ; // validation may behavior differently depend on the submit mode.\r // e.g. when submit mode = false, empty fields or value not changed cells\r // don't need to pass the validation rule. This allow partial save the form. \r // when submit mode = true, all cells need to pass the validation.\r if ( ! this . getHelper ( ) . getValidationHandler ( ) . preValidation ( ) ) { LOG . fine ( \"Validation failed before saving\" ) ; return ; } processSubmit ( ) ; this . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , false ) ; this . setSubmitMde ( false ) ; }", "nl": "Submit the current workbooks ."}}
{"translation": {"code": "public int loadWorkSheetByTabName ( final String tabName ) { try { int sheetId = this . getHelper ( ) . getWebSheetLoader ( ) . findTabIndexWithName ( tabName ) ; if ( ( getSheetConfigMap ( ) != null ) && ( sheetId < getSheetConfigMap ( ) . size ( ) ) ) { this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( tabName ) ; setActiveTabIndex ( sheetId ) ; } return 1 ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"loadWorkSheetByTabName failed. error = \" + ex . getMessage ( ) , ex ) ; } return - 1 ; }", "nl": "load worksheet by tab name ."}}
{"translation": {"code": "public void doExport ( ) { try { String fileName = this . getExportFileName ( ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; this . getWb ( ) . write ( out ) ; InputStream stream = new BufferedInputStream ( new ByteArrayInputStream ( out . toByteArray ( ) ) ) ; exportFile = new DefaultStreamedContent ( stream , \"application/force-download\" , fileName ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"Error in export file : \" + e . getLocalizedMessage ( ) , e ) ; } return ; }", "nl": "download current workbook ."}}
{"translation": {"code": "public void doSave ( ) { this . setSubmitMde ( false ) ; if ( ! this . getHelper ( ) . getValidationHandler ( ) . preValidation ( ) ) { LOG . fine ( \"Validation failded before saving\" ) ; return ; } processSave ( ) ; this . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , false ) ; }", "nl": "Save the current workbooks ."}}
{"translation": {"code": "public StreamedContent getPicture ( ) { FacesContext context = FacesContext . getCurrentInstance ( ) ; if ( context . getCurrentPhaseId ( ) == PhaseId . RENDER_RESPONSE ) { // So, we're rendering the HTML. Return a stub StreamedContent so\r // that it will generate right URL.\r LOG . fine ( \" return empty picture\" ) ; return new DefaultStreamedContent ( ) ; } else { // So, browser is requesting the image. Return a real\r // StreamedContent with the image bytes.\r String pictureId = context . getExternalContext ( ) . getRequestParameterMap ( ) . get ( \"pictureViewId\" ) ; PictureData picData = ( PictureData ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . get ( pictureId ) ; FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . remove ( pictureId ) ; LOG . fine ( \" return real picture and remove session\" ) ; return new DefaultStreamedContent ( new ByteArrayInputStream ( picData . getData ( ) ) ) ; } }", "nl": "Return picture to web front end ."}}
{"translation": {"code": "public final FacesCell getFacesCellWithRowColFromCurrentPage ( final int rowIndex , final int colIndex ) { if ( parent . getBodyRows ( ) != null ) { int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; int left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; return parent . getBodyRows ( ) . get ( rowIndex - top ) . getCells ( ) . get ( colIndex - left ) ; } return null ; }", "nl": "Gets the faces cell with row col from current page ."}}
{"translation": {"code": "public final Cell getPoiCellWithRowColFromTab ( final int rowIndex , final int colIndex , final String tabName ) { if ( parent . getWb ( ) != null ) { return CellUtility . getPoiCellFromSheet ( rowIndex , colIndex , parent . getWb ( ) . getSheet ( parent . getSheetConfigMap ( ) . get ( tabName ) . getSheetName ( ) ) ) ; } return null ; }", "nl": "Gets the poi cell with row col from tab ."}}
{"translation": {"code": "private boolean validateRow ( final int irow , final SheetConfiguration sheetConfig , boolean updateGui ) { boolean pass = true ; if ( sheetConfig == null ) { return pass ; } int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; List < FacesCell > cellRow = parent . getBodyRows ( ) . get ( irow - top ) . getCells ( ) ; for ( int index = 0 ; index < cellRow . size ( ) ; index ++ ) { FacesCell fcell = cellRow . get ( index ) ; if ( ( fcell != null ) && ( ! validateWithRowColInCurrentPage ( irow , fcell . getColumnIndex ( ) , updateGui ) ) ) { pass = false ; } } return pass ; }", "nl": "Validate row ."}}
{"translation": {"code": "public final boolean validateRowInCurrentPage ( final int irow , final boolean updateGui ) { SheetConfiguration sheetConfig = parent . getSheetConfigMap ( ) . get ( parent . getCurrent ( ) . getCurrentTabName ( ) ) ; return this . validateRow ( irow , sheetConfig , updateGui ) ; }", "nl": "Validate row in current page ."}}
{"translation": {"code": "public static boolean isDate ( final String s ) { Pattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; String [ ] terms = s . split ( \" \" ) ; Matcher matcher ; for ( String term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return true ; } } pattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; terms = s . split ( \" \" ) ; for ( String term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return true ; } } return false ; }", "nl": "Checks if is date ."}}
{"translation": {"code": "public final void reCalc ( ) { parent . getFormulaEvaluator ( ) . clearAllCachedResultValues ( ) ; try { parent . getFormulaEvaluator ( ) . evaluateAll ( ) ; } catch ( Exception ex ) { // skip the formula exception when recalc but log it\r LOG . log ( Level . SEVERE , \" recalc formula error : \" + ex . getLocalizedMessage ( ) , ex ) ; } }", "nl": "recalc whole workbook ."}}
{"translation": {"code": "public final void saveDataInContext ( final Cell poiCell , final String strValue ) { String saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , this ) ; if ( saveAttr != null ) { SaveAttrsUtility . saveDataToObjectInContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , strValue , parent . getExpEngine ( ) ) ; parent . getHelper ( ) . getWebSheetLoader ( ) . setUnsavedStatus ( RequestContext . getCurrentInstance ( ) , true ) ; } }", "nl": "Save data in context ."}}
{"translation": {"code": "private String assembleNewValue ( final Object value , final FacesCell facesCell ) { String newValue ; if ( value instanceof java . util . Date ) { String datePattern = facesCell . getDatePattern ( ) ; if ( datePattern == null || datePattern . isEmpty ( ) ) { datePattern = parent . getDefaultDatePattern ( ) ; } Format formatter = new SimpleDateFormat ( datePattern ) ; newValue = formatter . format ( value ) ; } else { newValue = ( String ) value ; } if ( \"textarea\" . equalsIgnoreCase ( facesCell . getInputType ( ) ) && ( newValue != null ) ) { // remove \"\\r\" because excel issue\r newValue = newValue . replace ( \"\\r\\n\" , \"\\n\" ) ; } return newValue ; }", "nl": "Assemble new value ."}}
{"translation": {"code": "public static boolean isNumeric ( final String str ) { String s = str ; if ( s . startsWith ( \"-\" ) ) { s = s . substring ( 1 ) ; } char c ; int i ; int sLen = s . length ( ) ; ShouldContinueParameter sPara = new ShouldContinueParameter ( false , false , 0 ) ; for ( i = 0 ; i < sLen ; i ++ ) { c = s . charAt ( i ) ; if ( c < ' ' || c > ' ' ) { if ( ! shouldContinue ( c , sPara ) ) { return false ; } } else { if ( sPara . isCommaHit ( ) ) { sPara . setSinceLastComma ( sPara . getSinceLastComma ( ) + 1 ) ; } } } return true ; }", "nl": "Checks if is numeric ."}}
{"translation": {"code": "public static String parseDate ( final String entry ) { Pattern pattern = Pattern . compile ( DATE_REGEX_4_DIGIT_YEAR ) ; String [ ] terms = entry . split ( \" \" ) ; Matcher matcher ; for ( String term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } pattern = Pattern . compile ( DATE_REGEX_2_DIGIT_YEAR ) ; terms = entry . split ( \" \" ) ; for ( String term : terms ) { matcher = pattern . matcher ( term ) ; if ( matcher . matches ( ) ) { return matcher . group ( ) ; } } return \"\" ; }", "nl": "Parses the date ."}}
{"translation": {"code": "public final boolean validateCurrentPage ( ) { boolean allpass = true ; int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; for ( int irow = 0 ; irow < parent . getBodyRows ( ) . size ( ) ; irow ++ ) { if ( ! validateRowInCurrentPage ( irow + top , false ) ) { allpass = false ; } } return allpass ; }", "nl": "Validate current page ."}}
{"translation": {"code": "private void setupFacesCellCharts ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String fId ) { try { String chartId = parent . getCharsData ( ) . getChartPositionMap ( ) . get ( fId ) ; if ( chartId != null ) { BufferedImage img = parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ; if ( img != null ) { fcell . setContainChart ( true ) ; fcell . setChartId ( chartId ) ; fcell . setChartStyle ( PicturesUtility . generateChartStyle ( sheet1 , fcell , cell , chartId , parent . getCharsData ( ) . getChartAnchorsMap ( ) ) ) ; } } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"setupFacesCell Charts error = \" + ex . getMessage ( ) , ex ) ; } }", "nl": "Setup faces cell charts ."}}
{"translation": {"code": "private void processRefreshCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { String newValue = CellUtility . getCellValueWithFormat ( cell , parent . getFormulaEvaluator ( ) , parent . getDataFormatter ( ) ) ; if ( parent . getCachedCells ( ) . isValueChanged ( cell , newValue ) ) { if ( fcell . isHasSaveAttr ( ) ) { parent . getCellHelper ( ) . saveDataInContext ( cell , newValue ) ; } RequestContext . getCurrentInstance ( ) . update ( tblName + \":\" + i + \":cocalc\" + index ) ; parent . getCachedCells ( ) . put ( cell , CellType . FORMULA ) ; } }", "nl": "Process refresh cell ."}}
{"translation": {"code": "private String loadChart ( final int rowIndex , final int colIndex ) { FacesCell facesCell = parent . getCellHelper ( ) . getFacesCellWithRowColFromCurrentPage ( rowIndex , colIndex ) ; if ( facesCell != null && facesCell . isContainChart ( ) ) { FacesContext context = FacesContext . getCurrentInstance ( ) ; String chartId = facesCell . getChartId ( ) ; String chartViewId = Integer . toHexString ( System . identityHashCode ( parent . getWb ( ) ) ) + chartId ; if ( context != null ) { Map < String , Object > sessionMap = context . getExternalContext ( ) . getSessionMap ( ) ; if ( sessionMap . get ( chartViewId ) == null ) { sessionMap . put ( chartViewId , parent . getCharsData ( ) . getChartsMap ( ) . get ( chartId ) ) ; } } return chartViewId ; } else { return null ; } }", "nl": "Put chart image to session map and return the key to web ."}}
{"translation": {"code": "private List < XColor > getColorListFromDPTWithValueList ( final List < CTDPt > dptList , final List < ParsedCell > cells , final ThemesTable themeTable , final ChartObject ctObj ) { List < XColor > colors = new ArrayList <> ( ) ; if ( ( dptList != null ) && ( cells != null ) ) { for ( int index = 0 ; index < cells . size ( ) ; index ++ ) { CTDPt dpt = getDPtFromListWithIndex ( dptList , index ) ; CTShapeProperties ctSpPr = null ; if ( dpt != null ) { ctSpPr = dpt . getSpPr ( ) ; } colors . add ( ColorUtility . geColorFromSpPr ( index , ctSpPr , themeTable , ctObj . isLineColor ( ) ) ) ; } } return colors ; }", "nl": "get color list from dpt ."}}
{"translation": {"code": "public final void buildCategoryList ( final CTAxDataSource ctAxDs ) { List < ParsedCell > cells = new ArrayList <> ( ) ; try { String fullRangeName = ctAxDs . getStrRef ( ) . getF ( ) ; String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; for ( int row = region . getFirstRow ( ) ; row <= region . getLastRow ( ) ; row ++ ) { for ( int col = region . getFirstColumn ( ) ; col <= region . getLastColumn ( ) ; col ++ ) { cells . add ( new ParsedCell ( sheetName , row , col ) ) ; } } } catch ( Exception ex ) { LOG . log ( Level . FINE , \"failed in buildCategoryList\" , ex ) ; } this . setCategoryList ( cells ) ; }", "nl": "build categotry list ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public final void buildSeriesList ( final List bsers , final ThemesTable themeTable , final ChartObject ctObj ) { List < ChartSeries > lseriesList = new ArrayList <> ( ) ; try { for ( int index = 0 ; index < bsers . size ( ) ; index ++ ) { Object ctObjSer = bsers . get ( index ) ; ChartSeries ctSer = buildChartSeriesInList ( themeTable , ctObj , ctObjSer , index ) ; lseriesList . add ( ctSer ) ; } } catch ( Exception ex ) { LOG . log ( Level . FINE , \"failed in buildSerialList\" , ex ) ; } this . setSeriesList ( lseriesList ) ; }", "nl": "build series list ."}}
{"translation": {"code": "private CTDPt getDPtFromListWithIndex ( final List < CTDPt > dptList , final int index ) { if ( dptList != null ) { for ( CTDPt dpt : dptList ) { if ( dpt . getIdx ( ) . getVal ( ) == index ) { return dpt ; } } } return null ; }", "nl": "get dpt from list ."}}
{"translation": {"code": "public static int cellCompareTo ( final Cell thisCell , final Cell otherCell ) { int r = thisCell . getRowIndex ( ) - otherCell . getRowIndex ( ) ; if ( r != 0 ) { return r ; } r = thisCell . getColumnIndex ( ) - otherCell . getColumnIndex ( ) ; if ( r != 0 ) { return r ; } return 0 ; }", "nl": "Cell compare to ."}}
{"translation": {"code": "public StreamedContent getChart ( ) throws IOException { FacesContext context = FacesContext . getCurrentInstance ( ) ; if ( context . getCurrentPhaseId ( ) == PhaseId . RENDER_RESPONSE ) { // So, we're rendering the HTML. Return a stub StreamedContent so\r // that it will generate right URL.\r LOG . fine ( \" return empty chart picture\" ) ; return new DefaultStreamedContent ( ) ; } else { // So, browser is requesting the image. Return a real\r // StreamedContent with the image bytes.\r String chartId = context . getExternalContext ( ) . getRequestParameterMap ( ) . get ( \"chartViewId\" ) ; BufferedImage bufferedImg = ( BufferedImage ) FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . get ( chartId ) ; ByteArrayOutputStream os = new ByteArrayOutputStream ( ) ; ImageIO . write ( bufferedImg , \"png\" , os ) ; FacesContext . getCurrentInstance ( ) . getExternalContext ( ) . getSessionMap ( ) . remove ( chartId ) ; return new DefaultStreamedContent ( new ByteArrayInputStream ( os . toByteArray ( ) ) , \"image/png\" ) ; } }", "nl": "Return real chart picture when browser requesting the image ."}}
{"translation": {"code": "private void fillToMaxColumns ( final List < HeaderCell > headercells ) { if ( headercells . size ( ) < parent . getMaxColCounts ( ) ) { int fills = parent . getMaxColCounts ( ) - headercells . size ( ) ; for ( int s = 0 ; s < fills ; s ++ ) { headercells . add ( new HeaderCell ( \"1\" , \"1\" , \"\" , \"\" , \"\" , false , false ) ) ; } } }", "nl": "Fill to max columns ."}}
{"translation": {"code": "private void initXSSFChartsMap ( final XSSFWorkbook wb , final ChartsData chartsData ) { initAnchorsMap ( wb , chartsData ) ; Map < String , ClientAnchor > anchorMap = chartsData . getChartAnchorsMap ( ) ; Map < String , BufferedImage > chartMap = chartsData . getChartsMap ( ) ; Map < String , ChartData > chartDataMap = chartsData . getChartDataMap ( ) ; chartMap . clear ( ) ; chartDataMap . clear ( ) ; for ( int i = 0 ; i < wb . getNumberOfSheets ( ) ; i ++ ) { XSSFSheet sheet = wb . getSheetAt ( i ) ; XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; List < XSSFChart > charts = drawing . getCharts ( ) ; if ( ( charts != null ) && ( ! charts . isEmpty ( ) ) ) { for ( XSSFChart chart : charts ) { generateSingleXSSFChart ( chart , getChartIdFromParent ( chart , sheet . getSheetName ( ) ) , sheet , anchorMap , chartMap , chartDataMap ) ; } } } }", "nl": "initial chart map for XSSF format file . XSSF file is actually the only format in POI support chart object ."}}
{"translation": {"code": "private void generateSingleXSSFChart ( final XSSFChart chart , final String chartId , final XSSFSheet sheet , final Map < String , ClientAnchor > anchorMap , final Map < String , BufferedImage > chartMap , final Map < String , ChartData > chartDataMap ) { ClientAnchor anchor ; try { anchor = anchorMap . get ( chartId ) ; if ( anchor != null ) { ChartData chartData = ChartUtility . initChartDataFromXSSFChart ( chartId , chart , ( XSSFWorkbook ) parent . getWb ( ) ) ; chartDataMap . put ( chartId , chartData ) ; JFreeChart jchart = createChart ( chartData ) ; if ( jchart != null ) { AnchorSize anchorSize = PicturesUtility . getAnchorSize ( sheet , null , null , anchor ) ; BufferedImage img = jchart . createBufferedImage ( anchorSize . getWidth ( ) , anchorSize . getHeight ( ) ) ; chartMap . put ( chartId , img ) ; } } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"generate chart for \" + chartId + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; } }", "nl": "Generate single XSSF chart ."}}
{"translation": {"code": "public JFreeChart createPie3DChart ( final ChartData chartData ) { // create the chart...\r final JFreeChart chart = ChartFactory . createPieChart3D ( getPieTitle ( chartData ) , // chart title\r createPieDataset ( chartData ) , // data\r true , // include legend\r false , // tooltips\r false // urls\r ) ; setupPieStyle ( chart , chartData ) ; return chart ; }", "nl": "create pie 3d chart ."}}
{"translation": {"code": "public static XColor getBgColor ( final CTPlotArea ctPlot , final ThemesTable themeTable ) { CTSolidColorFillProperties colorFill = null ; try { colorFill = ctPlot . getSpPr ( ) . getSolidFill ( ) ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \"No entry in bgcolor for solidFill\" , ex ) ; } XColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; if ( xcolor != null ) { return xcolor ; } else { return new XColor ( new XSSFColor ( Color . WHITE ) ) ; } }", "nl": "retrieve background color for plot area ."}}
{"translation": {"code": "public static XColor geColorFromSpPr ( final int index , final CTShapeProperties ctSpPr , final ThemesTable themeTable , final boolean isLineColor ) { CTSolidColorFillProperties colorFill = null ; try { if ( isLineColor ) { colorFill = ctSpPr . getLn ( ) . getSolidFill ( ) ; } else { colorFill = ctSpPr . getSolidFill ( ) ; } } catch ( Exception ex ) { LOG . log ( Level . FINE , \"No entry for solidFill\" , ex ) ; } XColor xcolor = findAutomaticFillColor ( themeTable , colorFill ) ; if ( xcolor != null ) { return xcolor ; } else { return getXColorWithAutomaticFill ( index , themeTable ) ; } }", "nl": "get line color of line chart from CTLineSer ."}}
{"translation": {"code": "private static XColor getXColorFromSchemeClr ( final CTSchemeColor ctsColor , final ThemesTable themeTable ) { if ( ctsColor . getVal ( ) != null ) { return getXColorWithSchema ( ctsColor . getVal ( ) . toString ( ) , 0 , ctsColor , themeTable ) ; } return null ; }", "nl": "retrieve xcolor from scheme color ."}}
{"translation": {"code": "private void setupBarStyle ( final JFreeChart chart , final ChartData chartData ) { setupStyle ( chart , chartData ) ; CategoryPlot plot = ( CategoryPlot ) chart . getPlot ( ) ; BarRenderer renderer = ( BarRenderer ) plot . getRenderer ( ) ; renderer . setBarPainter ( new StandardBarPainter ( ) ) ; renderer . setItemMargin ( TieConstants . DEFAULT_BAR_STYLE_ITEM_MARGIN ) ; plot . setForegroundAlpha ( TieConstants . DEFAULT_BARSTYLE_FOREGROUND_ALPHA ) ; }", "nl": "finalize the style for barchart . This will call setupStyle common first ."}}
{"translation": {"code": "private static XColor getXColorWithAutomaticFill ( final int index , final ThemesTable themeTable ) { int reminder = ( index + 1 ) % AUTOCOLORSIZE ; if ( reminder == 0 ) { reminder = AUTOCOLORSIZE ; } String schema = AUTOCOLORNAME + reminder ; double tint = getAutomaticTint ( index ) ; return getXColorWithSchema ( schema , tint , null , themeTable ) ; }", "nl": "Get xcolor for automatic fill setting . This is the default setting in Excel for chart colors . Normally the colors will be accent1 to 7 ."}}
{"translation": {"code": "public static Color xssfClrToClr ( final XSSFColor xssfColor ) { short [ ] rgb = getTripletFromXSSFColor ( xssfColor ) ; return new Color ( rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; }", "nl": "convert xssf color to color ."}}
{"translation": {"code": "public static short [ ] getTripletFromXSSFColor ( final XSSFColor xssfColor ) { short [ ] rgbfix = { RGB8BITS , RGB8BITS , RGB8BITS } ; if ( xssfColor != null ) { byte [ ] rgb = xssfColor . getRGBWithTint ( ) ; if ( rgb == null ) { rgb = xssfColor . getRGB ( ) ; } // Bytes are signed, so values of 128+ are negative!\r // 0: red, 1: green, 2: blue\r rgbfix [ 0 ] = ( short ) ( ( rgb [ 0 ] < 0 ) ? ( rgb [ 0 ] + RGB8BITS ) : rgb [ 0 ] ) ; rgbfix [ 1 ] = ( short ) ( ( rgb [ 1 ] < 0 ) ? ( rgb [ 1 ] + RGB8BITS ) : rgb [ 1 ] ) ; rgbfix [ 2 ] = ( short ) ( ( rgb [ 2 ] < 0 ) ? ( rgb [ 2 ] + RGB8BITS ) : rgb [ 2 ] ) ; } return rgbfix ; }", "nl": "Convert xssfcolor to triple let numbers ."}}
{"translation": {"code": "private static XColor getXColorFromRgbClr ( final CTSRgbColor ctrColor ) { XSSFColor bcolor = null ; try { byte [ ] rgb = ctrColor . getVal ( ) ; bcolor = new XSSFColor ( rgb ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"Cannot get rgb color error = \" + ex . getLocalizedMessage ( ) , ex ) ; return null ; } int lumOff = 0 ; int lumMod = 0 ; int alphaStr = 0 ; try { lumOff = ctrColor . getLumOffArray ( 0 ) . getVal ( ) ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \"No lumOff entry\" , ex ) ; } try { lumMod = ctrColor . getLumModArray ( 0 ) . getVal ( ) ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \"No lumMod entry\" , ex ) ; } try { alphaStr = ctrColor . getAlphaArray ( 0 ) . getVal ( ) ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \"No alpha entry\" , ex ) ; } return assembleXcolor ( bcolor , 0 , lumOff , lumMod , alphaStr ) ; }", "nl": "get xcolor from ctsRgbColor ."}}
{"translation": {"code": "public void reCalcMaxColCounts ( ) { if ( ( this . getSheetConfigMap ( ) == null ) || ( this . getSheetConfigMap ( ) . isEmpty ( ) ) ) { this . maxColCounts = 0 ; return ; } int maxColumns = 0 ; for ( SheetConfiguration sheetConfig : this . getSheetConfigMap ( ) . values ( ) ) { int counts = sheetConfig . getHeaderCellRange ( ) . getRightCol ( ) - sheetConfig . getHeaderCellRange ( ) . getLeftCol ( ) + 1 ; if ( maxColumns < counts ) { maxColumns = counts ; } } this . maxColCounts = maxColumns ; }", "nl": "recalculate max coulumn count across sheets in the workbook ."}}
{"translation": {"code": "private void initChartsMap ( final Workbook wb ) { try { if ( wb instanceof XSSFWorkbook ) { initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"getChartsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; } }", "nl": "initial chart map for specified workbook ."}}
{"translation": {"code": "private String getPieTitle ( final ChartData chartData ) { for ( ChartSeries chartSeries : chartData . getSeriesList ( ) ) { if ( chartSeries != null ) { return getParsedCellValue ( chartSeries . getSeriesLabel ( ) ) ; } } return \"\" ; }", "nl": "return pie chart title from chartData ."}}
{"translation": {"code": "public final void setSeriesStyle ( final JFreeChart chart , final int seriesIndex , final String style ) { if ( chart != null && style != null ) { BasicStroke stroke = ChartUtility . toStroke ( style ) ; Plot plot = chart . getPlot ( ) ; if ( plot instanceof CategoryPlot ) { CategoryPlot categoryPlot = chart . getCategoryPlot ( ) ; CategoryItemRenderer cir = categoryPlot . getRenderer ( ) ; try { cir . setSeriesStroke ( seriesIndex , stroke ) ; // series line\r // style\r } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; } } else if ( plot instanceof XYPlot ) { XYPlot xyPlot = chart . getXYPlot ( ) ; XYItemRenderer xyir = xyPlot . getRenderer ( ) ; try { xyir . setSeriesStroke ( seriesIndex , stroke ) ; // series line\r // style\r } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"Error setting style '\" + style + \"' for series '\" + Integer . toString ( seriesIndex ) + \"' of chart '\" + chart . toString ( ) + \"': \" + e . getLocalizedMessage ( ) , e ) ; } } else { LOG . log ( Level . FINE , \"setSeriesColor() unsupported plot: {}\" , plot . toString ( ) ) ; } } }", "nl": "Set color of series ."}}
{"translation": {"code": "public int loadWebSheet ( final Workbook pWb , final Map < String , Object > pDataContext ) { return this . getHelper ( ) . getWebSheetLoader ( ) . loadWorkbook ( pWb , pDataContext ) ; }", "nl": "load web sheet from giving workbook with data object ."}}
{"translation": {"code": "public final Object evaluate ( final Map < String , Object > context ) { JexlContext jexlContext = new MapContext ( context ) ; try { return jExpression . evaluate ( jexlContext ) ; } catch ( Exception e ) { throw new EvaluationException ( \"An error occurred when evaluating expression \" + jExpression . getExpression ( ) , e ) ; } }", "nl": "evaluate from giving context ."}}
{"translation": {"code": "public static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { try { Method method = obj . getClass ( ) . getMethod ( \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) , new Class [ ] { String . class } ) ; method . invoke ( obj , propertyValue ) ; } catch ( Exception e ) { String msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; if ( ignoreNonExisting ) { LOG . info ( msg ) ; } else { LOG . warning ( msg ) ; throw new IllegalArgumentException ( e ) ; } } }", "nl": "Sets the object property ."}}
{"translation": {"code": "public static boolean insideRange ( final ConfigRange child , final ConfigRange parent ) { return ( ( cellCompareTo ( child . getFirstRowRef ( ) , parent . getFirstRowRef ( ) ) >= 0 ) && ( cellCompareTo ( child . getLastRowPlusRef ( ) , parent . getLastRowPlusRef ( ) ) <= 0 ) ) ; }", "nl": "Inside range ."}}
{"translation": {"code": "public final Object evaluate ( final String expression , final Map < String , Object > context ) { JexlContext jexlContext = new MapContext ( context ) ; try { JexlEngine jexl = JEXL_LOCAL . get ( ) ; Map < String , Expression > expMap = JEXL_MAP_LOCAL . get ( ) ; Expression jexlExpression = expMap . get ( expression ) ; if ( jexlExpression == null ) { jexlExpression = jexl . createExpression ( expression ) ; expMap . put ( expression , jexlExpression ) ; } return jexlExpression . evaluate ( jexlContext ) ; } catch ( Exception e ) { throw new EvaluationException ( e ) ; } }", "nl": "Evaluate the expression ."}}
{"translation": {"code": "public final void setFirstRowRef ( final Cell pFirstRowRef , final boolean alsoCreateAddr ) { this . attrs . setFirstRowRef ( pFirstRowRef ) ; if ( alsoCreateAddr ) { this . setFirstRowAddr ( new SerialCellAddress ( pFirstRowRef ) ) ; } }", "nl": "set first cell also set static relative address firstCellAddress ."}}
{"translation": {"code": "public final void setLastRowPlusRef ( final Sheet sheet , final int rightCol , final int lastRow , final boolean alsoSetAddr ) { if ( ( lastRow >= 0 ) && ( sheet != null ) && ( rightCol >= 0 ) ) { Row row = sheet . getRow ( lastRow + 1 ) ; if ( row == null ) { row = sheet . createRow ( lastRow + 1 ) ; } Cell cell = row . getCell ( rightCol ) ; if ( cell == null ) { cell = row . getCell ( rightCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; this . attrs . setLastCellCreated ( true ) ; } else { this . attrs . setLastCellCreated ( false ) ; } this . attrs . setLastRowPlusRef ( cell ) ; if ( alsoSetAddr ) { this . setLastRowPlusAddr ( new SerialCellAddress ( cell ) ) ; } } else { this . attrs . setLastRowPlusRef ( null ) ; if ( alsoSetAddr ) { this . attrs . setLastRowPlusAddr ( null ) ; } } }", "nl": "set last cell also set static relative address lastCellAddress ."}}
{"translation": {"code": "private List < Integer > buildFormWatchList ( final XSSFEvaluationWorkbook wbWrapper , final Sheet sheet ) { List < Integer > watchList = new ArrayList <> ( ) ; ConfigRange cRange = this . getConfigRange ( ) ; List < ConfigCommand > commandList = cRange . getCommandList ( ) ; if ( commandList . isEmpty ( ) ) { // if no command then no dynamic changes. then no need formula\r // shifts.\r return watchList ; } int lastStaticRow = commandList . get ( 0 ) . getTopRow ( ) - 1 ; if ( lastStaticRow < 0 ) { lastStaticRow = this . getTopRow ( ) ; } int sheetIndex = sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ; for ( int i = this . getTopRow ( ) ; i <= this . getLastRow ( ) ; i ++ ) { Row row = sheet . getRow ( i ) ; for ( Cell cell : row ) { if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { buildWatchListForCell ( wbWrapper , sheetIndex , cell , watchList , lastStaticRow ) ; } } } return watchList ; }", "nl": "Watch list serve for formula changes . Basically all the rows appeared in the formula in the current sheet will be watched . Note if the cell reference is from other sheet or workbooks it will be ignored ."}}
{"translation": {"code": "public void setWb ( final Workbook pWb ) { this . getSerialWb ( ) . setWb ( pWb ) ; this . wbWrapper = XSSFEvaluationWorkbook . create ( ( XSSFWorkbook ) pWb ) ; }", "nl": "Set up workbook . Also create evaluation wrapper ."}}
{"translation": {"code": "private void addToWatchList ( final int addRow , final int lastStaticRow , final List < Integer > watchList ) { if ( ( addRow > lastStaticRow ) && ! ( watchList . contains ( addRow ) ) ) { watchList . add ( addRow ) ; } }", "nl": "Only rows in dynamic area will be added to watch list ."}}
{"translation": {"code": "public final void removeRow ( final Integer sourceRowNum , final Row targetRow ) { List < SerialRow > mapRowList = rowsMap . get ( sourceRowNum ) ; if ( mapRowList != null ) { mapRowList . remove ( new SerialRow ( targetRow , - 1 ) ) ; rowsMap . put ( sourceRowNum , mapRowList ) ; } }", "nl": "Removes the row ."}}
{"translation": {"code": "public final void mergeMap ( final RowsMapping addMap ) { Map < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; for ( Map . Entry < Integer , List < SerialRow > > entry : map . entrySet ( ) ) { List < SerialRow > entryRowList = entry . getValue ( ) ; if ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) { for ( SerialRow row : entryRowList ) { this . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; } } } }", "nl": "Merge map ."}}
{"translation": {"code": "public final void refreshCachedCell ( final String tblName , final int i , final int index , final Cell cell , final FacesCell fcell ) { if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) && ( tblName != null ) ) { try { processRefreshCell ( tblName , i , index , cell , fcell ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"refresh Cached Cell error : \" + ex . getLocalizedMessage ( ) , ex ) ; } } }", "nl": "Refresh cached cell ."}}
{"translation": {"code": "public final void putShiftAttrs ( final String fullName , final ConfigRangeAttrs attrs , final RowsMapping unitRowsMapping ) { attrs . setUnitRowsMapping ( unitRowsMapping ) ; this . shiftMap . put ( fullName , attrs ) ; }", "nl": "Put shift attrs ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) private int buildEachObjects ( String fullName , final ConfigBuildRef configBuildRef , final int atRow , final Map < String , Object > context , final List < RowsMapping > currentRowsMappingList , final Collection itemsCollection , final String objClassName ) { int index = 0 ; int insertPosition = atRow ; String thisObjClassName = objClassName ; // loop through each object in the collection\r for ( Object obj : itemsCollection ) { // gather and cache object class name which used for add row\r if ( thisObjClassName == null ) { thisObjClassName = obj . getClass ( ) . getName ( ) ; configBuildRef . getCollectionObjNameMap ( ) . put ( this . var , thisObjClassName ) ; } RowsMapping unitRowsMapping = new RowsMapping ( ) ; context . put ( var , obj ) ; CommandUtility . insertEachTemplate ( this . getConfigRange ( ) , configBuildRef , index , insertPosition , unitRowsMapping ) ; ConfigRange currentRange = ConfigurationUtility . buildCurrentRange ( this . getConfigRange ( ) , configBuildRef . getSheet ( ) , insertPosition ) ; currentRowsMappingList . add ( unitRowsMapping ) ; String unitFullName = fullName + \".\" + index ; currentRange . getAttrs ( ) . setAllowAdd ( false ) ; if ( ( this . allowAdd != null ) && ( \"true\" . equalsIgnoreCase ( this . allowAdd . trim ( ) ) ) ) { currentRange . getAttrs ( ) . setAllowAdd ( true ) ; configBuildRef . setBodyAllowAdd ( true ) ; } configBuildRef . putShiftAttrs ( unitFullName , currentRange . getAttrs ( ) , new RowsMapping ( unitRowsMapping ) ) ; int length = currentRange . buildAt ( unitFullName , configBuildRef , insertPosition , context , currentRowsMappingList ) ; currentRange . getAttrs ( ) . setFinalLength ( length ) ; insertPosition += length ; currentRowsMappingList . remove ( unitRowsMapping ) ; index ++ ; context . remove ( var ) ; } return insertPosition ; }", "nl": "Builds the each objects ."}}
{"translation": {"code": "public final void setCommandIndexMap ( final Map < String , Command > pcommandIndexMap ) { if ( pcommandIndexMap instanceof HashMap ) { this . commandIndexMap = ( HashMap < String , Command > ) pcommandIndexMap ; } else { this . commandIndexMap = new HashMap <> ( ) ; this . commandIndexMap . putAll ( pcommandIndexMap ) ; } }", "nl": "Sets the command index map ."}}
{"translation": {"code": "private void refreshBodyRowsInRange ( final int insertPosition , final int length , final Sheet sheet , final SheetConfiguration sheetConfig ) { Map < String , CellRangeAddress > cellRangeMap = ConfigurationUtility . indexMergedRegion ( sheet ) ; List < String > skippedRegionCells = ConfigurationUtility . skippedRegionCells ( sheet ) ; int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; int left = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; int right = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; for ( int irow = insertPosition ; irow < ( insertPosition + length ) ; irow ++ ) { parent . getBodyRows ( ) . add ( irow - top , assembleFacesBodyRow ( irow , sheet , left , right , sheetConfig , cellRangeMap , skippedRegionCells ) ) ; } for ( int irow = insertPosition + length - top ; irow < parent . getBodyRows ( ) . size ( ) ; irow ++ ) { FacesRow facesrow = parent . getBodyRows ( ) . get ( irow ) ; facesrow . setRowIndex ( facesrow . getRowIndex ( ) + length ) ; } }", "nl": "Refresh body rows in range ."}}
{"translation": {"code": "private static String findComponentNameFromClass ( final UIComponent component ) { String cname = component . getClass ( ) . getSimpleName ( ) ; if ( supportComponents . contains ( cname ) ) { return cname ; } return null ; }", "nl": "find component according it s class ."}}
{"translation": {"code": "public static String getObjectPropertyValue ( final Object obj , final String propertyName , final boolean ignoreNonExisting ) { try { Method method = obj . getClass ( ) . getMethod ( \"get\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ) ; return ( String ) method . invoke ( obj ) ; } catch ( Exception e ) { String msg = \"failed to get property '\" + propertyName + \"' for object \" + obj ; if ( ignoreNonExisting ) { LOG . log ( Level . FINE , msg , e ) ; } else { LOG . warning ( msg ) ; throw new IllegalArgumentException ( e ) ; } } return null ; }", "nl": "get object property value ."}}
{"translation": {"code": "public static void setObjectProperty ( final Object obj , final String propertyName , final String propertyValue , final boolean ignoreNonExisting ) { try { String methodName = \"set\" + Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; AttributesType parameterType = matchParaMeterOfMethod ( obj , methodName ) ; if ( parameterType != null ) { Method method = obj . getClass ( ) . getMethod ( methodName , new Class [ ] { parameterType . clazz } ) ; method . invoke ( obj , convertToObject ( parameterType , propertyValue ) ) ; } } catch ( Exception e ) { String msg = \"failed to set property '\" + propertyName + \"' to value '\" + propertyValue + \"' for object \" + obj ; if ( ignoreNonExisting ) { LOG . log ( Level . FINE , msg , e ) ; } else { LOG . warning ( msg ) ; throw new IllegalArgumentException ( e ) ; } } }", "nl": "set object property ."}}
{"translation": {"code": "private static AttributesType matchParaMeterOfMethod ( final Object obj , final String methodName ) { for ( AttributesType attr : AttributesType . values ( ) ) { try { obj . getClass ( ) . getMethod ( methodName , new Class [ ] { attr . clazz } ) ; return attr ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \" error in matchParaMeterOfMethod = \" + ex . getLocalizedMessage ( ) , ex ) ; } } return null ; }", "nl": "match parameter of method ."}}
{"translation": {"code": "public static void populateAttributes ( final UIComponent component , final FacesCell fcell , final Map < String , Map < String , String > > defaultControlMap ) { List < CellFormAttributes > inputAttrs = fcell . getInputAttrs ( ) ; String cname = findComponentNameFromClass ( component ) ; if ( cname == null ) { return ; } Map < String , String > defaultMap = defaultControlMap . get ( cname ) ; if ( defaultMap == null ) { defaultMap = new HashMap <> ( ) ; defaultControlMap . put ( cname , defaultMap ) ; } for ( Map . Entry < String , String > entry : defaultMap . entrySet ( ) ) { setObjectProperty ( component , entry . getKey ( ) , entry . getValue ( ) , true ) ; } for ( CellFormAttributes attr : inputAttrs ) { String propertyName = attr . getType ( ) ; String propertyValue = attr . getValue ( ) ; if ( ! defaultMap . containsKey ( propertyName ) ) { String defaultValue = getObjectPropertyValue ( component , propertyName , true ) ; defaultMap . put ( propertyName , defaultValue ) ; } setObjectProperty ( component , propertyName , propertyValue , true ) ; } }", "nl": "populate attributes ."}}
{"translation": {"code": "public final void shiftRowRef ( final Sheet sheet , final int shiftnum ) { try { this . setFirstRowRef ( sheet . getRow ( attrs . getFirstRowAddr ( ) . getRow ( ) + shiftnum ) . getCell ( attrs . getFirstRowAddr ( ) . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) , false ) ; this . setLastRowPlusRef ( sheet , attrs . getLastRowPlusAddr ( ) . getColumn ( ) , attrs . getLastRowPlusAddr ( ) . getRow ( ) + shiftnum - 1 , false ) ; if ( commandList != null ) { for ( ConfigCommand command : commandList ) { command . shiftRowRef ( sheet , shiftnum ) ; } } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"shiftRowRef error =\" + ex . getLocalizedMessage ( ) , ex ) ; } }", "nl": "Shift row ref ."}}
{"translation": {"code": "public void populateComponent ( final ComponentSystemEvent event ) { UIComponent component = event . getComponent ( ) ; int [ ] rowcol = CellUtility . getRowColFromComponentAttributes ( component ) ; int row = rowcol [ 0 ] ; int col = rowcol [ 1 ] ; FacesCell fcell = CellUtility . getFacesCellFromBodyRow ( row , col , this . getBodyRows ( ) , this . getCurrent ( ) . getCurrentTopRow ( ) , this . getCurrent ( ) . getCurrentLeftColumn ( ) ) ; CellControlsUtility . populateAttributes ( component , fcell , this . getCellDefaultControl ( ) ) ; }", "nl": "populate component ."}}
{"translation": {"code": "private Locale getLocale ( final FacesContext context , final UIComponent component ) { String localeStr = ( String ) component . getAttributes ( ) . get ( TieConstants . COMPONENT_ATTR_LOCALE ) ; if ( localeStr == null ) { return context . getViewRoot ( ) . getLocale ( ) ; } return Locale . forLanguageTag ( localeStr ) ; }", "nl": "Gets the locale ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T findBean ( final String beanName ) { FacesContext context = FacesContext . getCurrentInstance ( ) ; return ( T ) context . getApplication ( ) . evaluateExpressionGet ( context , TieConstants . EL_START + beanName + TieConstants . EL_END , Object . class ) ; }", "nl": "Find bean in context ."}}
{"translation": {"code": "public static boolean evalInputType ( final String input , final String type ) { Scanner scanner = new Scanner ( input ) ; boolean ireturn = false ; if ( \"Integer\" . equalsIgnoreCase ( type ) ) { ireturn = scanner . hasNextInt ( ) ; } else if ( \"Double\" . equalsIgnoreCase ( type ) ) { ireturn = scanner . hasNextDouble ( ) ; } else if ( \"Boolean\" . equalsIgnoreCase ( type ) ) { ireturn = scanner . hasNextBoolean ( ) ; } else if ( \"Byte\" . equalsIgnoreCase ( type ) ) { ireturn = scanner . hasNextByte ( ) ; } else if ( type . toLowerCase ( ) . startsWith ( \"text\" ) ) { ireturn = true ; } scanner . close ( ) ; return ireturn ; }", "nl": "evaluate input type ."}}
{"translation": {"code": "public static InputStream getResourceAsStream ( final FacesContext context , final String path ) { return context . getExternalContext ( ) . getResourceAsStream ( path ) ; }", "nl": "get resource file as stream ."}}
{"translation": {"code": "public final void clear ( ) { if ( this . templateCommentMap != null ) { this . templateCommentMap . clear ( ) ; } if ( this . cellDatePattern != null ) { this . cellDatePattern . clear ( ) ; } if ( this . cellInputAttributes != null ) { this . cellInputAttributes . clear ( ) ; } if ( this . cellInputType != null ) { this . cellInputType . clear ( ) ; } if ( this . cellSelectItemsAttributes != null ) { this . cellSelectItemsAttributes . clear ( ) ; } }", "nl": "clear all the related maps ."}}
{"translation": {"code": "public static Set < String > getResourcePaths ( final FacesContext context , final String path ) { return context . getExternalContext ( ) . getResourcePaths ( path ) ; }", "nl": "return faces context resource path ."}}
{"translation": {"code": "public static double round ( final double value , final int places ) { if ( places < 0 ) { throw new IllegalArgumentException ( ) ; } BigDecimal bd = BigDecimal . valueOf ( value ) ; bd = bd . setScale ( places , RoundingMode . HALF_UP ) ; return bd . doubleValue ( ) ; }", "nl": "round number according to decimal places ."}}
{"translation": {"code": "public static String removePrefixPath ( final String prefix , final String resource ) { String normalizedResource = resource ; if ( normalizedResource . startsWith ( prefix ) ) { normalizedResource = normalizedResource . substring ( prefix . length ( ) - 1 ) ; } return normalizedResource ; }", "nl": "remove prefix path of the full path ."}}
{"translation": {"code": "public static String strJoin ( final short [ ] aArr , final String sSep ) { StringBuilder sbStr = new StringBuilder ( ) ; for ( int i = 0 , il = aArr . length ; i < il ; i ++ ) { if ( i > 0 ) { sbStr . append ( sSep ) ; } sbStr . append ( aArr [ i ] ) ; } return sbStr . toString ( ) ; }", "nl": "join string ."}}
{"translation": {"code": "private void buildSingleCell ( final Cell cell , final Map < String , Object > context , final ConfigBuildRef configBuildRef , final ShiftFormulaRef shiftFormulaRef ) { try { CommandUtility . evaluate ( context , cell , configBuildRef . getEngine ( ) ) ; if ( cell . getCellTypeEnum ( ) == CellType . FORMULA ) { // rebuild formula if necessary for dynamic row\r String originFormula = cell . getCellFormula ( ) ; shiftFormulaRef . setFormulaChanged ( 0 ) ; ConfigurationUtility . buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , cell . getCellFormula ( ) ) ; if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; } } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"build cell ( row = \" + cell . getRowIndex ( ) + \" column = \" + cell . getColumnIndex ( ) + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; } }", "nl": "Builds the single cell ."}}
{"translation": {"code": "private static void buildDynamicRowForAreaPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg ) { AreaPtgBase areaPtg = ( AreaPtgBase ) ptg ; int originFirstRow = areaPtg . getFirstRow ( ) ; int originLastRow = areaPtg . getLastRow ( ) ; int unitSize = 2 ; for ( int i = 0 ; i < rowList . size ( ) ; i ++ ) { Row row = rowList . get ( i ) . getRow ( ) ; int shiftRow = row . getRowNum ( ) - originFirstRow ; if ( ptg instanceof Area3DPxg ) { Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; new3dpxg . setClass ( originalOperandClass ) ; new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; new3dpxg . setFirstRow ( originFirstRow + shiftRow ) ; new3dpxg . setLastRow ( originLastRow + shiftRow ) ; new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; newPtg [ i * unitSize ] = new3dpxg ; } else { AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; newPtg [ i * unitSize ] = new AreaPtg ( originFirstRow + shiftRow , originLastRow + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; } if ( i < ( rowList . size ( ) - 1 ) ) { newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; } } }", "nl": "Builds the dynamic row for area ptg base ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) public static Cell setCellValue ( final Cell c , final String value ) { try { if ( value . length ( ) == 0 ) { c . setCellType ( CellType . BLANK ) ; } else if ( WebSheetUtility . isNumeric ( value ) ) { setCellValueNumber ( c , value ) ; } else if ( WebSheetUtility . isDate ( value ) ) { setCellValueDate ( c , value ) ; } else if ( c . getCellTypeEnum ( ) == CellType . BOOLEAN ) { setCellValueBoolean ( c , value ) ; } else { setCellValueString ( c , value ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , \" error in setCellValue of CellUtility = \" + e . getLocalizedMessage ( ) , e ) ; setCellValueString ( c , value ) ; } return c ; }", "nl": "Set cell value with giving String value ."}}
{"translation": {"code": "private static String getCellStringValueWithType ( final Cell poiCell , final CellType cellType ) { switch ( cellType ) { case BOOLEAN : return getCellStringValueWithBooleanType ( poiCell ) ; case NUMERIC : return getCellStringValueWithNumberType ( poiCell ) ; case STRING : return poiCell . getStringCellValue ( ) ; default : return \"\" ; } // switch\r }", "nl": "Get cell value as string but with giving type ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithoutFormat ( final Cell poiCell ) { if ( poiCell == null ) { return null ; } if ( poiCell . getCellTypeEnum ( ) == CellType . FORMULA ) { return getCellStringValueWithType ( poiCell , poiCell . getCachedFormulaResultTypeEnum ( ) ) ; } else { return getCellStringValueWithType ( poiCell , poiCell . getCellTypeEnum ( ) ) ; } }", "nl": "get input cell value . none input return blank"}}
{"translation": {"code": "private String fmtNumber ( final double d ) { if ( Double . compare ( d % 1 , 0 ) == 0 ) { return String . format ( \"%d\" , ( int ) d ) ; } else { return String . format ( \"%.2f\" , d ) ; } }", "nl": "Fmt number ."}}
{"translation": {"code": "private static void setCellValueBoolean ( final Cell c , final String value ) { if ( \"Y\" . equalsIgnoreCase ( value ) || \"Yes\" . equalsIgnoreCase ( value ) || \"True\" . equalsIgnoreCase ( value ) ) { c . setCellValue ( true ) ; } else { c . setCellValue ( false ) ; } }", "nl": "Sets the cell value boolean ."}}
{"translation": {"code": "public static void copyRows ( final Sheet srcSheet , final Sheet destSheet , final int srcRowStart , final int srcRowEnd , final int destRow , final boolean checkLock , final boolean setHiddenColumn ) { int length = srcRowEnd - srcRowStart + 1 ; if ( length <= 0 ) { return ; } destSheet . shiftRows ( destRow , destSheet . getLastRowNum ( ) , length , true , false ) ; for ( int i = 0 ; i < length ; i ++ ) { copySingleRow ( srcSheet , destSheet , srcRowStart + i , destRow + i , checkLock , setHiddenColumn ) ; } // If there are are any merged regions in the source row, copy to new\r // row\r for ( int i = 0 ; i < srcSheet . getNumMergedRegions ( ) ; i ++ ) { CellRangeAddress cellRangeAddress = srcSheet . getMergedRegion ( i ) ; if ( ( cellRangeAddress . getFirstRow ( ) >= srcRowStart ) && ( cellRangeAddress . getLastRow ( ) <= srcRowEnd ) ) { int targetRowFrom = cellRangeAddress . getFirstRow ( ) - srcRowStart + destRow ; int targetRowTo = cellRangeAddress . getLastRow ( ) - srcRowStart + destRow ; CellRangeAddress newCellRangeAddress = new CellRangeAddress ( targetRowFrom , targetRowTo , cellRangeAddress . getFirstColumn ( ) , cellRangeAddress . getLastColumn ( ) ) ; destSheet . addMergedRegion ( newCellRangeAddress ) ; } } }", "nl": "Copy rows ."}}
{"translation": {"code": "public static Ptg [ ] convertSharedFormulas ( final Ptg [ ] ptgs , final ShiftFormulaRef shiftFormulaRef ) { List < Ptg > newPtgList = new ArrayList <> ( ) ; Object ptg ; for ( int k = 0 ; k < ptgs . length ; ++ k ) { ptg = ptgs [ k ] ; newPtgList . addAll ( Arrays . asList ( convertPtg ( ptgs , k , shiftFormulaRef , ptg ) ) ) ; } return newPtgList . toArray ( new Ptg [ newPtgList . size ( ) ] ) ; }", "nl": "Convert shared formulas ."}}
{"translation": {"code": "public static Cell copyCell ( final Sheet destSheet , final Row sourceRow , final Row newRow , final int cellIndex , final boolean checkLock ) { // If the old cell is null jump to next cell\r Cell sourceCell = sourceRow . getCell ( cellIndex ) ; if ( sourceCell == null ) { return null ; } // If source cell is dest cell refresh it\r boolean refreshCell = false ; if ( sourceRow . equals ( newRow ) && ( sourceCell . getColumnIndex ( ) == cellIndex ) ) { sourceRow . removeCell ( sourceCell ) ; refreshCell = true ; } Cell newCell = newRow . createCell ( cellIndex ) ; try { if ( ! refreshCell && ( sourceCell . getCellComment ( ) != null ) ) { // If there is a cell comment, copy\r cloneComment ( sourceCell , newCell ) ; } copyCellSetStyle ( destSheet , sourceCell , newCell ) ; copyCellSetValue ( sourceCell , newCell , checkLock ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"copy cell set error = \" + ex . getLocalizedMessage ( ) , ex ) ; } return newCell ; }", "nl": "Copy cell ."}}
{"translation": {"code": "public static int getInitRowsFromConfig ( final SheetConfiguration sheetConfig ) { int initRows = 1 ; if ( \"Repeat\" . equalsIgnoreCase ( sheetConfig . getFormBodyType ( ) ) ) { initRows = sheetConfig . getBodyInitialRows ( ) ; if ( initRows < 1 ) { initRows = 1 ; } } return initRows ; }", "nl": "Gets the inits the rows from config ."}}
{"translation": {"code": "public static int [ ] getRowColFromComponentAttributes ( final UIComponent target ) { int rowIndex = ( Integer ) target . getAttributes ( ) . get ( \"data-row\" ) ; int colIndex = ( Integer ) target . getAttributes ( ) . get ( \"data-column\" ) ; int [ ] list = new int [ 2 ] ; list [ 0 ] = rowIndex ; list [ 1 ] = colIndex ; return list ; }", "nl": "Gets the row col from component attributes ."}}
{"translation": {"code": "public static void convertCell ( final SheetConfiguration sheetConfig , final FacesCell fcell , final Cell poiCell , final Map < String , CellRangeAddress > cellRangeMap , final int originRowIndex , final CellAttributesMap cellAttributesMap , final String saveAttrs ) { CellRangeAddress caddress ; String key = getCellIndexNumberKey ( poiCell ) ; caddress = cellRangeMap . get ( key ) ; if ( caddress != null ) { // has col or row span\r fcell . setColspan ( caddress . getLastColumn ( ) - caddress . getFirstColumn ( ) + 1 ) ; fcell . setRowspan ( caddress . getLastRow ( ) - caddress . getFirstRow ( ) + 1 ) ; } CellControlsUtility . setupControlAttributes ( originRowIndex , fcell , poiCell , sheetConfig , cellAttributesMap ) ; fcell . setHasSaveAttr ( SaveAttrsUtility . isHasSaveAttr ( poiCell , saveAttrs ) ) ; }", "nl": "set up facesCell s attribute from poiCell and others ."}}
{"translation": {"code": "private static CellStyle getCellStyleFromSourceCell ( final Sheet destSheet , final Cell sourceCell ) { Workbook wb = destSheet . getWorkbook ( ) ; // Copy style from old cell and apply to new cell\r CellStyle newCellStyle = wb . createCellStyle ( ) ; newCellStyle . cloneStyleFrom ( sourceCell . getCellStyle ( ) ) ; return newCellStyle ; }", "nl": "create cell style from source cell ."}}
{"translation": {"code": "private static Ptg [ ] convertPtgForWatchList ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg , final byte originalOperandClass , final int currentRow ) { List < SerialRow > rowlist = getRowsList ( currentRow , shiftFormulaRef . getCurrentRowsMappingList ( ) ) ; if ( ( rowlist == null ) || ( rowlist . isEmpty ( ) ) ) { // no need change ptg\r return singlePtg ( ptg , originalOperandClass , - 1 ) ; } shiftFormulaRef . setFormulaChanged ( 1 ) ; // one to one or has no round brackets\r if ( ( rowlist . size ( ) == 1 ) || ( ( position + 1 ) >= ptgs . length ) || ! ( ptgs [ position + 1 ] instanceof ParenthesisPtg ) ) { // change ptg one to one\r // return changed ptg\r return singlePtg ( fixupRefRelativeRowOneToOne ( ptg , rowlist . get ( 0 ) . getRow ( ) ) , originalOperandClass , - 1 ) ; } shiftFormulaRef . setFormulaChanged ( rowlist . size ( ) ) ; return fixupRefRelativeRowOneToMany ( ptg , originalOperandClass , rowlist , ptgs , position ) ; }", "nl": "Convert ptg for watch list ."}}
{"translation": {"code": "private static void copySingleRow ( final Sheet srcSheet , final Sheet destSheet , final int sourceRowNum , final int destinationRowNum , final boolean checkLock , final boolean setHiddenColumn ) { // Get the source / new row\r Row newRow = destSheet . getRow ( destinationRowNum ) ; Row sourceRow = srcSheet . getRow ( sourceRowNum ) ; if ( newRow == null ) { newRow = destSheet . createRow ( destinationRowNum ) ; } newRow . setHeight ( sourceRow . getHeight ( ) ) ; // Loop through source columns to add to new row\r for ( int i = 0 ; i < sourceRow . getLastCellNum ( ) ; i ++ ) { // Grab a copy of the old/new cell\r copyCell ( destSheet , sourceRow , newRow , i , checkLock ) ; } if ( setHiddenColumn ) { ConfigurationUtility . setOriginalRowNumInHiddenColumn ( newRow , sourceRow . getRowNum ( ) ) ; } return ; }", "nl": "Copy single row ."}}
{"translation": {"code": "private static Ptg [ ] singlePtg ( final Object ptg , final byte originalOperandClass , final int formulaChanged ) { Ptg [ ] newPtg = new Ptg [ 1 ] ; if ( originalOperandClass != ( - 1 ) ) { ( ( Ptg ) ptg ) . setClass ( originalOperandClass ) ; } Object ptgAfter = ptg ; if ( ptg instanceof FuncVarPtg ) { FuncVarPtg fptg = ( FuncVarPtg ) ptg ; if ( ( formulaChanged > 0 ) && ( fptg . getNumberOfOperands ( ) != formulaChanged ) ) { ptgAfter = FuncVarPtg . create ( ( ( FuncVarPtg ) ptg ) . getName ( ) , formulaChanged ) ; } } newPtg [ 0 ] = ( Ptg ) ptgAfter ; return newPtg ; }", "nl": "Single ptg ."}}
{"translation": {"code": "public static FacesCell getFacesCellFromBodyRow ( final int row , final int col , final List < FacesRow > bodyRows , final int topRow , final int leftCol ) { FacesCell cell = null ; try { cell = bodyRows . get ( row - topRow ) . getCells ( ) . get ( col - leftCol ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"getFacesCellFromBodyRow Error row = \" + row + \" col = \" + col + \"top row = \" + topRow + \" leftCol = \" + leftCol + \" ; error = \" + e . getLocalizedMessage ( ) , e ) ; } return cell ; }", "nl": "Gets the faces cell from body row ."}}
{"translation": {"code": "public static Cell getPoiCellFromSheet ( final int rowIndex , final int colIndex , final Sheet sheet1 ) { if ( ( sheet1 != null ) && ( sheet1 . getRow ( rowIndex ) != null ) ) { return sheet1 . getRow ( rowIndex ) . getCell ( colIndex ) ; } return null ; }", "nl": "Gets the poi cell from sheet ."}}
{"translation": {"code": "private static List < SerialRow > assembleRowsListFromRowsMapping ( final List < SerialRow > all , final List < SerialRow > current ) { List < SerialRow > list ; if ( all == null ) { list = new ArrayList <> ( ) ; list . addAll ( current ) ; } else { list = all ; for ( SerialRow row : current ) { if ( ! all . contains ( row ) ) { list . add ( row ) ; } } } return list ; }", "nl": "assemble rowslist from rowsmapping ."}}
{"translation": {"code": "protected static Object fixupRefRelativeRowOneToOne ( final Object ptg , final Row newRow ) { if ( ptg instanceof RefPtgBase ) { if ( ptg instanceof Ref3DPxg ) { Ref3DPxg ref3dPxg = ( Ref3DPxg ) ptg ; Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( newRow . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; new3dpxg . setClass ( ref3dPxg . getPtgClass ( ) ) ; new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; return new3dpxg ; } else { RefPtgBase refPtgBase = ( RefPtgBase ) ptg ; return new RefPtg ( newRow . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; } } else { if ( ptg instanceof Area3DPxg ) { Area3DPxg area3dPxg = ( Area3DPxg ) ptg ; Area3DPxg new3dpxg = new Area3DPxg ( area3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( area3dPxg . getSheetName ( ) , false ) ) , area3dPxg . format2DRefAsString ( ) ) ; new3dpxg . setClass ( area3dPxg . getPtgClass ( ) ) ; new3dpxg . setFirstColRelative ( area3dPxg . isFirstColRelative ( ) ) ; new3dpxg . setLastColRelative ( area3dPxg . isLastColRelative ( ) ) ; int shiftRow = newRow . getRowNum ( ) - area3dPxg . getFirstRow ( ) ; new3dpxg . setFirstRow ( area3dPxg . getFirstRow ( ) + shiftRow ) ; new3dpxg . setLastRow ( area3dPxg . getLastRow ( ) + shiftRow ) ; new3dpxg . setFirstRowRelative ( area3dPxg . isFirstRowRelative ( ) ) ; new3dpxg . setLastRowRelative ( area3dPxg . isLastRowRelative ( ) ) ; new3dpxg . setLastSheetName ( area3dPxg . getLastSheetName ( ) ) ; return new3dpxg ; } else { AreaPtgBase areaPtgBase = ( AreaPtgBase ) ptg ; int shiftRow = newRow . getRowNum ( ) - areaPtgBase . getFirstRow ( ) ; return new AreaPtg ( areaPtgBase . getFirstRow ( ) + shiftRow , areaPtgBase . getLastRow ( ) + shiftRow , areaPtgBase . getFirstColumn ( ) , areaPtgBase . getLastColumn ( ) , areaPtgBase . isFirstRowRelative ( ) , areaPtgBase . isLastRowRelative ( ) , areaPtgBase . isFirstColRelative ( ) , areaPtgBase . isLastColRelative ( ) ) ; } } }", "nl": "Fixup ref relative row one to one ."}}
{"translation": {"code": "private static void buildDynamicRowForRefPtgBase ( final Object ptg , final byte originalOperandClass , final List < SerialRow > rowList , final Ptg [ ] newPtg , final boolean includeParenthesis ) { RefPtgBase refPtg = ( RefPtgBase ) ptg ; int unitSize = 1 ; if ( includeParenthesis ) { unitSize = 2 ; } for ( int i = 0 ; i < rowList . size ( ) ; i ++ ) { Row row = rowList . get ( i ) . getRow ( ) ; if ( refPtg instanceof Ref3DPxg ) { Ref3DPxg ref3dPxg = ( Ref3DPxg ) refPtg ; Ref3DPxg new3dpxg = new Ref3DPxg ( ref3dPxg . getExternalWorkbookNumber ( ) , new SheetIdentifier ( null , new NameIdentifier ( ref3dPxg . getSheetName ( ) , false ) ) , new CellReference ( row . getRowNum ( ) , ref3dPxg . getColumn ( ) ) ) ; new3dpxg . setClass ( originalOperandClass ) ; new3dpxg . setColRelative ( ref3dPxg . isColRelative ( ) ) ; new3dpxg . setRowRelative ( ref3dPxg . isRowRelative ( ) ) ; new3dpxg . setLastSheetName ( ref3dPxg . getLastSheetName ( ) ) ; newPtg [ i * unitSize ] = new3dpxg ; } else { RefPtgBase refPtgBase = refPtg ; newPtg [ i * unitSize ] = new RefPtg ( row . getRowNum ( ) , refPtgBase . getColumn ( ) , refPtgBase . isRowRelative ( ) , refPtgBase . isColRelative ( ) ) ; } if ( ( unitSize == 2 ) && ( i < ( rowList . size ( ) - 1 ) ) ) { newPtg [ i * unitSize + 1 ] = ParenthesisPtg . instance ; } } }", "nl": "Builds the dynamic row for ref ptg base ."}}
{"translation": {"code": "private static Ptg [ ] convertPtg ( final Ptg [ ] ptgs , final int position , final ShiftFormulaRef shiftFormulaRef , final Object ptg ) { byte originalOperandClass = - 1 ; if ( ! ( ( Ptg ) ptg ) . isBaseToken ( ) ) { originalOperandClass = ( ( Ptg ) ptg ) . getPtgClass ( ) ; } int currentRow ; currentRow = getFirstSupportedRowNumFromPtg ( ptg ) ; if ( ( currentRow >= 0 ) && shiftFormulaRef . getWatchList ( ) . contains ( currentRow ) ) { return convertPtgForWatchList ( ptgs , position , shiftFormulaRef , ptg , originalOperandClass , currentRow ) ; } // no need change ptg\r if ( ( ptg instanceof AttrPtg ) && ( shiftFormulaRef . getFormulaChanged ( ) > 1 ) ) { AttrPtg newPtg = ( AttrPtg ) ptg ; if ( newPtg . isSum ( ) ) { FuncVarPtg fptg = FuncVarPtg . create ( \"sum\" , shiftFormulaRef . getFormulaChanged ( ) ) ; return singlePtg ( fptg , fptg . getPtgClass ( ) , shiftFormulaRef . getFormulaChanged ( ) ) ; } } return singlePtg ( ptg , originalOperandClass , shiftFormulaRef . getFormulaChanged ( ) ) ; }", "nl": "Convert ptg ."}}
{"translation": {"code": "private static List < SerialRow > getRowsList ( final int currentRow , final List < RowsMapping > currentRowsMappingList ) { List < SerialRow > all = null ; int size = currentRowsMappingList . size ( ) ; for ( RowsMapping rowsmapping : currentRowsMappingList ) { List < SerialRow > current = rowsmapping . get ( currentRow ) ; if ( current != null ) { if ( size == 1 ) { return current ; } all = assembleRowsListFromRowsMapping ( all , current ) ; } } return all ; }", "nl": "Gets the rows list ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) public static String getCellValueWithFormat ( final Cell poiCell , final FormulaEvaluator formulaEvaluator , final DataFormatter dataFormatter ) { if ( poiCell == null ) { return null ; } String result ; try { CellType cellType = poiCell . getCellTypeEnum ( ) ; if ( cellType == CellType . FORMULA ) { cellType = formulaEvaluator . evaluate ( poiCell ) . getCellTypeEnum ( ) ; } if ( cellType == CellType . ERROR ) { result = \"\" ; } else { result = dataFormatter . formatCellValue ( poiCell , formulaEvaluator ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"Web Form WebFormHelper getCellValue Error row = \" + poiCell . getRowIndex ( ) + \" column = \" + poiCell . getColumnIndex ( ) + \" error = \" + e . getLocalizedMessage ( ) + \"; Change return result to blank\" , e ) ; result = \"\" ; } return result ; }", "nl": "return cell value with format ."}}
{"translation": {"code": "public void setUnsavedStatus ( final RequestContext requestContext , final Boolean statusFlag ) { // in client js should have setUnsavedState method\r if ( requestContext != null ) { LOG . log ( Level . FINE , \"run setUnsavedState( {} )\" , statusFlag . toString ( ) ) ; requestContext . execute ( \"setUnsavedState(\" + statusFlag . toString ( ) + \")\" ) ; } }", "nl": "Sets the unsaved status ."}}
{"translation": {"code": "public final Boolean isUnsavedStatus ( ) { Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; Boolean flag = ( Boolean ) viewMap . get ( TieConstants . UNSAVEDSTATE ) ; if ( flag == null ) { return false ; } return flag ; }", "nl": "Checks if is unsaved status ."}}
{"translation": {"code": "private static void gatherSpecialAttributes ( final String type , final SpecialAttributes sAttr , final CellFormAttributes attr ) { String attrKey = attr . getType ( ) ; if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_LABELS ) ) { sAttr . selectLabels = attr . getValue ( ) . split ( \";\" ) ; } if ( attrKey . equalsIgnoreCase ( TieConstants . SELECT_ITEM_VALUES ) ) { sAttr . selectValues = attr . getValue ( ) . split ( \";\" ) ; } if ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_LABEL ) ) { sAttr . defaultSelectLabel = attr . getValue ( ) ; } if ( attrKey . equalsIgnoreCase ( TieConstants . DEFAULT_SELECT_ITEM_VALUE ) ) { sAttr . defaultSelectValue = attr . getValue ( ) ; } if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) && attrKey . equalsIgnoreCase ( TieConstants . WIDGET_ATTR_PATTERN ) ) { sAttr . defaultDatePattern = attr . getValue ( ) ; } }", "nl": "Gather special attributes ."}}
{"translation": {"code": "public static void parseSpecialAttributes ( final String key , final String type , final List < CellFormAttributes > inputs , final CellAttributesMap cellAttributesMap ) { SpecialAttributes sAttr = new SpecialAttributes ( ) ; for ( CellFormAttributes attr : inputs ) { gatherSpecialAttributes ( type , sAttr , attr ) ; } if ( sAttr . selectLabels != null ) { processSelectItemAttributes ( key , cellAttributesMap , sAttr ) ; } if ( type . equalsIgnoreCase ( TieConstants . WIDGET_CALENDAR ) ) { processCalendarAttributes ( key , cellAttributesMap , sAttr ) ; } }", "nl": "parse select item attributes ."}}
{"translation": {"code": "public static void parseInputAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { // only one type control allowed for one cell.\r clist . clear ( ) ; if ( controlAttrs != null ) { String [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; for ( String cattr : cattrs ) { String [ ] details = splitByEualSign ( cattr ) ; if ( details . length > 1 ) { CellFormAttributes attr = new CellFormAttributes ( ) ; attr . setType ( details [ 0 ] . trim ( ) ) ; attr . setValue ( details [ 1 ] . replaceAll ( \"\\\"\" , \"\" ) ) ; clist . add ( attr ) ; } } } }", "nl": "parse input attributes ."}}
{"translation": {"code": "public static boolean isCommandString ( final String str ) { if ( str == null ) { return false ; } return str . startsWith ( TieConstants . COMMAND_PREFIX ) ; }", "nl": "check it s a command comment ."}}
{"translation": {"code": "public static void parseWidgetAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { return ; } int widgetStart = newComment . indexOf ( TieConstants . METHOD_WIDGET_PREFIX ) ; int elStart = newComment . indexOf ( TieConstants . EL_START_BRACKET ) ; if ( ( widgetStart < 0 ) || ( widgetStart >= elStart ) ) { return ; } String type = newComment . substring ( widgetStart + TieConstants . METHOD_WIDGET_PREFIX . length ( ) , elStart ) ; String values = getStringBetweenBracket ( newComment ) ; if ( values == null ) { return ; } // map's key is sheetName!$columnIndex$rowIndex\r String key = getAttributeKeyInMapByCell ( cell ) ; // one cell only has one control widget\r cellAttributesMap . getCellInputType ( ) . put ( key , type ) ; List < CellFormAttributes > inputs = cellAttributesMap . getCellInputAttributes ( ) . get ( key ) ; if ( inputs == null ) { inputs = new ArrayList <> ( ) ; cellAttributesMap . getCellInputAttributes ( ) . put ( key , inputs ) ; } parseInputAttributes ( inputs , values ) ; parseSpecialAttributes ( key , type , inputs , cellAttributesMap ) ; }", "nl": "Parses the widget attributes ."}}
{"translation": {"code": "public static Map < String , String > parseCommandAttributes ( final String attrString ) { Map < String , String > attrMap = new LinkedHashMap <> ( ) ; Matcher attrMatcher = TieConstants . ATTR_REGEX_PATTERN . matcher ( attrString ) ; while ( attrMatcher . find ( ) ) { String attrData = attrMatcher . group ( ) ; int attrNameEndIndex = attrData . indexOf ( ' ' ) ; String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; String attrValuePart = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; String attrValue = attrValuePart . substring ( 1 , attrValuePart . length ( ) - 1 ) ; attrMap . put ( attrName , attrValue ) ; } return attrMap ; }", "nl": "Parse the attributes from string ."}}
{"translation": {"code": "public static String getAttributeKeyInMapByCell ( final Cell cell ) { if ( cell == null ) { return null ; } // map's key is sheetName!$columnIndex$rowIndex\r return cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell ) ; }", "nl": "get attribute key in map by cell ."}}
{"translation": {"code": "public final CellHelper getCellHelper ( ) { if ( ( this . cellHelper == null ) && ( this . parent != null ) ) { this . cellHelper = new CellHelper ( parent ) ; } return cellHelper ; }", "nl": "Gets the cell helper ."}}
{"translation": {"code": "public final PicturesHelper getPicHelper ( ) { if ( ( this . picHelper == null ) && ( this . parent != null ) ) { this . picHelper = new PicturesHelper ( parent ) ; } return picHelper ; }", "nl": "Gets the pic helper ."}}
{"translation": {"code": "public final ValidationHandler getValidationHandler ( ) { if ( ( this . validationHandler == null ) && ( this . parent != null ) ) { this . validationHandler = new ValidationHandler ( parent ) ; } return validationHandler ; }", "nl": "Gets the validation handler ."}}
{"translation": {"code": "public final ChartHelper getChartHelper ( ) { if ( ( this . chartHelper == null ) && ( this . parent != null ) ) { this . chartHelper = new ChartHelper ( parent ) ; } return chartHelper ; }", "nl": "Gets the chart helper ."}}
{"translation": {"code": "public static void parseCommentToMap ( final String cellKey , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { if ( ( newComment != null ) && ( ! newComment . trim ( ) . isEmpty ( ) ) ) { // normal comment key is $$\r String commentKey = TieConstants . NORMAL_COMMENT_KEY_IN_MAP ; if ( ! normalComment ) { // not normal comment. e.g. ${... or $init{... or\r // key = $ or key = $init\r commentKey = newComment . substring ( 0 , newComment . indexOf ( TieConstants . EL_START_BRACKET ) ) ; } Map < String , String > map = sheetCommentMap . get ( commentKey ) ; if ( map == null ) { map = new HashMap <> ( ) ; } // inner map's key is sheetName!$columnIndex$rowIndex\r map . put ( cellKey , newComment ) ; sheetCommentMap . put ( commentKey , map ) ; } }", "nl": "Parse Comment To Map"}}
{"translation": {"code": "private static String [ ] splitByEualSign ( final String attrData ) { int attrNameEndIndex = attrData . indexOf ( ' ' ) ; if ( attrNameEndIndex < 0 ) { return new String [ 0 ] ; } String attrName = attrData . substring ( 0 , attrNameEndIndex ) . trim ( ) ; String attrValue = attrData . substring ( attrNameEndIndex + 1 ) . trim ( ) ; String [ ] rlist = new String [ 2 ] ; rlist [ 0 ] = attrName ; rlist [ 1 ] = attrValue ; return rlist ; }", "nl": "split string by = sign ."}}
{"translation": {"code": "public static void parseValidateAttributes ( final List < CellFormAttributes > clist , final String controlAttrs ) { // one cell could have multiple validation rules.\r if ( controlAttrs == null ) { return ; } String [ ] cattrs = controlAttrs . split ( TieConstants . SPLIT_SPACE_SEPERATE_ATTRS_REGX , - 1 ) ; CellFormAttributes attr = new CellFormAttributes ( ) ; for ( String cattr : cattrs ) { extractValidationAttributes ( attr , cattr ) ; } if ( ( attr . getValue ( ) != null ) && ( ! attr . getValue ( ) . isEmpty ( ) ) ) { clist . add ( attr ) ; } }", "nl": "parse validate attributes ."}}
{"translation": {"code": "public final String getCurrentDataContextName ( ) { if ( currentDataContextName == null ) { StringBuilder sb = new StringBuilder ( ) ; List < String > list = this . getCurrentDataContextNameList ( ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( i > 0 ) { sb . append ( \":\" + list . get ( i ) ) ; } else { sb . append ( list . get ( i ) ) ; } } this . setCurrentDataContextName ( sb . toString ( ) ) ; } return currentDataContextName ; }", "nl": "Gets the current data context name ."}}
{"translation": {"code": "public static void parseValidateAttributes ( final Cell cell , final String newComment , final CellAttributesMap cellAttributesMap ) { if ( ( newComment == null ) || ( newComment . isEmpty ( ) ) ) { return ; } if ( ! newComment . startsWith ( TieConstants . METHOD_VALIDATE_PREFIX ) ) { return ; } String values = getStringBetweenBracket ( newComment ) ; if ( values == null ) { return ; } // map's key is sheetName!$columnIndex$rowIndex\r String key = getAttributeKeyInMapByCell ( cell ) ; List < CellFormAttributes > attrs = cellAttributesMap . getCellValidateAttributes ( ) . get ( key ) ; if ( attrs == null ) { attrs = new ArrayList <> ( ) ; cellAttributesMap . getCellValidateAttributes ( ) . put ( key , attrs ) ; } parseValidateAttributes ( attrs , values ) ; }", "nl": "Parses the validate attributes ."}}
{"translation": {"code": "private static String getCellStringValueWithNumberType ( final Cell poiCell ) { String result ; if ( DateUtil . isCellDateFormatted ( poiCell ) ) { result = poiCell . getDateCellValue ( ) . toString ( ) ; } else { result = BigDecimal . valueOf ( poiCell . getNumericCellValue ( ) ) . toPlainString ( ) ; // remove .0 from end for int\r if ( result . endsWith ( \".0\" ) ) { result = result . substring ( 0 , result . length ( ) - 2 ) ; } } return result ; }", "nl": "Gets the cell string value with number type ."}}
{"translation": {"code": "public static String getRowStyle ( final Workbook wb , final Cell poiCell , final String inputType , final float rowHeight , final int rowspan ) { CellStyle cellStyle = poiCell . getCellStyle ( ) ; if ( ( cellStyle != null ) && ( rowspan == 1 ) ) { short fontIdx = cellStyle . getFontIndex ( ) ; Font font = wb . getFontAt ( fontIdx ) ; float maxHeight = rowHeight ; if ( ! inputType . isEmpty ( ) ) { maxHeight = Math . min ( font . getFontHeightInPoints ( ) + 8f , rowHeight ) ; } return \"height:\" + WebSheetUtility . pointsToPixels ( maxHeight ) + \"px;\" ; } return \"\" ; }", "nl": "Gets the row style ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) private static String getInputTypeFromCellType ( final Cell cell ) { String inputType = TieConstants . CELL_INPUT_TYPE_TEXT ; if ( cell . getCellTypeEnum ( ) == CellType . NUMERIC ) { inputType = TieConstants . CELL_INPUT_TYPE_DOUBLE ; } CellStyle style = cell . getCellStyle ( ) ; if ( style != null ) { int formatIndex = style . getDataFormat ( ) ; String formatString = style . getDataFormatString ( ) ; if ( DateUtil . isADateFormat ( formatIndex , formatString ) ) { inputType = TieConstants . CELL_INPUT_TYPE_DATE ; } else { if ( isAPercentageCell ( formatString ) ) { inputType = TieConstants . CELL_INPUT_TYPE_PERCENTAGE ; } } } return inputType ; }", "nl": "Gets the input type from cell type ."}}
{"translation": {"code": "public static void setupCellStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { CellStyle cellStyle = poiCell . getCellStyle ( ) ; if ( ( cellStyle != null ) && ( ! cellStyle . getLocked ( ) ) ) { // not locked\r if ( fcell . getInputType ( ) . isEmpty ( ) ) { fcell . setInputType ( CellStyleUtility . getInputTypeFromCellType ( poiCell ) ) ; } if ( fcell . getControl ( ) . isEmpty ( ) && ( ! fcell . getInputType ( ) . isEmpty ( ) ) ) { fcell . setControl ( \"text\" ) ; } setInputStyleBaseOnInputType ( fcell , poiCell ) ; } String webStyle = getCellStyle ( wb , poiCell , fcell . getInputType ( ) ) + getCellFontStyle ( wb , poiCell ) + getRowStyle ( wb , poiCell , fcell . getInputType ( ) , rowHeight , fcell . getRowspan ( ) ) ; fcell . setStyle ( webStyle ) ; fcell . setColumnStyle ( getColumnStyle ( wb , fcell , poiCell , rowHeight ) ) ; }", "nl": "Setup cell style ."}}
{"translation": {"code": "public static int calcTotalHeight ( final Sheet sheet1 , final int firstRow , final int lastRow , final int additionalHeight ) { int totalHeight = additionalHeight ; for ( int i = firstRow ; i <= lastRow ; i ++ ) { totalHeight += sheet1 . getRow ( i ) . getHeight ( ) ; } return totalHeight ; }", "nl": "Calc total height ."}}
{"translation": {"code": "private static String getVerticalAlignmentFromCell ( final CellStyle cellStyle ) { String style = \"\" ; switch ( cellStyle . getVerticalAlignmentEnum ( ) ) { case TOP : style = TieConstants . VERTICAL_ALIGN_TOP ; break ; case CENTER : style = TieConstants . VERTICAL_ALIGN_CENTER ; break ; case BOTTOM : style = TieConstants . VERTICAL_ALIGN_BOTTOM ; break ; default : break ; } return style ; }", "nl": "Gets the vertical alignment from cell ."}}
{"translation": {"code": "private static String getAlignmentFromCell ( final Cell poiCell , final CellStyle cellStyle ) { String style = \"\" ; switch ( cellStyle . getAlignmentEnum ( ) ) { case LEFT : style = TieConstants . TEXT_ALIGN_LEFT ; break ; case RIGHT : style = TieConstants . TEXT_ALIGN_RIGHT ; break ; case CENTER : style = TieConstants . TEXT_ALIGN_CENTER ; break ; case GENERAL : style = getAlignmentFromCellType ( poiCell ) ; break ; default : break ; } return style ; }", "nl": "Gets the alignment from cell ."}}
{"translation": {"code": "public static String getColumnStyle ( final Workbook wb , final FacesCell fcell , final Cell poiCell , final float rowHeight ) { String inputType = fcell . getInputType ( ) ; CellStyle cellStyle = poiCell . getCellStyle ( ) ; StringBuilder webStyle = new StringBuilder ( ) ; if ( cellStyle != null ) { if ( fcell . isContainPic ( ) || fcell . isContainChart ( ) ) { webStyle . append ( \"vertical-align: top;\" ) ; } else { webStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; webStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; } webStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , cellStyle ) ) ; webStyle . append ( getRowStyle ( wb , poiCell , inputType , rowHeight , fcell . getRowspan ( ) ) ) ; } else { webStyle . append ( getAlignmentFromCellType ( poiCell ) ) ; } return webStyle . toString ( ) ; }", "nl": "Gets the column style ."}}
{"translation": {"code": "public static String getCellStyle ( final Workbook wb , final Cell poiCell , final String inputType ) { CellStyle cellStyle = poiCell . getCellStyle ( ) ; StringBuilder webStyle = new StringBuilder ( ) ; if ( cellStyle != null ) { if ( ! inputType . isEmpty ( ) ) { webStyle . append ( getAlignmentFromCell ( poiCell , cellStyle ) ) ; webStyle . append ( getVerticalAlignmentFromCell ( cellStyle ) ) ; } webStyle . append ( ColorUtility . getBgColorFromCell ( wb , poiCell , cellStyle ) ) ; } return webStyle . toString ( ) ; }", "nl": "Gets the cell style ."}}
{"translation": {"code": "private static String getCellFontDecoration ( final Font font ) { StringBuilder decoration = new StringBuilder ( ) ; if ( font . getUnderline ( ) != 0 ) { decoration . append ( \" underline\" ) ; } if ( font . getStrikeout ( ) ) { decoration . append ( \" line-through\" ) ; } return decoration . toString ( ) ; }", "nl": "Get font decoration ."}}
{"translation": {"code": "private static String getCellFontColor ( final Font font ) { short [ ] rgbfix = { TieConstants . RGB_MAX , TieConstants . RGB_MAX , TieConstants . RGB_MAX } ; if ( font instanceof XSSFFont ) { XSSFColor color = ( ( XSSFFont ) font ) . getXSSFColor ( ) ; if ( color != null ) { rgbfix = ColorUtility . getTripletFromXSSFColor ( color ) ; } } if ( rgbfix [ 0 ] != TieConstants . RGB_MAX ) { return \"color:rgb(\" + FacesUtility . strJoin ( rgbfix , \",\" ) + \");\" ; } return \"\" ; }", "nl": "get cell font color ."}}
{"translation": {"code": "public static String getCellFontStyle ( final Workbook wb , final Cell poiCell ) { CellStyle cellStyle = poiCell . getCellStyle ( ) ; StringBuilder webStyle = new StringBuilder ( ) ; if ( cellStyle != null ) { short fontIdx = cellStyle . getFontIndex ( ) ; Font font = wb . getFontAt ( fontIdx ) ; if ( font . getItalic ( ) ) { webStyle . append ( \"font-style: italic;\" ) ; } if ( font . getBold ( ) ) { webStyle . append ( \"font-weight: bold;\" ) ; } webStyle . append ( \"font-size: \" + font . getFontHeightInPoints ( ) + \"pt;\" ) ; String decoration = getCellFontDecoration ( font ) ; if ( decoration . length ( ) > 0 ) { webStyle . append ( \"text-decoration:\" + decoration + \";\" ) ; } webStyle . append ( getCellFontColor ( font ) ) ; } return webStyle . toString ( ) ; }", "nl": "Gets the cell font style ."}}
{"translation": {"code": "public static String parseSaveAttr ( final Cell cell , final Map < String , String > saveCommentsMap ) { if ( cell != null ) { String key = cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , cell . getRowIndex ( ) ) ; String saveAttr = null ; if ( saveCommentsMap != null ) { saveAttr = ParserUtility . getStringBetweenBracket ( saveCommentsMap . get ( key ) ) ; } if ( ( saveAttr == null ) && ( cell . getCellTypeEnum ( ) == CellType . STRING ) ) { saveAttr = SaveAttrsUtility . parseSaveAttrString ( cell . getStringCellValue ( ) ) ; } if ( ( saveAttr != null ) && ( ! saveAttr . isEmpty ( ) ) ) { return TieConstants . CELL_ADDR_PRE_FIX + cell . getColumnIndex ( ) + \"=\" + saveAttr + \",\" ; } } return \"\" ; }", "nl": "Parses the save attr ."}}
{"translation": {"code": "private static void setCellValueNumber ( final Cell c , final String value ) { double val = Double . parseDouble ( value . replace ( Character . toString ( ' ' ) , \"\" ) ) ; c . setCellType ( CellType . NUMERIC ) ; c . setCellValue ( val ) ; }", "nl": "Sets the cell value number ."}}
{"translation": {"code": "private static void setCellValueDate ( final Cell c , final String value ) { String date = WebSheetUtility . parseDate ( value ) ; setCellValueString ( c , date ) ; }", "nl": "Sets the cell value date ."}}
{"translation": {"code": "private static void setCellValueString ( final Cell c , final String value ) { c . setCellType ( CellType . STRING ) ; c . setCellValue ( value ) ; }", "nl": "Sets the cell value string ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) private static void copyCellSetStyle ( final Sheet destSheet , final Cell sourceCell , final Cell newCell ) { CellStyle newCellStyle = getCellStyleFromSourceCell ( destSheet , sourceCell ) ; newCell . setCellStyle ( newCellStyle ) ; // If there is a cell hyperlink, copy\r if ( sourceCell . getHyperlink ( ) != null ) { newCell . setHyperlink ( sourceCell . getHyperlink ( ) ) ; } // Set the cell data type\r newCell . setCellType ( sourceCell . getCellTypeEnum ( ) ) ; }", "nl": "set up cell style ."}}
{"translation": {"code": "public static void setSaveAttrsForSheet ( final Sheet sheet , final int minRowNum , final int maxRowNum , final Map < String , String > saveCommentsMap ) { for ( Row row : sheet ) { int rowIndex = row . getRowNum ( ) ; if ( ( rowIndex >= minRowNum ) && ( rowIndex <= maxRowNum ) ) { setSaveAttrsForRow ( row , saveCommentsMap ) ; } } }", "nl": "Sets the save attrs for sheet ."}}
{"translation": {"code": "public static void setSaveObjectsInHiddenColumn ( final Row row , final String saveAttr ) { Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; cell . setCellValue ( saveAttr ) ; }", "nl": "Sets the save objects in hidden column ."}}
{"translation": {"code": "public static String getSaveAttrFromList ( final int columnIndex , final String saveAttrs ) { if ( ( saveAttrs != null ) && ( ! saveAttrs . isEmpty ( ) ) ) { String str = TieConstants . CELL_ADDR_PRE_FIX + columnIndex + \"=\" ; int istart = saveAttrs . indexOf ( str ) ; if ( istart >= 0 ) { int iend = saveAttrs . indexOf ( ' ' , istart ) ; if ( iend > istart ) { return saveAttrs . substring ( istart + str . length ( ) , iend ) ; } } } return null ; }", "nl": "Gets the save attr from list ."}}
{"translation": {"code": "public static String getSaveAttrListFromRow ( final Row row ) { if ( row != null ) { Cell cell = row . getCell ( TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; if ( cell != null ) { String str = cell . getStringCellValue ( ) ; if ( ( str != null ) && ( ! str . isEmpty ( ) ) ) { return str ; } } } return null ; }", "nl": "Gets the save attr list from row ."}}
{"translation": {"code": "static String getBgColorFromCell ( final Workbook wb , final Cell poiCell , final CellStyle cellStyle ) { String style = \"\" ; if ( poiCell instanceof HSSFCell ) { int bkColorIndex = cellStyle . getFillForegroundColor ( ) ; HSSFColor color = HSSFColor . getIndexHash ( ) . get ( bkColorIndex ) ; if ( color != null ) { // correct color for customPalette\r HSSFPalette palette = ( ( HSSFWorkbook ) wb ) . getCustomPalette ( ) ; HSSFColor color2 = palette . getColor ( bkColorIndex ) ; if ( ! color . getHexString ( ) . equalsIgnoreCase ( color2 . getHexString ( ) ) ) { color = color2 ; } style = \"background-color:rgb(\" + FacesUtility . strJoin ( color . getTriplet ( ) , \",\" ) + \");\" ; } } else if ( poiCell instanceof XSSFCell ) { XSSFColor color = ( ( XSSFCell ) poiCell ) . getCellStyle ( ) . getFillForegroundColorColor ( ) ; if ( color != null ) { style = \"background-color:rgb(\" + FacesUtility . strJoin ( getTripletFromXSSFColor ( color ) , \",\" ) + \");\" ; } } return style ; }", "nl": "Gets the bg color from cell ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) private static void copyCellSetValue ( final Cell sourceCell , final Cell newCell , final boolean checkLock ) { CellStyle newCellStyle = newCell . getCellStyle ( ) ; String name = sourceCell . getCellTypeEnum ( ) . toString ( ) ; CellValueType e = Enum . valueOf ( CellValueType . class , name ) ; e . setCellValue ( newCell , sourceCell , checkLock , newCellStyle ) ; }", "nl": "set cell value ."}}
{"translation": {"code": "public static String prepareContextAndAttrsForCell ( Cell poiCell , String fullName , CellHelper cellHelper ) { if ( fullName == null ) { return null ; } String saveAttrList = SaveAttrsUtility . getSaveAttrListFromRow ( poiCell . getRow ( ) ) ; if ( saveAttrList != null ) { String saveAttr = SaveAttrsUtility . getSaveAttrFromList ( poiCell . getColumnIndex ( ) , saveAttrList ) ; if ( saveAttr != null ) { cellHelper . restoreDataContext ( fullName ) ; return saveAttr ; } } return null ; }", "nl": "Prepare context and attrs for cell ."}}
{"translation": {"code": "public static void setSaveAttrsForRow ( final Row row , final Map < String , String > saveCommentsMap ) { StringBuilder saveAttr = new StringBuilder ( ) ; for ( Cell cell : row ) { String sAttr = parseSaveAttr ( cell , saveCommentsMap ) ; if ( ! sAttr . isEmpty ( ) ) { saveAttr . append ( sAttr ) ; } } if ( saveAttr . length ( ) > 0 ) { SaveAttrsUtility . setSaveObjectsInHiddenColumn ( row , saveAttr . toString ( ) ) ; } }", "nl": "Sets the save attrs for row ."}}
{"translation": {"code": "public static String parseSaveAttrString ( final String strValue ) { if ( strValue != null ) { int first = strValue . indexOf ( TieConstants . METHOD_PREFIX ) ; int last = strValue . lastIndexOf ( TieConstants . METHOD_PREFIX ) ; int end = strValue . lastIndexOf ( TieConstants . METHOD_END ) ; if ( ( first >= 0 ) && ( first == last ) && ( end > 1 ) ) { return strValue . substring ( first + 2 , end ) ; } } return \"\" ; }", "nl": "Parses the save attr string ."}}
{"translation": {"code": "public static void saveDataToObjectInContext ( final Map < String , Object > context , final String saveAttr , final String strValue , final ExpressionEngine engine ) { int index = saveAttr . lastIndexOf ( ' ' ) ; if ( index > 0 ) { String strObject = saveAttr . substring ( 0 , index ) ; String strMethod = saveAttr . substring ( index + 1 ) ; strObject = TieConstants . METHOD_PREFIX + strObject + TieConstants . METHOD_END ; Object object = CommandUtility . evaluate ( strObject , context , engine ) ; CellControlsUtility . setObjectProperty ( object , strMethod , strValue , true ) ; } }", "nl": "Save data to object in context ."}}
{"translation": {"code": "private void refreshCachedCellsInRow ( final String tblName , final int top , final int left , final int i ) { FacesRow dataRow = parent . getBodyRows ( ) . get ( i ) ; int isize = dataRow . getCells ( ) . size ( ) ; for ( int index = 0 ; index < isize ; index ++ ) { FacesCell fcell = dataRow . getCells ( ) . get ( index ) ; Cell poiCell = parent . getCellHelper ( ) . getPoiCellWithRowColFromCurrentPage ( i + top , index + left ) ; if ( poiCell != null ) { parent . getHelper ( ) . getWebSheetLoader ( ) . refreshCachedCell ( tblName , i , index , poiCell , fcell ) ; } } }", "nl": "Refresh cached cells in row ."}}
{"translation": {"code": "private void readObject ( final java . io . ObjectInputStream in ) throws IOException { try { in . defaultReadObject ( ) ; Gson objGson = new GsonBuilder ( ) . setPrettyPrinting ( ) . create ( ) ; Type listType = new TypeToken < Map < String , Object > > ( ) { } . getType ( ) ; this . dataContext = objGson . fromJson ( mapToJson , listType ) ; } catch ( EncryptedDocumentException | ClassNotFoundException e ) { LOG . log ( Level . SEVERE , \" error in readObject of serialWorkbook : \" + e . getLocalizedMessage ( ) , e ) ; } }", "nl": "load the workbook from saving ."}}
{"translation": {"code": "public SheetConfiguration getCurrentSheetConfig ( ) { String currentTabName = this . getCurrent ( ) . getCurrentTabName ( ) ; if ( currentTabName == null ) { return null ; } return this . getSheetConfigMap ( ) . get ( currentTabName ) ; }", "nl": "Gets the current sheet config ."}}
{"translation": {"code": "public final void recover ( final Sheet sheet ) { if ( this . cellAddr != null ) { this . setCell ( sheet . getRow ( this . cellAddr . getRow ( ) ) . getCell ( this . cellAddr . getColumn ( ) ) ) ; } }", "nl": "recover cell by using it s address ."}}
{"translation": {"code": "private void buildWatchListForCell ( final XSSFEvaluationWorkbook wbWrapper , final int sheetIndex , final Cell cell , final List < Integer > watchList , final int lastStaticRow ) { String formula = cell . getCellFormula ( ) ; Ptg [ ] ptgs = FormulaParser . parse ( formula , wbWrapper , FormulaType . CELL , sheetIndex ) ; for ( int k = 0 ; k < ptgs . length ; k ++ ) { Object ptg = ptgs [ k ] ; // For area formula, only first row is watched.\r // Reason is the lastRow must shift same rows with\r // firstRow.\r // Otherwise it's difficult to calculate.\r // In case some situation cannot fit, then should make\r // change to the formula.\r int areaInt = ShiftFormulaUtility . getFirstSupportedRowNumFromPtg ( ptg ) ; if ( areaInt >= 0 ) { addToWatchList ( areaInt , lastStaticRow , watchList ) ; } } // when insert row, the formula may changed. so here is the\r // workaround.\r // change formula to user formula to preserve the row\r // changes.\r cell . setCellType ( CellType . STRING ) ; cell . setCellValue ( TieConstants . USER_FORMULA_PREFIX + formula + TieConstants . USER_FORMULA_SUFFIX ) ; }", "nl": "Builds the watch list for cell ."}}
{"translation": {"code": "private void buildCellsForRow ( final Row row , final String fullName , final Map < String , Object > context , final ConfigBuildRef configBuildRef , ShiftFormulaRef shiftFormulaRef ) { if ( ( row == null ) || ! ConfigurationUtility . isStaticRowRef ( this , row ) ) { return ; } for ( Cell cell : row ) { buildSingleCell ( cell , context , configBuildRef , shiftFormulaRef ) ; } ConfigurationUtility . setFullNameInHiddenColumn ( row , fullName ) ; }", "nl": "Builds the cells for row ."}}
{"translation": {"code": "private void initAnchorsMap ( final Workbook wb , final ChartsData chartsData ) { try { if ( wb instanceof XSSFWorkbook ) { ChartUtility . initXSSFAnchorsMap ( ( XSSFWorkbook ) wb , chartsData ) ; } } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"Web Form getAnchorsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; } }", "nl": "initial anchors map for specified workbook . Excel put the chart position information in draw . xml instead of chart . xml . anchors map contains the information getting from draw . xml ."}}
{"translation": {"code": "private void refreshCachedCellsInCurrentPage ( final FacesContext facesContext , final String tblName ) { // refresh current page calculation fields\r UIComponent s = facesContext . getViewRoot ( ) . findComponent ( tblName ) ; if ( s == null ) { return ; } DataTable webDataTable = ( DataTable ) s ; int first = webDataTable . getFirst ( ) ; int rowsToRender = webDataTable . getRowsToRender ( ) ; int rowCounts = webDataTable . getRowCount ( ) ; int top = parent . getCurrent ( ) . getCurrentTopRow ( ) ; int left = parent . getCurrent ( ) . getCurrentLeftColumn ( ) ; for ( int i = first ; i <= ( first + rowsToRender ) ; i ++ ) { if ( i < rowCounts ) { refreshCachedCellsInRow ( tblName , top , left , i ) ; } } }", "nl": "Refresh cached cells in current page ."}}
{"translation": {"code": "public void setSubmitModeInView ( final Boolean fullflag ) { if ( FacesContext . getCurrentInstance ( ) != null ) { Map < String , Object > viewMap = FacesContext . getCurrentInstance ( ) . getViewRoot ( ) . getViewMap ( ) ; if ( viewMap != null ) { Boolean flag = ( Boolean ) viewMap . get ( TieConstants . SUBMITMODE ) ; if ( ( flag == null ) || ( ! flag . equals ( fullflag ) ) ) { viewMap . put ( TieConstants . SUBMITMODE , fullflag ) ; } } } }", "nl": "set submit mode flag with javascript for holding in client side ."}}
{"translation": {"code": "public boolean preValidation ( ) { String currentTabName = parent . getCurrent ( ) . getCurrentTabName ( ) ; String tabName = null ; String firstInvalidTabName = null ; boolean reload = false ; for ( Map . Entry < String , SheetConfiguration > entry : parent . getSheetConfigMap ( ) . entrySet ( ) ) { tabName = entry . getKey ( ) ; // if not reload and tabname==current then skip reloading.\r if ( reload || ( ! tabName . equals ( currentTabName ) ) ) { parent . getWebSheetLoader ( ) . prepareWorkShee ( tabName ) ; reload = true ; } if ( ! parent . getValidationHandler ( ) . validateCurrentPage ( ) && ( firstInvalidTabName == null ) ) { firstInvalidTabName = tabName ; } } if ( firstInvalidTabName != null ) { if ( ! tabName . equals ( firstInvalidTabName ) ) { parent . getHelper ( ) . getWebSheetLoader ( ) . loadWorkSheet ( firstInvalidTabName ) ; } return false ; } return true ; }", "nl": "triggered validation process before actions like save or submit ."}}
{"translation": {"code": "private boolean isNeedRestore ( final String fullName , final String [ ] parts ) { if ( fullName == null ) { return false ; } if ( ( parent . getCurrent ( ) . getCurrentDataContextName ( ) != null ) && ( parent . getCurrent ( ) . getCurrentDataContextName ( ) . toLowerCase ( ) . startsWith ( fullName . toLowerCase ( ) ) ) ) { return false ; } return ( ( parts != null ) && ( parts . length > 1 ) ) ; }", "nl": "Checks if is need restore ."}}
{"translation": {"code": "private void writeObject ( final java . io . ObjectOutputStream out ) throws IOException { this . rowIndex = this . getRow ( ) . getRowNum ( ) ; out . defaultWriteObject ( ) ; }", "nl": "save the row before serialize ."}}
{"translation": {"code": "public final void restoreDataContext ( final String fullName ) { String [ ] parts = fullName . split ( \":\" ) ; if ( ! isNeedRestore ( fullName , parts ) ) { return ; } boolean stopSkip = false ; List < String > list = parent . getCurrent ( ) . getCurrentDataContextNameList ( ) ; int listSize = list . size ( ) ; // prepare collection data in context.\r // must loop through the full name which may have multiple\r // layer.\r // i.e. E.department.1:E.employee.0\r // need prepare department.1 and employee.0\r for ( int i = 0 ; i < parts . length ; i ++ ) { String part = parts [ i ] ; boolean skip = false ; if ( ( ! stopSkip ) && ( i < listSize ) ) { String listPart = list . get ( i ) ; if ( part . equalsIgnoreCase ( listPart ) ) { skip = true ; } } if ( ! skip ) { stopSkip = true ; startRestoreDataContext ( part ) ; } } if ( stopSkip ) { parent . getCurrent ( ) . setCurrentDataContextName ( fullName ) ; } return ; }", "nl": "Restore data context ."}}
{"translation": {"code": "public final void recover ( final Sheet sheet ) { for ( Map . Entry < Integer , List < SerialRow > > entry : this . getRowsMap ( ) . entrySet ( ) ) { List < SerialRow > listRow = entry . getValue ( ) ; for ( SerialRow serialRow : listRow ) { serialRow . recover ( sheet ) ; } } }", "nl": "recover rows mapping by using it s address ."}}
{"translation": {"code": "private CollectionObject startRestoreDataContext ( final String part ) { if ( part . startsWith ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX ) ) { String [ ] varparts = part . split ( \"\\\\.\" ) ; CollectionObject collect = new CollectionObject ( ) ; collect . setEachCommand ( CommandUtility . getEachCommandFromPartsName ( parent . getCurrentSheetConfig ( ) . getCommandIndexMap ( ) , varparts ) ) ; collect . setLastCollection ( ConfigurationUtility . transformToCollectionObject ( parent . getExpEngine ( ) , collect . getEachCommand ( ) . getItems ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) ) ) ; collect . setLastCollectionIndex ( CommandUtility . prepareCollectionDataInContext ( varparts , collect . getLastCollection ( ) , parent . getSerialDataContext ( ) . getDataContext ( ) ) ) ; return collect ; } return null ; }", "nl": "Start restore data context ."}}
{"translation": {"code": "private ChartSeries buildChartSeriesInList ( final ThemesTable themeTable , final ChartObject ctObj , final Object ctObjSer , final int index ) { ChartSeries ctSer = new ChartSeries ( ) ; ctSer . setSeriesLabel ( new ParsedCell ( ctObj . getSeriesLabelFromCTSer ( ctObjSer ) ) ) ; ctSer . setSeriesColor ( ColorUtility . geColorFromSpPr ( index , ctObj . getShapePropertiesFromCTSer ( ctObjSer ) , themeTable , ctObj . isLineColor ( ) ) ) ; List < ParsedCell > cells = new ArrayList <> ( ) ; String fullRangeName = ( ctObj . getCTNumDataSourceFromCTSer ( ctObjSer ) ) . getNumRef ( ) . getF ( ) ; String sheetName = WebSheetUtility . getSheetNameFromFullCellRefName ( fullRangeName ) ; CellRangeAddress region = CellRangeAddress . valueOf ( WebSheetUtility . removeSheetNameFromFullCellRefName ( fullRangeName ) ) ; for ( int row = region . getFirstRow ( ) ; row <= region . getLastRow ( ) ; row ++ ) { for ( int col = region . getFirstColumn ( ) ; col <= region . getLastColumn ( ) ; col ++ ) { cells . add ( new ParsedCell ( sheetName , row , col ) ) ; } } ctSer . setValueList ( cells ) ; ctSer . setValueColorList ( getColorListFromDPTWithValueList ( ctObj . getDPtListFromCTSer ( ctObjSer ) , cells , themeTable , ctObj ) ) ; return ctSer ; }", "nl": "Builds the chart series in list ."}}
{"translation": {"code": "private void readObject ( final java . io . ObjectInputStream in ) throws IOException { try { in . defaultReadObject ( ) ; recover ( ) ; } catch ( EncryptedDocumentException | ClassNotFoundException e ) { LOG . log ( Level . SEVERE , \" error in readObject of serialWorkbook : \" + e . getLocalizedMessage ( ) , e ) ; } }", "nl": "load the bean from saving ."}}
{"translation": {"code": "private String getChartIdFromParent ( final XSSFChart chart , final String sheetName ) { if ( chart . getParent ( ) != null ) { for ( RelationPart rp : chart . getParent ( ) . getRelationParts ( ) ) { if ( rp . getDocumentPart ( ) == chart ) { return sheetName + \"!\" + rp . getRelationship ( ) . getId ( ) ; } } } return null ; }", "nl": "Gets the chart id from parent ."}}
{"translation": {"code": "private static boolean shouldContinue ( final char c , final ShouldContinueParameter para ) { if ( c == ' ' && ! para . isDecimalHit ( ) ) { para . setDecimalHit ( true ) ; if ( para . isCommaHit ( ) && para . getSinceLastComma ( ) != 3 ) { return false ; } return true ; } else if ( c == ' ' && ! para . isDecimalHit ( ) ) { if ( para . isCommaHit ( ) ) { if ( para . getSinceLastComma ( ) != 3 ) { return false ; } para . setSinceLastComma ( 0 ) ; } para . setCommaHit ( true ) ; return true ; } return false ; }", "nl": "Should continue ."}}
{"translation": {"code": "public static List < CellFormAttributes > findCellValidateAttributes ( final Map < String , List < CellFormAttributes > > validateMaps , final int originRowIndex , final Cell cell ) { String key = cell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( cell . getColumnIndex ( ) , originRowIndex ) ; return validateMaps . get ( key ) ; }", "nl": "Find cell validate attributes ."}}
{"translation": {"code": "public static void setupControlAttributes ( final int originRowIndex , final FacesCell fcell , final Cell poiCell , final SheetConfiguration sheetConfig , final CellAttributesMap cellAttributesMap ) { int rowIndex = originRowIndex ; if ( rowIndex < 0 ) { rowIndex = poiCell . getRowIndex ( ) ; } String skey = poiCell . getSheet ( ) . getSheetName ( ) + \"!\" + CellUtility . getCellIndexNumberKey ( poiCell . getColumnIndex ( ) , rowIndex ) ; Map < String , String > commentMap = cellAttributesMap . getTemplateCommentMap ( ) . get ( \"$$\" ) ; if ( commentMap != null ) { String comment = commentMap . get ( skey ) ; if ( comment != null ) { CommandUtility . createCellComment ( poiCell , comment , sheetConfig . getFinalCommentMap ( ) ) ; } } String widgetType = cellAttributesMap . getCellInputType ( ) . get ( skey ) ; if ( widgetType != null ) { fcell . setControl ( widgetType . toLowerCase ( ) ) ; fcell . setInputAttrs ( cellAttributesMap . getCellInputAttributes ( ) . get ( skey ) ) ; fcell . setSelectItemAttrs ( cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( skey ) ) ; fcell . setDatePattern ( cellAttributesMap . getCellDatePattern ( ) . get ( skey ) ) ; } }", "nl": "Setup control attributes ."}}
{"translation": {"code": "private static void processCalendarAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { cellAttributesMap . getCellDatePattern ( ) . put ( key , sAttr . defaultDatePattern ) ; }", "nl": "Process calendar attributes ."}}
{"translation": {"code": "@ Override public final void processEvent ( final SystemEvent event ) { LOGGER . log ( Level . INFO , \"Running on TieFaces {0}\" , AppUtils . getBuildVersion ( ) ) ; }", "nl": "process event ."}}
{"translation": {"code": "private static void processSelectItemAttributes ( final String key , final CellAttributesMap cellAttributesMap , final SpecialAttributes sAttr ) { if ( ( sAttr . selectValues == null ) || ( sAttr . selectValues . length != sAttr . selectLabels . length ) ) { sAttr . selectValues = sAttr . selectLabels ; } Map < String , String > smap = cellAttributesMap . getCellSelectItemsAttributes ( ) . get ( key ) ; if ( smap == null ) { smap = new LinkedHashMap <> ( ) ; } smap . clear ( ) ; if ( sAttr . defaultSelectLabel != null ) { smap . put ( sAttr . defaultSelectLabel , sAttr . defaultSelectValue ) ; } for ( int i = 0 ; i < sAttr . selectLabels . length ; i ++ ) { smap . put ( sAttr . selectLabels [ i ] , sAttr . selectValues [ i ] ) ; } cellAttributesMap . getCellSelectItemsAttributes ( ) . put ( key , smap ) ; }", "nl": "Process select item attributes ."}}
{"translation": {"code": "public final CollectionObject getLastCollect ( final String fullName ) { String [ ] parts = fullName . split ( \":\" ) ; String part = parts [ parts . length - 1 ] ; return startRestoreDataContext ( part ) ; }", "nl": "Get last collect object from full name ."}}
{"translation": {"code": "private static void initXSSFAnchorsMapForSheet ( final Map < String , ClientAnchor > anchortMap , final Map < String , String > positionMap , final XSSFSheet sheet ) { XSSFDrawing drawing = sheet . createDrawingPatriarch ( ) ; CTDrawing ctDrawing = drawing . getCTDrawing ( ) ; if ( ctDrawing . sizeOfTwoCellAnchorArray ( ) <= 0 ) { return ; } List < CTTwoCellAnchor > alist = ctDrawing . getTwoCellAnchorList ( ) ; for ( int j = 0 ; j < alist . size ( ) ; j ++ ) { CTTwoCellAnchor ctanchor = alist . get ( j ) ; String singleChartId = getAnchorAssociateChartId ( ctanchor ) ; if ( singleChartId != null ) { String chartId = sheet . getSheetName ( ) + \"!\" + singleChartId ; int dx1 = ( int ) ctanchor . getFrom ( ) . getColOff ( ) ; int dy1 = ( int ) ctanchor . getFrom ( ) . getRowOff ( ) ; int dx2 = ( int ) ctanchor . getTo ( ) . getColOff ( ) ; int dy2 = ( int ) ctanchor . getTo ( ) . getRowOff ( ) ; int col1 = ctanchor . getFrom ( ) . getCol ( ) ; int row1 = ctanchor . getFrom ( ) . getRow ( ) ; int col2 = ctanchor . getTo ( ) . getCol ( ) ; int row2 = ctanchor . getTo ( ) . getRow ( ) ; anchortMap . put ( chartId , new XSSFClientAnchor ( dx1 , dy1 , dx2 , dy2 , col1 , row1 , col2 , row2 ) ) ; positionMap . put ( WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , row1 , col1 ) , chartId ) ; } } }", "nl": "Inits the XSSF anchors map for sheet ."}}
{"translation": {"code": "public static void initXSSFAnchorsMap ( final XSSFWorkbook wb , final ChartsData charsData ) { Map < String , ClientAnchor > anchortMap = charsData . getChartAnchorsMap ( ) ; Map < String , String > positionMap = charsData . getChartPositionMap ( ) ; anchortMap . clear ( ) ; positionMap . clear ( ) ; for ( int i = 0 ; i < wb . getNumberOfSheets ( ) ; i ++ ) { initXSSFAnchorsMapForSheet ( anchortMap , positionMap , wb . getSheetAt ( i ) ) ; } }", "nl": "retrieve anchor information from draw . xml for all the charts in the workbook . then save them to anchors map ."}}
{"translation": {"code": "public static void setUpChartData ( final ChartData chartData , final CTChart ctChart , final ThemesTable themeTable , final ChartObject ctObj ) { Object chartObj = null ; @ SuppressWarnings ( \"rawtypes\" ) List plotCharts = ctObj . getChartListFromCtChart ( ctChart ) ; // chart object\r if ( plotCharts != null && ( ! plotCharts . isEmpty ( ) ) ) { chartObj = plotCharts . get ( 0 ) ; } if ( chartObj != null ) { @ SuppressWarnings ( \"rawtypes\" ) List bsers = ctObj . getSerListFromCtObjChart ( chartObj ) ; if ( ! AppUtils . emptyList ( bsers ) ) { chartData . buildCategoryList ( ctObj . getCtAxDataSourceFromSerList ( bsers ) ) ; chartData . buildSeriesList ( bsers , themeTable , ctObj ) ; } } }", "nl": "build chartData for line chart . chartData include categoryList and seriesList which used for generate jfreechart ."}}
{"translation": {"code": "private static XColor findAutomaticFillColor ( final ThemesTable themeTable , final CTSolidColorFillProperties colorFill ) { // if there's no solidFill, then use automaticFill color\r if ( colorFill == null ) { return null ; } CTSchemeColor ctsColor = colorFill . getSchemeClr ( ) ; if ( ctsColor != null ) { return getXColorFromSchemeClr ( ctsColor , themeTable ) ; } else { CTSRgbColor ctrColor = colorFill . getSrgbClr ( ) ; if ( ctrColor != null ) { return getXColorFromRgbClr ( ctrColor ) ; } } return null ; }", "nl": "Find automatic fill color ."}}
{"translation": {"code": "public static BasicStroke toStroke ( final String style ) { BasicStroke result = null ; if ( style != null ) { float lineWidth = STROKE_DEFAULT_LINE_WIDTH ; float [ ] dash = { STROKE_DEFAULT_DASH_WIDTH } ; float [ ] dot = { lineWidth } ; if ( style . equalsIgnoreCase ( STYLE_LINE ) ) { result = new BasicStroke ( lineWidth ) ; } else if ( style . equalsIgnoreCase ( STYLE_DASH ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DASH , dash , STROKE_DEFAULT_DASHPHASE ) ; } else if ( style . equalsIgnoreCase ( STYLE_DOT ) ) { result = new BasicStroke ( lineWidth , BasicStroke . CAP_BUTT , BasicStroke . JOIN_MITER , STROKE_MITER_LIMIT_STYLE_DOT , dot , STROKE_DEFAULT_DASHPHASE ) ; } } return result ; }", "nl": "Convert style string to stroke object ."}}
{"translation": {"code": "public static ChartType getChartType ( final CTChart ctChart ) { CTPlotArea plotArea = ctChart . getPlotArea ( ) ; for ( ChartType chartType : ChartType . values ( ) ) { if ( chartType . isThisType ( plotArea ) ) { return chartType ; } } return null ; }", "nl": "return chart type from CTChart object ."}}
{"translation": {"code": "private static String getChartIdFromChildNodeAttributes ( final NamedNodeMap attrs ) { for ( int j = 0 ; j < attrs . getLength ( ) ; j ++ ) { Attr attribute = ( Attr ) attrs . item ( j ) ; if ( \"r:id\" . equalsIgnoreCase ( attribute . getName ( ) ) ) { return attribute . getValue ( ) ; } } return null ; }", "nl": "Gets the chart id from child node attributes ."}}
{"translation": {"code": "private static String getAnchorAssociateChartId ( final CTTwoCellAnchor ctanchor ) { if ( ctanchor . getGraphicFrame ( ) == null ) { return null ; } Node parentNode = ctanchor . getGraphicFrame ( ) . getGraphic ( ) . getGraphicData ( ) . getDomNode ( ) ; NodeList childNodes = parentNode . getChildNodes ( ) ; for ( int i = 0 ; i < childNodes . getLength ( ) ; i ++ ) { Node childNode = childNodes . item ( i ) ; if ( ( childNode != null ) && ( \"c:chart\" . equalsIgnoreCase ( childNode . getNodeName ( ) ) ) && ( childNode . hasAttributes ( ) ) ) { String rId = getChartIdFromChildNodeAttributes ( childNode . getAttributes ( ) ) ; if ( rId != null ) { return rId ; } } } return null ; }", "nl": "Gets the anchor associate chart id ."}}
{"translation": {"code": "public static ChartData initChartDataFromXSSFChart ( final String chartId , final XSSFChart chart , final XSSFWorkbook wb ) { ThemesTable themeTable = wb . getStylesSource ( ) . getTheme ( ) ; ChartData chartData = new ChartData ( ) ; XSSFRichTextString chartTitle = chart . getTitle ( ) ; if ( chartTitle != null ) { chartData . setTitle ( chartTitle . toString ( ) ) ; } CTChart ctChart = chart . getCTChart ( ) ; ChartType chartType = ChartUtility . getChartType ( ctChart ) ; if ( chartType == null ) { throw new IllegalChartException ( \"Unknown chart type\" ) ; } chartData . setBgColor ( ColorUtility . getBgColor ( ctChart . getPlotArea ( ) , themeTable ) ) ; chartData . setId ( chartId ) ; chartData . setType ( chartType ) ; List < CTCatAx > ctCatAxList = ctChart . getPlotArea ( ) . getCatAxList ( ) ; if ( ( ctCatAxList != null ) && ( ! ctCatAxList . isEmpty ( ) ) ) { chartData . setCatAx ( new ChartAxis ( ctCatAxList . get ( 0 ) ) ) ; } List < CTValAx > ctValAxList = ctChart . getPlotArea ( ) . getValAxList ( ) ; if ( ( ctValAxList != null ) && ( ! ctValAxList . isEmpty ( ) ) ) { chartData . setValAx ( new ChartAxis ( ctValAxList . get ( 0 ) ) ) ; } ChartObject ctObj = chartType . createChartObject ( ) ; if ( ctObj == null ) { throw new IllegalChartException ( \"Cannot create chart object.\" ) ; } setUpChartData ( chartData , ctChart , themeTable , ctObj ) ; return chartData ; }", "nl": "init chart data ."}}
{"translation": {"code": "public static AnchorSize getAnchorSize ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final ClientAnchor anchor ) { if ( ! ( sheet1 instanceof XSSFSheet ) ) { return null ; } double picWidth = 0.0 ; double picHeight = 0.0 ; int left = anchor . getDx1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; int top = ( int ) ( ( double ) anchor . getDy1 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; int right = anchor . getDx2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL ; int bottom = ( int ) ( ( double ) anchor . getDy2 ( ) / org . apache . poi . util . Units . EMU_PER_PIXEL / WebSheetUtility . PICTURE_HEIGHT_ADJUST ) ; double cellWidth = 0.0 ; double cellHeight = 0.0 ; if ( ( cell != null ) && ( fcell != null ) ) { for ( int col = cell . getColumnIndex ( ) ; col < cell . getColumnIndex ( ) + fcell . getColspan ( ) ; col ++ ) { cellWidth += sheet1 . getColumnWidthInPixels ( col ) ; } double lastCellWidth = sheet1 . getColumnWidthInPixels ( cell . getColumnIndex ( ) + fcell . getColspan ( ) - 1 ) ; for ( int rowIndex = cell . getRowIndex ( ) ; rowIndex < cell . getRowIndex ( ) + fcell . getRowspan ( ) ; rowIndex ++ ) { cellHeight += WebSheetUtility . pointsToPixels ( sheet1 . getRow ( rowIndex ) . getHeightInPoints ( ) ) ; } double lastCellHeight = WebSheetUtility . pointsToPixels ( sheet1 . getRow ( cell . getRowIndex ( ) + fcell . getRowspan ( ) - 1 ) . getHeightInPoints ( ) ) ; picWidth = cellWidth - lastCellWidth + right - left ; picHeight = cellHeight - lastCellHeight + bottom - top ; } else { for ( short col = anchor . getCol1 ( ) ; col < anchor . getCol2 ( ) ; col ++ ) { picWidth += sheet1 . getColumnWidthInPixels ( col ) ; } for ( int rowindex = anchor . getRow1 ( ) ; rowindex < anchor . getRow2 ( ) ; rowindex ++ ) { Row row = sheet1 . getRow ( rowindex ) ; if ( row != null ) { picHeight += WebSheetUtility . pointsToPixels ( row . getHeightInPoints ( ) ) ; } } } return new AnchorSize ( left , top , ( int ) picWidth , ( int ) picHeight , cellWidth , cellHeight ) ; }", "nl": "Gets the anchor size ."}}
{"translation": {"code": "public static String generateChartStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final String chartId , final Map < String , ClientAnchor > anchorsMap ) { ClientAnchor anchor = anchorsMap . get ( chartId ) ; if ( anchor != null ) { AnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; if ( anchorSize != null ) { return \"MARGIN-LEFT:\" + String . format ( \"%.2f\" , anchorSize . getPercentLeft ( ) ) + \"%;MARGIN-TOP:\" + String . format ( \"%.2f\" , anchorSize . getPercentTop ( ) ) + \"%;width:\" + String . format ( \"%.2f\" , anchorSize . getPercentWidth ( ) ) + \"%;height:135%;\" ; } } return \"\" ; }", "nl": "Generate chart style ."}}
{"translation": {"code": "public static String generatePictureStyle ( final Sheet sheet1 , final FacesCell fcell , final Cell cell , final Picture pic ) { ClientAnchor anchor = pic . getClientAnchor ( ) ; if ( anchor != null ) { AnchorSize anchorSize = getAnchorSize ( sheet1 , fcell , cell , anchor ) ; if ( anchorSize != null ) { return \"MARGIN-LEFT:\" + String . format ( \"%.2f\" , anchorSize . getPercentLeft ( ) ) + \"%;MARGIN-TOP:\" + String . format ( \"%.2f\" , anchorSize . getPercentTop ( ) ) + \"%;width:\" + String . format ( \"%.2f\" , anchorSize . getPercentWidth ( ) ) + \"%;\" ; } } return \"\" ; }", "nl": "Generate picture style ."}}
{"translation": {"code": "private static void indexPictureInMap ( final Map < String , Picture > picMap , final XSSFSheet sheet , final POIXMLDocumentPart dr ) { if ( dr instanceof XSSFDrawing ) { XSSFDrawing drawing = ( XSSFDrawing ) dr ; List < XSSFShape > shapes = drawing . getShapes ( ) ; for ( XSSFShape shape : shapes ) { if ( shape instanceof XSSFPicture ) { XSSFPicture pic = ( XSSFPicture ) shape ; XSSFClientAnchor anchor = pic . getPreferredSize ( ) ; CTMarker ctMarker = anchor . getFrom ( ) ; String picIndex = WebSheetUtility . getFullCellRefName ( sheet . getSheetName ( ) , ctMarker . getRow ( ) , ctMarker . getCol ( ) ) ; picMap . put ( picIndex , pic ) ; } } } }", "nl": "save pciture in map with index ."}}
{"translation": {"code": "private static void getXSSFPictruesMap ( final XSSFWorkbook wb , final Map < String , Picture > picMap ) { picMap . clear ( ) ; List < XSSFPictureData > pictures = wb . getAllPictures ( ) ; if ( pictures . isEmpty ( ) ) { return ; } for ( int i = 0 ; i < wb . getNumberOfSheets ( ) ; i ++ ) { XSSFSheet sheet = wb . getSheetAt ( i ) ; for ( POIXMLDocumentPart dr : sheet . getRelations ( ) ) { try { indexPictureInMap ( picMap , sheet , dr ) ; } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"Load Picture error = \" + ex . getLocalizedMessage ( ) , ex ) ; } } } return ; }", "nl": "Gets the XSSF pictrues map ."}}
{"translation": {"code": "public static void getPictruesMap ( final Workbook wb , final Map < String , Picture > picMap ) { if ( wb instanceof XSSFWorkbook ) { getXSSFPictruesMap ( ( XSSFWorkbook ) wb , picMap ) ; } return ; }", "nl": "Gets the pictrues map ."}}
{"translation": {"code": "private FormCommand buildFormCommandFromSheetConfig ( final SheetConfiguration sheetConfig , final Sheet sheet ) { int firstRow = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; int leftCol = sheetConfig . getBodyCellRange ( ) . getLeftCol ( ) ; int rightCol = sheetConfig . getBodyCellRange ( ) . getRightCol ( ) ; int lastRow = sheetConfig . getBodyCellRange ( ) . getBottomRow ( ) ; Cell firstCell = sheet . getRow ( firstRow ) . getCell ( leftCol , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; FormCommand fcommand = new FormCommand ( ) ; fcommand . setCommandTypeName ( TieConstants . COMMAND_FORM ) ; if ( sheetConfig . isHidden ( ) ) { fcommand . setHidden ( TieConstants . TRUE_STRING ) ; } else { fcommand . setHidden ( TieConstants . FALSE_STRING ) ; } fcommand . setName ( sheetConfig . getFormName ( ) ) ; fcommand . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; fcommand . getConfigRange ( ) . setLastRowPlusRef ( sheet , rightCol , lastRow , true ) ; fcommand . setHeaderLength ( \"0\" ) ; fcommand . setFooterLength ( \"0\" ) ; fcommand . setLength ( Integer . toString ( lastRow - firstRow + 1 ) ) ; return fcommand ; }", "nl": "Builds the form command from sheet config ."}}
{"translation": {"code": "public final Map < String , SheetConfiguration > buildConfiguration ( ) { Map < String , SheetConfiguration > sheetConfigMap = new LinkedHashMap <> ( ) ; // in buildsheet, it's possible to add sheets in workbook.\r // so cache the sheetname first here.\r List < String > sheetNames = new ArrayList <> ( ) ; String sname ; for ( int i = 0 ; i < parent . getWb ( ) . getNumberOfSheets ( ) ; i ++ ) { sname = parent . getWb ( ) . getSheetName ( i ) ; if ( ! sname . startsWith ( org . tiefaces . common . TieConstants . COPY_SHEET_PREFIX ) ) { sheetNames . add ( sname ) ; } } for ( String sheetName : sheetNames ) { Sheet sheet = parent . getWb ( ) . getSheet ( sheetName ) ; ConfigurationUtility . buildSheetCommentFromAlias ( sheet , parent . getTieCommandAliasList ( ) ) ; buildSheet ( sheet , sheetConfigMap , parent . getCellAttributesMap ( ) ) ; } return sheetConfigMap ; }", "nl": "Builds the configuration ."}}
{"translation": {"code": "public static String getFullNameFromRow ( final Row row ) { if ( row != null ) { Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; if ( cell != null ) { return cell . getStringCellValue ( ) ; } } return null ; }", "nl": "Gets the full name from row ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public static Collection transformToCollectionObject ( final ExpressionEngine engine , final String collectionName , final Map < String , Object > context ) { Object collectionObject = engine . evaluate ( collectionName , context ) ; if ( ! ( collectionObject instanceof Collection ) ) { throw new EvaluationException ( collectionName + \" expression is not a collection\" ) ; } return ( Collection ) collectionObject ; }", "nl": "Transform to collection object ."}}
{"translation": {"code": "private SheetConfiguration getSheetConfiguration ( final Sheet sheet , final String formName , final int sheetRightCol ) { SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; sheetConfig . setFormName ( formName ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; int leftCol = sheet . getLeftCol ( ) ; int lastRow = sheet . getLastRowNum ( ) ; int firstRow = sheet . getFirstRowNum ( ) ; int rightCol = 0 ; int maxRow = 0 ; for ( Row row : sheet ) { if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { break ; } maxRow = row . getRowNum ( ) ; int firstCellNum = row . getFirstCellNum ( ) ; if ( firstCellNum >= 0 && firstCellNum < leftCol ) { leftCol = firstCellNum ; } if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { int verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; if ( verifiedcol > rightCol ) { rightCol = verifiedcol ; } } } if ( maxRow < lastRow ) { lastRow = maxRow ; } // header range row set to 0 while column set to first column to\r // max\r // column (FF) e.g. $A$0 : $FF$0\r String tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0 : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + \"0\" ; sheetConfig . setFormHeaderRange ( tempStr ) ; sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; // body range row set to first row to last row while column set\r // to\r // first column to max column (FF) e.g. $A$1 : $FF$1000\r tempStr = TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( leftCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( firstRow + 1 ) + \" : \" + TieConstants . CELL_ADDR_PRE_FIX + WebSheetUtility . getExcelColumnName ( rightCol ) + TieConstants . CELL_ADDR_PRE_FIX + ( lastRow + 1 ) ; sheetConfig . setFormBodyRange ( tempStr ) ; sheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; sheetConfig . setFormBodyType ( org . tiefaces . common . TieConstants . FORM_TYPE_FREE ) ; sheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; // check it's a hidden sheet\r int sheetIndex = parent . getWb ( ) . getSheetIndex ( sheet ) ; if ( parent . getWb ( ) . isSheetHidden ( sheetIndex ) || parent . getWb ( ) . isSheetVeryHidden ( sheetIndex ) ) { sheetConfig . setHidden ( true ) ; } return sheetConfig ; }", "nl": "Gets the sheet configuration ."}}
{"translation": {"code": "private static void addSkipCellToListInTheRegion ( final List < String > skipCellList , final CellRangeAddress caddress ) { for ( int col = caddress . getFirstColumn ( ) ; col <= caddress . getLastColumn ( ) ; col ++ ) { for ( int row = caddress . getFirstRow ( ) ; row <= caddress . getLastRow ( ) ; row ++ ) { if ( ( col == caddress . getFirstColumn ( ) ) && ( row == caddress . getFirstRow ( ) ) ) { continue ; } skipCellList . add ( CellUtility . getCellIndexNumberKey ( col , row ) ) ; } } }", "nl": "Add skipped cell into the list of a region ."}}
{"translation": {"code": "private void copyTemplateForTieCommands ( final Sheet sheet ) { // if skip configuration. then return.\r if ( parent . isSkipConfiguration ( ) ) { return ; } Workbook wb = sheet . getWorkbook ( ) ; String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; if ( wb . getSheet ( copyName ) == null ) { Sheet newSheet = wb . cloneSheet ( wb . getSheetIndex ( sheet ) ) ; int sheetIndex = wb . getSheetIndex ( newSheet ) ; wb . setSheetName ( sheetIndex , copyName ) ; wb . setSheetHidden ( sheetIndex , Workbook . SHEET_STATE_VERY_HIDDEN ) ; } }", "nl": "Copy the each command area to seperated sheet . As it will be used for iteration ."}}
{"translation": {"code": "public static Map < String , CellRangeAddress > indexMergedRegion ( final Sheet sheet1 ) { int numRegions = sheet1 . getNumMergedRegions ( ) ; Map < String , CellRangeAddress > cellRangeMap = new HashMap <> ( ) ; for ( int i = 0 ; i < numRegions ; i ++ ) { CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; if ( caddress != null ) { cellRangeMap . put ( CellUtility . getCellIndexNumberKey ( caddress . getFirstColumn ( ) , caddress . getFirstRow ( ) ) , caddress ) ; } } return cellRangeMap ; }", "nl": "Index merged region ."}}
{"translation": {"code": "public static void changeIndexNumberInShiftMap ( final Map < String , ConfigRangeAttrs > shiftMap , final Map < String , String > changeMap ) { for ( Map . Entry < String , String > entry : changeMap . entrySet ( ) ) { String key = entry . getKey ( ) ; String newKey = entry . getValue ( ) ; ConfigRangeAttrs attrs = shiftMap . get ( key ) ; if ( attrs != null ) { shiftMap . remove ( key ) ; shiftMap . put ( newKey , attrs ) ; } } }", "nl": "Increase index number in shift map ."}}
{"translation": {"code": "public static void changeUpperLevelFinalLength ( final Map < String , ConfigRangeAttrs > shiftMap , final String addedFullName , final int increasedLength ) { String [ ] parts = addedFullName . split ( \":\" ) ; StringBuilder fname = new StringBuilder ( ) ; for ( int i = 0 ; i < ( parts . length - 1 ) ; i ++ ) { if ( i == 0 ) { fname . append ( parts [ i ] ) ; } else { fname . append ( \":\" ) . append ( parts [ i ] ) ; } String sname = fname . toString ( ) ; shiftMap . get ( sname ) . setFinalLength ( shiftMap . get ( sname ) . getFinalLength ( ) + increasedLength ) ; } }", "nl": "Increase upper level final length ."}}
{"translation": {"code": "public static void changeIndexNumberInHiddenColumn ( final ConfigBuildRef configBuildRef , final int startRowIndex , final String fullName , final Map < String , String > changeMap , final int steps ) { String searchName = fullName . substring ( 0 , fullName . lastIndexOf ( ' ' ) + 1 ) ; Sheet sheet = configBuildRef . getSheet ( ) ; for ( int i = startRowIndex ; i <= sheet . getLastRowNum ( ) ; i ++ ) { Row row = sheet . getRow ( i ) ; String fname = getFullNameFromRow ( row ) ; if ( ( fname != null ) && ( fname . indexOf ( searchName ) >= 0 ) ) { int sindex = fname . indexOf ( searchName ) ; String snum = fname . substring ( sindex + searchName . length ( ) ) ; int sufindex = snum . indexOf ( ' ' ) ; String suffix = \"\" ; if ( sufindex > 0 ) { snum = snum . substring ( 0 , sufindex ) ; suffix = \":\" ; } int increaseNum = Integer . parseInt ( snum ) + steps ; String realFullName = fname . substring ( sindex ) ; String changeName = fname . replace ( searchName + snum + suffix , searchName + increaseNum + suffix ) ; if ( changeMap . get ( realFullName ) == null ) { changeMap . put ( realFullName , changeName . substring ( sindex ) ) ; } setFullNameInHiddenColumn ( row , changeName ) ; } else { return ; } } }", "nl": "Change index number in hidden column ."}}
{"translation": {"code": "public static void setFullNameInHiddenColumn ( final Row row , final String fullName ) { Cell cell = row . getCell ( TieConstants . HIDDEN_FULL_NAME_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; cell . setCellValue ( fullName ) ; }", "nl": "Sets the full name in hidden column ."}}
{"translation": {"code": "public static int getOriginalRowNumInHiddenColumn ( final Row row ) { if ( row != null ) { Cell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; String rowNum = cell . getStringCellValue ( ) ; try { if ( ( rowNum != null ) && ( ! rowNum . isEmpty ( ) ) && ( WebSheetUtility . isNumeric ( rowNum ) ) ) { return Integer . parseInt ( rowNum ) ; } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"getOriginalRowNumInHiddenColumn rowNum = \" + rowNum + \" error = \" + ex . getLocalizedMessage ( ) , ex ) ; } } return - 1 ; }", "nl": "Gets the original row num in hidden column ."}}
{"translation": {"code": "public static void setOriginalRowNumInHiddenColumn ( final Row row , final int rowNum ) { Cell cell = row . getCell ( TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; cell . setCellValue ( Integer . toString ( rowNum ) ) ; cell . setCellType ( CellType . STRING ) ; }", "nl": "Sets the original row num in hidden column ."}}
{"translation": {"code": "public static List < RowsMapping > findParentRowsMappingFromShiftMap ( final String [ ] parts , final Map < String , ConfigRangeAttrs > shiftMap ) { StringBuilder fullName = new StringBuilder ( ) ; List < RowsMapping > rowsMappingList = new ArrayList <> ( ) ; /**\r\n\t\t * skip first one and last one. first one is line no. last one is it's\r\n\t\t * self.\r\n\t\t */ for ( int i = 1 ; i < parts . length - 1 ; i ++ ) { String part = parts [ i ] ; if ( fullName . length ( ) == 0 ) { fullName . append ( part ) ; } else { fullName . append ( \":\" + part ) ; } if ( fullName . length ( ) > 0 ) { ConfigRangeAttrs rangeAttrs = shiftMap . get ( fullName . toString ( ) ) ; if ( rangeAttrs != null ) { rowsMappingList . add ( rangeAttrs . getUnitRowsMapping ( ) ) ; } } } return rowsMappingList ; }", "nl": "Find parent rows mapping from shift map ."}}
{"translation": {"code": "private static void setupUpperLevelFormula ( final Cell cell , final String originFormula , final String actionFullName , final Map < String , List < RowsMapping > > rowsMap , final ConfigBuildRef configBuildRef ) { String fullName = getFullNameFromRow ( cell . getRow ( ) ) ; // check wither it's upper level\r if ( actionFullName . startsWith ( fullName + \":\" ) ) { // get rows mapping for upper level row\r List < RowsMapping > currentRowsMappingList = rowsMap . get ( fullName ) ; if ( currentRowsMappingList == null ) { currentRowsMappingList = gatherRowsMappingByFullName ( configBuildRef , fullName ) ; rowsMap . put ( fullName , currentRowsMappingList ) ; } ShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef ( configBuildRef . getWatchList ( ) , currentRowsMappingList ) ; shiftFormulaRef . setFormulaChanged ( 0 ) ; buildCellFormulaForShiftedRows ( configBuildRef . getSheet ( ) , configBuildRef . getWbWrapper ( ) , shiftFormulaRef , cell , originFormula ) ; if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { configBuildRef . getCachedCells ( ) . put ( cell , originFormula ) ; } } }", "nl": "Setup upper level formula ."}}
{"translation": {"code": "public static void reBuildUpperLevelFormula ( final ConfigBuildRef configBuildRef , final String actionFullName ) { Map < Cell , String > cachedMap = configBuildRef . getCachedCells ( ) ; Map < String , List < RowsMapping > > rowsMap = new HashMap <> ( ) ; for ( Map . Entry < Cell , String > entry : cachedMap . entrySet ( ) ) { Cell cell = entry . getKey ( ) ; String originFormula = entry . getValue ( ) ; if ( originFormula != null ) { setupUpperLevelFormula ( cell , originFormula , actionFullName , rowsMap , configBuildRef ) ; } } }", "nl": "Re build upper level formula ."}}
{"translation": {"code": "public static List < RowsMapping > findChildRowsMappingFromShiftMap ( final String fullName , final NavigableMap < String , ConfigRangeAttrs > shiftMap ) { List < RowsMapping > rowsMappingList = new ArrayList <> ( ) ; NavigableMap < String , ConfigRangeAttrs > tailmap = shiftMap . tailMap ( fullName , false ) ; for ( Map . Entry < String , ConfigRangeAttrs > entry : tailmap . entrySet ( ) ) { String key = entry . getKey ( ) ; // check it's children\r if ( key . startsWith ( fullName ) ) { rowsMappingList . add ( entry . getValue ( ) . getUnitRowsMapping ( ) ) ; } else { break ; } } return rowsMappingList ; }", "nl": "Find child rows mapping from shift map ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public static Object findItemInCollection ( final Collection collection , final int index ) { if ( index >= 0 ) { if ( collection instanceof List ) { List list = ( List ) collection ; return list . get ( index ) ; } int i = 0 ; for ( Object object : collection ) { if ( i == index ) { return object ; } i ++ ; } } return null ; }", "nl": "Find item in collection ."}}
{"translation": {"code": "public static ConfigRange buildCurrentRange ( final ConfigRange sourceConfigRange , final Sheet sheet , final int insertPosition ) { ConfigRange current = new ConfigRange ( sourceConfigRange ) ; int shiftNum = insertPosition - sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; current . shiftRowRef ( sheet , shiftNum ) ; return current ; }", "nl": "Builds the current range ."}}
{"translation": {"code": "public static boolean isStaticRow ( final ConfigRange sourceConfigRange , final int rowIndex ) { if ( sourceConfigRange . getCommandList ( ) != null ) { for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) . size ( ) ; i ++ ) { Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; if ( ( rowIndex >= command . getConfigRange ( ) . getFirstRowAddr ( ) . getRow ( ) ) && ( rowIndex < ( command . getConfigRange ( ) . getLastRowPlusAddr ( ) . getRow ( ) ) ) ) { return false ; } } } return true ; }", "nl": "Whether the row is static . This only check rowIndex against original template ."}}
{"translation": {"code": "public static boolean isStaticRowRef ( final ConfigRange sourceConfigRange , final Row row ) { if ( sourceConfigRange . getCommandList ( ) != null ) { for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) . size ( ) ; i ++ ) { Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; int rowIndex = row . getRowNum ( ) ; if ( ( rowIndex >= command . getTopRow ( ) ) && ( rowIndex < ( command . getTopRow ( ) + command . getFinalLength ( ) ) ) ) { return false ; } } } return true ; }", "nl": "Whether the row is static . This check row after shifted ."}}
{"translation": {"code": "public static String replaceExpressionWithCellValue ( final String attrValue , final int rowIndex , final Sheet sheet ) { int ibegin = 0 ; int ifind ; int inameEnd ; String tempStr ; String findStr ; String replaceStr ; String returnStr = attrValue ; while ( ( ifind = attrValue . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , ibegin ) ) > 0 ) { inameEnd = ParserUtility . findFirstNonCellNamePosition ( attrValue , ifind ) ; if ( inameEnd > 0 ) { findStr = attrValue . substring ( ifind , inameEnd ) ; } else { findStr = attrValue . substring ( ifind ) ; } if ( findStr . indexOf ( TieConstants . CELL_ADDR_PRE_FIX , 1 ) < 0 ) { // only $A\r tempStr = findStr + TieConstants . CELL_ADDR_PRE_FIX + ( rowIndex + 1 ) ; } else { tempStr = findStr ; } replaceStr = CellUtility . getCellValueWithoutFormat ( WebSheetUtility . getCellByReference ( tempStr , sheet ) ) ; if ( replaceStr == null ) { replaceStr = \"\" ; } returnStr = attrValue . replace ( findStr , replaceStr ) ; ibegin = ifind + 1 ; } return returnStr ; }", "nl": "100 > = 80"}}
{"translation": {"code": "public static List < String > skippedRegionCells ( final Sheet sheet1 ) { int numRegions = sheet1 . getNumMergedRegions ( ) ; List < String > skipCellList = new ArrayList <> ( ) ; for ( int i = 0 ; i < numRegions ; i ++ ) { CellRangeAddress caddress = sheet1 . getMergedRegion ( i ) ; if ( caddress != null ) { addSkipCellToListInTheRegion ( skipCellList , caddress ) ; } } return skipCellList ; }", "nl": "Skipped region cells ."}}
{"translation": {"code": "private int verifyLastCell ( final Row row , final int stoppoint , final int sheetRightCol ) { int lastCol = sheetRightCol ; int col ; for ( col = lastCol ; col >= stoppoint ; col -- ) { Cell cell = row . getCell ( col ) ; if ( ( cell != null ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { break ; } } return col ; }", "nl": "check last column . if it s blank then treat it as null cell ."}}
{"translation": {"code": "private void setFooterOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { String tempStr ; if ( fcommand . calcFooterLength ( ) == 0 ) { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; } else { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + fcommand . calcBodyLength ( ) ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; } sheetConfig . setFormFooterRange ( tempStr ) ; sheetConfig . setFooterCellRange ( new CellRange ( tempStr ) ) ; }", "nl": "Sets the footer of sheet configuration ."}}
{"translation": {"code": "private List < ConfigCommand > buildCommandListFromSheetComment ( final XSSFSheet sheet , final int sheetRightCol , final CellAttributesMap cellAttributesMap ) { List < ConfigCommand > commandList = new ArrayList <> ( ) ; // if skip then return empty list.\r if ( parent . isSkipConfiguration ( ) ) { return commandList ; } Map < CellAddress , ? extends Comment > comments = null ; try { // due to a poi bug. null exception throwed if no comments in the\r // sheet.\r comments = sheet . getCellComments ( ) ; } catch ( Exception ex ) { LOG . log ( Level . FINE , \"Null exception throwed when no comment exists: \" + ex . getLocalizedMessage ( ) , ex ) ; } if ( comments == null ) { return commandList ; } // not sure the map is sorted. So use tree map to sort it.\r SortedSet < CellAddress > keys = new TreeSet <> ( comments . keySet ( ) ) ; // go through each comments\r // if found tie command then transfer it to list also remove from\r // comments.\r for ( CellAddress key : keys ) { Cell cell = sheet . getRow ( key . getRow ( ) ) . getCell ( key . getColumn ( ) , MissingCellPolicy . CREATE_NULL_AS_BLANK ) ; buildCommandList ( sheet , sheetRightCol , cell , commandList , cellAttributesMap ) ; } return commandList ; }", "nl": "build command list from comments . after transfer the comment to command remove it from comments ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"rawtypes\" , \"unchecked\" } ) private static String insertEmptyObjectInContext ( final String fullName , final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { if ( ! ( lastCollection instanceof List ) ) { throw new EvaluationException ( \"Collection must be list in order to insert/delete.\" ) ; } List collectionList = ( List ) lastCollection ; // the object must support empty constructor.\r Object currentObj = collectionList . get ( lastCollectionIndex ) ; Object insertObj ; try { insertObj = currentObj . getClass ( ) . newInstance ( ) ; collectionList . add ( lastCollectionIndex + 1 , insertObj ) ; dataContext . put ( eachCommand . getVar ( ) , insertObj ) ; return fullName . substring ( 0 , fullName . lastIndexOf ( ' ' ) + 1 ) + ( lastCollectionIndex + 1 ) ; } catch ( InstantiationException | IllegalAccessException e ) { throw new EvaluationException ( e ) ; } }", "nl": "Insert empty object in context ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"rawtypes\" } ) private static void deleteObjectInContext ( final Collection lastCollection , final EachCommand eachCommand , final int lastCollectionIndex , final Map < String , Object > dataContext ) { if ( ! ( lastCollection instanceof List ) ) { throw new EvaluationException ( eachCommand . getVar ( ) + TieConstants . EACH_COMMAND_INVALID_MSG ) ; } List collectionList = ( List ) lastCollection ; // the object must support empty constructor.\r collectionList . remove ( lastCollectionIndex ) ; dataContext . remove ( eachCommand . getVar ( ) ) ; }", "nl": "Delete object in context ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public static int prepareCollectionDataInContext ( final String [ ] varparts , final Collection collection , final Map < String , Object > dataContext ) { if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { int collectionIndex = Integer . parseInt ( varparts [ 2 ] ) ; Object obj = ConfigurationUtility . findItemInCollection ( collection , collectionIndex ) ; if ( obj != null ) { dataContext . put ( varparts [ 1 ] , obj ) ; return collectionIndex ; } } return - 1 ; }", "nl": "Prepare collection data in context ."}}
{"translation": {"code": "public static void indexCommandRange ( final ConfigRange sourceConfigRange , final Map < String , Command > indexMap ) { if ( sourceConfigRange . getCommandList ( ) != null ) { for ( int i = 0 ; i < sourceConfigRange . getCommandList ( ) . size ( ) ; i ++ ) { Command command = sourceConfigRange . getCommandList ( ) . get ( i ) ; indexMap . put ( command . getCommandName ( ) , command ) ; command . getConfigRange ( ) . indexCommandRange ( indexMap ) ; } } }", "nl": "Index command range ."}}
{"translation": {"code": "public static boolean isRowAllowAdd ( final Row row , final SheetConfiguration sheetConfig ) { String fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; if ( fullName != null ) { ConfigRangeAttrs attrs = sheetConfig . getShiftMap ( ) . get ( fullName ) ; if ( ( attrs != null ) && ( attrs . isAllowAdd ( ) ) && ( row . getRowNum ( ) == attrs . getFirstRowRef ( ) . getRowIndex ( ) ) ) { return true ; } } return false ; }", "nl": "Checks if is row allow add ."}}
{"translation": {"code": "public static void insertEachTemplate ( final ConfigRange sourceConfigRange , final ConfigBuildRef configBuildRef , final int index , final int insertPosition , final RowsMapping unitRowsMapping ) { int srcStartRow = sourceConfigRange . getFirstRowAddr ( ) . getRow ( ) ; int srcEndRow = sourceConfigRange . getLastRowPlusAddr ( ) . getRow ( ) - 1 ; Sheet sheet = configBuildRef . getSheet ( ) ; Workbook wb = sheet . getWorkbook ( ) ; // excel sheet name has limit 31 chars\r String copyName = TieConstants . COPY_SHEET_PREFIX + sheet . getSheetName ( ) ; if ( copyName . length ( ) > TieConstants . EXCEL_SHEET_NAME_LIMIT ) { copyName = copyName . substring ( 0 , TieConstants . EXCEL_SHEET_NAME_LIMIT ) ; } Sheet srcSheet = wb . getSheet ( copyName ) ; if ( index > 0 ) { CellUtility . copyRows ( srcSheet , sheet , srcStartRow , srcEndRow , insertPosition , false , true ) ; } for ( int rowIndex = srcStartRow ; rowIndex <= srcEndRow ; rowIndex ++ ) { if ( configBuildRef . getWatchList ( ) . contains ( rowIndex ) && ( ConfigurationUtility . isStaticRow ( sourceConfigRange , rowIndex ) ) ) { unitRowsMapping . addRow ( rowIndex , sheet . getRow ( insertPosition + rowIndex - srcStartRow ) ) ; } } }", "nl": "Insert each template ."}}
{"translation": {"code": "public static void evaluateNormalCells ( final Cell cell , final String strValue , final Map < String , Object > context , final ExpressionEngine engine ) { if ( strValue . contains ( TieConstants . METHOD_PREFIX ) ) { Object evaluationResult = evaluate ( strValue , context , engine ) ; if ( evaluationResult == null ) { evaluationResult = \"\" ; } CellUtility . setCellValue ( cell , evaluationResult . toString ( ) ) ; createTieCell ( cell , context , engine ) ; } }", "nl": "Evaluate normal cells ."}}
{"translation": {"code": "private static void evaluateUserFormula ( final Cell cell , final String strValue ) { String formulaStr = strValue . substring ( 2 , strValue . length ( ) - 1 ) ; if ( ( formulaStr != null ) && ( ! formulaStr . isEmpty ( ) ) ) { cell . setCellFormula ( formulaStr ) ; } }", "nl": "Evaluate user formula ."}}
{"translation": {"code": "private static boolean isUserFormula ( final String str ) { return str . startsWith ( TieConstants . USER_FORMULA_PREFIX ) && str . endsWith ( TieConstants . USER_FORMULA_SUFFIX ) ; }", "nl": "Checks if is user formula ."}}
{"translation": {"code": "public static void createCellComment ( final Cell cell , final String newComment , final Map < Cell , String > finalCommentMap ) { // due to poi's bug. the comment must be set in sorted order ( row first\r // then column),\r // otherwise poi will mess up.\r // workaround solution is to save all comments into a map,\r // and output them together when download workbook.\r if ( newComment != null ) { finalCommentMap . put ( cell , newComment ) ; } }", "nl": "Creates the cell comment ."}}
{"translation": {"code": "public static boolean evalBoolExpression ( final ExpressionEngine expEngine , final String pscript ) { Object result = null ; String script = \"( \" + pscript + \" )\" ; script = script . toUpperCase ( ) . replace ( \"AND\" , \"&&\" ) ; script = script . toUpperCase ( ) . replace ( \"OR\" , \"||\" ) ; try { result = expEngine . evaluate ( script ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , \"WebForm WebFormHelper evalBoolExpression script = \" + script + \"; error = \" + e . getLocalizedMessage ( ) , e ) ; } if ( result != null ) { return ( ( Boolean ) result ) . booleanValue ( ) ; } else { return false ; } }", "nl": "evaluate boolean express ."}}
{"translation": {"code": "public static void removeRowsInSheet ( final Sheet sheet , final int rowIndexStart , final int rowIndexEnd , final Map < Cell , String > cachedMap ) { for ( int irow = rowIndexStart ; irow <= rowIndexEnd ; irow ++ ) { removeCachedCellForRow ( sheet , irow , cachedMap ) ; } int irows = rowIndexEnd - rowIndexStart + 1 ; if ( ( irows < 1 ) || ( rowIndexStart < 0 ) ) { return ; } int lastRowNum = sheet . getLastRowNum ( ) ; if ( rowIndexEnd < lastRowNum ) { sheet . shiftRows ( rowIndexEnd + 1 , lastRowNum , - irows ) ; } if ( rowIndexEnd == lastRowNum ) { // reverse order to delete rows.\r for ( int i = rowIndexEnd ; i >= rowIndexStart ; i -- ) { removeSingleRowInSheet ( sheet , rowIndexStart ) ; } } }", "nl": "Remove the rows ."}}
{"translation": {"code": "private static void removeSingleRowInSheet ( final Sheet sheet , final int rowIndexStart ) { Row removingRow = sheet . getRow ( rowIndexStart ) ; if ( removingRow != null ) { sheet . removeRow ( removingRow ) ; } }", "nl": "Removes the single row in sheet ."}}
{"translation": {"code": "private static void removeCachedCellForRow ( final Sheet sheet , final int rowIndexStart , final Map < Cell , String > cachedMap ) { Row removingRow = sheet . getRow ( rowIndexStart ) ; if ( removingRow != null ) { // remove cached cell.\r for ( Cell cell : removingRow ) { cachedMap . remove ( cell ) ; } } }", "nl": "Removes the cached cell for row ."}}
{"translation": {"code": "public static void removeRowsInBody ( final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows , final int rowIndexStart , final int rowIndexEnd ) { int top = sheetConfig . getBodyCellRange ( ) . getTopRow ( ) ; if ( ( rowIndexEnd < rowIndexStart ) || ( rowIndexStart < top ) ) { return ; } int irows = rowIndexEnd - rowIndexStart + 1 ; for ( int rowIndex = rowIndexEnd ; rowIndex >= rowIndexStart ; rowIndex -- ) { bodyRows . remove ( rowIndex - top ) ; } for ( int irow = rowIndexStart - top ; irow < bodyRows . size ( ) ; irow ++ ) { FacesRow facesrow = bodyRows . get ( irow ) ; facesrow . setRowIndex ( facesrow . getRowIndex ( ) - irows ) ; } }", "nl": "Removes the rows in body ."}}
{"translation": {"code": "public static EachCommand getEachCommandFromPartsName ( final Map < String , Command > commandIndexMap , final String [ ] varparts ) { if ( varparts . length == TieConstants . DEFAULT_COMMAND_PART_LENGTH ) { return ( EachCommand ) commandIndexMap . get ( TieConstants . EACH_COMMAND_FULL_NAME_PREFIX + varparts [ 1 ] ) ; } return null ; }", "nl": "Gets the each command from parts name ."}}
{"translation": {"code": "public final void buildSheet ( final Sheet sheet , final Map < String , SheetConfiguration > sheetConfigMap , final CellAttributesMap cellAttributesMap ) { if ( ( sheet . getLastRowNum ( ) <= 0 ) && ( sheet . getRow ( 0 ) == null ) ) { // this is a empty sheet. skip it.\r return ; } checkAndRepairLastRow ( sheet ) ; int sheetRightCol = WebSheetUtility . getSheetRightCol ( sheet ) ; List < ConfigCommand > commandList = buildCommandListFromSheetComment ( ( XSSFSheet ) sheet , sheetRightCol , cellAttributesMap ) ; boolean hasEachCommand = hasEachCommandInTheList ( commandList ) ; List < String > formList = new ArrayList <> ( ) ; buildSheetConfigMapFromFormCommand ( sheet , sheetConfigMap , commandList , formList , sheetRightCol ) ; // match parent command\r matchParentCommand ( commandList ) ; // setup save attrs in hidden column in the sheet.\r // loop command list again to assemble other command list into sheet\r // configuration\r matchSheetConfigForm ( sheetConfigMap , commandList , formList ) ; initTemplateForCommand ( sheet , sheetConfigMap , formList , hasEachCommand ) ; }", "nl": "build a sheet for configuration map ."}}
{"translation": {"code": "public static void buildCellFormulaForShiftedRows ( final Sheet sheet , final XSSFEvaluationWorkbook wbWrapper , final ShiftFormulaRef shiftFormulaRef , final Cell cell , final String originFormula ) { // only shift when there's watchlist exist.\r if ( ( shiftFormulaRef . getWatchList ( ) != null ) && ( ! shiftFormulaRef . getWatchList ( ) . isEmpty ( ) ) ) { Ptg [ ] ptgs = FormulaParser . parse ( originFormula , wbWrapper , FormulaType . CELL , sheet . getWorkbook ( ) . getSheetIndex ( sheet ) ) ; Ptg [ ] convertedFormulaPtg = ShiftFormulaUtility . convertSharedFormulas ( ptgs , shiftFormulaRef ) ; if ( shiftFormulaRef . getFormulaChanged ( ) > 0 ) { // only change formula when indicator is true\r cell . setCellFormula ( FormulaRenderer . toFormulaString ( wbWrapper , convertedFormulaPtg ) ) ; } } }", "nl": "Builds the cell formula for shifted rows ."}}
{"translation": {"code": "private ConfigCommand createConfigCommand ( final Sheet sheet , final Cell firstCell , final int sheetRightCol , final String commandName , final Map < String , String > attrMap ) { @ SuppressWarnings ( \"rawtypes\" ) Class clas = commandMap . get ( commandName ) ; if ( clas == null ) { LOG . log ( Level . WARNING , \"Cannot find command class for {} \" , commandName ) ; return null ; } try { ConfigCommand command = ( ConfigCommand ) clas . newInstance ( ) ; command . setCommandTypeName ( commandName ) ; for ( Map . Entry < String , String > attr : attrMap . entrySet ( ) ) { WebSheetUtility . setObjectProperty ( command , attr . getKey ( ) , attr . getValue ( ) , true ) ; } command . getConfigRange ( ) . setFirstRowRef ( firstCell , true ) ; command . getConfigRange ( ) . setLastRowPlusRef ( sheet , sheetRightCol , command . getLastRow ( ) , true ) ; return command ; } catch ( Exception e ) { LOG . log ( Level . WARNING , \"Failed to initialize command class \" + clas . getName ( ) + \" for command\" + commandName , e ) ; return null ; } }", "nl": "create configuration command ."}}
{"translation": {"code": "private static List < String > findRemoveFullNameList ( final Sheet sheet , final int startRow , final int endRow ) { List < String > list = new ArrayList <> ( ) ; for ( int rowIndex = startRow ; rowIndex <= endRow ; rowIndex ++ ) { String fullName = ConfigurationUtility . getFullNameFromRow ( sheet . getRow ( rowIndex ) ) ; if ( ! list . contains ( fullName ) ) { list . add ( fullName ) ; } } return list ; }", "nl": "Find remove full name list ."}}
{"translation": {"code": "private static void removeRangesFromShiftMap ( final NavigableMap < String , ConfigRangeAttrs > shiftMap , final List < String > removeFullNameList ) { for ( String fname : removeFullNameList ) { shiftMap . remove ( fname ) ; } }", "nl": "Removes the ranges from shift map ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"rawtypes\" } ) public static int deleteRow ( final ConfigBuildRef configBuildRef , final int rowIndex , final Map < String , Object > dataContext , final SheetConfiguration sheetConfig , final List < FacesRow > bodyRows ) { String fullName = ConfigurationUtility . getFullNameFromRow ( configBuildRef . getSheet ( ) . getRow ( rowIndex ) ) ; configBuildRef . getCellHelper ( ) . restoreDataContext ( fullName ) ; CollectionObject collect = configBuildRef . getCellHelper ( ) . getLastCollect ( fullName ) ; Collection lastCollection = collect . getLastCollection ( ) ; int lastCollectionIndex = collect . getLastCollectionIndex ( ) ; EachCommand eachCommand = collect . getEachCommand ( ) ; if ( lastCollectionIndex < 0 ) { // no each command in the loop.\r throw new DeleteRowException ( \"No each command found.\" ) ; } if ( lastCollection . size ( ) <= 1 ) { // this is the last record and no parent left.\r throw new DeleteRowException ( \"Cannot delete the last record in the group.\" ) ; } CommandUtility . deleteObjectInContext ( lastCollection , eachCommand , lastCollectionIndex , dataContext ) ; // find range from shiftmap.\r ConfigRangeAttrs currentRangeAttrs = configBuildRef . getShiftMap ( ) . get ( fullName ) ; if ( currentRangeAttrs == null ) { throw new DeleteRowException ( \"Cannot find delete range.\" ) ; } // The lastRowRef is wrong in rangeAttrs. So use length to recalc it.\r int startRow = currentRangeAttrs . getFirstRowIndex ( ) ; int length = currentRangeAttrs . getFinalLength ( ) ; int endRow = startRow + length - 1 ; List < String > removeFullNameList = findRemoveFullNameList ( configBuildRef . getSheet ( ) , startRow , endRow ) ; // remove range from shiftmap.\r removeRangesFromShiftMap ( configBuildRef . getShiftMap ( ) , removeFullNameList ) ; // 1. remove ranged rows from sheet\r String var = eachCommand . getVar ( ) ; CommandUtility . removeRowsInSheet ( configBuildRef . getSheet ( ) , startRow , endRow , configBuildRef . getCachedCells ( ) ) ; // 2. reset FacesRow row index.\r CommandUtility . removeRowsInBody ( sheetConfig , bodyRows , startRow , endRow ) ; // 3. decrease index number in hidden column\r Map < String , String > changeMap = new TreeMap <> ( ) ; ConfigurationUtility . changeIndexNumberInHiddenColumn ( configBuildRef , startRow , fullName , changeMap , - 1 ) ; // 4. decrease index number in shift map\r ConfigurationUtility . changeIndexNumberInShiftMap ( configBuildRef . getShiftMap ( ) , changeMap ) ; // 5. rebuild upper level formula\r ConfigurationUtility . reBuildUpperLevelFormula ( configBuildRef , fullName ) ; // 6. decrease upper level final length\r ConfigurationUtility . changeUpperLevelFinalLength ( configBuildRef . getShiftMap ( ) , fullName , - length ) ; dataContext . remove ( var ) ; return length ; }", "nl": "Delete row ."}}
{"translation": {"code": "private void setHeaderOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int rightCol ) { String tempStr ; if ( fcommand . calcHeaderLength ( ) == 0 ) { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , 0 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , 0 ) ; } else { tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) ) ; } sheetConfig . setFormHeaderRange ( tempStr ) ; sheetConfig . setHeaderCellRange ( new CellRange ( tempStr ) ) ; }", "nl": "Sets the header of sheet configuration ."}}
{"translation": {"code": "private void setBodyOfSheetConfiguration ( final FormCommand fcommand , final SheetConfiguration sheetConfig , final int leftCol , final int lastRow , final int rightCol ) { String tempStr ; tempStr = CellUtility . getCellIndexLetterKey ( leftCol , fcommand . getTopRow ( ) + fcommand . calcHeaderLength ( ) + 1 ) + \" : \" + CellUtility . getCellIndexLetterKey ( rightCol , lastRow + 1 ) ; sheetConfig . setFormBodyRange ( tempStr ) ; sheetConfig . setBodyCellRange ( new CellRange ( tempStr ) ) ; sheetConfig . setFormBodyType ( TieConstants . FORM_TYPE_FREE ) ; sheetConfig . setCellFormAttributes ( new HashMap < String , List < CellFormAttributes > > ( ) ) ; }", "nl": "Sets the body of sheet configuration ."}}
{"translation": {"code": "public static List < RowsMapping > gatherRowsMappingByFullName ( final ConfigBuildRef configBuildRef , final String fullName ) { List < RowsMapping > list = new ArrayList <> ( ) ; Map < String , ConfigRangeAttrs > shiftMap = configBuildRef . getShiftMap ( ) ; for ( Map . Entry < String , ConfigRangeAttrs > entry : shiftMap . entrySet ( ) ) { String fname = entry . getKey ( ) ; if ( fname . startsWith ( fullName + \":\" ) || fname . equals ( fullName ) ) { ConfigRangeAttrs attrs = entry . getValue ( ) ; list . add ( attrs . getUnitRowsMapping ( ) ) ; } } return list ; }", "nl": "Gather rows mapping by full name ."}}
{"translation": {"code": "private SheetConfiguration getSheetConfigurationFromConfigCommand ( final Sheet sheet , final FormCommand fcommand , final int sheetRightCol ) { SheetConfiguration sheetConfig = new SheetConfiguration ( ) ; sheetConfig . setFormName ( fcommand . getName ( ) ) ; sheetConfig . setSheetName ( sheet . getSheetName ( ) ) ; int leftCol = fcommand . getLeftCol ( ) ; int lastRow = fcommand . getLastRow ( ) ; int rightCol = 0 ; int maxRow = 0 ; for ( Row row : sheet ) { if ( row . getRowNum ( ) > TieConstants . TIE_WEB_SHEET_MAX_ROWS ) { break ; } maxRow = row . getRowNum ( ) ; if ( ( row . getLastCellNum ( ) - 1 ) > rightCol ) { int verifiedcol = verifyLastCell ( row , rightCol , sheetRightCol ) ; if ( verifiedcol > rightCol ) { rightCol = verifiedcol ; } } } if ( maxRow < lastRow ) { lastRow = maxRow ; } // header range row set to 0 while column set to first column to\r // max\r // column (FF) e.g. $A$0 : $FF$0\r setHeaderOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; // body range row set to first row to last row while column set\r // to\r // first column to max column (FF) e.g. $A$1 : $FF$1000\r setBodyOfSheetConfiguration ( fcommand , sheetConfig , leftCol , lastRow , rightCol ) ; // footer range row set to 0 while column set to first column to\r // max\r // column (FF) e.g. $A$0 : $FF$0\r setFooterOfSheetConfiguration ( fcommand , sheetConfig , leftCol , rightCol ) ; String hidden = fcommand . getHidden ( ) ; if ( ( hidden != null ) && ( Boolean . parseBoolean ( hidden ) ) ) { sheetConfig . setHidden ( true ) ; } String fixedWidthStyle = fcommand . getFixedWidthStyle ( ) ; if ( ( fixedWidthStyle != null ) && ( Boolean . parseBoolean ( fixedWidthStyle ) ) ) { sheetConfig . setFixedWidthStyle ( true ) ; } sheetConfig . setFormCommand ( fcommand ) ; return sheetConfig ; }", "nl": "Create sheet configuration from form command ."}}
{"translation": {"code": "private Map < String , String > buildAttrMap ( final String commandLine , final int nameEndIndex ) { int paramsEndIndex = commandLine . lastIndexOf ( TieConstants . ATTR_SUFFIX ) ; if ( paramsEndIndex < 0 ) { String errMsg = \"Failed to parse command line [\" + commandLine + \"]. Expected '\" + TieConstants . ATTR_SUFFIX + \"' symbol.\" ; throw new IllegalArgumentException ( errMsg ) ; } String attrString = commandLine . substring ( nameEndIndex + 1 , paramsEndIndex ) . trim ( ) ; return ParserUtility . parseCommandAttributes ( attrString ) ; }", "nl": "Build the attributes map ."}}
{"translation": {"code": "private void setParentForChildCommand ( final List < ConfigCommand > commandList , final int i , final ConfigCommand child ) { int matchIndex = - 1 ; ConfigRange matchRange = null ; for ( int j = 0 ; j < commandList . size ( ) ; j ++ ) { if ( j != i ) { Command commandParent = commandList . get ( j ) ; if ( ! commandParent . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_FORM ) && WebSheetUtility . insideRange ( child . getConfigRange ( ) , commandParent . getConfigRange ( ) ) && ( ( matchRange == null ) || ( WebSheetUtility . insideRange ( commandParent . getConfigRange ( ) , matchRange ) ) ) ) { matchRange = commandParent . getConfigRange ( ) ; matchIndex = j ; } } } if ( matchIndex >= 0 ) { commandList . get ( matchIndex ) . getConfigRange ( ) . addCommand ( child ) ; child . setParentFound ( true ) ; } }", "nl": "Sets the parent for child command ."}}
{"translation": {"code": "private void moveCommentToMap ( final Cell cell , final String newComment , final Map < String , Map < String , String > > sheetCommentMap , final boolean normalComment ) { String cellKey = cell . getSheet ( ) . getSheetName ( ) + \"!$\" + cell . getColumnIndex ( ) + \"$\" + cell . getRowIndex ( ) ; ParserUtility . parseCommentToMap ( cellKey , newComment , sheetCommentMap , normalComment ) ; }", "nl": "change the comment ."}}
{"translation": {"code": "private void processCommandLine ( final Sheet sheet , final Cell cell , final String line , final List < ConfigCommand > cList , final int sheetRightCol ) { int nameEndIndex = line . indexOf ( TieConstants . ATTR_PREFIX , TieConstants . COMMAND_PREFIX . length ( ) ) ; if ( nameEndIndex < 0 ) { String errMsg = \"Failed to parse command line [\" + line + \"]. Expected '\" + TieConstants . ATTR_PREFIX + \"' symbol.\" ; LOG . severe ( errMsg ) ; throw new IllegalStateException ( errMsg ) ; } String commandName = line . substring ( TieConstants . COMMAND_PREFIX . length ( ) , nameEndIndex ) . trim ( ) ; Map < String , String > attrMap = buildAttrMap ( line , nameEndIndex ) ; ConfigCommand configCommand = createConfigCommand ( sheet , cell , sheetRightCol , commandName , attrMap ) ; if ( configCommand != null ) { cList . add ( configCommand ) ; } }", "nl": "Process command line ."}}
{"translation": {"code": "private void processMethodLine ( final Cell cell , final String line , final CellAttributesMap cellAttributesMap ) { if ( ParserUtility . isWidgetMethodString ( line ) ) { ParserUtility . parseWidgetAttributes ( cell , line , cellAttributesMap ) ; } else if ( ParserUtility . isValidateMethodString ( line ) ) { ParserUtility . parseValidateAttributes ( cell , line , cellAttributesMap ) ; } else { moveCommentToMap ( cell , line , cellAttributesMap . getTemplateCommentMap ( ) , false ) ; } }", "nl": "Process method line ."}}
{"translation": {"code": "private List < ConfigCommand > buildCommandList ( final Sheet sheet , final int sheetRightCol , final Cell cell , final List < ConfigCommand > cList , final CellAttributesMap cellAttributesMap ) { Comment comment = cell . getCellComment ( ) ; String text = comment . getString ( ) . getString ( ) ; String [ ] commentLines = text . split ( \"\\\\n\" ) ; StringBuilder newComment = new StringBuilder ( ) ; boolean changed = false ; for ( String commentLine : commentLines ) { String line = commentLine . trim ( ) ; if ( ParserUtility . isCommandString ( line ) ) { processCommandLine ( sheet , cell , line , cList , sheetRightCol ) ; changed = true ; } else if ( ParserUtility . isEmptyMethodString ( line ) || ParserUtility . isMethodString ( line ) ) { processMethodLine ( cell , line , cellAttributesMap ) ; changed = true ; } else { if ( newComment . length ( ) > 0 ) { newComment . append ( \"\\\\n\" + commentLine ) ; } else { newComment . append ( commentLine ) ; } } } if ( ! changed ) { moveCommentToMap ( cell , text , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; } else { // reset comment string if changed\r if ( newComment . length ( ) > 0 ) { moveCommentToMap ( cell , newComment . toString ( ) , cellAttributesMap . getTemplateCommentMap ( ) , true ) ; CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; RichTextString str = factory . createRichTextString ( newComment . toString ( ) ) ; comment . setString ( str ) ; } else { // remove cell comment if new comment become empty.\r cell . removeCellComment ( ) ; } } return cList ; }", "nl": "build command list from comment ."}}
{"translation": {"code": "private void matchCommandToSheetConfigForm ( final Map < String , SheetConfiguration > sheetConfigMap , final List < String > formList , final ConfigCommand command ) { for ( String formname : formList ) { SheetConfiguration sheetConfig = sheetConfigMap . get ( formname ) ; if ( WebSheetUtility . insideRange ( command . getConfigRange ( ) , sheetConfig . getFormCommand ( ) . getConfigRange ( ) ) ) { sheetConfig . getFormCommand ( ) . getConfigRange ( ) . addCommand ( command ) ; break ; } } }", "nl": "Match command to sheet config form ."}}
{"translation": {"code": "private boolean hasEachCommandInTheList ( final List < ConfigCommand > commandList ) { if ( commandList != null ) { for ( ConfigCommand command : commandList ) { if ( command . getCommandTypeName ( ) . equalsIgnoreCase ( TieConstants . COMMAND_EACH ) ) { return true ; } } } return false ; }", "nl": "check whether contain each command in the list ."}}