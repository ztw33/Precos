{"translation": {"code": "private static void deleteHiddenColumnsInRow ( final Row row ) { deleteCellFromRow ( row , TieConstants . HIDDEN_SAVE_OBJECTS_COLUMN ) ; deleteCellFromRow ( row , TieConstants . HIDDEN_ORIGIN_ROW_NUMBER_COLUMN ) ; deleteCellFromRow ( row , TieConstants . HIDDEN_FULL_NAME_COLUMN ) ; }", "nl": "Delete hidden columns in row ."}}
{"translation": {"code": "public static void cloneComment ( final Cell sourceCell , final Cell newCell ) { XSSFSheet sheet = ( XSSFSheet ) newCell . getSheet ( ) ; CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; Drawing drawing = sheet . createDrawingPatriarch ( ) ; XSSFComment sourceComment = ( XSSFComment ) sourceCell . getCellComment ( ) ; // Below code are from POI busy manual.\r // When the comment box is visible, have it show in a 1x3 space\r ClientAnchor anchor = createCommentAnchor ( newCell , factory ) ; // Create the comment and set the text+author\r Comment comment = drawing . createCellComment ( anchor ) ; RichTextString str = factory . createRichTextString ( sourceComment . getString ( ) . toString ( ) ) ; comment . setString ( str ) ; comment . setAuthor ( sourceComment . getAuthor ( ) ) ; // Assign the comment to the cell\r newCell . setCellComment ( comment ) ; comment . setColumn ( newCell . getColumnIndex ( ) ) ; comment . setRow ( newCell . getRowIndex ( ) ) ; // As POI doesn't has well support for comments,\r // So we have to use low level api to match the comments.\r matchCommentSettings ( newCell , sourceCell ) ; }", "nl": "clone existing comments into new cell comment ."}}
{"translation": {"code": "private final void checkAndRepairLastRow ( final Sheet sheet ) { // repair last row if it's inserted in the configuration generation\r Row lastrow = sheet . getRow ( sheet . getLastRowNum ( ) ) ; // if it's lastrow and all the cells are blank. then remove the lastrow.\r if ( lastrow != null ) { for ( Cell cell : lastrow ) { if ( ( cell . getCellTypeEnum ( ) != CellType . _NONE ) && ( cell . getCellTypeEnum ( ) != CellType . BLANK ) ) { return ; } } sheet . removeRow ( lastrow ) ; } }", "nl": "check and repair the sheet s lastrow . If the row is blank then remove it ."}}
{"translation": {"code": "private boolean checkErrorMessageFromObjectInContext ( final int formRow , final int formCol , final FacesCell cell , final Cell poiCell , final String value , final SheetConfiguration sheetConfig , boolean updateGui ) { @ SuppressWarnings ( \"unchecked\" ) HashMap < String , TieCell > tieCells = ( HashMap < String , TieCell > ) parent . getSerialDataContext ( ) . getDataContext ( ) . get ( \"tiecells\" ) ; if ( tieCells != null ) { TieCell tieCell = tieCells . get ( CellUtility . getSkeyFromPoiCell ( poiCell ) ) ; if ( tieCell != null && tieCell . getContextObject ( ) != null ) { String errorMethod = tieCell . getMethodStr ( ) + parent . getConfigAdvancedContext ( ) . getErrorSuffix ( ) ; String errorMessage = CellControlsUtility . getObjectPropertyValue ( tieCell . getContextObject ( ) , errorMethod , true ) ; if ( errorMessage != null && ! errorMessage . isEmpty ( ) ) { cell . setErrormsg ( errorMessage ) ; LOG . log ( Level . INFO , \"Validation failed for sheet {0} row {1} column {2} : {3}\" , new Object [ ] { poiCell . getSheet ( ) . getSheetName ( ) , poiCell . getRowIndex ( ) , poiCell . getColumnIndex ( ) , errorMessage } ) ; refreshAfterStatusChanged ( false , true , formRow , formCol , cell , updateGui ) ; return false ; } } } return true ; }", "nl": "Check error message from object in context ."}}
{"translation": {"code": "public String getDecimalSeparatorByDefaultLocale ( ) { final DecimalFormat nf = ( DecimalFormat ) DecimalFormat . getInstance ( getDefaultLocale ( ) ) ; return \"\" + nf . getDecimalFormatSymbols ( ) . getDecimalSeparator ( ) ; }", "nl": "Gets the decimal separator by default locale ."}}
{"translation": {"code": "private boolean validateByTieWebSheetValidationBean ( final Cell poiCell , final int topRow , final int leftCol , final FacesCell cell , final String value , boolean updateGui ) { if ( parent . getTieWebSheetValidationBean ( ) != null ) { String errormsg = null ; String fullName = ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) ; String saveAttr = SaveAttrsUtility . prepareContextAndAttrsForCell ( poiCell , fullName , parent . getCellHelper ( ) ) ; if ( saveAttr != null ) { int row = poiCell . getRowIndex ( ) ; int col = poiCell . getColumnIndex ( ) ; errormsg = parent . getTieWebSheetValidationBean ( ) . validate ( parent . getSerialDataContext ( ) . getDataContext ( ) , saveAttr , ConfigurationUtility . getFullNameFromRow ( poiCell . getRow ( ) ) , poiCell . getSheet ( ) . getSheetName ( ) , row , col , value ) ; if ( ( errormsg != null ) && ( ! errormsg . isEmpty ( ) ) ) { cell . setErrormsg ( errormsg ) ; refreshAfterStatusChanged ( false , true , row - topRow , col - leftCol , cell , updateGui ) ; return false ; } } } return true ; }", "nl": "Validate by tie web sheet validation bean ."}}
{"translation": {"code": "private static int findPairBracketPosition ( final String str , final int startPos ) { int bracketNum = 0 ; for ( int i = startPos ; i < str . length ( ) ; i ++ ) { char current = str . charAt ( i ) ; if ( current == TieConstants . EL_START_BRACKET ) { bracketNum ++ ; } else if ( current == TieConstants . EL_END ) { bracketNum -- ; if ( bracketNum <= 0 ) { return i ; } } } return - 1 ; }", "nl": "Find pair bracket position ."}}
{"translation": {"code": "public String getThousandSeparatorByDefaultLocale ( ) { final DecimalFormat nf = ( DecimalFormat ) DecimalFormat . getInstance ( getDefaultLocale ( ) ) ; return \"\" + nf . getDecimalFormatSymbols ( ) . getGroupingSeparator ( ) ; }", "nl": "Gets the thousand separator by default locale ."}}
{"translation": {"code": "public Pattern getPattern ( ) { if ( ( this . pattern == null ) && ( alias != null ) ) { this . pattern = Pattern . compile ( \"\\\\s*\" + ParserUtility . wildcardToRegex ( alias ) ) ; } return pattern ; }", "nl": "Gets the pattern ."}}
{"translation": {"code": "public static void createOrInsertComment ( final Cell cell , final String commentStr ) { XSSFSheet sheet = ( XSSFSheet ) cell . getSheet ( ) ; CreationHelper factory = sheet . getWorkbook ( ) . getCreationHelper ( ) ; Drawing drawing = sheet . createDrawingPatriarch ( ) ; Comment comment = cell . getCellComment ( ) ; String originStr = \"\" ; if ( comment == null ) { // Below code are from POI busy manual.\r // When the comment box is visible, have it show in a 1x3 space\r ClientAnchor anchor = createCommentAnchor ( cell , factory ) ; // Create the comment and set the text+author\r comment = drawing . createCellComment ( anchor ) ; } else { originStr = comment . getString ( ) . getString ( ) + \"\\n\" ; } originStr += commentStr ; RichTextString str = factory . createRichTextString ( originStr ) ; comment . setString ( str ) ; comment . setAuthor ( \"\" ) ; // Assign the comment to the cell\r cell . setCellComment ( comment ) ; comment . setColumn ( cell . getColumnIndex ( ) ) ; comment . setRow ( cell . getRowIndex ( ) ) ; }", "nl": "Creates the or insert comment ."}}
{"translation": {"code": "public static void refreshSheetRowFromContext ( final Map < String , Object > context , final String fullSaveAttr , final Row row , final ExpressionEngine engine ) { if ( ! fullSaveAttr . startsWith ( TieConstants . CELL_ADDR_PRE_FIX ) ) { return ; } int ipos = fullSaveAttr . indexOf ( ' ' ) ; if ( ipos > 0 ) { String columnIndex = fullSaveAttr . substring ( 1 , ipos ) ; String saveAttr = fullSaveAttr . substring ( ipos + 1 ) ; Cell cell = row . getCell ( Integer . parseInt ( columnIndex ) ) ; if ( cell . getCellTypeEnum ( ) != CellType . FORMULA ) { CommandUtility . evaluateNormalCells ( cell , TieConstants . METHOD_PREFIX + saveAttr + TieConstants . METHOD_END , context , engine ) ; } } }", "nl": "reload the data from context to websheet row ."}}
{"translation": {"code": "private void refreshDataForCell ( Row row , String fullSaveAttr ) { if ( fullSaveAttr != null ) { try { String fullName = ConfigurationUtility . getFullNameFromRow ( row ) ; if ( fullName != null ) { parent . getCellHelper ( ) . restoreDataContext ( fullName ) ; SaveAttrsUtility . refreshSheetRowFromContext ( parent . getSerialDataContext ( ) . getDataContext ( ) , fullSaveAttr , row , parent . getExpEngine ( ) ) ; } } catch ( Exception ex ) { LOG . log ( Level . SEVERE , \"refreshDataForCell with fullAaveAttr =\" + fullSaveAttr + \" error = \" + ex . getMessage ( ) , ex ) ; } } }", "nl": "refresh data for single cell ."}}
{"translation": {"code": "public static void buildSheetCommentFromAlias ( Sheet sheet , List < TieCommandAlias > tieCommandAliasList ) { if ( ( tieCommandAliasList == null ) || ( tieCommandAliasList . isEmpty ( ) ) ) { return ; } for ( Row row : sheet ) { for ( Cell cell : row ) { buildCellCommentFromalias ( tieCommandAliasList , cell ) ; } } }", "nl": "Build Sheet Comment From command alias ."}}
{"translation": {"code": "public static String removeCharsFromString ( String inputStr , int start , int end ) { StringBuilder sb = new StringBuilder ( inputStr ) ; sb . delete ( start , end ) ; //    \t if ((start > 0) && (inputStr.charAt(start - 1) ==' ')) {\r //    \t\t // if end with a space, then remove it as well.\r //    \t\t sb.deleteCharAt(start - 1);\r //    \t }\r return sb . toString ( ) ; }", "nl": "Removes the chars from string ."}}