{"translation": {"code": "public static void main ( final String [ ] args ) { loadPropertiesFiles ( args ) ; final ShutdownSignalBarrier barrier = new ShutdownSignalBarrier ( ) ; final MediaDriver . Context ctx = new MediaDriver . Context ( ) ; ctx . terminationHook ( barrier :: signal ) ; try ( MediaDriver ignore = MediaDriver . launch ( ctx ) ) { barrier . await ( ) ; System . out . println ( \"Shutdown Driver...\" ) ; } }", "nl": "Start Media Driver as a stand - alone process ."}}
{"translation": {"code": "public PublicationMessageFlyweight channel ( final String channel ) { lengthOfChannel = buffer . putStringAscii ( offset + CHANNEL_OFFSET , channel ) ; return this ; }", "nl": "Set the channel field in ASCII"}}
{"translation": {"code": "public ImageMessageFlyweight channel ( final String channel ) { lengthOfChannel = buffer . putStringAscii ( offset + CHANNEL_OFFSET , channel ) ; return this ; }", "nl": "Set the channel field as ASCII"}}
{"translation": {"code": "public String channel ( ) { final int length = buffer . getInt ( offset + CHANNEL_OFFSET ) ; lengthOfChannel = SIZE_OF_INT + length ; return buffer . getStringAscii ( offset + CHANNEL_OFFSET , length ) ; }", "nl": "Get the channel field as ASCII"}}
{"translation": {"code": "public static void checkTermLength ( final int termLength ) { if ( termLength < TERM_MIN_LENGTH ) { throw new IllegalStateException ( \"Term length less than min length of \" + TERM_MIN_LENGTH + \": length=\" + termLength ) ; } if ( termLength > TERM_MAX_LENGTH ) { throw new IllegalStateException ( \"Term length more than max length of \" + TERM_MAX_LENGTH + \": length=\" + termLength ) ; } if ( ! BitUtil . isPowerOfTwo ( termLength ) ) { throw new IllegalStateException ( \"Term length not a power of 2: length=\" + termLength ) ; } }", "nl": "Check that term length is valid and alignment is valid ."}}
{"translation": {"code": "public void close ( ) { CloseHelper . close ( sharedRunner ) ; CloseHelper . close ( sharedNetworkRunner ) ; CloseHelper . close ( receiverRunner ) ; CloseHelper . close ( senderRunner ) ; CloseHelper . close ( conductorRunner ) ; CloseHelper . close ( sharedInvoker ) ; if ( ctx . useWindowsHighResTimer ( ) && SystemUtil . osName ( ) . startsWith ( \"win\" ) ) { if ( ! wasHighResTimerEnabled ) { HighResolutionTimer . disable ( ) ; } } }", "nl": "Shutdown the media driver by stopping all threads and freeing resources ."}}
{"translation": {"code": "int insertPacket ( final int termId , final int termOffset , final UnsafeBuffer buffer , final int length , final int transportIndex , final InetSocketAddress srcAddress ) { final boolean isHeartbeat = DataHeaderFlyweight . isHeartbeat ( buffer , length ) ; final long packetPosition = computePosition ( termId , termOffset , positionBitsToShift , initialTermId ) ; final long proposedPosition = isHeartbeat ? packetPosition : packetPosition + length ; if ( ! isFlowControlUnderRun ( packetPosition ) && ! isFlowControlOverRun ( proposedPosition ) ) { trackConnection ( transportIndex , srcAddress , lastPacketTimestampNs ) ; if ( isHeartbeat ) { if ( DataHeaderFlyweight . isEndOfStream ( buffer ) && ! isEndOfStream && allEos ( transportIndex ) ) { LogBufferDescriptor . endOfStreamPosition ( rawLog . metaData ( ) , proposedPosition ) ; isEndOfStream = true ; } heartbeatsReceived . incrementOrdered ( ) ; } else { final UnsafeBuffer termBuffer = termBuffers [ indexByPosition ( packetPosition , positionBitsToShift ) ] ; TermRebuilder . insert ( termBuffer , termOffset , buffer , length ) ; } lastPacketTimestampNs = cachedNanoClock . nanoTime ( ) ; hwmPosition . proposeMaxOrdered ( proposedPosition ) ; } return length ; }", "nl": "Insert frame into term buffer ."}}
{"translation": {"code": "public void onNak ( final int termId , final int termOffset , final int length , final int termLength , final RetransmitSender retransmitSender ) { if ( ! isInvalid ( termOffset , termLength ) ) { if ( null == activeRetransmitsMap . get ( termId , termOffset ) && activeRetransmitsMap . size ( ) < MAX_RETRANSMITS_DEFAULT ) { final RetransmitAction action = assignRetransmitAction ( ) ; action . termId = termId ; action . termOffset = termOffset ; action . length = Math . min ( length , termLength - termOffset ) ; final long delay = delayGenerator . generateDelay ( ) ; if ( 0 == delay ) { retransmitSender . resend ( termId , termOffset , action . length ) ; action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; } else { action . delay ( delay , nanoClock . nanoTime ( ) ) ; } activeRetransmitsMap . put ( termId , termOffset , action ) ; } } }", "nl": "Called on reception of a NAK to start retransmits handling ."}}
{"translation": {"code": "public static UnsafeBuffer createDefaultHeader ( final int sessionId , final int streamId , final int termId ) { final UnsafeBuffer buffer = new UnsafeBuffer ( BufferUtil . allocateDirectAligned ( HEADER_LENGTH , CACHE_LINE_LENGTH ) ) ; buffer . putByte ( VERSION_FIELD_OFFSET , CURRENT_VERSION ) ; buffer . putByte ( FLAGS_FIELD_OFFSET , ( byte ) BEGIN_AND_END_FLAGS ) ; buffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_DATA , LITTLE_ENDIAN ) ; buffer . putInt ( SESSION_ID_FIELD_OFFSET , sessionId , LITTLE_ENDIAN ) ; buffer . putInt ( STREAM_ID_FIELD_OFFSET , streamId , LITTLE_ENDIAN ) ; buffer . putInt ( TERM_ID_FIELD_OFFSET , termId , LITTLE_ENDIAN ) ; buffer . putLong ( RESERVED_VALUE_OFFSET , DEFAULT_RESERVE_VALUE ) ; return buffer ; }", "nl": "Return an initialised default Data Frame Header ."}}
{"translation": {"code": "public void close ( ) { final MappedByteBuffer cncByteBuffer = this . cncByteBuffer ; this . cncByteBuffer = null ; IoUtil . unmap ( cncByteBuffer ) ; super . close ( ) ; }", "nl": "Clean up all resources that the client uses to communicate with the Media Driver ."}}
{"translation": {"code": "public void run ( ) { do { LockSupport . parkNanos ( parkNs ) ; final long currentTotalMessages = totalMessages ; final long currentTotalBytes = totalBytes ; final long currentTimestamp = System . nanoTime ( ) ; final long timeSpanNs = currentTimestamp - lastTimestamp ; final double messagesPerSec = ( ( currentTotalMessages - lastTotalMessages ) * ( double ) reportIntervalNs ) / ( double ) timeSpanNs ; final double bytesPerSec = ( ( currentTotalBytes - lastTotalBytes ) * ( double ) reportIntervalNs ) / ( double ) timeSpanNs ; reportingFunc . onReport ( messagesPerSec , bytesPerSec , currentTotalMessages , currentTotalBytes ) ; lastTotalBytes = currentTotalBytes ; lastTotalMessages = currentTotalMessages ; lastTimestamp = currentTimestamp ; } while ( ! halt ) ; }", "nl": "Run loop for the rate reporter"}}
{"translation": {"code": "@ SuppressWarnings ( \"unused\" ) public static void printError ( final String channel , final int streamId , final int sessionId , final String message , final HeaderFlyweight cause ) { System . out . println ( message ) ; }", "nl": "Generic error handler that just prints message to stdout ."}}
{"translation": {"code": "public static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { System . out . println ( String . format ( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\" , messagesPerSec , bytesPerSec , totalMessages , totalBytes / ( 1024 * 1024 ) ) ) ; }", "nl": "Print the rates to stdout"}}
{"translation": {"code": "public static int producerWindowLength ( final int termBufferLength , final int defaultTermWindowLength ) { int termWindowLength = termBufferLength / 2 ; if ( 0 != defaultTermWindowLength ) { termWindowLength = Math . min ( defaultTermWindowLength , termWindowLength ) ; } return termWindowLength ; }", "nl": "How far ahead a producer can get from a consumer position ."}}
{"translation": {"code": "public BufferBuilder append ( final DirectBuffer srcBuffer , final int srcOffset , final int length ) { ensureCapacity ( length ) ; buffer . putBytes ( limit , srcBuffer , srcOffset , length ) ; limit += length ; return this ; }", "nl": "Append a source buffer to the end of the internal buffer resizing the internal buffer as required ."}}
{"translation": {"code": "public InetSocketAddress receive ( final ByteBuffer buffer ) { buffer . clear ( ) ; InetSocketAddress address = null ; try { if ( receiveDatagramChannel . isOpen ( ) ) { address = ( InetSocketAddress ) receiveDatagramChannel . receive ( buffer ) ; } } catch ( final PortUnreachableException ignored ) { } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } return address ; }", "nl": "Receive a datagram from the media layer ."}}
{"translation": {"code": "public boolean isValidFrame ( final UnsafeBuffer buffer , final int length ) { boolean isFrameValid = true ; if ( frameVersion ( buffer , 0 ) != HeaderFlyweight . CURRENT_VERSION ) { isFrameValid = false ; invalidPackets . increment ( ) ; } else if ( length < HeaderFlyweight . MIN_HEADER_LENGTH ) { isFrameValid = false ; invalidPackets . increment ( ) ; } return isFrameValid ; }", "nl": "Is the received frame valid . This method will do some basic checks on the header and can be overridden in a subclass for further validation ."}}
{"translation": {"code": "public void close ( ) { if ( ! isClosed ) { isClosed = true ; try { if ( null != selectionKey ) { selectionKey . cancel ( ) ; } if ( null != transportPoller ) { transportPoller . cancelRead ( this ) ; transportPoller . selectNowWithoutProcessing ( ) ; } if ( null != sendDatagramChannel ) { sendDatagramChannel . close ( ) ; } if ( receiveDatagramChannel != sendDatagramChannel && null != receiveDatagramChannel ) { receiveDatagramChannel . close ( ) ; } if ( null != transportPoller ) { transportPoller . selectNowWithoutProcessing ( ) ; } } catch ( final IOException ex ) { errorLog . record ( ex ) ; } } }", "nl": "Close transport canceling any pending read operations and closing channel"}}
{"translation": {"code": "public void openDatagramChannel ( final AtomicCounter statusIndicator ) { try { sendDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; receiveDatagramChannel = sendDatagramChannel ; if ( udpChannel . isMulticast ( ) ) { if ( null != connectAddress ) { receiveDatagramChannel = DatagramChannel . open ( udpChannel . protocolFamily ( ) ) ; } receiveDatagramChannel . setOption ( StandardSocketOptions . SO_REUSEADDR , true ) ; receiveDatagramChannel . bind ( new InetSocketAddress ( endPointAddress . getPort ( ) ) ) ; receiveDatagramChannel . join ( endPointAddress . getAddress ( ) , udpChannel . localInterface ( ) ) ; sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_IF , udpChannel . localInterface ( ) ) ; if ( udpChannel . isHasMulticastTtl ( ) ) { sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , udpChannel . multicastTtl ( ) ) ; multicastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; } else if ( context . socketMulticastTtl ( ) != 0 ) { sendDatagramChannel . setOption ( StandardSocketOptions . IP_MULTICAST_TTL , context . socketMulticastTtl ( ) ) ; multicastTtl = sendDatagramChannel . getOption ( StandardSocketOptions . IP_MULTICAST_TTL ) ; } } else { sendDatagramChannel . bind ( bindAddress ) ; } if ( null != connectAddress ) { sendDatagramChannel . connect ( connectAddress ) ; } if ( 0 != context . socketSndbufLength ( ) ) { sendDatagramChannel . setOption ( SO_SNDBUF , context . socketSndbufLength ( ) ) ; } if ( 0 != context . socketRcvbufLength ( ) ) { receiveDatagramChannel . setOption ( SO_RCVBUF , context . socketRcvbufLength ( ) ) ; } sendDatagramChannel . configureBlocking ( false ) ; receiveDatagramChannel . configureBlocking ( false ) ; } catch ( final IOException ex ) { if ( null != statusIndicator ) { statusIndicator . setOrdered ( ChannelEndpointStatus . ERRORED ) ; } CloseHelper . quietClose ( sendDatagramChannel ) ; if ( receiveDatagramChannel != sendDatagramChannel ) { CloseHelper . quietClose ( receiveDatagramChannel ) ; } sendDatagramChannel = null ; receiveDatagramChannel = null ; throw new AeronException ( \"channel error - \" + ex . getMessage ( ) + \" (at \" + ex . getStackTrace ( ) [ 0 ] . toString ( ) + \"): \" + udpChannel . originalUriString ( ) , ex ) ; } }", "nl": "Create the underlying channel for reading and writing ."}}
{"translation": {"code": "public static int frameLengthVolatile ( final UnsafeBuffer buffer , final int termOffset ) { int frameLength = buffer . getIntVolatile ( termOffset ) ; if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { frameLength = Integer . reverseBytes ( frameLength ) ; } return frameLength ; }", "nl": "Get the length of a frame from the header as a volatile read ."}}
{"translation": {"code": "public static void frameLengthOrdered ( final UnsafeBuffer buffer , final int termOffset , final int frameLength ) { int length = frameLength ; if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { length = Integer . reverseBytes ( frameLength ) ; } buffer . putIntOrdered ( termOffset , length ) ; }", "nl": "Write the length header for a frame in a memory ordered fashion ."}}
{"translation": {"code": "public static void frameFlags ( final UnsafeBuffer buffer , final int termOffset , final byte flags ) { buffer . putByte ( flagsOffset ( termOffset ) , flags ) ; }", "nl": "Write the flags field for a frame ."}}
{"translation": {"code": "public static void frameType ( final UnsafeBuffer buffer , final int termOffset , final int type ) { buffer . putShort ( typeOffset ( termOffset ) , ( short ) type , LITTLE_ENDIAN ) ; }", "nl": "Write the type field for a frame ."}}
{"translation": {"code": "public static void frameTermOffset ( final UnsafeBuffer buffer , final int termOffset ) { buffer . putInt ( termOffsetOffset ( termOffset ) , termOffset , LITTLE_ENDIAN ) ; }", "nl": "Write the term offset field for a frame ."}}
{"translation": {"code": "final int updatePublisherLimit ( ) { int workCount = 0 ; final long senderPosition = this . senderPosition . getVolatile ( ) ; if ( hasReceivers || ( spiesSimulateConnection && spyPositions . length > 0 ) ) { long minConsumerPosition = senderPosition ; for ( final ReadablePosition spyPosition : spyPositions ) { minConsumerPosition = Math . min ( minConsumerPosition , spyPosition . getVolatile ( ) ) ; } final long proposedPublisherLimit = minConsumerPosition + termWindowLength ; if ( publisherLimit . proposeMaxOrdered ( proposedPublisherLimit ) ) { cleanBuffer ( proposedPublisherLimit ) ; workCount = 1 ; } } else if ( publisherLimit . get ( ) > senderPosition ) { publisherLimit . setOrdered ( senderPosition ) ; } return workCount ; }", "nl": "Update the publishers limit for flow control as part of the conductor duty cycle ."}}
{"translation": {"code": "public final void commit ( ) { int frameLength = buffer . capacity ( ) ; if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { frameLength = Integer . reverseBytes ( frameLength ) ; } buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; }", "nl": "Commit the message to the log buffer so that is it available to subscribers ."}}
{"translation": {"code": "public final void abort ( ) { int frameLength = buffer . capacity ( ) ; if ( ByteOrder . nativeOrder ( ) != LITTLE_ENDIAN ) { frameLength = Integer . reverseBytes ( frameLength ) ; } buffer . putShort ( TYPE_FIELD_OFFSET , ( short ) HDR_TYPE_PAD , LITTLE_ENDIAN ) ; buffer . putIntOrdered ( FRAME_LENGTH_FIELD_OFFSET , frameLength ) ; }", "nl": "Abort a claim of the message space to the log buffer so that the log can progress by ignoring this claim ."}}
{"translation": {"code": "public static boolean casActiveTermCount ( final UnsafeBuffer metadataBuffer , final int expectedTermCount , final int updateTermCount ) { return metadataBuffer . compareAndSetInt ( LOG_ACTIVE_TERM_COUNT_OFFSET , expectedTermCount , updateTermCount ) ; }", "nl": "Compare and set the value of the current active term count ."}}
{"translation": {"code": "public static long computePosition ( final int activeTermId , final int termOffset , final int positionBitsToShift , final int initialTermId ) { final long termCount = activeTermId - initialTermId ; // copes with negative activeTermId on rollover return ( termCount << positionBitsToShift ) + termOffset ; }", "nl": "Compute the current position in absolute number of bytes ."}}
{"translation": {"code": "public static long computeLogLength ( final int termLength , final int filePageSize ) { if ( termLength < ( 1024 * 1024 * 1024 ) ) { return align ( ( termLength * PARTITION_COUNT ) + LOG_META_DATA_LENGTH , filePageSize ) ; } return ( PARTITION_COUNT * ( long ) termLength ) + align ( LOG_META_DATA_LENGTH , filePageSize ) ; }", "nl": "Compute the total length of a log file given the term length ."}}
{"translation": {"code": "public static void storeDefaultFrameHeader ( final UnsafeBuffer metadataBuffer , final DirectBuffer defaultHeader ) { if ( defaultHeader . capacity ( ) != HEADER_LENGTH ) { throw new IllegalArgumentException ( \"Default header length not equal to HEADER_LENGTH: length=\" + defaultHeader . capacity ( ) ) ; } metadataBuffer . putInt ( LOG_DEFAULT_FRAME_HEADER_LENGTH_OFFSET , HEADER_LENGTH ) ; metadataBuffer . putBytes ( LOG_DEFAULT_FRAME_HEADER_OFFSET , defaultHeader , 0 , HEADER_LENGTH ) ; }", "nl": "Store the default frame header to the log meta data buffer ."}}
{"translation": {"code": "public static long scanForAvailability ( final UnsafeBuffer termBuffer , final int offset , final int maxLength ) { final int limit = Math . min ( maxLength , termBuffer . capacity ( ) - offset ) ; int available = 0 ; int padding = 0 ; do { final int termOffset = offset + available ; final int frameLength = frameLengthVolatile ( termBuffer , termOffset ) ; if ( frameLength <= 0 ) { break ; } int alignedFrameLength = align ( frameLength , FRAME_ALIGNMENT ) ; if ( isPaddingFrame ( termBuffer , termOffset ) ) { padding = alignedFrameLength - HEADER_LENGTH ; alignedFrameLength = HEADER_LENGTH ; } available += alignedFrameLength ; if ( available > limit ) { available -= alignedFrameLength ; padding = 0 ; break ; } } while ( 0 == padding && available < limit ) ; return pack ( padding , available ) ; }", "nl": "Scan the term buffer for availability of new message fragments from a given offset up to a maxLength of bytes ."}}
{"translation": {"code": "public long position ( ) { if ( isClosed ) { return CLOSED ; } final long rawTail = rawTailVolatile ( logMetaDataBuffer ) ; final int termOffset = termOffset ( rawTail , termBufferLength ) ; return computePosition ( termId ( rawTail ) , termOffset , positionBitsToShift , initialTermId ) ; }", "nl": "Get the current position to which the publication has advanced for this stream ."}}
{"translation": {"code": "public final long position ( ) { final int resultingOffset = BitUtil . align ( termOffset ( ) + frameLength ( ) , FRAME_ALIGNMENT ) ; return computePosition ( termId ( ) , resultingOffset , positionBitsToShift , initialTermId ) ; }", "nl": "Get the current position to which the image has advanced on reading this message ."}}
{"translation": {"code": "public static void eventAvailableImage ( final Image image ) { final Subscription subscription = image . subscription ( ) ; System . out . format ( \"new image on %s streamId %x sessionId %x from %s%n\" , subscription . channel ( ) , subscription . streamId ( ) , image . sessionId ( ) , image . sourceIdentity ( ) ) ; }", "nl": "Print the information for an available image to stdout ."}}
{"translation": {"code": "public static void eventUnavailableImage ( final Image image ) { final Subscription subscription = image . subscription ( ) ; System . out . format ( \"inactive image on %s streamId %d sessionId %x%n\" , subscription . channel ( ) , subscription . streamId ( ) , image . sessionId ( ) ) ; }", "nl": "This handler is called when image is unavailable"}}
{"translation": {"code": "public final void wrap ( final AtomicBuffer buffer , final int offset , final int length ) { this . buffer . wrap ( buffer , offset , length ) ; }", "nl": "Wrap a region of an underlying log buffer so can can represent a claimed space for use by a publisher ."}}
{"translation": {"code": "public static void applyDefaultHeader ( final UnsafeBuffer metadataBuffer , final UnsafeBuffer termBuffer , final int termOffset ) { termBuffer . putBytes ( termOffset , metadataBuffer , LOG_DEFAULT_FRAME_HEADER_OFFSET , HEADER_LENGTH ) ; }", "nl": "Apply the default header for a message in a term ."}}
{"translation": {"code": "public ErrorResponseFlyweight errorCode ( final ErrorCode code ) { buffer . putInt ( offset + ERROR_CODE_OFFSET , code . value ( ) ) ; return this ; }", "nl": "Set the error code for the command ."}}
{"translation": {"code": "public static boolean isDriverActive ( final File directory , final long driverTimeoutMs , final Consumer < String > logger ) { final File cncFile = new File ( directory , CncFileDescriptor . CNC_FILE ) ; if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { logger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; final MappedByteBuffer cncByteBuffer = IoUtil . mapExistingFile ( cncFile , \"CnC file\" ) ; try { return isDriverActive ( driverTimeoutMs , logger , cncByteBuffer ) ; } finally { IoUtil . unmap ( cncByteBuffer ) ; } } return false ; }", "nl": "Is a media driver active in the given directory?"}}
{"translation": {"code": "public MappedByteBuffer mapExistingCncFile ( final Consumer < String > logger ) { final File cncFile = new File ( aeronDirectory , CncFileDescriptor . CNC_FILE ) ; if ( cncFile . exists ( ) && cncFile . length ( ) > 0 ) { if ( null != logger ) { logger . accept ( \"INFO: Aeron CnC file exists: \" + cncFile ) ; } return IoUtil . mapExistingFile ( cncFile , CncFileDescriptor . CNC_FILE ) ; } return null ; }", "nl": "Map the CnC file if it exists ."}}
{"translation": {"code": "public void processTimeouts ( final long nowNs , final RetransmitSender retransmitSender ) { if ( activeRetransmitsMap . size ( ) > 0 ) { for ( final RetransmitAction action : retransmitActionPool ) { if ( DELAYED == action . state && ( action . expireNs - nowNs < 0 ) ) { retransmitSender . resend ( action . termId , action . termOffset , action . length ) ; action . linger ( lingerTimeoutGenerator . generateDelay ( ) , nanoClock . nanoTime ( ) ) ; } else if ( LINGERING == action . state && ( action . expireNs - nowNs < 0 ) ) { action . cancel ( ) ; activeRetransmitsMap . remove ( action . termId , action . termOffset ) ; } } } }", "nl": "Called to process any outstanding timeouts ."}}
{"translation": {"code": "public static boolean unblock ( final UnsafeBuffer [ ] termBuffers , final UnsafeBuffer logMetaDataBuffer , final long blockedPosition , final int termLength ) { final int positionBitsToShift = LogBufferDescriptor . positionBitsToShift ( termLength ) ; final int blockedTermCount = ( int ) ( blockedPosition >> positionBitsToShift ) ; final int blockedOffset = ( int ) blockedPosition & ( termLength - 1 ) ; final int activeTermCount = activeTermCount ( logMetaDataBuffer ) ; if ( activeTermCount == ( blockedTermCount - 1 ) && blockedOffset == 0 ) { final int currentTermId = termId ( rawTailVolatile ( logMetaDataBuffer , indexByTermCount ( activeTermCount ) ) ) ; return rotateLog ( logMetaDataBuffer , activeTermCount , currentTermId ) ; } final int blockedIndex = indexByTermCount ( blockedTermCount ) ; final long rawTail = rawTailVolatile ( logMetaDataBuffer , blockedIndex ) ; final int termId = termId ( rawTail ) ; final int tailOffset = termOffset ( rawTail , termLength ) ; final UnsafeBuffer termBuffer = termBuffers [ blockedIndex ] ; switch ( TermUnblocker . unblock ( logMetaDataBuffer , termBuffer , blockedOffset , tailOffset , termId ) ) { case UNBLOCKED_TO_END : rotateLog ( logMetaDataBuffer , blockedTermCount , termId ) ; // fall through case UNBLOCKED : return true ; } return false ; }", "nl": "Attempt to unblock a log buffer at given position"}}
{"translation": {"code": "public static int termOffset ( final long rawTail , final long termLength ) { final long tail = rawTail & 0xFFFF_FFFF  L ; return ( int ) Math . min ( tail , termLength ) ; }", "nl": "Read the termOffset from a packed raw tail value ."}}
{"translation": {"code": "public static boolean rotateLog ( final UnsafeBuffer metadataBuffer , final int termCount , final int termId ) { final int nextTermId = termId + 1 ; final int nextTermCount = termCount + 1 ; final int nextIndex = indexByTermCount ( nextTermCount ) ; final int expectedTermId = nextTermId - PARTITION_COUNT ; long rawTail ; do { rawTail = rawTail ( metadataBuffer , nextIndex ) ; if ( expectedTermId != termId ( rawTail ) ) { break ; } } while ( ! casRawTail ( metadataBuffer , nextIndex , rawTail , packTail ( nextTermId , 0 ) ) ) ; return casActiveTermCount ( metadataBuffer , termCount , nextTermCount ) ; }", "nl": "Rotate the log and update the tail counter for the new term ."}}
{"translation": {"code": "public void limit ( final int limit ) { if ( limit < 0 || limit >= buffer . capacity ( ) ) { throw new IllegalArgumentException ( \"limit outside range: capacity=\" + buffer . capacity ( ) + \" limit=\" + limit ) ; } this . limit = limit ; }", "nl": "Set this limit for this buffer as the position at which the next append operation will occur ."}}
{"translation": {"code": "public static void frameTermId ( final UnsafeBuffer buffer , final int termOffset , final int termId ) { buffer . putInt ( termIdOffset ( termOffset ) , termId , LITTLE_ENDIAN ) ; }", "nl": "Write the term id field for a frame ."}}
{"translation": {"code": "public static void initialiseTailWithTermId ( final UnsafeBuffer metadataBuffer , final int partitionIndex , final int termId ) { metadataBuffer . putLong ( TERM_TAIL_COUNTERS_OFFSET + ( partitionIndex * SIZE_OF_LONG ) , packTail ( termId , 0 ) ) ; }", "nl": "Set the initial value for the termId in the upper bits of the tail counter ."}}
{"translation": {"code": "public static UnsafeBufferPosition allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final long registrationId , final int sessionId , final int streamId , final String channel ) { return new UnsafeBufferPosition ( ( UnsafeBuffer ) countersManager . valuesBuffer ( ) , allocateCounterId ( tempBuffer , name , typeId , countersManager , registrationId , sessionId , streamId , channel ) , countersManager ) ; }", "nl": "Allocate a counter for tracking a position on a stream of messages ."}}
{"translation": {"code": "public static String labelName ( final int typeId ) { switch ( typeId ) { case PublisherLimit . PUBLISHER_LIMIT_TYPE_ID : return PublisherLimit . NAME ; case SenderPos . SENDER_POSITION_TYPE_ID : return SenderPos . NAME ; case ReceiverHwm . RECEIVER_HWM_TYPE_ID : return ReceiverHwm . NAME ; case SubscriberPos . SUBSCRIBER_POSITION_TYPE_ID : return SubscriberPos . NAME ; case ReceiverPos . RECEIVER_POS_TYPE_ID : return ReceiverPos . NAME ; case SenderLimit . SENDER_LIMIT_TYPE_ID : return SenderLimit . NAME ; case PublisherPos . PUBLISHER_POS_TYPE_ID : return PublisherPos . NAME ; case SenderBpe . SENDER_BPE_TYPE_ID : return SenderBpe . NAME ; default : return \"<unknown>\" ; } }", "nl": "Return the label name for a counter type identifier ."}}
{"translation": {"code": "public static AtomicCounter allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final String channel ) { final int keyLength = tempBuffer . putStringWithoutLengthAscii ( CHANNEL_OFFSET + SIZE_OF_INT , channel , 0 , MAX_CHANNEL_LENGTH ) ; tempBuffer . putInt ( CHANNEL_OFFSET , keyLength ) ; int labelLength = 0 ; labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , name ) ; labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , \": \" ) ; labelLength += tempBuffer . putStringWithoutLengthAscii ( keyLength + labelLength , channel , 0 , MAX_LABEL_LENGTH - labelLength ) ; return countersManager . newCounter ( typeId , tempBuffer , 0 , keyLength , tempBuffer , keyLength , labelLength ) ; }", "nl": "Allocate an indicator for tracking the status of a channel endpoint ."}}
{"translation": {"code": "public static long rawTailVolatile ( final UnsafeBuffer metadataBuffer ) { final int partitionIndex = indexByTermCount ( activeTermCount ( metadataBuffer ) ) ; return metadataBuffer . getLongVolatile ( TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ) ; }", "nl": "Get the raw value of the tail for the current active partition ."}}
{"translation": {"code": "public static String status ( final long status ) { if ( INITIALIZING == status ) { return \"INITIALIZING\" ; } if ( ERRORED == status ) { return \"ERRORED\" ; } if ( ACTIVE == status ) { return \"ACTIVE\" ; } if ( CLOSING == status ) { return \"CLOSING\" ; } return \"unknown id=\" + status ; }", "nl": "String representation of the channel status ."}}
{"translation": {"code": "public StatusMessageFlyweight applicationSpecificFeedback ( final byte [ ] source , final int offset , final int length ) { frameLength ( HEADER_LENGTH + length ) ; putBytes ( APP_SPECIFIC_FEEDBACK_FIELD_OFFSET , source , offset , length ) ; return this ; }", "nl": "Set the Application Specific Feedback for the Status Message ."}}
{"translation": {"code": "public static MappedByteBuffer mapLossReport ( final String aeronDirectoryName , final int reportFileLength ) { return mapNewFile ( file ( aeronDirectoryName ) , reportFileLength , false ) ; }", "nl": "Map a new loss report in the Aeron directory for a given length ."}}
{"translation": {"code": "public static InetSocketAddress destinationAddress ( final ChannelUri uri ) { try { validateConfiguration ( uri ) ; return getEndpointAddress ( uri ) ; } catch ( final Exception ex ) { throw new InvalidChannelException ( ErrorCode . INVALID_CHANNEL , ex ) ; } }", "nl": "Get the endpoint address from the URI ."}}
{"translation": {"code": "public long appendPadding ( final int length ) { checkMaxMessageLength ( length ) ; long newPosition = CLOSED ; if ( ! isClosed ) { final long limit = positionLimit . getVolatile ( ) ; final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; final long position = termBeginPosition + termOffset ; if ( position < limit ) { checkPositiveLength ( length ) ; final int result = termAppender . appendPadding ( termId , termOffset , headerWriter , length ) ; newPosition = newPosition ( result ) ; } else { newPosition = backPressureStatus ( position , length ) ; } } return newPosition ; }", "nl": "Append a padding record log of a given length to make up the log to a position ."}}
{"translation": {"code": "public static boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger , final ByteBuffer cncByteBuffer ) { if ( null == cncByteBuffer ) { return false ; } final UnsafeBuffer cncMetaDataBuffer = CncFileDescriptor . createMetaDataBuffer ( cncByteBuffer ) ; final long startTimeMs = System . currentTimeMillis ( ) ; int cncVersion ; while ( 0 == ( cncVersion = cncMetaDataBuffer . getIntVolatile ( CncFileDescriptor . cncVersionOffset ( 0 ) ) ) ) { if ( System . currentTimeMillis ( ) > ( startTimeMs + driverTimeoutMs ) ) { throw new DriverTimeoutException ( \"CnC file is created but not initialised.\" ) ; } sleep ( 1 ) ; } if ( CNC_VERSION != cncVersion ) { throw new AeronException ( \"Aeron CnC version does not match: required=\" + CNC_VERSION + \" version=\" + cncVersion ) ; } final ManyToOneRingBuffer toDriverBuffer = new ManyToOneRingBuffer ( CncFileDescriptor . createToDriverBuffer ( cncByteBuffer , cncMetaDataBuffer ) ) ; final long timestamp = toDriverBuffer . consumerHeartbeatTime ( ) ; final long now = System . currentTimeMillis ( ) ; final long timestampAge = now - timestamp ; logger . accept ( \"INFO: Aeron toDriver consumer heartbeat is (ms): \" + timestampAge ) ; return timestampAge <= driverTimeoutMs ; }", "nl": "Is a media driver active in the current mapped CnC buffer? If the driver is mid start then it will wait for up to the driverTimeoutMs by checking for the cncVersion being set ."}}
{"translation": {"code": "public boolean isDriverActive ( final long driverTimeoutMs , final Consumer < String > logger ) { final MappedByteBuffer cncByteBuffer = mapExistingCncFile ( logger ) ; try { return isDriverActive ( driverTimeoutMs , logger , cncByteBuffer ) ; } finally { IoUtil . unmap ( cncByteBuffer ) ; } }", "nl": "Is a media driver active in the current Aeron directory?"}}
{"translation": {"code": "public boolean connect ( final String responseChannel , final int responseStreamId , final long correlationId ) { connectRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . correlationId ( correlationId ) . responseStreamId ( responseStreamId ) . version ( AeronArchive . Configuration . SEMANTIC_VERSION ) . responseChannel ( responseChannel ) ; return offerWithTimeout ( connectRequestEncoder . encodedLength ( ) , null ) ; }", "nl": "Connect to an archive on its control interface providing the response stream details ."}}
{"translation": {"code": "public boolean startRecording ( final String channel , final int streamId , final SourceLocation sourceLocation , final long correlationId , final long controlSessionId ) { startRecordingRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . streamId ( streamId ) . sourceLocation ( sourceLocation ) . channel ( channel ) ; return offer ( startRecordingRequestEncoder . encodedLength ( ) ) ; }", "nl": "Start recording streams for a given channel and stream id pairing ."}}
{"translation": {"code": "public boolean stopRecording ( final String channel , final int streamId , final long correlationId , final long controlSessionId ) { stopRecordingRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . streamId ( streamId ) . channel ( channel ) ; return offer ( stopRecordingRequestEncoder . encodedLength ( ) ) ; }", "nl": "Stop an active recording ."}}
{"translation": {"code": "public boolean replay ( final long recordingId , final long position , final long length , final String replayChannel , final int replayStreamId , final long correlationId , final long controlSessionId ) { replayRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . recordingId ( recordingId ) . position ( position ) . length ( length ) . replayStreamId ( replayStreamId ) . replayChannel ( replayChannel ) ; return offer ( replayRequestEncoder . encodedLength ( ) ) ; }", "nl": "Replay a recording from a given position ."}}
{"translation": {"code": "public boolean listRecordings ( final long fromRecordingId , final int recordCount , final long correlationId , final long controlSessionId ) { listRecordingsRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . fromRecordingId ( fromRecordingId ) . recordCount ( recordCount ) ; return offer ( listRecordingsRequestEncoder . encodedLength ( ) ) ; }", "nl": "List a range of recording descriptors ."}}
{"translation": {"code": "public int appendPadding ( final int termId , final int termOffset , final HeaderWriter header , final int length ) { final int frameLength = length + HEADER_LENGTH ; final int alignedLength = align ( frameLength , FRAME_ALIGNMENT ) ; final UnsafeBuffer termBuffer = this . termBuffer ; final int termLength = termBuffer . capacity ( ) ; int resultingOffset = termOffset + alignedLength ; putRawTailOrdered ( termId , resultingOffset ) ; if ( resultingOffset > termLength ) { resultingOffset = handleEndOfLogCondition ( termBuffer , termOffset , header , termLength , termId ) ; } else { header . write ( termBuffer , termOffset , frameLength , termId ) ; frameType ( termBuffer , termOffset , PADDING_FRAME_TYPE ) ; frameLengthOrdered ( termBuffer , termOffset , frameLength ) ; } return resultingOffset ; }", "nl": "Pad a length of the term buffer with a padding record ."}}
{"translation": {"code": "public ChannelUriStringBuilder controlMode ( final String controlMode ) { if ( null != controlMode && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_MANUAL ) && ! controlMode . equals ( CommonContext . MDC_CONTROL_MODE_DYNAMIC ) ) { throw new IllegalArgumentException ( \"invalid control mode: \" + controlMode ) ; } this . controlMode = controlMode ; return this ; }", "nl": "Set the control mode for multi - destination - cast . Set to manual for allowing control from the publication API ."}}
{"translation": {"code": "public ChannelUriStringBuilder media ( final String media ) { switch ( media ) { case CommonContext . UDP_MEDIA : case CommonContext . IPC_MEDIA : break ; default : throw new IllegalArgumentException ( \"invalid media: \" + media ) ; } this . media = media ; return this ; }", "nl": "Set the media for this channel . Valid values are udp and ipc ."}}
{"translation": {"code": "public ChannelUriStringBuilder prefix ( final String prefix ) { if ( null != prefix && ! prefix . equals ( \"\" ) && ! prefix . equals ( SPY_QUALIFIER ) ) { throw new IllegalArgumentException ( \"invalid prefix: \" + prefix ) ; } this . prefix = prefix ; return this ; }", "nl": "Set the prefix for taking an addition action such as spying on an outgoing publication with aeron - spy ."}}
{"translation": {"code": "public ChannelUriStringBuilder validate ( ) { if ( null == media ) { throw new IllegalStateException ( \"media type is mandatory\" ) ; } if ( CommonContext . UDP_MEDIA . equals ( media ) && ( null == endpoint && null == controlEndpoint ) ) { throw new IllegalStateException ( \"either 'endpoint' or 'control' must be specified for UDP.\" ) ; } int count = 0 ; count += null == initialTermId ? 0 : 1 ; count += null == termId ? 0 : 1 ; count += null == termOffset ? 0 : 1 ; if ( count > 0 ) { if ( count < 3 ) { throw new IllegalStateException ( \"if any of then a complete set of 'initialTermId', 'termId', and 'termOffset' must be provided\" ) ; } if ( termId - initialTermId < 0 ) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException ( \"difference greater than 2^31 - 1: termId=\" + termId + \" - initialTermId=\" + initialTermId ) ; } if ( null != termLength && termOffset > termLength ) // lgtm [java/dereferenced-value-may-be-null] { throw new IllegalStateException ( \"termOffset=\" + termOffset + \" > termLength=\" + termLength ) ; } } return this ; }", "nl": "Validates that the collection of set parameters are valid together ."}}
{"translation": {"code": "public ChannelUriStringBuilder termOffset ( final Integer termOffset ) { if ( null != termOffset ) { if ( ( termOffset < 0 || termOffset > LogBufferDescriptor . TERM_MAX_LENGTH ) ) { throw new IllegalArgumentException ( \"term offset not in range 0-1g: \" + termOffset ) ; } if ( 0 != ( termOffset & ( FRAME_ALIGNMENT - 1 ) ) ) { throw new IllegalArgumentException ( \"term offset not multiple of FRAME_ALIGNMENT: \" + termOffset ) ; } } this . termOffset = termOffset ; return this ; }", "nl": "Set the offset within a term at which a publication will start . This when combined with the term id can establish a starting position ."}}
{"translation": {"code": "public ChannelUriStringBuilder termLength ( final Integer termLength ) { if ( null != termLength ) { LogBufferDescriptor . checkTermLength ( termLength ) ; } this . termLength = termLength ; return this ; }", "nl": "Set the length of buffer used for each term of the log . Valid values are powers of 2 in the 64K - 1G range ."}}
{"translation": {"code": "public ChannelUriStringBuilder clear ( ) { prefix = null ; media = null ; endpoint = null ; networkInterface = null ; controlEndpoint = null ; controlMode = null ; tags = null ; alias = null ; reliable = null ; ttl = null ; mtu = null ; termLength = null ; initialTermId = null ; termId = null ; termOffset = null ; sessionId = null ; linger = null ; sparse = null ; eos = null ; tether = null ; isSessionIdTagged = false ; return this ; }", "nl": "Clear out all the values thus setting back to the initial state ."}}
{"translation": {"code": "public boolean listRecordingsForUri ( final long fromRecordingId , final int recordCount , final String channelFragment , final int streamId , final long correlationId , final long controlSessionId ) { listRecordingsForUriRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . fromRecordingId ( fromRecordingId ) . recordCount ( recordCount ) . streamId ( streamId ) . channel ( channelFragment ) ; return offer ( listRecordingsForUriRequestEncoder . encodedLength ( ) ) ; }", "nl": "List a range of recording descriptors which match a channel URI fragment and stream id ."}}
{"translation": {"code": "public void close ( ) { lock . lock ( ) ; try { if ( ! isClosed ) { isClosed = true ; archiveProxy . closeSession ( controlSessionId ) ; if ( ! context . ownsAeronClient ( ) ) { CloseHelper . close ( controlResponsePoller . subscription ( ) ) ; CloseHelper . close ( archiveProxy . publication ( ) ) ; } context . close ( ) ; } } finally { lock . unlock ( ) ; } }", "nl": "Notify the archive that this control session is closed so it can promptly release resources then close the local resources associated with the client ."}}
{"translation": {"code": "public int poll ( ) { controlSessionId = - 1 ; correlationId = - 1 ; relevantId = - 1 ; templateId = - 1 ; errorMessage = null ; pollComplete = false ; return subscription . controlledPoll ( fragmentAssembler , fragmentLimit ) ; }", "nl": "Poll for control response events ."}}
{"translation": {"code": "public static void dispatchDescriptor ( final RecordingDescriptorDecoder decoder , final RecordingDescriptorConsumer consumer ) { consumer . onRecordingDescriptor ( decoder . controlSessionId ( ) , decoder . correlationId ( ) , decoder . recordingId ( ) , decoder . startTimestamp ( ) , decoder . stopTimestamp ( ) , decoder . startPosition ( ) , decoder . stopPosition ( ) , decoder . initialTermId ( ) , decoder . segmentFileLength ( ) , decoder . termBufferLength ( ) , decoder . mtuLength ( ) , decoder . sessionId ( ) , decoder . streamId ( ) , decoder . strippedChannel ( ) , decoder . originalChannel ( ) , decoder . sourceIdentity ( ) ) ; }", "nl": "Dispatch a descriptor message to a consumer by reading the fields in the correct order ."}}
{"translation": {"code": "public boolean closeSession ( final long controlSessionId ) { closeSessionRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) ; return offer ( closeSessionRequestEncoder . encodedLength ( ) ) ; }", "nl": "Close this control session with the archive ."}}
{"translation": {"code": "public String pollForErrorResponse ( ) { lock . lock ( ) ; try { ensureOpen ( ) ; if ( controlResponsePoller . poll ( ) != 0 && controlResponsePoller . isPollComplete ( ) ) { if ( controlResponsePoller . controlSessionId ( ) == controlSessionId && controlResponsePoller . templateId ( ) == ControlResponseDecoder . TEMPLATE_ID && controlResponsePoller . code ( ) == ControlResponseCode . ERROR ) { return controlResponsePoller . errorMessage ( ) ; } } return null ; } finally { lock . unlock ( ) ; } }", "nl": "Poll the response stream once for an error . If another message is present then it will be skipped over so only call when not expecting another response ."}}
{"translation": {"code": "public String put ( final String key , final String value ) { return params . put ( key , value ) ; }", "nl": "Put a key and value pair in the map of params ."}}
{"translation": {"code": "public static void validateSocketBufferLengths ( final MediaDriver . Context ctx ) { try ( DatagramChannel probe = DatagramChannel . open ( ) ) { final int defaultSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; probe . setOption ( StandardSocketOptions . SO_SNDBUF , Integer . MAX_VALUE ) ; final int maxSoSndBuf = probe . getOption ( StandardSocketOptions . SO_SNDBUF ) ; if ( maxSoSndBuf < ctx . socketSndbufLength ( ) ) { System . err . format ( \"WARNING: Could not get desired SO_SNDBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . socketSndbufLength ( ) , maxSoSndBuf ) ; } probe . setOption ( StandardSocketOptions . SO_RCVBUF , Integer . MAX_VALUE ) ; final int maxSoRcvBuf = probe . getOption ( StandardSocketOptions . SO_RCVBUF ) ; if ( maxSoRcvBuf < ctx . socketRcvbufLength ( ) ) { System . err . format ( \"WARNING: Could not get desired SO_RCVBUF, adjust OS to allow %s: attempted=%d, actual=%d%n\" , SOCKET_RCVBUF_LENGTH_PROP_NAME , ctx . socketRcvbufLength ( ) , maxSoRcvBuf ) ; } final int soSndBuf = 0 == ctx . socketSndbufLength ( ) ? defaultSoSndBuf : ctx . socketSndbufLength ( ) ; if ( ctx . mtuLength ( ) > soSndBuf ) { throw new ConfigurationException ( String . format ( \"MTU greater than socket SO_SNDBUF, adjust %s to match MTU: mtuLength=%d, SO_SNDBUF=%d\" , SOCKET_SNDBUF_LENGTH_PROP_NAME , ctx . mtuLength ( ) , soSndBuf ) ) ; } if ( ctx . initialWindowLength ( ) > maxSoRcvBuf ) { throw new ConfigurationException ( \"window length greater than socket SO_RCVBUF, increase '\" + Configuration . INITIAL_WINDOW_LENGTH_PROP_NAME + \"' to match window: windowLength=\" + ctx . initialWindowLength ( ) + \", SO_RCVBUF=\" + maxSoRcvBuf ) ; } } catch ( final IOException ex ) { throw new AeronException ( \"probe socket: \" + ex . toString ( ) , ex ) ; } }", "nl": "Validate that the socket buffer lengths are sufficient for the media driver configuration ."}}
{"translation": {"code": "public String description ( ) { final StringBuilder builder = new StringBuilder ( \"UdpChannel - \" ) ; if ( null != localInterface ) { builder . append ( \"interface: \" ) . append ( localInterface . getDisplayName ( ) ) . append ( \", \" ) ; } builder . append ( \"localData: \" ) . append ( localData ) . append ( \", remoteData: \" ) . append ( remoteData ) . append ( \", ttl: \" ) . append ( multicastTtl ) ; return builder . toString ( ) ; }", "nl": "Used for debugging to get a human readable description of the channel ."}}
{"translation": {"code": "public DirectBufferVector validate ( ) { final int capacity = buffer . capacity ( ) ; if ( offset < 0 || offset >= capacity ) { throw new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity ) ; } if ( length < 0 || length > ( capacity - offset ) ) { throw new IllegalArgumentException ( \"offset=\" + offset + \" capacity=\" + capacity + \" length=\" + length ) ; } return this ; }", "nl": "Ensure the vector is valid for the buffer ."}}
{"translation": {"code": "public DirectBufferVector reset ( final DirectBuffer buffer , final int offset , final int length ) { this . buffer = buffer ; this . offset = offset ; this . length = length ; return this ; }", "nl": "Reset the values ."}}
{"translation": {"code": "public static int validateAndComputeLength ( final DirectBufferVector [ ] vectors ) { int messageLength = 0 ; for ( final DirectBufferVector vector : vectors ) { vector . validate ( ) ; messageLength += vector . length ; if ( messageLength < 0 ) { throw new IllegalStateException ( \"length overflow: \" + Arrays . toString ( vectors ) ) ; } } return messageLength ; }", "nl": "Validate an array of vectors to make up a message and compute the total length ."}}
{"translation": {"code": "public long offer ( final DirectBufferVector [ ] vectors , final ReservedValueSupplier reservedValueSupplier ) { final int length = DirectBufferVector . validateAndComputeLength ( vectors ) ; long newPosition = CLOSED ; if ( ! isClosed ) { final long limit = positionLimit . getVolatile ( ) ; final ExclusiveTermAppender termAppender = termAppenders [ activePartitionIndex ] ; final long position = termBeginPosition + termOffset ; if ( position < limit ) { final int result ; if ( length <= maxPayloadLength ) { result = termAppender . appendUnfragmentedMessage ( termId , termOffset , headerWriter , vectors , length , reservedValueSupplier ) ; } else { checkMaxMessageLength ( length ) ; result = termAppender . appendFragmentedMessage ( termId , termOffset , headerWriter , vectors , length , maxPayloadLength , reservedValueSupplier ) ; } newPosition = newPosition ( result ) ; } else { newPosition = backPressureStatus ( position , length ) ; } } return newPosition ; }", "nl": "Non - blocking publish by gathering buffer vectors into a message ."}}
{"translation": {"code": "public static boolean casRawTail ( final UnsafeBuffer metadataBuffer , final int partitionIndex , final long expectedRawTail , final long updateRawTail ) { final int index = TERM_TAIL_COUNTERS_OFFSET + ( SIZE_OF_LONG * partitionIndex ) ; return metadataBuffer . compareAndSetLong ( index , expectedRawTail , updateRawTail ) ; }", "nl": "Compare and set the raw value of the tail for the given partition ."}}
{"translation": {"code": "public static void checkPageSize ( final int pageSize ) { if ( pageSize < PAGE_MIN_SIZE ) { throw new IllegalStateException ( \"Page size less than min size of \" + PAGE_MIN_SIZE + \": page size=\" + pageSize ) ; } if ( pageSize > PAGE_MAX_SIZE ) { throw new IllegalStateException ( \"Page size more than max size of \" + PAGE_MAX_SIZE + \": page size=\" + pageSize ) ; } if ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { throw new IllegalStateException ( \"Page size not a power of 2: page size=\" + pageSize ) ; } }", "nl": "Check that page size is valid and alignment is valid ."}}
{"translation": {"code": "public static void validatePageSize ( final int pageSize ) { if ( pageSize < PAGE_MIN_SIZE ) { throw new ConfigurationException ( \"page size less than min size of \" + PAGE_MIN_SIZE + \": \" + pageSize ) ; } if ( pageSize > PAGE_MAX_SIZE ) { throw new ConfigurationException ( \"page size greater than max size of \" + PAGE_MAX_SIZE + \": \" + pageSize ) ; } if ( ! BitUtil . isPowerOfTwo ( pageSize ) ) { throw new ConfigurationException ( \"page size not a power of 2: \" + pageSize ) ; } }", "nl": "Validate that page size is valid and alignment is valid ."}}
{"translation": {"code": "public static StatusIndicatorReader receiveChannelStatus ( final CountersReader countersReader , final String channel ) { StatusIndicatorReader statusReader = null ; final MutableInteger id = new MutableInteger ( - 1 ) ; countersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { if ( typeId == ReceiveChannelStatus . RECEIVE_CHANNEL_STATUS_TYPE_ID ) { if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) { id . value = counterId ; } } } ) ; if ( Aeron . NULL_VALUE != id . value ) { statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; } return statusReader ; }", "nl": "Return the read - only status indicator for the given receive channel URI ."}}
{"translation": {"code": "public static StatusIndicatorReader sendChannelStatus ( final CountersReader countersReader , final String channel ) { StatusIndicatorReader statusReader = null ; final MutableInteger id = new MutableInteger ( - 1 ) ; countersReader . forEach ( ( counterId , typeId , keyBuffer , label ) -> { if ( typeId == SendChannelStatus . SEND_CHANNEL_STATUS_TYPE_ID ) { if ( channel . startsWith ( keyBuffer . getStringAscii ( ChannelEndpointStatus . CHANNEL_OFFSET ) ) ) { id . value = counterId ; } } } ) ; if ( Aeron . NULL_VALUE != id . value ) { statusReader = new UnsafeBufferStatusIndicator ( countersReader . valuesBuffer ( ) , id . value ) ; } return statusReader ; }", "nl": "Return the read - only status indicator for the given send channel URI ."}}
{"translation": {"code": "public void close ( ) { if ( null != publication && publication . isConnected ( ) ) { closeSession ( ) ; } if ( ! ctx . ownsAeronClient ( ) ) { CloseHelper . close ( subscription ) ; CloseHelper . close ( publication ) ; } ctx . close ( ) ; }", "nl": "Close session and release associated resources ."}}
{"translation": {"code": "public CounterMessageFlyweight keyBuffer ( final DirectBuffer keyBuffer , final int keyOffset , final int keyLength ) { buffer . putInt ( KEY_LENGTH_OFFSET , keyLength ) ; if ( null != keyBuffer && keyLength > 0 ) { buffer . putBytes ( keyBufferOffset ( ) , keyBuffer , keyOffset , keyLength ) ; } return this ; }", "nl": "Fill the key buffer ."}}
{"translation": {"code": "public CounterMessageFlyweight labelBuffer ( final DirectBuffer labelBuffer , final int labelOffset , final int labelLength ) { buffer . putInt ( labelOffset ( ) , labelLength ) ; buffer . putBytes ( labelBufferOffset ( ) , labelBuffer , labelOffset , labelLength ) ; return this ; }", "nl": "Fill the label buffer ."}}
{"translation": {"code": "public long offer ( final DirectBuffer buffer , final int offset , final int length ) { return cluster . offer ( id , responsePublication , buffer , offset , length ) ; }", "nl": "Non - blocking publish of a partial buffer containing a message to a cluster ."}}
{"translation": {"code": "public boolean stopReplay ( final long replaySessionId , final long correlationId , final long controlSessionId ) { stopReplayRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . replaySessionId ( replaySessionId ) ; return offer ( replayRequestEncoder . encodedLength ( ) ) ; }", "nl": "Stop an existing replay session ."}}
{"translation": {"code": "public void stopReplay ( final long replaySessionId ) { lock . lock ( ) ; try { ensureOpen ( ) ; final long correlationId = aeron . nextCorrelationId ( ) ; if ( ! archiveProxy . stopReplay ( replaySessionId , correlationId , controlSessionId ) ) { throw new ArchiveException ( \"failed to send stop replay request\" ) ; } pollForResponse ( correlationId ) ; } finally { lock . unlock ( ) ; } }", "nl": "Stop a replay session ."}}
{"translation": {"code": "public static long getRecordingId ( final CountersReader countersReader , final int counterId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID ) { return buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) ; } } return NULL_RECORDING_ID ; }", "nl": "Get the recording id for a given counter id ."}}
{"translation": {"code": "public void commitLogPosition ( final long leadershipTermId , final long logPosition ) { final int index = getLeadershipTermEntryIndex ( leadershipTermId ) ; commitEntryValue ( index , logPosition , LOG_POSITION_OFFSET ) ; final Entry entry = entries . get ( index ) ; entries . set ( index , new Entry ( entry . recordingId , entry . leadershipTermId , entry . termBaseLogPosition , logPosition , entry . timestamp , entry . serviceId , entry . type , entry . entryIndex ) ) ; }", "nl": "Commit the position reached in a leadership term before a clean shutdown ."}}
{"translation": {"code": "public void appendSnapshot ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long logPosition , final long timestamp , final int serviceId ) { final int size = entries . size ( ) ; if ( size > 0 ) { final Entry entry = entries . get ( size - 1 ) ; if ( entry . type == ENTRY_TYPE_TERM && entry . leadershipTermId != leadershipTermId ) { throw new ClusterException ( \"leadershipTermId out of sequence: previous \" + entry . leadershipTermId + \" this \" + leadershipTermId ) ; } } append ( ENTRY_TYPE_SNAPSHOT , recordingId , leadershipTermId , termBaseLogPosition , logPosition , timestamp , serviceId ) ; }", "nl": "Append a log entry for a snapshot ."}}
{"translation": {"code": "public void appendTerm ( final long recordingId , final long leadershipTermId , final long termBaseLogPosition , final long timestamp ) { final int size = entries . size ( ) ; if ( size > 0 ) { final Entry lastEntry = entries . get ( size - 1 ) ; if ( lastEntry . type != NULL_VALUE && lastEntry . leadershipTermId >= leadershipTermId ) { throw new ClusterException ( \"leadershipTermId out of sequence: previous \" + lastEntry . leadershipTermId + \" this \" + leadershipTermId ) ; } } indexByLeadershipTermIdMap . put ( leadershipTermId , nextEntryIndex ) ; append ( ENTRY_TYPE_TERM , recordingId , leadershipTermId , termBaseLogPosition , NULL_POSITION , timestamp , NULL_VALUE ) ; }", "nl": "Append a log entry for a leadership term ."}}
{"translation": {"code": "public static AtomicCounter findControlToggle ( final CountersReader counters ) { final AtomicBuffer buffer = counters . metaDataBuffer ( ) ; for ( int i = 0 , size = counters . maxCounterId ( ) ; i < size ; i ++ ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( counters . getCounterState ( i ) == RECORD_ALLOCATED && buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == CONTROL_TOGGLE_TYPE_ID ) { return new AtomicCounter ( counters . valuesBuffer ( ) , i , null ) ; } } return null ; }", "nl": "Find the control toggle counter or return null if not found ."}}
{"translation": {"code": "public boolean listRecording ( final long recordingId , final long correlationId , final long controlSessionId ) { listRecordingRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . recordingId ( recordingId ) ; return offer ( listRecordingRequestEncoder . encodedLength ( ) ) ; }", "nl": "List a recording descriptor for a given recording id ."}}
{"translation": {"code": "public static int findCounterIdBySession ( final CountersReader countersReader , final int sessionId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; for ( int i = 0 , size = countersReader . maxCounterId ( ) ; i < size ; i ++ ) { if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SESSION_ID_OFFSET ) == sessionId ) { return i ; } } } return NULL_COUNTER_ID ; }", "nl": "Find the active counter id for a stream based on the session id ."}}
{"translation": {"code": "public static int findCounterIdByRecording ( final CountersReader countersReader , final long recordingId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; for ( int i = 0 , size = countersReader . maxCounterId ( ) ; i < size ; i ++ ) { if ( countersReader . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ) { return i ; } } } return NULL_COUNTER_ID ; }", "nl": "Find the active counter id for a stream based on the recording id ."}}
{"translation": {"code": "public static void main ( final String [ ] args ) { loadPropertiesFiles ( args ) ; try ( ClusteredServiceContainer container = launch ( ) ) { container . context ( ) . shutdownSignalBarrier ( ) . await ( ) ; System . out . println ( \"Shutdown ClusteredServiceContainer...\" ) ; } }", "nl": "Launch the clustered service container and await a shutdown signal ."}}
{"translation": {"code": "public static int findCounterId ( final CountersReader counters ) { final DirectBuffer buffer = counters . metaDataBuffer ( ) ; for ( int i = 0 , size = counters . maxCounterId ( ) ; i < size ; i ++ ) { if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { return i ; } } } return NULL_COUNTER_ID ; }", "nl": "Find the active counter id for recovery state ."}}
{"translation": {"code": "public static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final long leadershipTermId , final long logPosition , final long timestamp , final boolean hasReplay , final long ... snapshotRecordingIds ) { tempBuffer . putLong ( LEADERSHIP_TERM_ID_OFFSET , leadershipTermId ) ; tempBuffer . putLong ( LOG_POSITION_OFFSET , logPosition ) ; tempBuffer . putLong ( TIMESTAMP_OFFSET , timestamp ) ; tempBuffer . putInt ( REPLAY_FLAG_OFFSET , hasReplay ? 1 : 0 ) ; final int serviceCount = snapshotRecordingIds . length ; tempBuffer . putInt ( SERVICE_COUNT_OFFSET , serviceCount ) ; final int keyLength = SNAPSHOT_RECORDING_IDS_OFFSET + ( serviceCount * SIZE_OF_LONG ) ; if ( keyLength > MAX_KEY_LENGTH ) { throw new ClusterException ( keyLength + \" exceeds max key length \" + MAX_KEY_LENGTH ) ; } for ( int i = 0 ; i < serviceCount ; i ++ ) { tempBuffer . putLong ( SNAPSHOT_RECORDING_IDS_OFFSET + ( i * SIZE_OF_LONG ) , snapshotRecordingIds [ i ] ) ; } final int labelOffset = BitUtil . align ( keyLength , SIZE_OF_INT ) ; int labelLength = 0 ; labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; labelLength += tempBuffer . putLongAscii ( keyLength + labelLength , leadershipTermId ) ; labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" logPosition=\" ) ; labelLength += tempBuffer . putLongAscii ( labelOffset + labelLength , logPosition ) ; labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , \" hasReplay=\" + hasReplay ) ; return aeron . addCounter ( RECOVERY_STATE_TYPE_ID , tempBuffer , 0 , keyLength , tempBuffer , labelOffset , labelLength ) ; }", "nl": "Allocate a counter to represent the snapshot services should load on start ."}}
{"translation": {"code": "public void reload ( ) { entries . clear ( ) ; indexByLeadershipTermIdMap . clear ( ) ; indexByLeadershipTermIdMap . compact ( ) ; nextEntryIndex = 0 ; byteBuffer . clear ( ) ; try { while ( true ) { final int bytes = fileChannel . read ( byteBuffer ) ; if ( byteBuffer . remaining ( ) == 0 ) { byteBuffer . flip ( ) ; captureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; byteBuffer . clear ( ) ; } if ( - 1 == bytes ) { if ( byteBuffer . position ( ) > 0 ) { byteBuffer . flip ( ) ; captureEntriesFromBuffer ( byteBuffer , buffer , entries ) ; byteBuffer . clear ( ) ; } break ; } } } catch ( final IOException ex ) { LangUtil . rethrowUnchecked ( ex ) ; } }", "nl": "Reload the log from disk ."}}
{"translation": {"code": "public static boolean hasReplay ( final CountersReader counters , final int counterId ) { final DirectBuffer buffer = counters . metaDataBuffer ( ) ; if ( counters . getCounterState ( counterId ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECOVERY_STATE_TYPE_ID ) { return buffer . getInt ( recordOffset + KEY_OFFSET + REPLAY_FLAG_OFFSET ) == 1 ; } } return false ; }", "nl": "Has the recovery process got a log to replay?"}}
{"translation": {"code": "public RecoveryPlan createRecoveryPlan ( final AeronArchive archive , final int serviceCount ) { final ArrayList < Snapshot > snapshots = new ArrayList <> ( ) ; final ArrayList < Log > logs = new ArrayList <> ( ) ; planRecovery ( snapshots , logs , entries , archive , serviceCount ) ; long lastLeadershipTermId = NULL_VALUE ; long lastTermBaseLogPosition = 0 ; long committedLogPosition = - 1 ; long appendedLogPosition = 0 ; final int snapshotStepsSize = snapshots . size ( ) ; if ( snapshotStepsSize > 0 ) { final Snapshot snapshot = snapshots . get ( 0 ) ; lastLeadershipTermId = snapshot . leadershipTermId ; lastTermBaseLogPosition = snapshot . termBaseLogPosition ; appendedLogPosition = snapshot . logPosition ; committedLogPosition = snapshot . logPosition ; } if ( ! logs . isEmpty ( ) ) { final Log log = logs . get ( 0 ) ; lastLeadershipTermId = log . leadershipTermId ; lastTermBaseLogPosition = log . termBaseLogPosition ; appendedLogPosition = log . stopPosition ; committedLogPosition = log . logPosition ; } return new RecoveryPlan ( lastLeadershipTermId , lastTermBaseLogPosition , appendedLogPosition , committedLogPosition , snapshots , logs ) ; }", "nl": "Create a recovery plan for the cluster that when the steps are replayed will bring the cluster back to the latest stable state ."}}
{"translation": {"code": "public static boolean isActive ( final CountersReader countersReader , final int counterId , final long recordingId ) { final DirectBuffer buffer = countersReader . metaDataBuffer ( ) ; if ( countersReader . getCounterState ( counterId ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( counterId ) ; return buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == RECORDING_POSITION_TYPE_ID && buffer . getLong ( recordOffset + KEY_OFFSET + RECORDING_ID_OFFSET ) == recordingId ; } return false ; }", "nl": "Is the recording counter still active ."}}
{"translation": {"code": "public static String addSessionId ( final String channel , final int sessionId ) { final ChannelUri channelUri = ChannelUri . parse ( channel ) ; channelUri . put ( CommonContext . SESSION_ID_PARAM_NAME , Integer . toString ( sessionId ) ) ; return channelUri . toString ( ) ; }", "nl": "Add a sessionId to a given channel ."}}
{"translation": {"code": "public boolean extendRecording ( final String channel , final int streamId , final SourceLocation sourceLocation , final long recordingId , final long correlationId , final long controlSessionId ) { extendRecordingRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . recordingId ( recordingId ) . streamId ( streamId ) . sourceLocation ( sourceLocation ) . channel ( channel ) ; return offer ( extendRecordingRequestEncoder . encodedLength ( ) ) ; }", "nl": "Extend an existing non - active recorded stream for a the same channel and stream id ."}}
{"translation": {"code": "public static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { final int length = rankedPositions . length ; for ( int i = 0 ; i < length ; i ++ ) { rankedPositions [ i ] = 0 ; } for ( final ClusterMember member : members ) { long newPosition = member . logPosition ; for ( int i = 0 ; i < length ; i ++ ) { final long rankedPosition = rankedPositions [ i ] ; if ( newPosition > rankedPosition ) { rankedPositions [ i ] = newPosition ; newPosition = rankedPosition ; } } } return rankedPositions [ length - 1 ] ; }", "nl": "Calculate the position reached by a quorum of cluster members ."}}
{"translation": {"code": "public void tombstoneEntry ( final long leadershipTermId , final int entryIndex ) { int index = - 1 ; for ( int i = 0 , size = entries . size ( ) ; i < size ; i ++ ) { final Entry entry = entries . get ( i ) ; if ( entry . leadershipTermId == leadershipTermId && entry . entryIndex == entryIndex ) { index = entry . entryIndex ; if ( ENTRY_TYPE_TERM == entry . type ) { indexByLeadershipTermIdMap . remove ( leadershipTermId ) ; } break ; } } if ( - 1 == index ) { throw new ClusterException ( \"unknown entry index: \" + entryIndex ) ; } buffer . putInt ( 0 , NULL_VALUE , LITTLE_ENDIAN ) ; byteBuffer . limit ( SIZE_OF_INT ) . position ( 0 ) ; final long filePosition = ( index * ( long ) ENTRY_LENGTH ) + ENTRY_TYPE_OFFSET ; try { if ( SIZE_OF_INT != fileChannel . write ( byteBuffer , filePosition ) ) { throw new ClusterException ( \"failed to write field atomically\" ) ; } } catch ( final Exception ex ) { LangUtil . rethrowUnchecked ( ex ) ; } }", "nl": "Tombstone an entry in the log so it is no longer valid ."}}
{"translation": {"code": "public ChannelUriStringBuilder linger ( final Long lingerNs ) { if ( null != lingerNs && lingerNs < 0 ) { throw new IllegalArgumentException ( \"linger value cannot be negative: \" + lingerNs ) ; } this . linger = lingerNs ; return this ; }", "nl": "Set the time a network publication will linger in nanoseconds after being drained . This time is so that tail loss can be recovered ."}}
{"translation": {"code": "public static void addMemberStatusPublications ( final ClusterMember [ ] members , final ClusterMember exclude , final ChannelUri channelUri , final int streamId , final Aeron aeron ) { for ( final ClusterMember member : members ) { if ( member != exclude ) { channelUri . put ( ENDPOINT_PARAM_NAME , member . memberFacingEndpoint ( ) ) ; member . publication = aeron . addExclusivePublication ( channelUri . toString ( ) , streamId ) ; } } }", "nl": "Add the publications for sending status messages to the other members of the cluster ."}}
{"translation": {"code": "public static void closeMemberPublications ( final ClusterMember [ ] clusterMembers ) { for ( final ClusterMember member : clusterMembers ) { CloseHelper . close ( member . publication ) ; } }", "nl": "Close the publications associated with members of the cluster ."}}
{"translation": {"code": "public static void resetLogPositions ( final ClusterMember [ ] clusterMembers , final long logPosition ) { for ( final ClusterMember member : clusterMembers ) { member . logPosition ( logPosition ) ; } }", "nl": "Reset the log position of all the members to the provided value ."}}
{"translation": {"code": "public static boolean haveVotersReachedPosition ( final ClusterMember [ ] clusterMembers , final long position , final long leadershipTermId ) { for ( final ClusterMember member : clusterMembers ) { if ( member . vote != null && ( member . logPosition < position || member . leadershipTermId != leadershipTermId ) ) { return false ; } } return true ; }", "nl": "Has the members of the cluster the voted reached the provided position in their log ."}}
{"translation": {"code": "public static boolean hasMajorityVote ( final ClusterMember [ ] clusterMembers , final long candidateTermId ) { int votes = 0 ; for ( final ClusterMember member : clusterMembers ) { if ( Boolean . TRUE . equals ( member . vote ) && member . candidateTermId == candidateTermId ) { ++ votes ; } } return votes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; }", "nl": "Has sufficient votes being counted for a majority?"}}
{"translation": {"code": "public static boolean hasWonVoteOnFullCount ( final ClusterMember [ ] members , final long candidateTermId ) { int votes = 0 ; for ( final ClusterMember member : members ) { if ( null == member . vote || member . candidateTermId != candidateTermId ) { return false ; } votes += member . vote ? 1 : 0 ; } return votes >= ClusterMember . quorumThreshold ( members . length ) ; }", "nl": "Has the candidate got unanimous support of the cluster?"}}
{"translation": {"code": "public static int findCounterId ( final CountersReader counters , final int serviceId ) { final DirectBuffer buffer = counters . metaDataBuffer ( ) ; for ( int i = 0 , size = counters . maxCounterId ( ) ; i < size ; i ++ ) { if ( counters . getCounterState ( i ) == RECORD_ALLOCATED ) { final int recordOffset = CountersReader . metaDataOffset ( i ) ; if ( buffer . getInt ( recordOffset + TYPE_ID_OFFSET ) == SERVICE_HEARTBEAT_TYPE_ID && buffer . getInt ( recordOffset + KEY_OFFSET + SERVICE_ID_OFFSET ) == serviceId ) { return i ; } } } return NULL_COUNTER_ID ; }", "nl": "Find the active counter id for heartbeat of a given service id ."}}
{"translation": {"code": "public static Counter allocate ( final Aeron aeron , final MutableDirectBuffer tempBuffer , final int serviceId ) { tempBuffer . putInt ( SERVICE_ID_OFFSET , serviceId ) ; final int labelOffset = BitUtil . align ( KEY_LENGTH , SIZE_OF_INT ) ; int labelLength = 0 ; labelLength += tempBuffer . putStringWithoutLengthAscii ( labelOffset + labelLength , NAME ) ; labelLength += tempBuffer . putIntAscii ( labelOffset + labelLength , serviceId ) ; return aeron . addCounter ( SERVICE_HEARTBEAT_TYPE_ID , tempBuffer , 0 , KEY_LENGTH , tempBuffer , labelOffset , labelLength ) ; }", "nl": "Allocate a counter to represent the heartbeat of a clustered service ."}}
{"translation": {"code": "public boolean getRecordingPosition ( final long recordingId , final long correlationId , final long controlSessionId ) { recordingPositionRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . recordingId ( recordingId ) ; return offer ( recordingPositionRequestEncoder . encodedLength ( ) ) ; }", "nl": "Get the recorded position of an active recording ."}}
{"translation": {"code": "public boolean tryConnect ( final String responseChannel , final int responseStreamId , final long correlationId ) { connectRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . correlationId ( correlationId ) . responseStreamId ( responseStreamId ) . version ( AeronArchive . Configuration . SEMANTIC_VERSION ) . responseChannel ( responseChannel ) ; final int length = MessageHeaderEncoder . ENCODED_LENGTH + connectRequestEncoder . encodedLength ( ) ; return publication . offer ( buffer , 0 , length ) > 0 ; }", "nl": "Try Connect to an archive on its control interface providing the response stream details . Only one attempt will be made to offer the request ."}}
{"translation": {"code": "public static boolean isUnanimousCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { for ( final ClusterMember member : clusterMembers ) { if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { return false ; } } return true ; }", "nl": "Has the member achieved a unanimous view to be a suitable candidate in an election ."}}
{"translation": {"code": "public static boolean isQuorumCandidate ( final ClusterMember [ ] clusterMembers , final ClusterMember candidate ) { int possibleVotes = 0 ; for ( final ClusterMember member : clusterMembers ) { if ( NULL_POSITION == member . logPosition || compareLog ( candidate , member ) < 0 ) { continue ; } ++ possibleVotes ; } return possibleVotes >= ClusterMember . quorumThreshold ( clusterMembers . length ) ; }", "nl": "Has the member achieved a quorum view to be a suitable candidate in an election ."}}