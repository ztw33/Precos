{"translation": {"code": "public void reset ( ) { isBallotSent = false ; isLeader = false ; hasRequestedJoin = false ; hasSentTerminationAck = false ; vote = null ; candidateTermId = Aeron . NULL_VALUE ; leadershipTermId = Aeron . NULL_VALUE ; logPosition = NULL_POSITION ; }", "nl": "Reset the state of a cluster member so it can be canvassed and reestablished ."}}
{"translation": {"code": "public static AtomicCounter allocate ( final MutableDirectBuffer tempBuffer , final String name , final int typeId , final CountersManager countersManager , final long registrationId ) { return new AtomicCounter ( countersManager . valuesBuffer ( ) , allocateCounterId ( tempBuffer , name , typeId , countersManager , registrationId ) , countersManager ) ; }", "nl": "Allocate a counter for tracking the last heartbeat of an entity ."}}
{"translation": {"code": "public Map < StreamCompositeKey , List < StreamPosition > > snapshot ( ) { final Map < StreamCompositeKey , List < StreamPosition > > streams = new HashMap <> ( ) ; counters . forEach ( ( counterId , typeId , keyBuffer , label ) -> { if ( ( typeId >= PUBLISHER_LIMIT_TYPE_ID && typeId <= RECEIVER_POS_TYPE_ID ) || typeId == SENDER_LIMIT_TYPE_ID || typeId == PER_IMAGE_TYPE_ID || typeId == PUBLISHER_POS_TYPE_ID ) { final StreamCompositeKey key = new StreamCompositeKey ( keyBuffer . getInt ( SESSION_ID_OFFSET ) , keyBuffer . getInt ( STREAM_ID_OFFSET ) , keyBuffer . getStringAscii ( CHANNEL_OFFSET ) ) ; final StreamPosition position = new StreamPosition ( keyBuffer . getLong ( REGISTRATION_ID_OFFSET ) , counters . getCounterValue ( counterId ) , typeId ) ; streams . computeIfAbsent ( key , ( ignore ) - > new ArrayList <> ( ) ) . add ( position ) ; } } ) ; return streams ; }", "nl": "Take a snapshot of all the counters and group them by streams ."}}
{"translation": {"code": "public String channelTag ( ) { return ( null != tags && tags . length > CHANNEL_TAG_INDEX ) ? tags [ CHANNEL_TAG_INDEX ] : null ; }", "nl": "Get the channel tag if it exists that refers to an another channel ."}}
{"translation": {"code": "public static long getTag ( final String paramValue ) { return isTagged ( paramValue ) ? AsciiEncoding . parseLongAscii ( paramValue , 4 , paramValue . length ( ) - 4 ) : INVALID_TAG ; }", "nl": "Get the value of the tag from a given parameter value ."}}
{"translation": {"code": "public String entityTag ( ) { return ( null != tags && tags . length > ENTITY_TAG_INDEX ) ? tags [ ENTITY_TAG_INDEX ] : null ; }", "nl": "Get the entity tag if it exists that refers to an entity such as subscription or publication ."}}
{"translation": {"code": "public static int highMemberId ( final ClusterMember [ ] clusterMembers ) { int highId = Aeron . NULL_VALUE ; for ( final ClusterMember member : clusterMembers ) { highId = Math . max ( highId , member . id ( ) ) ; } return highId ; }", "nl": "Find the highest member id in an array of members ."}}
{"translation": {"code": "public static boolean isNotDuplicateEndpoints ( final ClusterMember [ ] members , final String memberEndpoints ) { for ( final ClusterMember member : members ) { if ( member . endpointsDetail ( ) . equals ( memberEndpoints ) ) { return false ; } } return true ; }", "nl": "Is the string of member endpoints not duplicated in the members ."}}
{"translation": {"code": "public static String encodeAsString ( final ClusterMember [ ] clusterMembers ) { final StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 , length = clusterMembers . length ; i < length ; i ++ ) { final ClusterMember member = clusterMembers [ i ] ; builder . append ( member . id ( ) ) . append ( ' ' ) . append ( member . endpointsDetail ( ) ) ; if ( ( length - 1 ) != i ) { builder . append ( ' ' ) ; } } return builder . toString ( ) ; }", "nl": "Encode member details from a cluster members array to a string ."}}
{"translation": {"code": "public static void validateMemberEndpoints ( final ClusterMember member , final String memberEndpoints ) { final ClusterMember endpointMember = ClusterMember . parseEndpoints ( Aeron . NULL_VALUE , memberEndpoints ) ; if ( ! areSameEndpoints ( member , endpointMember ) ) { throw new ClusterException ( \"clusterMembers and memberEndpoints differ: \" + member . endpointsDetail ( ) + \" != \" + memberEndpoints ) ; } }", "nl": "Check the member with the memberEndpoints"}}
{"translation": {"code": "public static boolean areSameEndpoints ( final ClusterMember lhs , final ClusterMember rhs ) { return lhs . clientFacingEndpoint ( ) . equals ( rhs . clientFacingEndpoint ( ) ) && lhs . memberFacingEndpoint ( ) . equals ( rhs . memberFacingEndpoint ( ) ) && lhs . logEndpoint ( ) . equals ( rhs . logEndpoint ( ) ) && lhs . transferEndpoint ( ) . equals ( rhs . transferEndpoint ( ) ) && lhs . archiveEndpoint ( ) . equals ( rhs . archiveEndpoint ( ) ) ; }", "nl": "Are two cluster members using the same endpoints?"}}
{"translation": {"code": "public static boolean hasActiveQuorum ( final ClusterMember [ ] clusterMembers , final long nowMs , final long timeoutMs ) { int threshold = quorumThreshold ( clusterMembers . length ) ; for ( final ClusterMember member : clusterMembers ) { if ( member . isLeader ( ) || nowMs <= ( member . timeOfLastAppendPositionMs ( ) + timeoutMs ) ) { if ( -- threshold <= 0 ) { return true ; } } } return false ; }", "nl": "Check if the cluster leader has an active quorum of cluster followers ."}}
{"translation": {"code": "public boolean listRecordingSubscriptions ( final int pseudoIndex , final int subscriptionCount , final String channelFragment , final int streamId , final boolean applyStreamId , final long correlationId , final long controlSessionId ) { listRecordingSubscriptionsRequestEncoder . wrapAndApplyHeader ( buffer , 0 , messageHeaderEncoder ) . controlSessionId ( controlSessionId ) . correlationId ( correlationId ) . pseudoIndex ( pseudoIndex ) . subscriptionCount ( subscriptionCount ) . applyStreamId ( applyStreamId ? BooleanType . TRUE : BooleanType . FALSE ) . streamId ( streamId ) . channel ( channelFragment ) ; return offer ( listRecordingSubscriptionsRequestEncoder . encodedLength ( ) ) ; }", "nl": "List registered subscriptions in the archive which have been used to record streams ."}}
{"translation": {"code": "public static void validateSessionIdRange ( final int low , final int high ) { if ( low > high ) { throw new ConfigurationException ( \"low session id value \" + low + \" must be <= high value \" + high ) ; } if ( Math . abs ( ( long ) high - low ) > Integer . MAX_VALUE ) { throw new ConfigurationException ( \"reserved range to too large\" ) ; } }", "nl": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping ."}}
{"translation": {"code": "public static void validateUnblockTimeout ( final long publicationUnblockTimeoutNs , final long clientLivenessTimeoutNs , final long timerIntervalNs ) { if ( publicationUnblockTimeoutNs <= clientLivenessTimeoutNs ) { throw new ConfigurationException ( \"publicationUnblockTimeoutNs=\" + publicationUnblockTimeoutNs + \" <= clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs ) ; } if ( clientLivenessTimeoutNs <= timerIntervalNs ) { throw new ConfigurationException ( \"clientLivenessTimeoutNs=\" + clientLivenessTimeoutNs + \" <= timerIntervalNs=\" + timerIntervalNs ) ; } }", "nl": "Validate that the timeouts for unblocking publications from a client are valid ."}}
{"translation": {"code": "public static ClusterMember determineMember ( final ClusterMember [ ] clusterMembers , final int memberId , final String memberEndpoints ) { ClusterMember member = NULL_VALUE != memberId ? ClusterMember . findMember ( clusterMembers , memberId ) : null ; if ( ( null == clusterMembers || 0 == clusterMembers . length ) && null == member ) { member = ClusterMember . parseEndpoints ( NULL_VALUE , memberEndpoints ) ; } else { if ( null == member ) { throw new ClusterException ( \"memberId=\" + memberId + \" not found in clusterMembers\" ) ; } if ( ! \"\" . equals ( memberEndpoints ) ) { ClusterMember . validateMemberEndpoints ( member , memberEndpoints ) ; } } return member ; }", "nl": "Determine which member of a cluster this is and check endpoints ."}}