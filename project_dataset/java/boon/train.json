{"translation": {"code": "public static < K , V > boolean valueIn ( V value , Map < K , V > map ) { return map . containsValue ( value ) ; }", "nl": "End universal methods ."}}
{"translation": {"code": "@ Universal public static String add ( String str , char c ) { return FastStringUtils . noCopyStringFromChars ( Chr . add ( FastStringUtils . toCharArray ( str ) , c ) ) ; }", "nl": "Add a char to a string"}}
{"translation": {"code": "public static String compact ( String str ) { return FastStringUtils . noCopyStringFromChars ( Chr . compact ( FastStringUtils . toCharArray ( str ) ) ) ; }", "nl": "Gets rid of null characters lurking in the string"}}
{"translation": {"code": "@ Universal public static String slc ( String str , int start ) { return FastStringUtils . noCopyStringFromChars ( Chr . slc ( FastStringUtils . toCharArray ( str ) , start ) ) ; }", "nl": "Gets slice of a string ."}}
{"translation": {"code": "public static String [ ] split ( String str ) { char [ ] [ ] split = Chr . split ( FastStringUtils . toCharArray ( str ) ) ; return fromCharArrayOfArrayToStringArray ( split ) ; }", "nl": "Split a string"}}
{"translation": {"code": "public static String [ ] splitByPipe ( String str ) { char [ ] [ ] split = CharScanner . splitByPipe ( FastStringUtils . toCharArray ( str ) ) ; return fromCharArrayOfArrayToStringArray ( split ) ; }", "nl": "Split a string by pipe"}}
{"translation": {"code": "public static String [ ] fromCharArrayOfArrayToStringArray ( char [ ] [ ] split ) { String [ ] results = new String [ split . length ] ; char [ ] array ; for ( int index = 0 ; index < split . length ; index ++ ) { array = split [ index ] ; results [ index ] = array . length == 0 ? EMPTY_STRING : FastStringUtils . noCopyStringFromChars ( array ) ; } return results ; }", "nl": "Convert arrays of chars to arrays of strings"}}
{"translation": {"code": "public static String [ ] splitByDelimiters ( final String string , final String delimiters ) { char [ ] [ ] comps = CharScanner . splitByChars ( FastStringUtils . toCharArray ( string ) , delimiters . toCharArray ( ) ) ; return Str . fromCharArrayOfArrayToStringArray ( comps ) ; }", "nl": "Split string by a list of delimiters"}}
{"translation": {"code": "public static String camelCase ( String inStr , boolean upper ) { char [ ] in = FastStringUtils . toCharArray ( inStr ) ; char [ ] out = Chr . camelCase ( in , upper ) ; return FastStringUtils . noCopyStringFromChars ( out ) ; }", "nl": "Convert to camel case and pass upper or lower"}}
{"translation": {"code": "public static String underBarCase ( String inStr ) { char [ ] in = FastStringUtils . toCharArray ( inStr ) ; char [ ] out = Chr . underBarCase ( in ) ; return FastStringUtils . noCopyStringFromChars ( out ) ; }", "nl": "Convert to under bar case"}}
{"translation": {"code": "public void sort ( List list , Map < String , FieldAccess > fields ) { Collections . sort ( list , this . comparator ( fields ) ) ; }", "nl": "Sort if you already know the reflection fields ."}}
{"translation": {"code": "public Comparator comparator ( Map < String , FieldAccess > fields ) { if ( comparator == null ) { comparator = universalComparator ( this . getName ( ) , fields , this . getType ( ) , this . childComparators ( fields ) ) ; } return comparator ; }", "nl": "This is what really does the magic . This is the comparator creator ."}}
{"translation": {"code": "private List < Comparator > childComparators ( Map < String , FieldAccess > fields ) { if ( this . comparators == null ) { this . comparators = new ArrayList <> ( this . sorts . size ( ) + 1 ) ; for ( Sort sort : sorts ) { Comparator comparator = universalComparator ( sort . getName ( ) , fields , sort . getType ( ) , sort . childComparators ( fields ) ) ; this . comparators . add ( comparator ) ; } } return this . comparators ; }", "nl": "This creates a list of children comparators based on the child list ."}}
{"translation": {"code": "private ResultSet mainQueryPlan ( Criteria [ ] expressions ) { ResultSetInternal results = new ResultSetImpl ( this . fields ) ; if ( expressions == null || expressions . length == 0 ) { results . addResults ( searchableCollection . all ( ) ) ; } /* I am sure this looked easy to read when I wrote it.\n         * If there is only one expression and first expression is a group then\n         * the group is that first expression otherwise wrap\n         * all of the expressions in an and clause. */ Group group = expressions . length == 1 && expressions [ 0 ] instanceof Group ? ( Group ) expressions [ 0 ] : ObjectFilter . and ( expressions ) ; /**\n         * Run the filter on the group.\n         */ doFilterGroup ( group , results ) ; return results ; }", "nl": "This is the main criteria plan in case the name was not obvious ."}}
{"translation": {"code": "private void doFilterGroup ( Group group , ResultSetInternal results ) { /* The group was n or group so handle it that way. */ if ( group . getGrouping ( ) == Grouping . OR ) { /* nice short method name, or. */ or ( group . getExpressions ( ) , fields , results ) ; } else { /* create a result internal (why?), wrap the fields in the result set\n            internal, and pass that to the and method.\n             */ ResultSetInternal resultsForAnd = new ResultSetImpl ( fields ) ; and ( group . getExpressions ( ) , fields , resultsForAnd ) ; results . addResults ( resultsForAnd . asList ( ) ) ; } }", "nl": "Run the filter on the group ."}}
{"translation": {"code": "public static Sort sorts ( Sort ... sorts ) { if ( sorts == null || sorts . length == 0 ) { return null ; } Sort main = sorts [ 0 ] ; for ( int index = 1 ; index < sorts . length ; index ++ ) { main . then ( sorts [ index ] ) ; } return main ; }", "nl": "Helper method to create a Sort that is a composite of other sorts ."}}
{"translation": {"code": "public static Criterion notIn ( final Object name , final Object ... values ) { return new Criterion < Object > ( name . toString ( ) , Operator . NOT_IN , values ) { @ Override public boolean resolve ( Object owner ) { Object fieldValue = fieldValue ( ) ; if ( value == null ) { return false ; } return ! valueSet ( ) . contains ( fieldValue ) ; } } ; }", "nl": "This has to convert values to field type ."}}
{"translation": {"code": "public static Selector select ( final String propName ) { return new Selector ( propName , propName ) { @ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { getPropertyValueAndPutIntoRow ( row , item , fields ) ; } @ Override public void handleStart ( Collection < ? > results ) { } @ Override public void handleComplete ( List < Map < String , Object > > rows ) { } } ; }", "nl": "Allows you to select a property or property path ."}}
{"translation": {"code": "public static Selector selectAs ( final String propName , final String alias , final Function transform ) { return new Selector ( propName , alias ) { @ Override public void handleRow ( int index , Map < String , Object > row , Object item , Map < String , FieldAccess > fields ) { if ( ! path && fields != null ) { row . put ( this . name , transform . apply ( fields . get ( this . name ) . getValue ( item ) ) ) ; } else { row . put ( alias , transform . apply ( BeanUtils . atIndex ( item , propName ) ) ) ; } } @ Override public void handleStart ( Collection < ? > results ) { } @ Override public void handleComplete ( List < Map < String , Object > > rows ) { } } ; }", "nl": "Selects but allows having a different alias for the output ."}}
{"translation": {"code": "public static String euroUTCSystemDateString ( long timestamp ) { Calendar calendar = Calendar . getInstance ( ) ; calendar . setTimeInMillis ( timestamp ) ; calendar . setTimeZone ( UTC_TIME_ZONE ) ; int day = calendar . get ( Calendar . DAY_OF_MONTH ) ; int month = calendar . get ( Calendar . MONTH ) ; int year = calendar . get ( Calendar . YEAR ) ; int hour = calendar . get ( Calendar . HOUR_OF_DAY ) ; int minute = calendar . get ( Calendar . MINUTE ) ; int second = calendar . get ( Calendar . SECOND ) ; CharBuf buf = CharBuf . create ( 16 ) ; buf . add ( Str . zfill ( day , 2 ) ) . add ( ' ' ) ; buf . add ( Str . zfill ( month , 2 ) ) . add ( ' ' ) ; buf . add ( year ) . add ( ' ' ) ; buf . add ( Str . zfill ( hour , 2 ) ) . add ( ' ' ) ; buf . add ( Str . zfill ( minute , 2 ) ) . add ( ' ' ) ; buf . add ( Str . zfill ( second , 2 ) ) . add ( \"_utc_euro\" ) ; return buf . toString ( ) ; }", "nl": "Useful for generated file names and generated work directories ."}}
{"translation": {"code": "public List < ValidatorMetaData > readMetaData ( Class < ? > clazz , String propertyName ) { /* Generate a key to the cache based on the classname and the propertyName. */ String propertyKey = clazz . getName ( ) + \".\" + propertyName ; /* Look up the validation meta data in the cache. */ List < ValidatorMetaData > validatorMetaDataList = metaDataCache . get ( propertyKey ) ; /* If the meta-data was not found, then generate it. */ if ( validatorMetaDataList == null ) { // if not found\r validatorMetaDataList = extractValidatorMetaData ( clazz , propertyName , validatorMetaDataList ) ; /* Put it in the cache to avoid the processing in the future.\r\n             * Design notes: The processing does a lot of reflection, there\r\n             * is no need to do this each time.\r\n             */ metaDataCache . put ( propertyKey , validatorMetaDataList ) ; } return validatorMetaDataList ; }", "nl": "Read the meta - data from annotation . This copies the meta - data from the annotation into a POJO . It first checks the meta - data cache if the meta data is not found in the cache it then reads it from the class ."}}
{"translation": {"code": "private List < ValidatorMetaData > extractMetaDataFromAnnotations ( Collection < AnnotationData > annotations ) { List < ValidatorMetaData > list = new ArrayList < ValidatorMetaData > ( ) ; for ( AnnotationData annotationData : annotations ) { ValidatorMetaData validatorMetaData = convertAnnotationDataToValidatorMetaData ( annotationData ) ; list . add ( validatorMetaData ) ; } return list ; }", "nl": "Extract meta - data from the annotationData we collected thus far ."}}
{"translation": {"code": "public static String createToolTipWithNameSpace ( final String namespace , final String fieldName , final ResourceBundle bundle , final String toolTipType ) { String toolTip = null ; try { try { /** Look for name-space + . + fieldName, e.g., Employee.firstName.toolTip. */ toolTip = bundle . getString ( namespace + ' ' + fieldName + ' ' + toolTipType ) ; } catch ( MissingResourceException mre ) { /** Look for fieldName only, e.g., firstName.toolTip. */ toolTip = bundle . getString ( fieldName + ' ' + toolTipType ) ; } } catch ( MissingResourceException mre ) { } return toolTip ; }", "nl": "Get the tool tip ."}}
{"translation": {"code": "public static String generateLabelValue ( final String fieldName ) { final StringBuilder buffer = new StringBuilder ( fieldName . length ( ) * 2 ) ; class GenerationCommand { boolean capNextChar = false ; boolean lastCharWasUpperCase = false ; boolean lastCharWasNumber = false ; boolean lastCharWasSpecial = false ; boolean shouldContinue = true ; char [ ] chars = fieldName . toCharArray ( ) ; void processFieldName ( ) { for ( int index = 0 ; index < chars . length ; index ++ ) { char cchar = chars [ index ] ; shouldContinue = true ; processCharWasNumber ( buffer , index , cchar ) ; if ( ! shouldContinue ) { continue ; } processCharWasUpperCase ( buffer , index , cchar ) ; if ( ! shouldContinue ) { continue ; } processSpecialChars ( buffer , cchar ) ; if ( ! shouldContinue ) { continue ; } cchar = processCapitalizeCommand ( cchar ) ; cchar = processFirstCharacterCheck ( buffer , index , cchar ) ; if ( ! shouldContinue ) { continue ; } buffer . append ( cchar ) ; } } private void processCharWasNumber ( StringBuilder buffer , int index , char cchar ) { if ( lastCharWasSpecial ) { return ; } if ( Character . isDigit ( cchar ) ) { if ( index != 0 && ! lastCharWasNumber ) { buffer . append ( ' ' ) ; } lastCharWasNumber = true ; buffer . append ( cchar ) ; this . shouldContinue = false ; } else { lastCharWasNumber = false ; } } private char processFirstCharacterCheck ( final StringBuilder buffer , int index , char cchar ) { /* Always capitalize the first character. */ if ( index == 0 ) { cchar = Character . toUpperCase ( cchar ) ; buffer . append ( cchar ) ; this . shouldContinue = false ; } return cchar ; } private char processCapitalizeCommand ( char cchar ) { /* Capitalize the character. */ if ( capNextChar ) { capNextChar = false ; cchar = Character . toUpperCase ( cchar ) ; } return cchar ; } private void processSpecialChars ( final StringBuilder buffer , char cchar ) { lastCharWasSpecial = false ; /* If the character is '.' or '_' then append a space and mark\n                 * the next iteration to capitalize.\n\t\t\t\t */ if ( cchar == ' ' || cchar == ' ' ) { buffer . append ( ' ' ) ; capNextChar = true ; lastCharWasSpecial = false ; this . shouldContinue = false ; } } private void processCharWasUpperCase ( final StringBuilder buffer , int index , char cchar ) { /* If the character is uppercase, append a space and keep track\n                 * that the last character was uppercase for the next iteration.\n\t\t\t\t */ if ( Character . isUpperCase ( cchar ) ) { if ( index != 0 && ! lastCharWasUpperCase ) { buffer . append ( ' ' ) ; } lastCharWasUpperCase = true ; buffer . append ( cchar ) ; this . shouldContinue = false ; } else { lastCharWasUpperCase = false ; } } } GenerationCommand gc = new GenerationCommand ( ) ; gc . processFieldName ( ) ; /* This is a hack to get address.line_1 to work. */ return buffer . toString ( ) . replace ( \"  \" , \" \" ) ; }", "nl": "Generate the field . Transforms firstName into First Name . This allows reasonable defaults for labels ."}}
{"translation": {"code": "private FieldValidator lookupValidatorInRegistry ( String validationMetaDataName ) { Map < String , Object > applicationContext = ValidationContext . get ( ) . getObjectRegistry ( ) ; Exceptions . requireNonNull ( applicationContext ) ; return ( FieldValidator ) applicationContext . get ( \"/org/boon/validator/\" + validationMetaDataName ) ; }", "nl": "This method looks up the validator in the registry ."}}
{"translation": {"code": "private List < FieldValidator > lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties ( List < ValidatorMetaData > validationMetaDataList ) { List < FieldValidator > validatorsList = new ArrayList <> ( ) ; /*\n         * Look up the crank validators and then apply the properties from the\n         * validationMetaData to them.\n         */ for ( ValidatorMetaData validationMetaData : validationMetaDataList ) { /* Look up the FieldValidator. */ FieldValidator validator = lookupValidatorInRegistry ( validationMetaData . getName ( ) ) ; /*\n             * Apply the properties from the validationMetaData to the\n             * validator.\n             */ applyValidationMetaDataPropertiesToValidator ( validationMetaData , validator ) ; validatorsList . add ( validator ) ; } return validatorsList ; }", "nl": "Lookup the list of validators for the current field and initialize them with validation meta - data properties ."}}
{"translation": {"code": "private ValidatorMetaData convertAnnotationDataToValidatorMetaData ( AnnotationData annotationData ) { ValidatorMetaData metaData = new ValidatorMetaData ( ) ; metaData . setName ( annotationData . getName ( ) ) ; metaData . setProperties ( annotationData . getValues ( ) ) ; return metaData ; }", "nl": "Converts an AnnotationData into a ValidatorMetaData POJO ."}}
{"translation": {"code": "protected CompositeValidator createValidator ( List < ValidatorMetaData > validationMetaDataList ) { /*\n         * A field (property) can be associated with many validators so we use a\n         * CompositeValidator to hold all of the validators associated with this\n         * validator.\n         */ CompositeValidator compositeValidator = new CompositeValidator ( ) ; // hold // all // of // the // validators // associated // with // the // field. /*\n         * Lookup the list of validators for the current field and initialize\n         * them with validation meta-data properties.\n         */ List < FieldValidator > validatorsList = lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties ( validationMetaDataList ) ; compositeValidator . setValidatorList ( validatorsList ) ; return compositeValidator ; }", "nl": "Create the validator by looking it up in the ObjectRegistry and then populating it with values from the meta - data list ."}}
{"translation": {"code": "private List < ValidatorMetaData > extractMetaDataFromString ( Class < ? > clazz , String propertyName , String unparsedString ) { String propertyKey = clazz . getName ( ) + \".\" + propertyName ; /* See if we parsed this bad boy already. */ List < ValidatorMetaData > validatorMetaDataList = metaDataCache . get ( propertyKey ) ; /* If we did not find the list, then we have some work to do.*/ if ( validatorMetaDataList == null ) { /* Initialize a new list. */ validatorMetaDataList = new ArrayList < ValidatorMetaData > ( ) ; /* Remember we have a string that looks like this:\r\n             * required; length min=10, max=100\r\n             * So we need to split on semi-colon.\r\n             */ String [ ] validatorsParts = unparsedString . split ( \"[;]\" ) ; /* Now we have the two strings as follows:\r\n             *  [\"required\",\r\n             *  [\"length min=10, max=100\"]\r\n             *\r\n             */ for ( String validatorString : validatorsParts ) { ValidatorMetaData validatorMetaData = new ValidatorMetaData ( ) ; validatorMetaDataList . add ( validatorMetaData ) ; /* Now we split one of the string (we will use length) \r\n                 * as follows: \r\n                 * parts=[\"length\", \"min=10\", \"max=100\"]\r\n                 * */ String [ ] parts = validatorString . trim ( ) . split ( \"[ ,]\" ) ; /* The first part is the name of the validation, \r\n                 * e.g., \"length\".\r\n                 * \r\n                 */ validatorMetaData . setName ( parts [ 0 ] ) ; /* If the string has more than one part, then there must\r\n                 * be arguments as in: [\"min=10\", \"max=100\"]\r\n                 * \r\n                 * Parse the arguments and addObject them to the list as well.\r\n                 */ if ( parts . length > 1 ) { /* This line converts:\r\n                     * \r\n                     * [\"length\", \"min=10\", \"max=100\"]\r\n                     * \r\n                     * into: \r\n                     * \r\n                     * [\"min=10\", \"max=100\"]\r\n                     */ List < String > values = Arrays . asList ( parts ) . subList ( 1 , parts . length ) ; /* For each value convert it into name value pairs. */ for ( String value : values ) { if ( value . indexOf ( \"=\" ) != - 1 ) { /* Split \"min=10\" into [\"min\", \"10\"] */ String [ ] valueParts = value . split ( \"[=]\" ) ; /* Stick this value into validatorMetaData's\r\n                             * list of properties. \r\n                             */ validatorMetaData . getProperties ( ) . put ( valueParts [ 0 ] , valueParts [ 1 ] ) ; } } } } metaDataCache . put ( propertyKey , validatorMetaDataList ) ; } return validatorMetaDataList ; }", "nl": "This method extracts meta - data from a string ."}}
{"translation": {"code": "private static PropertyDescriptor doGetPropertyDescriptor ( final Class < ? > type , final String propertyName ) { try { BeanInfo beanInfo = Introspector . getBeanInfo ( type ) ; PropertyDescriptor [ ] propertyDescriptors = beanInfo . getPropertyDescriptors ( ) ; for ( PropertyDescriptor pd : propertyDescriptors ) { if ( pd . getName ( ) . equals ( propertyName ) ) { return pd ; } } Class < ? > superclass = type . getSuperclass ( ) ; if ( superclass != null ) { return doGetPropertyDescriptor ( superclass , propertyName ) ; } return null ; } catch ( Exception ex ) { throw new RuntimeException ( \"Unable to get property \" + propertyName + \" for class \" + type , ex ) ; } }", "nl": "This needs to be refactored and put into Reflection or something ."}}
{"translation": {"code": "private static Annotation [ ] findPropertyAnnotations ( Class < ? > clazz , String propertyName , boolean useRead ) throws IntrospectionException { PropertyDescriptor propertyDescriptor = getPropertyDescriptor ( clazz , propertyName ) ; if ( propertyDescriptor == null ) { return new Annotation [ ] { } ; } Method accessMethod = null ; if ( useRead ) { accessMethod = propertyDescriptor . getReadMethod ( ) ; } else { accessMethod = propertyDescriptor . getWriteMethod ( ) ; } if ( accessMethod != null ) { Annotation [ ] annotations = accessMethod . getAnnotations ( ) ; return annotations ; } else { return new Annotation [ ] { } ; } }", "nl": "Find annotation given a particular property name and clazz . This figures out the writeMethod for the property and uses the write method to look up the annotation ."}}
{"translation": {"code": "public static List < AnnotationData > extractValidationAnnotationData ( Annotation [ ] annotations , Set < String > allowedPackages ) { List < AnnotationData > annotationsList = new ArrayList <> ( ) ; for ( Annotation annotation : annotations ) { AnnotationData annotationData = new AnnotationData ( annotation , allowedPackages ) ; if ( annotationData . isAllowed ( ) ) { annotationsList . add ( annotationData ) ; } } return annotationsList ; }", "nl": "Create an annotation data list ."}}
{"translation": {"code": "private static Annotation [ ] extractAllAnnotationsForProperty ( Class < ? > clazz , String propertyName , boolean useRead ) { try { Annotation [ ] annotations = findPropertyAnnotations ( clazz , propertyName , useRead ) ; /* In the land of dynamic proxied AOP classes,\n             * this class could be a proxy. This seems like a bug\n             * waiting to happen. So far it has worked... */ if ( annotations . length == 0 ) { annotations = findPropertyAnnotations ( clazz . getSuperclass ( ) , propertyName , useRead ) ; } return annotations ; } catch ( Exception ex ) { return Exceptions . handle ( Annotation [ ] . class , sputs ( \"Unable to extract annotation for property\" , propertyName , \" of class \" , clazz , \"  useRead \" , useRead ) , ex ) ; } }", "nl": "Extract all annotation for a given property . Searches current class and if none found searches super class for annotation . We do this because the class could be proxied with AOP ."}}
{"translation": {"code": "private void ifPropertyBlankRemove ( Map < String , Object > properties , String property ) { Object object = properties . get ( property ) ; if ( object == null ) { properties . remove ( property ) ; } else if ( object instanceof String ) { String string = ( String ) object ; if ( \"\" . equals ( string . trim ( ) ) ) { properties . remove ( property ) ; } } }", "nl": "Removes a property if it is null or an empty string . This allows the property to have a null or emtpy string in the meta - data but we don t copy it to the validator if the property is not set ."}}
{"translation": {"code": "private void dynamicallyInitIfNeeded ( Object value ) { /* Check to see if this class was already initialized,\r\n         * if not, initialize it based on the type of the value.\r\n\t\t */ if ( ! isInitialized ( ) ) { if ( value instanceof Integer ) { init ( new Integer ( min . intValue ( ) ) , new Integer ( max . intValue ( ) ) ) ; } else if ( value instanceof Byte ) { init ( new Byte ( min . byteValue ( ) ) , new Byte ( max . byteValue ( ) ) ) ; } else if ( value instanceof Short ) { init ( new Short ( min . shortValue ( ) ) , new Short ( max . shortValue ( ) ) ) ; } else { init ( min , max ) ; } } }", "nl": "If the type was not initialized we can still figure it out at runtime ."}}
{"translation": {"code": "private List < ValidatorMetaData > extractValidatorMetaData ( Class < ? > clazz , String propertyName , List < ValidatorMetaData > validatorMetaDataList ) { /* If the meta-data was not found, then generate it. */ if ( validatorMetaDataList == null ) { // if not found\r /* Read the annotation from the class based on the property name. */ Collection < AnnotationData > annotations = Annotations . getAnnotationDataForFieldAndProperty ( clazz , propertyName , this . validationAnnotationPackages ) ; /* Extract the POJO based meta-data from the annotation. */ validatorMetaDataList = extractMetaDataFromAnnotations ( annotations ) ; } return validatorMetaDataList ; }", "nl": "Extract BaseValidator Meta Data ."}}
{"translation": {"code": "public List < ValidatorMetaData > readMetaData ( Class < ? > clazz , String propertyName ) { /* Load the properties file. */ Properties props = loadMetaDataPropsFile ( clazz ) ; /* Get the raw validation data for the given property. */ String unparsedString = props . getProperty ( propertyName ) ; /* Parse the string into a list of ValidationMetaData. */ return extractMetaDataFromString ( clazz , propertyName , unparsedString ) ; }", "nl": "Read the meta - data from a properties file ."}}
{"translation": {"code": "Map < String , Object > doGetValues ( Annotation annotation ) { /* Holds the value map. */ Map < String , Object > values = new HashMap < String , Object > ( ) ; /* Get the declared staticMethodMap from the actual annotation. */ Method [ ] methods = annotation . annotationType ( ) . getDeclaredMethods ( ) ; final Object [ ] noargs = ( Object [ ] ) null ; /* Iterate through declared staticMethodMap and extract values\n         * by invoking decalared staticMethodMap if they are no arg staticMethodMap.\n         */ for ( Method method : methods ) { /* If it is a no arg method assume it is an annoation value. */ if ( method . getParameterTypes ( ) . length == 0 ) { try { /* Get the value. */ Object value = method . invoke ( annotation , noargs ) ; if ( value instanceof Enum ) { Enum enumVal = ( Enum ) value ; value = enumVal . name ( ) ; } values . put ( method . getName ( ) , value ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } } } return values ; }", "nl": "Get the values from the annotation . We use reflection to turn the annotation into a simple HashMap of values ."}}
{"translation": {"code": "public String createMessage ( String key , List < String > argKeys , Object ... args ) { /* Look up the message. */ String message = getMessage ( key ) ; /* Holds the actual arguments. */ Object [ ] actualArgs ; /* If they passed arguments, \n         * then use this as the actual arguments. */ if ( args . length > 0 ) { actualArgs = args ; /* If they did not pass arguments, use the configured ones. */ } else if ( argKeys != null ) { /* Convert the keys to values. */ actualArgs = keysToValues ( argKeys ) ; } else { actualArgs = new Object [ ] { } ; } return doCreateMessage ( message , actualArgs ) ; }", "nl": "Creates a message ."}}
{"translation": {"code": "public void init ( ) { /* If the parent and name are equal to null,\n         * use the classname to load listFromClassLoader.\n    \t * */ if ( name == null && parent == null ) { this . setDetailMessage ( \"{\" + this . getClass ( ) . getName ( ) + DETAIL_KEY + \"}\" ) ; this . setSummaryMessage ( \"{\" + this . getClass ( ) . getName ( ) + SUMMARY_KEY + \"}\" ) ; /* If the parent is null and the name is not,\n         * use the name to load listFromClassLoader.\n         */ } else if ( name != null && parent == null ) { this . setDetailMessage ( \"{\" + \"message.\" + getName ( ) + DETAIL_KEY + \"}\" ) ; this . setSummaryMessage ( \"{\" + \"message.\" + getName ( ) + SUMMARY_KEY + \"}\" ) ; /* If the parent is present, initialize the message keys\n         * with the parent name.\n         */ } else if ( parent != null ) { this . setDetailMessage ( \"{\" + \"message.\" + parent + DETAIL_KEY + \"}\" ) ; this . setSummaryMessage ( \"{\" + \"message.\" + parent + SUMMARY_KEY + \"}\" ) ; } }", "nl": "The init method tries to generate the message keys . You should only call the init method if you don t inject values into the detailMessage and summaryMessage ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) private String doCreateMessage ( String message , Object [ ] actualArgs ) { return ValidationContext . get ( ) . createMessage ( message , getSubject ( ) , actualArgs ) ; }", "nl": "Actually creates the message ."}}
{"translation": {"code": "private Object [ ] keysToValues ( List < String > argKeys ) { List < String > values = new ArrayList <> ( ) ; for ( String key : argKeys ) { values . add ( getMessage ( key ) ) ; } return values . toArray ( ) ; }", "nl": "Convert the keys to values ."}}
{"translation": {"code": "private void applyValidationMetaDataPropertiesToValidator ( ValidatorMetaData metaData , FieldValidator validator ) { Map < String , Object > properties = metaData . getProperties ( ) ; ifPropertyBlankRemove ( properties , \"detailMessage\" ) ; ifPropertyBlankRemove ( properties , \"summaryMessage\" ) ; BeanUtils . copyProperties ( validator , properties ) ; }", "nl": "This method applies the properties from the validationMetaData to the validator uses Spring s BeanWrapperImpl ."}}
{"translation": {"code": "public String getSubject ( ) { return ValidationContext . get ( ) . getCurrentSubject ( ) == null ? this . subject : ValidationContext . get ( ) . getCurrentSubject ( ) ; }", "nl": "Gets the current subject or the configured subject if the current subject is not found ."}}
{"translation": {"code": "public static String [ ] splitByCharsNoneEmpty ( final String string , int start , int end , final char ... delimiters ) { Exceptions . requireNonNull ( string ) ; char [ ] [ ] comps = CharScanner . splitByCharsNoneEmpty ( FastStringUtils . toCharArray ( string ) , start , end , delimiters ) ; return Str . fromCharArrayOfArrayToStringArray ( comps ) ; }", "nl": "Split string by a list of delimiters but none are empty within a range"}}
{"translation": {"code": "private final int compareTime ( CacheEntry other ) { if ( time > other . time ) { //this time stamp is  greater so it has higher priority return 1 ; } else if ( time < other . time ) { //this time stamp is lower so it has lower priority return - 1 ; } else if ( time == other . time ) { //equal priority return 0 ; } die ( ) ; return 0 ; }", "nl": "Compare the time ."}}
{"translation": {"code": "@ Override public final int compareTo ( CacheEntry other ) { switch ( type ) { case LFU : return compareToLFU ( other ) ; case LRU : return compareToLRU ( other ) ; case FIFO : return compareToFIFO ( other ) ; default : die ( ) ; return 0 ; } }", "nl": "Comparison of entries this determines what we will order the cache by which determines which type of cache it is ."}}
{"translation": {"code": "@ Override public int size ( ) { int size = 0 ; for ( SimpleCache < K , V > cache : cacheRegions ) { size += cache . size ( ) ; } return size ; }", "nl": "Get the size of the cache . This is not 100% accurate if cache is being concurrenly accessed ."}}
{"translation": {"code": "@ Override public VALUE get ( KEY key ) { removeThenAddKey ( key ) ; return map . get ( key ) ; }", "nl": "Get the value at key"}}
{"translation": {"code": "private final int hash ( Object k ) { int h = hashSeed ; h ^= k . hashCode ( ) ; h ^= ( h >>> 20 ) ^ ( h >>> 12 ) ; return h ^ ( h >>> 7 ) ^ ( h >>> 4 ) ; }", "nl": "Calculate the hash ."}}
{"translation": {"code": "public VALUE get ( KEY key ) { CacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; if ( cacheEntry != null ) { cacheEntry . readCount . incrementAndGet ( ) ; return cacheEntry . value ; } else { return null ; } }", "nl": "Get the value from the cache . It does not touch the lock so reads are fast . This does not touch the order list so it is fast ."}}
{"translation": {"code": "public VALUE getSilent ( KEY key ) { CacheEntry < KEY , VALUE > cacheEntry = map . get ( key ) ; if ( cacheEntry != null ) { return cacheEntry . value ; } else { return null ; } }", "nl": "Used for testing as it gets the value without updating stats"}}
{"translation": {"code": "private final int order ( ) { int order = count . incrementAndGet ( ) ; if ( order > Integer . MAX_VALUE - 100 ) { count . set ( 0 ) ; } return order ; }", "nl": "Avoid overflow ."}}
{"translation": {"code": "private final void evictIfNeeded ( ) { if ( list . size ( ) > evictSize ) { final List < CacheEntry < KEY , VALUE > > killList = list . sortAndReturnPurgeList ( 0.1f ) ; for ( CacheEntry < KEY , VALUE > cacheEntry : killList ) { map . remove ( cacheEntry . key ) ; } } }", "nl": "Evict if we are over the size limit ."}}
{"translation": {"code": "private static Object getCollectionProp ( Object o , String propName , int index , String [ ] path ) { o = _getFieldValuesFromCollectionOrArray ( o , propName ) ; if ( index + 1 == path . length ) { return o ; } else { index ++ ; return getCollectionProp ( o , path [ index ] , index , path ) ; } }", "nl": "This is an amazing little recursive method . It walks a fanout of nested collection to pull out the leaf nodes"}}
{"translation": {"code": "public static Class < ? > getPropertyType ( final Object root , final String property ) { Map < String , FieldAccess > fields = getPropertyFieldAccessMap ( root . getClass ( ) ) ; FieldAccess field = fields . get ( property ) ; return field . type ( ) ; }", "nl": "Get property value loads nested properties"}}
{"translation": {"code": "public static int getPropertyInt ( final Object root , final String ... properties ) { final String lastProperty = properties [ properties . length - 1 ] ; if ( isDigits ( lastProperty ) ) { return Conversions . toInt ( getPropertyValue ( root , properties ) ) ; } Object object = baseForGetProperty ( root , properties ) ; Map < String , FieldAccess > fields = getFieldsFromObject ( object ) ; FieldAccess field = fields . get ( lastProperty ) ; if ( field . type ( ) == Typ . intgr ) { return field . getInt ( object ) ; } else { return Conversions . toInt ( field . getValue ( object ) ) ; } }", "nl": "Get an int property ."}}
{"translation": {"code": "public static Map < String , FieldAccess > getFieldsFromObject ( Object object ) { try { Map < String , FieldAccess > fields ; if ( object instanceof Map ) { fields = getFieldsFromMap ( ( Map < String , Object > ) object ) ; } else { fields = getPropertyFieldAccessMap ( object . getClass ( ) ) ; } return fields ; } catch ( Exception ex ) { requireNonNull ( object , \"Item cannot be null\" ) ; return handle ( Map . class , ex , \"Unable to get fields from object\" , className ( object ) ) ; } }", "nl": "Get fields from object or Map . Allows maps to act like they have fields ."}}
{"translation": {"code": "public static Object getProp ( Object object , final String property ) { if ( object == null ) { return null ; } if ( isDigits ( property ) ) { /* We can index numbers and names. */ object = idx ( object , StringScanner . parseInt ( property ) ) ; } Class < ? > cls = object . getClass ( ) ; /** Tries the getters first. */ Map < String , FieldAccess > fields = Reflection . getPropertyFieldAccessors ( cls ) ; if ( ! fields . containsKey ( property ) ) { fields = Reflection . getAllAccessorFields ( cls ) ; } if ( ! fields . containsKey ( property ) ) { return null ; } else { return fields . get ( property ) . getValue ( object ) ; } }", "nl": "This is one is forgiving of null paths . This works with getters first i . e . properties ."}}
{"translation": {"code": "@ Override public final Object get ( Object key ) { Object object = null ; /* if the map is null, then we create it. */ if ( map == null ) { buildMap ( ) ; } object = map . get ( key ) ; lazyChopIfNeeded ( object ) ; return object ; }", "nl": "Gets the item by key from the mapping ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T fromValueMap ( boolean respectIgnore , String view , final FieldsAccessor fieldsAccessor , final Map < String , Value > valueMap , final Class < T > cls , Set < String > ignoreSet ) { Mapper mapper = new MapperComplex ( fieldsAccessor , ignoreSet , view , respectIgnore ) ; return mapper . fromValueMap ( valueMap , cls ) ; }", "nl": "Creates an object from a value map ."}}
{"translation": {"code": "public CharSequence addHex ( final int decoded ) { int _location = location ; char [ ] _buffer = buffer ; int _capacity = capacity ; if ( 2 + _location > _capacity ) { _buffer = Chr . grow ( _buffer ) ; _capacity = _buffer . length ; } _buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( ( decoded >> 4 ) & 0x0F ) ; _location ++ ; _buffer [ _location ] = ( char ) encodeNibbleToHexAsciiCharByte ( decoded & 0x0F ) ; ; _location ++ ; location = _location ; buffer = _buffer ; capacity = _capacity ; return this ; }", "nl": "Turn a single bytes into two hex character representation ."}}
{"translation": {"code": "public Object parseText ( String text ) { if ( text == null || text . length ( ) == 0 ) { throw new IllegalArgumentException ( \"The JSON input text should neither be null nor empty.\" ) ; } return JsonFactory . create ( ) . fromJson ( text ) ; }", "nl": "Parse a text representation of a JSON data structure"}}
{"translation": {"code": "public static String removeChars ( final String string , final char ... delimiters ) { char [ ] [ ] comps = CharScanner . splitByCharsNoneEmpty ( FastStringUtils . toCharArray ( string ) , delimiters ) ; return new String ( Chr . add ( comps ) ) ; }", "nl": "remove chars from a string"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T fromMap ( Map < String , Object > map , Class < T > clazz , String ... excludeProperties ) { Set < String > ignoreProps = excludeProperties . length > 0 ? Sets . set ( excludeProperties ) : null ; return new MapperComplex ( FieldAccessMode . FIELD_THEN_PROPERTY . create ( false ) , ignoreProps , null , true ) . fromMap ( map , clazz ) ; }", "nl": "fromMap converts a map into a java object ."}}
{"translation": {"code": "public static boolean matches ( Object obj , Criteria ... exp ) { return ObjectFilter . and ( exp ) . test ( obj ) ; }", "nl": "Does the object match this expression . An expression is a collection of criteria ."}}
{"translation": {"code": "public static String getSortableField ( Object value1 ) { if ( value1 instanceof Map ) { return getSortableFieldFromMap ( ( Map < String , ? > ) value1 ) ; } else { return getSortableFieldFromClass ( value1 . getClass ( ) ) ; } }", "nl": "Gets the first sortable fields found ."}}
{"translation": {"code": "public static String getFirstComparableOrPrimitiveFromClass ( Class < ? > clz ) { List < Field > fields = Reflection . getAllFields ( clz ) ; for ( Field field : fields ) { if ( ( field . getType ( ) . isPrimitive ( ) || Typ . isComparable ( field . getType ( ) ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) ) { return field . getName ( ) ; } } return null ; }", "nl": "This can be used for default sort ."}}
{"translation": {"code": "public static boolean classHasField ( Class < ? > clz , String name ) { List < Field > fields = Reflection . getAllFields ( clz ) ; for ( Field field : fields ) { if ( field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { return true ; } } return false ; }", "nl": "Checks to see if a class has a field ."}}
{"translation": {"code": "public static boolean classHasStringField ( Class < ? > clz , String name ) { List < Field > fields = Reflection . getAllFields ( clz ) ; for ( Field field : fields ) { if ( field . getType ( ) . equals ( Typ . string ) && field . getName ( ) . equals ( name ) && ! Modifier . isStatic ( field . getModifiers ( ) ) && field . getDeclaringClass ( ) == clz ) { return true ; } } return false ; }", "nl": "Checks to see if this class has a string field ."}}
{"translation": {"code": "public static boolean hasStringField ( final Object value1 , final String name ) { Class < ? > clz = value1 . getClass ( ) ; return classHasStringField ( clz , name ) ; }", "nl": "Checks to see if we have a string field ."}}
{"translation": {"code": "public static Map < String , Object > toMap ( final Object object , Set < String > ignore ) { return new MapperComplex ( ignore ) . toMap ( object ) ; }", "nl": "This could be refactored to use core . TypeType class and it would run faster . Converts an object into a map"}}
{"translation": {"code": "@ Universal public static String atIndex ( String str , int index , char c ) { return idx ( str , index , c ) ; }", "nl": "Puts character at index"}}
{"translation": {"code": "public static Object invokeMethodFromObjectArg ( Object object , MethodAccess method , Object args ) { return invokeMethodFromObjectArg ( false , null , null , object , method , args ) ; }", "nl": "Invokes method from list or map depending on what the Object arg is ."}}
{"translation": {"code": "public static String [ ] splitBySpace ( String str ) { char [ ] [ ] split = CharScanner . splitBySpace ( FastStringUtils . toCharArray ( str ) ) ; return fromCharArrayOfArrayToStringArray ( split ) ; }", "nl": "Split a string by space"}}
{"translation": {"code": "public static boolean insideOf ( String start , String inStr , String end ) { return Chr . insideOf ( FastStringUtils . toCharArray ( start ) , FastStringUtils . toCharArray ( inStr ) , FastStringUtils . toCharArray ( end ) ) ; }", "nl": "Checks to see if a string is inside of another"}}
{"translation": {"code": "public static void sort ( List list , String sortBy , boolean ascending , boolean nullsFirst ) { if ( list == null || list . size ( ) == 0 ) { return ; } if ( sortBy . equals ( \"this\" ) ) { Collections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; return ; } Iterator iterator = list . iterator ( ) ; Object object = iterator . next ( ) ; Map < String , FieldAccess > fields = null ; if ( object != null ) { fields = BeanUtils . getFieldsFromObject ( object ) ; } else { while ( iterator . hasNext ( ) ) { object = iterator . next ( ) ; if ( object != null ) { fields = BeanUtils . getFieldsFromObject ( object ) ; break ; } } } if ( fields != null ) { final FieldAccess field = fields . get ( sortBy ) ; if ( field != null ) { Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; } } }", "nl": "Sort a list ."}}
{"translation": {"code": "@ Universal public static boolean in ( char [ ] chars , String str ) { return Chr . in ( chars , FastStringUtils . toCharArray ( str ) ) ; }", "nl": "See if chars is in another string"}}
{"translation": {"code": "public static Comparator universalComparator ( final FieldAccess field , final boolean ascending , final boolean nullsFirst ) { return new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { Object value1 = null ; Object value2 = null ; if ( ascending ) { value1 = field . getValue ( o1 ) ; value2 = field . getValue ( o2 ) ; } else { value1 = field . getValue ( o2 ) ; value2 = field . getValue ( o1 ) ; } return Sorting . compare ( value1 , value2 , nullsFirst ) ; } } ; }", "nl": "This creates the universal comparator object which is used by the sort work horse ."}}
{"translation": {"code": "public static Comparator thisUniversalComparator ( final boolean ascending , final boolean nullsFirst ) { return new Comparator ( ) { @ Override public int compare ( Object o1 , Object o2 ) { Object value1 ; Object value2 ; if ( ascending ) { value1 = ( o1 ) ; value2 = ( o2 ) ; } else { value1 = ( o2 ) ; value2 = ( o1 ) ; } return Sorting . compare ( value1 , value2 , nullsFirst ) ; } } ; }", "nl": "This creates the universal comparator object used for this ."}}
{"translation": {"code": "public static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending , boolean nullsFirst ) { try { /* If this list is null or empty, we have nothing to do so return. */ if ( list == null || list . size ( ) == 0 ) { return ; } /* Grab the first item in the list and see what it is. */ Object o = list . get ( 0 ) ; /* if the sort by string is is this, and the object is comparable then use the objects\n            themselves for the sort.\n             */ if ( sortBy . equals ( \"this\" ) ) { Collections . sort ( list , thisUniversalComparator ( ascending , nullsFirst ) ) ; return ; } /* If you did not sort by \"this\", then sort by the field. */ final FieldAccess field = fields . get ( sortBy ) ; if ( field != null ) { Collections . sort ( list , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; } } catch ( Exception ex ) { Exceptions . handle ( ex , \"list\" , list , \"\\nsortBy\" , sortBy , \"fields\" , fields , \"ascending\" , ascending , \"nullFirst\" , nullsFirst ) ; } }", "nl": "This is the work horse . It does all of the sorting work for the simple cases ."}}
{"translation": {"code": "public static void sort ( List list , String sortBy , Map < String , FieldAccess > fields , boolean ascending ) { sort ( list , sortBy , fields , ascending , false ) ; }", "nl": "This is the work horse . It does all of the sorting work for the simple cases . Nulls are last by default ."}}
{"translation": {"code": "public static < T > List < T > least ( List < T > list , int count ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list ) ; return Lists . sliceOf ( list , 0 , count ) ; } else { return null ; } }", "nl": "Returns the least few ."}}
{"translation": {"code": "public static < T > T max ( T [ ] array ) { if ( array . length > 1 ) { Sorting . sortDesc ( array ) ; return array [ 0 ] ; } else { return null ; } }", "nl": "Gets the max item from the array . Sorts the list descending first ."}}
{"translation": {"code": "public static < T > T min ( List < T > list ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list ) ; return list . get ( 0 ) ; } else { return null ; } }", "nl": "Returns the min value using a natural sort ."}}
{"translation": {"code": "public static < T > List < T > firstOf ( List < T > list , int count , Sort ... sorts ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list , sorts ) ; return Lists . sliceOf ( list , 0 , count ) ; } else { return null ; } }", "nl": "From the sorts this is the first few items ."}}
{"translation": {"code": "public static < T > List < T > lastOf ( List < T > list , int count , Sort ... sorts ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list , sorts ) ; return Lists . endSliceOf ( list , count * - 1 ) ; } else { return null ; } }", "nl": "Grabs the last few items from the list ."}}
{"translation": {"code": "public static < T > T lastOf ( List < T > list , Sort ... sorts ) { if ( list . size ( ) > 1 ) { Sorting . sort ( list , sorts ) ; return list . get ( list . size ( ) - 1 ) ; } else { return null ; } }", "nl": "Grabs the last items after the sort ."}}
{"translation": {"code": "public static void sort ( List list , Sort ... sorts ) { Sort . sorts ( sorts ) . sort ( list ) ; }", "nl": "Takes a list an an array or sorts"}}
{"translation": {"code": "public static < T > void sort ( T [ ] array , String sortBy , boolean ascending , boolean nullsFirst ) { if ( array == null || array . length == 0 ) { return ; } if ( sortBy . equals ( \"this\" ) ) { Arrays . sort ( array , thisUniversalComparator ( ascending , nullsFirst ) ) ; return ; } Object object = array [ 0 ] ; Map < String , FieldAccess > fields = null ; if ( object != null ) { fields = BeanUtils . getFieldsFromObject ( object ) ; } else { for ( int index = 1 ; index < array . length ; index ++ ) { object = array [ index ] ; if ( object != null ) { fields = BeanUtils . getFieldsFromObject ( object ) ; break ; } } } if ( fields != null ) { final FieldAccess field = fields . get ( sortBy ) ; if ( field != null ) { Arrays . sort ( array , Sorting . universalComparator ( field , ascending , nullsFirst ) ) ; } } }", "nl": "Sort an array ."}}
{"translation": {"code": "public static < T > T min ( T [ ] array , String sortBy ) { if ( array . length > 1 ) { Sorting . sort ( array , sortBy ) ; return array [ 0 ] ; } else { return null ; } }", "nl": "Returns the min value of the object with the property given ."}}
{"translation": {"code": "public static void injectIntoProperty ( Object object , String path , Object value ) { String [ ] properties = propertyPathAsStringArray ( path ) ; setPropertyValue ( object , value , properties ) ; }", "nl": "Set property value to simulate dependency injection ."}}
{"translation": {"code": "public static boolean equalsOrDie ( int expected , int got ) { if ( expected != got ) { return die ( Boolean . class , \"Expected was\" , expected , \"but we got \" , got ) ; } return true ; }", "nl": "Checks to see if two values are the same"}}
{"translation": {"code": "public static < K , V > Collection < Map . Entry < K , V > > sortEntries ( Class < V > componentType , Map < K , V > map , String sortBy , boolean ascending , boolean nullsFirst ) { return sort ( ( Class ) componentType , ( Collection ) map . entrySet ( ) , sortBy , ascending , nullsFirst ) ; }", "nl": "Sort map entries ."}}
{"translation": {"code": "public static < K , V > Collection < Map . Entry < K , V > > sortValues ( Class < V > componentType , Map < K , V > map , String sortBy , boolean ascending , boolean nullsFirst ) { return sort ( ( Class ) componentType , ( Collection ) map . values ( ) , sortBy , ascending , nullsFirst ) ; }", "nl": "Sort map values ."}}
{"translation": {"code": "public static < K , V > Collection < Map . Entry < K , V > > sortKeys ( Class < V > componentType , Map < K , V > map , String sortBy , boolean ascending , boolean nullsFirst ) { return sort ( ( Class ) componentType , ( Collection ) map . keySet ( ) , sortBy , ascending , nullsFirst ) ; }", "nl": "Sort map keys ."}}
{"translation": {"code": "public static boolean equalsOrDie ( int [ ] expected , int [ ] got ) { if ( expected . length != got . length ) { die ( \"Lengths did not match, expected length\" , expected . length , \"but got\" , got . length ) ; } for ( int index = 0 ; index < expected . length ; index ++ ) { if ( expected [ index ] != got [ index ] ) { die ( \"value at index did not match index\" , index , \"expected value\" , expected [ index ] , \"but got\" , got [ index ] ) ; } } return true ; }", "nl": "Checks to see if two arrays are equals"}}
{"translation": {"code": "@ Universal public static < V > List < V > deepCopy ( List < V > list ) { if ( list instanceof LinkedList ) { return deepCopyToList ( list , new LinkedList < V > ( ) ) ; } else if ( list instanceof CopyOnWriteArrayList ) { return deepCopyToList ( list , new CopyOnWriteArrayList < V > ( ) ) ; } else { return deepCopy ( ( Collection ) list ) ; } }", "nl": "Clones each list item into a new instance with copied fields . It is like doing a clone operation ."}}
{"translation": {"code": "public static int sum ( int [ ] values , int start , int length ) { long sum = 0 ; for ( int index = start ; index < length ; index ++ ) { sum += values [ index ] ; } if ( sum < Integer . MIN_VALUE ) { die ( \"overflow the sum is too small\" , sum ) ; } if ( sum > Integer . MAX_VALUE ) { die ( \"overflow the sum is too big\" , sum ) ; } return ( int ) sum ; }", "nl": "Sum Provides overflow protection ."}}
{"translation": {"code": "public static double meanDouble ( long [ ] values , final int start , final int length ) { double mean = ( ( double ) sum ( values , start , length ) ) / ( ( double ) length ) ; return mean ; }", "nl": "Used internally to avoid loss and rounding errors a bit ."}}
{"translation": {"code": "public static void idx ( Class < ? > cls , String path , Object value ) { String [ ] properties = propertyPathAsStringArray ( path ) ; setPropertyValue ( cls , value , properties ) ; }", "nl": "Set a static value"}}
{"translation": {"code": "public static double reduceBy ( final float [ ] array , ReduceBy reduceBy ) { double sum = 0 ; for ( float v : array ) { sum = reduceBy . reduce ( sum , v ) ; } return sum ; }", "nl": "A very fast reduce by . If performance is your thing this seems to be as fast a plain for loop when benchmarking with JMH ."}}
{"translation": {"code": "public boolean addArray ( double ... integers ) { if ( end + integers . length >= values . length ) { values = grow ( values , ( values . length + integers . length ) * 2 ) ; } System . arraycopy ( integers , 0 , values , end , integers . length ) ; end += integers . length ; return true ; }", "nl": "Add a new array to the list ."}}
{"translation": {"code": "private static < T > double reduceByR ( final double [ ] array , T object ) { try { Method method = Invoker . invokeReducerLongIntReturnLongMethod ( object ) ; double sum = 0 ; for ( double v : array ) { sum = ( double ) method . invoke ( object , sum , v ) ; } return sum ; } catch ( Throwable throwable ) { return handle ( Long . class , throwable , \"Unable to perform reduceBy\" ) ; } }", "nl": "Fallback to reflection if the call - site will not work or did not work"}}
{"translation": {"code": "public static double varianceDouble ( double [ ] values , final int start , final int length ) { double mean = mean ( values , start , length ) ; double temp = 0 ; for ( int index = start ; index < length ; index ++ ) { double a = values [ index ] ; temp += ( mean - a ) * ( mean - a ) ; } return temp / length ; }", "nl": "Calculate Variance ."}}
{"translation": {"code": "public static < T > double reduceBy ( final double [ ] array , T object ) { if ( object . getClass ( ) . isAnonymousClass ( ) ) { return reduceByR ( array , object ) ; } try { ConstantCallSite callSite = Invoker . invokeReducerLongIntReturnLongMethodHandle ( object ) ; MethodHandle methodHandle = callSite . dynamicInvoker ( ) ; try { double sum = 0 ; for ( double v : array ) { sum = ( double ) methodHandle . invokeExact ( sum , v ) ; } return sum ; } catch ( Throwable throwable ) { return handle ( Long . class , throwable , \"Unable to perform reduceBy\" ) ; } } catch ( Exception ex ) { return reduceByR ( array , object ) ; } }", "nl": "Reduce by functional support for int arrays ."}}
{"translation": {"code": "public static Criteria criteriaFromList ( List < ? > list ) { List < Object > args = new ArrayList ( list ) ; Object o = atIndex ( args , - 1 ) ; if ( ! ( o instanceof List ) ) { atIndex ( args , - 1 , Collections . singletonList ( o ) ) ; } return ( Criteria ) Invoker . invokeFromList ( ObjectFilter . class , \"createCriteriaFromClass\" , args ) ; }", "nl": "Creates criteria from a list . This is used to configure Criteria in JSON ."}}
{"translation": {"code": "public static int roundUpToPowerOf2 ( int number ) { int rounded = number >= 1_000 ? 1_000 : ( rounded = Integer . highestOneBit ( number ) ) != 0 ? ( Integer . bitCount ( number ) > 1 ) ? rounded << 1 : rounded : 1 ; return rounded ; }", "nl": "Round up to the nearest power of 2"}}
{"translation": {"code": "public static Criteria criteriaFromJson ( String json ) { return ( Criteria ) Invoker . invokeFromObject ( ObjectFilter . class , \"createCriteriaFromClass\" , fromJson ( json ) ) ; }", "nl": "Converts a JSON string into a Criteria ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T fromMap ( Map < String , Object > map , Class < T > clazz ) { return mapper . fromMap ( map , clazz ) ; }", "nl": "From map ."}}
{"translation": {"code": "public static Map < String , Object > toMap ( final Object object , final String ... ignore ) { return toMap ( object , Sets . set ( ignore ) ) ; }", "nl": "Basic toMap to create an object into a map ."}}
{"translation": {"code": "public static String [ ] split ( final String string , final char split , final int limit ) { char [ ] [ ] comps = CharScanner . split ( FastStringUtils . toCharArray ( string ) , split , limit ) ; return Str . fromCharArrayOfArrayToStringArray ( comps ) ; }", "nl": "Splits a string into many parts"}}
{"translation": {"code": "public static String addObjects ( Object ... objects ) { int length = 0 ; for ( Object obj : objects ) { if ( obj == null ) { continue ; } length += obj . toString ( ) . length ( ) ; } CharBuf builder = CharBuf . createExact ( length ) ; for ( Object str : objects ) { if ( str == null ) { continue ; } builder . add ( str . toString ( ) ) ; } return builder . toString ( ) ; }", "nl": "Add many objects converted to strings together . Null are ignored so be careful ."}}
{"translation": {"code": "public static String num ( Number count ) { if ( count == null ) { return \"\" ; } if ( count instanceof Double || count instanceof BigDecimal ) { String s = count . toString ( ) ; if ( idx ( s , 1 ) == ' ' && s . length ( ) > 7 ) { s = slc ( s , 0 , 5 ) ; return s ; } else { return s ; } } else if ( count instanceof Integer || count instanceof Long || count instanceof Short || count instanceof BigInteger ) { String s = count . toString ( ) ; s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; CharBuf buf = CharBuf . create ( s . length ( ) ) ; int index = 0 ; for ( char c : s . toCharArray ( ) ) { index ++ ; buf . add ( c ) ; if ( index % 3 == 0 ) { buf . add ( ' ' ) ; } } if ( buf . lastChar ( ) == ' ' ) { buf . removeLastChar ( ) ; } s = buf . toString ( ) ; s = new StringBuilder ( s ) . reverse ( ) . toString ( ) ; return s ; } return count . toString ( ) ; }", "nl": "Do a nice pretty print of a number . Add commas and such ."}}
{"translation": {"code": "public static int parseInt ( String buffer , int from , int to ) { return CharScanner . parseInt ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }", "nl": "parse an int within a range"}}
{"translation": {"code": "public static double parseDouble ( String buffer , int from , int to ) { return CharScanner . parseDouble ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }", "nl": "parse a double"}}
{"translation": {"code": "public static long parseLong ( String buffer , int from , int to ) { return CharScanner . parseLong ( FastStringUtils . toCharArray ( buffer ) , from , to ) ; }", "nl": "parse an long within a range"}}
{"translation": {"code": "public static String [ ] splitByWhiteSpace ( final String string ) { char [ ] [ ] comps = CharScanner . splitByChars ( FastStringUtils . toCharArray ( string ) , WHITE_SPACE ) ; return Str . fromCharArrayOfArrayToStringArray ( comps ) ; }", "nl": "Split string by white space"}}
{"translation": {"code": "@ Override public List < ? > toList ( Object object ) { TypeType instanceType = TypeType . getInstanceType ( object ) ; switch ( instanceType ) { case NULL : return Lists . list ( ( Object ) null ) ; case ARRAY : case ARRAY_INT : case ARRAY_BYTE : case ARRAY_SHORT : case ARRAY_FLOAT : case ARRAY_DOUBLE : case ARRAY_LONG : case ARRAY_STRING : case ARRAY_OBJECT : return Conversions . toList ( object ) ; case INSTANCE : if ( Reflection . respondsTo ( object , \"toList\" ) ) { return ( List < ? > ) Reflection . invoke ( object , \"toList\" ) ; } break ; } return Lists . list ( object ) ; }", "nl": "Convert an object to a list ."}}
{"translation": {"code": "private void setFieldValueFromMap ( final Object parentObject , final FieldAccess field , final Map mapInner ) { Class < ? > fieldClassType = field . type ( ) ; Object value = null ; /* Is the field not a map. */ if ( ! Typ . isMap ( fieldClassType ) ) { if ( ! fieldClassType . isInterface ( ) && ! Typ . isAbstract ( fieldClassType ) ) { value = fromMap ( mapInner , field . type ( ) ) ; } else { Object oClassName = mapInner . get ( \"class\" ) ; if ( oClassName != null ) { value = fromMap ( mapInner , Reflection . loadClass ( oClassName . toString ( ) ) ) ; } else { value = null ; } } /*\n           REFACTOR:\n           This is at least the third time that I have seen this code in the class.\n            It was either cut and pasted or I forgot I wrote it three times.\n           REFACTOR:\n             */ } else if ( Typ . isMap ( fieldClassType ) ) { Class keyType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 0 ] ; Class valueType = ( Class ) field . getParameterizedType ( ) . getActualTypeArguments ( ) [ 1 ] ; Set < Map . Entry > set = mapInner . entrySet ( ) ; Map newMap = new LinkedHashMap ( ) ; for ( Map . Entry entry : set ) { Object evalue = entry . getValue ( ) ; Object key = entry . getKey ( ) ; if ( evalue instanceof ValueContainer ) { evalue = ( ( ValueContainer ) evalue ) . toValue ( ) ; } key = Conversions . coerce ( keyType , key ) ; evalue = Conversions . coerce ( valueType , evalue ) ; newMap . put ( key , evalue ) ; } value = newMap ; } field . setValue ( parentObject , value ) ; }", "nl": "Inject a map into an object s field ."}}
{"translation": {"code": "@ Override public Object fromMap ( Map < String , Object > map ) { String clazz = ( String ) map . get ( \"class\" ) ; Class cls = Reflection . loadClass ( clazz ) ; return fromMap ( map , cls ) ; }", "nl": "fromMap converts a map into a Java object . This version will see if there is a class parameter in the map and dies if there is not ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) private void handleCollectionOfMaps ( Object newInstance , FieldAccess field , Collection < Map < String , Object > > collectionOfMaps ) { Collection < Object > newCollection = Conversions . createCollection ( field . type ( ) , collectionOfMaps . size ( ) ) ; Class < ? > componentClass = field . getComponentClass ( ) ; if ( componentClass != null ) { for ( Map < String , Object > mapComponent : collectionOfMaps ) { newCollection . add ( fromMap ( mapComponent , componentClass ) ) ; } field . setObject ( newInstance , newCollection ) ; } }", "nl": "Processes an collection of maps ."}}
{"translation": {"code": "private void processArrayOfMaps ( Object newInstance , FieldAccess field , Map < String , Object > [ ] maps ) { List < Map < String , Object > > list = Lists . list ( maps ) ; handleCollectionOfMaps ( newInstance , field , list ) ; }", "nl": "Processes an array of maps ."}}