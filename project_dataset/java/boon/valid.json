{"translation": {"code": "private Object doLookup ( String objectExpression , Object defaultValue , boolean searchChildren ) { if ( Str . isEmpty ( objectExpression ) ) { return defaultValue ; } char firstChar = Str . idx ( objectExpression , 0 ) ; char secondChar = Str . idx ( objectExpression , 1 ) ; char lastChar = Str . idx ( objectExpression , - 1 ) ; boolean escape = false ; switch ( firstChar ) { case ' ' : if ( lastChar == ' ' ) { objectExpression = slc ( objectExpression , 2 , - 1 ) ; } else { objectExpression = slc ( objectExpression , 1 ) ; } break ; case ' ' : if ( secondChar == ' ' && lastChar == ' ' ) { char thirdChar = Str . idx ( objectExpression , 2 ) ; if ( thirdChar == ' ' ) { escape = true ; objectExpression = slc ( objectExpression , 3 , - 3 ) ; } else { objectExpression = slc ( objectExpression , 2 , - 2 ) ; } } else { if ( lastChar == ' ' ) { return jsonParser . parse ( objectExpression ) ; } else { escape = true ; objectExpression = slc ( objectExpression , 1 ) ; } } break ; case ' ' : return jsonParser . parse ( objectExpression ) ; case ' ' : if ( secondChar == ' ' ) { String newExp = slc ( objectExpression , 2 ) ; return parent . doLookup ( newExp , newExp , false ) ; } } Object value ; lastChar = Str . idx ( objectExpression , - 1 ) ; if ( lastChar == ' ' ) { value = handleFunction ( objectExpression , searchChildren ) ; } else { value = findProperty ( objectExpression , searchChildren ) ; value = value == null ? defaultValue : value ; } if ( ! escape ) { return value ; } else { return StandardFunctions . escapeXml ( value ) ; } }", "nl": "Lookup an object and supply a default value ."}}
{"translation": {"code": "protected void createLoadAllVersionDataSQL ( String table ) { CharBuf buf = CharBuf . create ( 100 ) ; buf . add ( \"select kv_key, 1, version, update_timestamp, create_timestamp from `\" ) ; buf . add ( table ) ; buf . add ( \"` where kv_key in (\" ) ; buf . multiply ( \"?,\" , this . loadKeyCount ) ; buf . removeLastChar ( ) ; buf . add ( \");\" ) ; this . loadAllVersionDataByKeysSQL = buf . toString ( ) ; }", "nl": "Create load all keys SQL ."}}
{"translation": {"code": "private Options defaultOptions ( ) { Options options = new Options ( ) ; options . createIfMissing ( true ) ; options . blockSize ( 32_768 ) ; //32K options . cacheSize ( 67_108_864 ) ; //64MB return options ; }", "nl": "Configures default options ."}}
{"translation": {"code": "private boolean openDB ( File file , Options options ) { try { database = JniDBFactory . factory . open ( file , options ) ; logger . info ( \"Using JNI Level DB\" ) ; return true ; } catch ( IOException ex1 ) { try { database = Iq80DBFactory . factory . open ( file , options ) ; logger . info ( \"Using Java Level DB\" ) ; return false ; } catch ( IOException ex2 ) { return Exceptions . handle ( Boolean . class , ex2 ) ; } } }", "nl": "Opens the database"}}
{"translation": {"code": "@ Override public void putAll ( Map < byte [ ] , byte [ ] > values ) { WriteBatch batch = database . createWriteBatch ( ) ; try { for ( Map . Entry < byte [ ] , byte [ ] > entry : values . entrySet ( ) ) { batch . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } if ( putAllWriteCount . addAndGet ( values . size ( ) ) > 10_000 ) { putAllWriteCount . set ( 0 ) ; database . write ( batch , flush ) ; } else { database . write ( batch , writeOptions ) ; } } finally { closeBatch ( batch ) ; } }", "nl": "Puts values into the key value store in batch mode"}}
{"translation": {"code": "@ Override public Map < byte [ ] , byte [ ] > loadAllByKeys ( Collection < byte [ ] > keys ) { if ( keys == null || keys . size ( ) == 0 ) { return Collections . EMPTY_MAP ; } Map < byte [ ] , byte [ ] > results = new LinkedHashMap <> ( keys . size ( ) ) ; DBIterator iterator = null ; try { iterator = database . iterator ( ) ; iterator . seek ( keys . iterator ( ) . next ( ) ) ; while ( iterator . hasNext ( ) ) { final Map . Entry < byte [ ] , byte [ ] > next = iterator . next ( ) ; results . put ( next . getKey ( ) , next . getValue ( ) ) ; } } finally { try { if ( iterator != null ) { iterator . close ( ) ; } } catch ( IOException e ) { Exceptions . handle ( e ) ; } } return results ; }", "nl": "Keys are expected to be sorted"}}
{"translation": {"code": "@ Override public void close ( ) { try { flush ( ) ; database . close ( ) ; } catch ( Exception e ) { Exceptions . handle ( e ) ; } }", "nl": "Close the database connection ."}}
{"translation": {"code": "private void processReadQueue ( ) throws InterruptedException { ReadStatus readStatus = new ReadStatus ( ) ; while ( true ) { DataStoreRequest request = readOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; while ( request != null ) { readStatus . tracker . addCall ( request , outputDataQueue ) ; readOperationsBatch . add ( request ) ; if ( readOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { break ; } request = readOperationsQueue . poll ( ) ; } if ( readOperationsBatch . size ( ) > 0 ) { try { recievedReadBatch ( new ArrayList <> ( readOperationsBatch ) ) ; } finally { readOperationsBatch . clear ( ) ; } } else { flushReadsIfNeeded ( ) ; } if ( readStatus . readBatchSize . size ( ) > 1_000 ) { StatCount count ; final long now = Timer . timer ( ) . time ( ) ; count = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME USER  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadUserTime ( ) ) ; this . outputDataQueue . put ( count ) ; count = new StatCount ( now , DataStoreSource . SERVER , Action . GET_STATS , \"Thread TIME CPU  BaseDataStore \" + Thread . currentThread ( ) . getName ( ) , Sys . threadCPUTime ( ) ) ; this . outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.max\" , readStatus . readBatchSize . max ( ) ) ; outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.min\" , readStatus . readBatchSize . min ( ) ) ; outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.median\" , readStatus . readBatchSize . median ( ) ) ; outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.mean\" , readStatus . readBatchSize . mean ( ) ) ; outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.standardDeviation\" , readStatus . readBatchSize . standardDeviation ( ) ) ; outputDataQueue . put ( count ) ; count = new StatCount ( now , source , Action . GET , \"BaseDataStore readStatus.readBatchSize.variance\" , readStatus . readBatchSize . variance ( ) ) ; outputDataQueue . put ( count ) ; readStatus . readBatchSize . clear ( ) ; } } }", "nl": "Called from worker thread ."}}
{"translation": {"code": "private void processWriteQueue ( ) throws InterruptedException { WriteStatus status = new WriteStatus ( ) ; while ( true ) { DataStoreRequest operation = writeOperationsQueue . poll ( dataStoreConfig . pollTimeoutMS ( ) , TimeUnit . MILLISECONDS ) ; while ( operation != null ) { status . tracker . addCall ( operation , outputDataQueue ) ; writeOperationsBatch . add ( operation ) ; if ( writeOperationsBatch . size ( ) > dataStoreConfig . processQueueMaxBatchSize ( ) ) { break ; } operation = writeOperationsQueue . poll ( ) ; } if ( writeOperationsBatch . size ( ) > 0 ) { try { status . writeBatchSize . add ( writeOperationsBatch . size ( ) ) ; recievedWriteBatch ( new ArrayList <> ( writeOperationsBatch ) ) ; } finally { writeOperationsBatch . clear ( ) ; } } else { flushWritesIfNeeded ( ) ; } if ( status . writeBatchSize . size ( ) > 1000 ) { status . sendBatchSize ( source , outputDataQueue ) ; } } }", "nl": "Called from worker thread . Processes the incoming queue for read and writes ."}}
{"translation": {"code": "private void startMonitor ( ) { final ScheduledExecutorService monitor = Executors . newScheduledThreadPool ( 2 , new ThreadFactory ( ) { @ Override public Thread newThread ( Runnable runnable ) { Thread thread = new Thread ( runnable ) ; thread . setPriority ( Thread . NORM_PRIORITY + 1 ) ; return thread ; } } ) ; monitorFuture = monitor . scheduleAtFixedRate ( new Runnable ( ) { @ Override public void run ( ) { monitor ( ) ; } } , MONITOR_INTERVAL_SECONDS , MONITOR_INTERVAL_SECONDS , TimeUnit . SECONDS ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( new Runnable ( ) { @ Override public void run ( ) { System . err . println ( \"shutting down....\" ) ; monitor ( ) ; } } ) ) ; }", "nl": "Start up the health monitor ."}}
{"translation": {"code": "public void start ( final TimeAware receiver ) { //This starts itself up again every 1/2 second if something really bad //happens like disk full. As soon as the problem gets corrected //then things start working again...happy day.    Only // one is running per instance of CollectionManagerImpl. writerFuture = scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { @ Override public void run ( ) { processWrites ( ) ; } } , 0 , 500 , TimeUnit . MILLISECONDS ) ; startMonitor ( ) ; tickTock = this . scheduledExecutorService . scheduleAtFixedRate ( new Runnable ( ) { @ Override public void run ( ) { long time = System . nanoTime ( ) / 1_000_000 ; if ( receiver != null ) { receiver . tick ( time ) ; } tick ( time ) ; } } , 0 , 20 , TimeUnit . MILLISECONDS ) ; }", "nl": "Starts up the batch writer ."}}
{"translation": {"code": "public void nextBufferToWrite ( final ByteBuffer bufferOut ) throws InterruptedException { dirty = true ; final int size = bufferOut . limit ( ) ; write ( bufferOut ) ; /* only increment bytes transferred after a successful write. */ if ( ! error . get ( ) ) { totalBytesTransferred += size ; bytesTransferred += size ; bytesSinceLastFlush += size ; buffersSent ++ ; } if ( this . bytesTransferred >= FILE_SIZE_BYTES || fileTimeOut . get ( ) ) { try { outputStream . close ( ) ; } catch ( IOException e ) { cleanupOutputStream ( ) ; e . printStackTrace ( System . err ) ; } finally { outputStream = null ; } } }", "nl": "Writes a buffer of data to the log system ."}}
{"translation": {"code": "private void write ( final ByteBuffer bufferOut ) throws InterruptedException { initOutputStream ( ) ; try { if ( outputStream != null ) { outputStream . write ( bufferOut ) ; } else { error . set ( true ) ; } if ( bytesSinceLastFlush > FLUSH_EVERY_N_BYTES ) { syncToDisk ( ) ; bytesSinceLastFlush = 0 ; } } catch ( ClosedByInterruptException cbie ) { throw new InterruptedException ( \"File closed by interruption\" ) ; } catch ( Exception e ) { cleanupOutputStream ( ) ; error . set ( true ) ; e . printStackTrace ( System . err ) ; diagnose ( ) ; Exceptions . handle ( e ) ; } }", "nl": "Write the actual data to disk ."}}
{"translation": {"code": "private boolean determineIfWeShouldExit ( ) { boolean shouldStop = stop . get ( ) ; if ( ! shouldStop ) { Thread . interrupted ( ) ; } else { System . out . println ( \"Exiting processing loop as requested\" ) ; return true ; } return false ; }", "nl": "See if it is time to stop We have been interrupted . Should we ignore it or break out of the loop ."}}