{"translation": {"code": "private void createAndCloseGeoPackage ( GeoPackageDatabase db ) { GeoPackageConnection connection = new GeoPackageConnection ( db ) ; // Set the GeoPackage application id and user version connection . setApplicationId ( ) ; connection . setUserVersion ( ) ; // Create the minimum required tables GeoPackageTableCreator tableCreator = new GeoPackageTableCreator ( connection ) ; tableCreator . createRequired ( ) ; connection . close ( ) ; }", "nl": "Create the required GeoPackage application id and tables in the newly created and open database connection . Then close the connection ."}}
{"translation": {"code": "public void registerTable ( String tableName , GeoPackageCursorWrapper cursorWrapper ) { // Remove an existing cursor wrapper tableCursors . remove ( tableName ) ; // Add the wrapper tableCursors . put ( tableName , cursorWrapper ) ; String quotedTableName = CoreSQLUtils . quoteWrap ( tableName ) ; tableCursors . put ( quotedTableName , cursorWrapper ) ; // The Android android.database.sqlite.SQLiteDatabase findEditTable method // finds the new cursor edit table name based upon the first space or comma. // Fix (hopefully temporary) to wrap with the expected cursor type int spacePosition = tableName . indexOf ( ' ' ) ; if ( spacePosition > 0 ) { tableCursors . put ( tableName . substring ( 0 , spacePosition ) , cursorWrapper ) ; tableCursors . put ( quotedTableName . substring ( 0 , quotedTableName . indexOf ( ' ' ) ) , cursorWrapper ) ; } }", "nl": "Register a cursor wrapper for the provided table name . Database queries will wrap the returned cursor"}}
{"translation": {"code": "public static File getInternalFile ( Context context , String filePath ) { File internalFile = null ; if ( filePath != null ) { internalFile = new File ( context . getFilesDir ( ) , filePath ) ; } else { internalFile = context . getFilesDir ( ) ; } return internalFile ; }", "nl": "Get the internal storage file for the file path"}}
{"translation": {"code": "public static String getInternalFilePath ( Context context , String filePath ) { return getInternalFile ( context , filePath ) . getAbsolutePath ( ) ; }", "nl": "Get the internal storage patch for the file path"}}
{"translation": {"code": "public static GeoPackageManager getManager ( Context context ) { Thread . currentThread ( ) . setContextClassLoader ( GeoPackageManager . class . getClassLoader ( ) ) ; return new GeoPackageManagerImpl ( context ) ; }", "nl": "Get a GeoPackage Manager"}}
{"translation": {"code": "private TRow getCurrentRow ( ) { TRow row = null ; if ( table != null ) { int [ ] columnTypes = new int [ table . columnCount ( ) ] ; Object [ ] values = new Object [ table . columnCount ( ) ] ; boolean valid = true ; for ( TColumn column : table . getColumns ( ) ) { int index = column . getIndex ( ) ; int columnType = getType ( index ) ; if ( column . isPrimaryKey ( ) && columnType == FIELD_TYPE_NULL ) { valid = false ; } columnTypes [ index ] = columnType ; values [ index ] = getValue ( column ) ; } row = getRow ( columnTypes , values ) ; if ( ! valid ) { invalidPositions . add ( getPosition ( ) ) ; row . setValid ( false ) ; } } return row ; }", "nl": "Get the current row"}}
{"translation": {"code": "private void addExternalDatabases ( Collection < String > databases ) { // Get the external GeoPackages, adding those where the file exists and // deleting those with missing files List < GeoPackageMetadata > externalGeoPackages = getExternalGeoPackages ( ) ; for ( GeoPackageMetadata external : externalGeoPackages ) { if ( new File ( external . getExternalPath ( ) ) . exists ( ) ) { databases . add ( external . getName ( ) ) ; } else { delete ( external . getName ( ) ) ; } } }", "nl": "Add all external databases to the collection"}}
{"translation": {"code": "private void addInternalDatabases ( Collection < String > databases ) { String [ ] databaseArray = context . databaseList ( ) ; for ( String database : databaseArray ) { if ( ! isTemporary ( database ) && ! database . equalsIgnoreCase ( GeoPackageMetadataDb . DATABASE_NAME ) ) { databases . add ( database ) ; } } }", "nl": "Add all internal databases to the collection"}}
{"translation": {"code": "private boolean importGeoPackage ( String database , boolean override , InputStream geoPackageStream , GeoPackageProgress progress ) { try { if ( exists ( database ) ) { if ( override ) { if ( ! delete ( database ) ) { throw new GeoPackageException ( \"Failed to delete existing database: \" + database ) ; } } else { throw new GeoPackageException ( \"GeoPackage database already exists: \" + database ) ; } } // Copy the geopackage over as a database File newDbFile = context . getDatabasePath ( database ) ; try { SQLiteDatabase db = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null ) ; db . close ( ) ; GeoPackageIOUtils . copyStream ( geoPackageStream , newDbFile , progress ) ; } catch ( IOException e ) { throw new GeoPackageException ( \"Failed to import GeoPackage database: \" + database , e ) ; } } finally { GeoPackageIOUtils . closeQuietly ( geoPackageStream ) ; } if ( progress == null || progress . isActive ( ) ) { // Verify that the database is valid try { SQLiteDatabase sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , null , new DatabaseErrorHandler ( ) { @ Override public void onCorruption ( SQLiteDatabase dbObj ) { } } ) ; validateDatabaseAndClose ( sqlite , importHeaderValidation , importIntegrityValidation ) ; GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; metadataDb . open ( ) ; try { GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; // Save in metadata GeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; metadata . setName ( database ) ; dataSource . create ( metadata ) ; } finally { metadataDb . close ( ) ; } } catch ( Exception e ) { delete ( database ) ; throw new GeoPackageException ( \"Invalid GeoPackage database file\" , e ) ; } GeoPackage geoPackage = open ( database , false ) ; if ( geoPackage != null ) { try { if ( ! geoPackage . getSpatialReferenceSystemDao ( ) . isTableExists ( ) || ! geoPackage . getContentsDao ( ) . isTableExists ( ) ) { delete ( database ) ; throw new GeoPackageException ( \"Invalid GeoPackage database file. Does not contain required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; } } catch ( SQLException e ) { delete ( database ) ; throw new GeoPackageException ( \"Invalid GeoPackage database file. Could not verify existence of required tables: \" + SpatialReferenceSystem . TABLE_NAME + \" & \" + Contents . TABLE_NAME + \", Database: \" + database ) ; } finally { geoPackage . close ( ) ; } } else { delete ( database ) ; throw new GeoPackageException ( \"Unable to open GeoPackage database. Database: \" + database ) ; } } return exists ( database ) ; }", "nl": "Import the GeoPackage stream"}}
{"translation": {"code": "private GeoPackageMetadata getGeoPackageMetadata ( String database ) { GeoPackageMetadata metadata = null ; GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; metadataDb . open ( ) ; try { GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; metadata = dataSource . get ( database ) ; } finally { metadataDb . close ( ) ; } return metadata ; }", "nl": "Get the GeoPackage metadata"}}
{"translation": {"code": "public Bitmap drawTileQueryAll ( int x , int y , int zoom ) { BoundingBox boundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; Bitmap bitmap = null ; // Query for all features FeatureCursor cursor = featureDao . queryForAll ( ) ; try { int totalCount = cursor . getCount ( ) ; // Draw if at least one geometry exists if ( totalCount > 0 ) { if ( maxFeaturesPerTile == null || totalCount <= maxFeaturesPerTile ) { // Draw the tile bitmap bitmap = drawTile ( zoom , boundingBox , cursor ) ; } else if ( maxFeaturesTileDraw != null ) { // Draw the unindexed max features tile bitmap = maxFeaturesTileDraw . drawUnindexedTile ( tileWidth , tileHeight , totalCount , cursor ) ; } } } finally { cursor . close ( ) ; } return bitmap ; }", "nl": "Draw a tile bitmap from the x y and zoom level by querying all features . This could be very slow if there are a lot of features"}}
{"translation": {"code": "public byte [ ] drawTileBytes ( int x , int y , int zoom ) { Bitmap bitmap = drawTile ( x , y , zoom ) ; byte [ ] tileData = null ; // Convert the bitmap to bytes if ( bitmap != null ) { try { tileData = BitmapConverter . toBytes ( bitmap , compressFormat ) ; } catch ( IOException e ) { Log . e ( FeatureTiles . class . getSimpleName ( ) , \"Failed to create tile. x: \" + x + \", y: \" + y + \", zoom: \" + zoom , e ) ; } finally { bitmap . recycle ( ) ; } } return tileData ; }", "nl": "Draw the tile and get the bytes from the x y and zoom level"}}
{"translation": {"code": "public Bitmap drawTile ( int x , int y , int zoom ) { Bitmap bitmap ; if ( isIndexQuery ( ) ) { bitmap = drawTileQueryIndex ( x , y , zoom ) ; } else { bitmap = drawTileQueryAll ( x , y , zoom ) ; } return bitmap ; }", "nl": "Draw a tile bitmap from the x y and zoom level"}}
{"translation": {"code": "public void setPolygonPaint ( Paint polygonPaint ) { if ( polygonPaint == null ) { throw new AssertionError ( \"Polygon Paint can not be null\" ) ; } this . polygonPaint = polygonPaint ; setPolygonStrokeWidth ( polygonPaint . getStrokeWidth ( ) ) ; }", "nl": "Set the polygon paint"}}
{"translation": {"code": "public void setLinePaint ( Paint linePaint ) { if ( linePaint == null ) { throw new AssertionError ( \"Line Paint can not be null\" ) ; } this . linePaint = linePaint ; setLineStrokeWidth ( linePaint . getStrokeWidth ( ) ) ; }", "nl": "Set the line paint"}}
{"translation": {"code": "public void calculateDrawOverlap ( ) { if ( pointIcon != null ) { heightOverlap = this . density * pointIcon . getHeight ( ) ; widthOverlap = this . density * pointIcon . getWidth ( ) ; } else { heightOverlap = this . density * pointRadius ; widthOverlap = this . density * pointRadius ; } float linePaintHalfStroke = this . density * lineStrokeWidth / 2.0f ; heightOverlap = Math . max ( heightOverlap , linePaintHalfStroke ) ; widthOverlap = Math . max ( widthOverlap , linePaintHalfStroke ) ; float polygonPaintHalfStroke = this . density * polygonStrokeWidth / 2.0f ; heightOverlap = Math . max ( heightOverlap , polygonPaintHalfStroke ) ; widthOverlap = Math . max ( widthOverlap , polygonPaintHalfStroke ) ; if ( featureTableStyles != null && featureTableStyles . has ( ) ) { // Style Rows Set < Long > styleRowIds = new HashSet <> ( ) ; List < Long > tableStyleIds = featureTableStyles . getAllTableStyleIds ( ) ; if ( tableStyleIds != null ) { styleRowIds . addAll ( tableStyleIds ) ; } List < Long > styleIds = featureTableStyles . getAllStyleIds ( ) ; if ( styleIds != null ) { styleRowIds . addAll ( styleIds ) ; } StyleDao styleDao = featureTableStyles . getStyleDao ( ) ; for ( long styleRowId : styleRowIds ) { StyleRow styleRow = styleDao . getRow ( styleDao . queryForIdRow ( styleRowId ) ) ; float styleHalfWidth = this . density * ( float ) ( styleRow . getWidthOrDefault ( ) / 2.0f ) ; widthOverlap = Math . max ( widthOverlap , styleHalfWidth ) ; heightOverlap = Math . max ( heightOverlap , styleHalfWidth ) ; } // Icon Rows Set < Long > iconRowIds = new HashSet <> ( ) ; List < Long > tableIconIds = featureTableStyles . getAllTableIconIds ( ) ; if ( tableIconIds != null ) { iconRowIds . addAll ( tableIconIds ) ; } List < Long > iconIds = featureTableStyles . getAllIconIds ( ) ; if ( iconIds != null ) { iconRowIds . addAll ( iconIds ) ; } IconDao iconDao = featureTableStyles . getIconDao ( ) ; for ( long iconRowId : iconRowIds ) { IconRow iconRow = iconDao . getRow ( iconDao . queryForIdRow ( iconRowId ) ) ; double [ ] iconDimensions = iconRow . getDerivedDimensions ( ) ; float iconWidth = this . density * ( float ) Math . ceil ( iconDimensions [ 0 ] ) ; float iconHeight = this . density * ( float ) Math . ceil ( iconDimensions [ 1 ] ) ; widthOverlap = Math . max ( widthOverlap , iconWidth ) ; heightOverlap = Math . max ( heightOverlap , iconHeight ) ; } } }", "nl": "Call after making changes to the point icon point radius or paint stroke widths . Determines the pixel overlap between tiles"}}
{"translation": {"code": "private void adjustGeoPackageBoundsWGS84 ( BoundingBox boundingBox , int zoom ) { // Get the fitting tile grid and determine the bounding box that fits it TileGrid tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( boundingBox , zoom ) ; tileGridBoundingBox = TileBoundingBoxUtils . getWGS84BoundingBox ( tileGrid , zoom ) ; matrixWidth = tileGrid . getMaxX ( ) + 1 - tileGrid . getMinX ( ) ; matrixHeight = tileGrid . getMaxY ( ) + 1 - tileGrid . getMinY ( ) ; }", "nl": "Adjust the tile matrix set and WGS84 bounds for GeoPackage format . Determine the tile grid width and height"}}
{"translation": {"code": "public void setBitmapCompressionConfig ( Config config ) { if ( options == null ) { options = new Options ( ) ; } options . inPreferredConfig = config ; }", "nl": "Set the Bitmap Compress Config"}}
{"translation": {"code": "public int getTileCount ( ) { if ( tileCount == null ) { long count = 0 ; boolean degrees = projection . isUnit ( Units . DEGREES ) ; ProjectionTransform transformToWebMercator = null ; if ( ! degrees ) { transformToWebMercator = projection . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; } for ( int zoom = minZoom ; zoom <= maxZoom ; zoom ++ ) { BoundingBox expandedBoundingBox = getBoundingBox ( zoom ) ; // Get the tile grid that includes the entire bounding box TileGrid tileGrid = null ; if ( degrees ) { tileGrid = TileBoundingBoxUtils . getTileGridWGS84 ( expandedBoundingBox , zoom ) ; } else { tileGrid = TileBoundingBoxUtils . getTileGrid ( expandedBoundingBox . transform ( transformToWebMercator ) , zoom ) ; } count += tileGrid . count ( ) ; tileGrids . put ( zoom , tileGrid ) ; tileBounds . put ( zoom , expandedBoundingBox ) ; } tileCount = ( int ) Math . min ( count , Integer . MAX_VALUE ) ; } return tileCount ; }", "nl": "Get the tile count of tiles to be generated"}}
{"translation": {"code": "private void adjustBounds ( BoundingBox boundingBox , int zoom ) { // Google Tile Format if ( googleTiles ) { adjustGoogleBounds ( ) ; } else if ( projection . isUnit ( Units . DEGREES ) ) { adjustGeoPackageBoundsWGS84 ( boundingBox , zoom ) ; } else { adjustGeoPackageBounds ( boundingBox , zoom ) ; } }", "nl": "Adjust the tile matrix set and bounds"}}
{"translation": {"code": "private void adjustGoogleBounds ( ) { // Set the tile matrix set bounding box to be the world BoundingBox standardWgs84Box = new BoundingBox ( - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH , ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE , ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH , ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE ) ; ProjectionTransform wgs84ToWebMercatorTransform = ProjectionFactory . getProjection ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) . getTransformation ( ProjectionConstants . EPSG_WEB_MERCATOR ) ; tileGridBoundingBox = standardWgs84Box . transform ( wgs84ToWebMercatorTransform ) ; }", "nl": "Adjust the tile matrix set and web mercator bounds for Google tile format"}}
{"translation": {"code": "private void adjustGeoPackageBounds ( BoundingBox requestWebMercatorBoundingBox , int zoom ) { // Get the fitting tile grid and determine the bounding box that // fits it TileGrid tileGrid = TileBoundingBoxUtils . getTileGrid ( requestWebMercatorBoundingBox , zoom ) ; tileGridBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( tileGrid , zoom ) ; matrixWidth = tileGrid . getMaxX ( ) + 1 - tileGrid . getMinX ( ) ; matrixHeight = tileGrid . getMaxY ( ) + 1 - tileGrid . getMinY ( ) ; }", "nl": "Adjust the tile matrix set and web mercator bounds for GeoPackage format . Determine the tile grid width and height"}}
{"translation": {"code": "public int update ( ContentValues values , String whereClause , String [ ] whereArgs ) { return db . update ( getTableName ( ) , values , whereClause , whereArgs ) ; }", "nl": "Update all rows matching the where clause with the provided values"}}
{"translation": {"code": "public static GeometryMetadata createGeometryMetadata ( Cursor cursor ) { GeometryMetadata metadata = new GeometryMetadata ( ) ; metadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; metadata . setTableName ( cursor . getString ( 1 ) ) ; metadata . setId ( cursor . getLong ( 2 ) ) ; metadata . setMinX ( cursor . getDouble ( 3 ) ) ; metadata . setMaxX ( cursor . getDouble ( 4 ) ) ; metadata . setMinY ( cursor . getDouble ( 5 ) ) ; metadata . setMaxY ( cursor . getDouble ( 6 ) ) ; if ( ! cursor . isNull ( 7 ) ) { metadata . setMinZ ( cursor . getDouble ( 7 ) ) ; } if ( ! cursor . isNull ( 8 ) ) { metadata . setMaxZ ( cursor . getDouble ( 8 ) ) ; } if ( ! cursor . isNull ( 9 ) ) { metadata . setMinM ( cursor . getDouble ( 9 ) ) ; } if ( ! cursor . isNull ( 10 ) ) { metadata . setMaxM ( cursor . getDouble ( 10 ) ) ; } return metadata ; }", "nl": "Create a geometry metadata from the current cursor location"}}
{"translation": {"code": "public int deleteTile ( long column , long row , long zoomLevel ) { StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( TileTable . COLUMN_TILE_COLUMN , column ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( TileTable . COLUMN_TILE_ROW , row ) ) ; String [ ] whereArgs = buildWhereArgs ( new Object [ ] { zoomLevel , column , row } ) ; int deleted = delete ( where . toString ( ) , whereArgs ) ; return deleted ; }", "nl": "Delete a Tile"}}
{"translation": {"code": "public boolean createOrUpdate ( GeometryMetadata metadata ) { boolean success = false ; if ( exists ( metadata ) ) { success = update ( metadata ) ; } else { create ( metadata ) ; success = true ; } return success ; }", "nl": "Create the geometry metadata or update if it already exists"}}
{"translation": {"code": "public TileRow queryForTile ( long column , long row , long zoomLevel ) { Map < String , Object > fieldValues = new HashMap < String , Object > ( ) ; fieldValues . put ( TileTable . COLUMN_TILE_COLUMN , column ) ; fieldValues . put ( TileTable . COLUMN_TILE_ROW , row ) ; fieldValues . put ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; TileCursor cursor = queryForFieldValues ( fieldValues ) ; TileRow tileRow = null ; try { if ( cursor . moveToNext ( ) ) { tileRow = cursor . getRow ( ) ; } } finally { cursor . close ( ) ; } return tileRow ; }", "nl": "Query for a Tile"}}
{"translation": {"code": "public TileCursor queryForTileDescending ( long zoomLevel ) { return queryForEq ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel , null , null , TileTable . COLUMN_TILE_ROW + \" DESC, \" + TileTable . COLUMN_TILE_COLUMN + \" DESC\" ) ; }", "nl": "Query for Tiles at a zoom level in descending row and column order"}}
{"translation": {"code": "public int delete ( long geoPackageId ) { String whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + \" = ?\" ; String [ ] whereArgs = new String [ ] { String . valueOf ( geoPackageId ) } ; int deleteCount = db . delete ( GeometryMetadata . TABLE_NAME , whereClause , whereArgs ) ; return deleteCount ; }", "nl": "Delete geometry metadata by database"}}
{"translation": {"code": "public int count ( long zoomLevel ) { String where = buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; String [ ] whereArgs = buildWhereArgs ( zoomLevel ) ; return count ( where , whereArgs ) ; }", "nl": "Count of Tiles at a zoom level"}}
{"translation": {"code": "public boolean isGoogleTiles ( ) { // Convert the bounding box to wgs84 BoundingBox boundingBox = tileMatrixSet . getBoundingBox ( ) ; BoundingBox wgs84BoundingBox = boundingBox . transform ( projection . getTransformation ( ProjectionConstants . EPSG_WORLD_GEODETIC_SYSTEM ) ) ; boolean googleTiles = false ; // Verify the bounds are the entire world if ( wgs84BoundingBox . getMinLatitude ( ) <= ProjectionConstants . WEB_MERCATOR_MIN_LAT_RANGE && wgs84BoundingBox . getMaxLatitude ( ) >= ProjectionConstants . WEB_MERCATOR_MAX_LAT_RANGE && wgs84BoundingBox . getMinLongitude ( ) <= - ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH && wgs84BoundingBox . getMaxLongitude ( ) >= ProjectionConstants . WGS84_HALF_WORLD_LON_WIDTH ) { googleTiles = true ; // Verify each tile matrix is the correct width and height for ( TileMatrix tileMatrix : tileMatrices ) { long zoomLevel = tileMatrix . getZoomLevel ( ) ; long tilesPerSide = TileBoundingBoxUtils . tilesPerSide ( ( int ) zoomLevel ) ; if ( tileMatrix . getMatrixWidth ( ) != tilesPerSide || tileMatrix . getMatrixHeight ( ) != tilesPerSide ) { googleTiles = false ; break ; } } } return googleTiles ; }", "nl": "Determine if the tiles are in the Google tile coordinate format"}}
{"translation": {"code": "public GeometryMetadata populate ( long geoPackageId , String tableName , long geomId , GeometryEnvelope envelope ) { GeometryMetadata metadata = new GeometryMetadata ( ) ; metadata . setGeoPackageId ( geoPackageId ) ; metadata . setTableName ( tableName ) ; metadata . setId ( geomId ) ; metadata . setMinX ( envelope . getMinX ( ) ) ; metadata . setMaxX ( envelope . getMaxX ( ) ) ; metadata . setMinY ( envelope . getMinY ( ) ) ; metadata . setMaxY ( envelope . getMaxY ( ) ) ; if ( envelope . hasZ ( ) ) { metadata . setMinZ ( envelope . getMinZ ( ) ) ; metadata . setMaxZ ( envelope . getMaxZ ( ) ) ; } if ( envelope . hasM ( ) ) { metadata . setMinM ( envelope . getMinM ( ) ) ; metadata . setMaxM ( envelope . getMaxM ( ) ) ; } return metadata ; }", "nl": "Populate a new geometry metadata from an envelope"}}
{"translation": {"code": "public long create ( GeometryMetadata metadata ) { ContentValues values = new ContentValues ( ) ; values . put ( GeometryMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; values . put ( GeometryMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; values . put ( GeometryMetadata . COLUMN_ID , metadata . getId ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; long insertId = db . insert ( GeometryMetadata . TABLE_NAME , null , values ) ; if ( insertId == - 1 ) { throw new GeoPackageException ( \"Failed to insert geometry metadata. GeoPackage Id: \" + metadata . getGeoPackageId ( ) + \", Table Name: \" + metadata . getTableName ( ) + \", Geometry Id: \" + metadata . getId ( ) ) ; } metadata . setId ( insertId ) ; return insertId ; }", "nl": "Create a new geometry metadata"}}
{"translation": {"code": "public boolean update ( GeometryMetadata metadata ) { String whereClause = GeometryMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + GeometryMetadata . COLUMN_TABLE_NAME + \" = ? AND \" + GeometryMetadata . COLUMN_ID + \" = ?\" ; String [ ] whereArgs = new String [ ] { String . valueOf ( metadata . getGeoPackageId ( ) ) , metadata . getTableName ( ) , String . valueOf ( metadata . getId ( ) ) } ; ContentValues values = new ContentValues ( ) ; values . put ( GeometryMetadata . COLUMN_MIN_X , metadata . getMinX ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_X , metadata . getMaxX ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_Y , metadata . getMinY ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_Y , metadata . getMaxY ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_Z , metadata . getMinZ ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_Z , metadata . getMaxZ ( ) ) ; values . put ( GeometryMetadata . COLUMN_MIN_M , metadata . getMinM ( ) ) ; values . put ( GeometryMetadata . COLUMN_MAX_M , metadata . getMaxM ( ) ) ; int updateCount = db . update ( GeometryMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; return updateCount > 0 ; }", "nl": "Update the geometry metadata"}}
{"translation": {"code": "private void updateLastIndexed ( GeoPackageMetadataDb db , long geoPackageId ) { long indexedTime = ( new Date ( ) ) . getTime ( ) ; TableMetadataDataSource ds = new TableMetadataDataSource ( db ) ; if ( ! ds . updateLastIndexed ( geoPackageId , featureDao . getTableName ( ) , indexedTime ) ) { throw new GeoPackageException ( \"Failed to update last indexed time. Table: GeoPackage Id: \" + geoPackageId + \", Table: \" + featureDao . getTableName ( ) + \", Last Indexed: \" + indexedTime ) ; } }", "nl": "Update the least indexed time"}}
{"translation": {"code": "private GeoPackageMetadata createGeoPackageMetadata ( Cursor cursor ) { GeoPackageMetadata metadata = new GeoPackageMetadata ( ) ; metadata . setId ( cursor . getLong ( 0 ) ) ; metadata . setName ( cursor . getString ( 1 ) ) ; metadata . setExternalPath ( cursor . getString ( 2 ) ) ; return metadata ; }", "nl": "Create a GeoPackage metadata from the current cursor location"}}
{"translation": {"code": "public FeatureRow getFeatureRow ( GeometryMetadata geometryMetadata ) { long geomId = geometryMetadata . getId ( ) ; // Get the row or lock for reading FeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; if ( row == null ) { // Query for the row and set in the sync try { row = featureDao . queryForIdRow ( geomId ) ; } finally { featureRowSync . setRow ( geomId , row ) ; } } return row ; }", "nl": "Get the feature row for the Geometry Metadata"}}
{"translation": {"code": "public boolean isExternal ( String database ) { GeoPackageMetadata metadata = get ( database ) ; return get ( database ) != null && metadata . getExternalPath ( ) != null ; }", "nl": "Determine if the GeoPackage is external"}}
{"translation": {"code": "public GeoPackageMetadata getOrCreate ( String geoPackage ) { GeoPackageMetadata metadata = get ( geoPackage ) ; if ( metadata == null ) { metadata = new GeoPackageMetadata ( ) ; metadata . setName ( geoPackage ) ; create ( metadata ) ; } return metadata ; }", "nl": "Get GeoPackage metadata or create it if it does not exist"}}
{"translation": {"code": "public GeoPackageMetadata get ( long id ) { GeoPackageMetadata metadata = null ; String selection = GeoPackageMetadata . COLUMN_ID + \" = ?\" ; String [ ] selectionArgs = new String [ ] { String . valueOf ( id ) } ; Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; try { if ( cursor . moveToNext ( ) ) { metadata = createGeoPackageMetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }", "nl": "Get GeoPackage metadata by id"}}
{"translation": {"code": "public GeoPackageMetadata get ( String database ) { GeoPackageMetadata metadata = null ; String selection = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; String [ ] selectionArgs = new String [ ] { database } ; Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; try { if ( cursor . moveToNext ( ) ) { metadata = createGeoPackageMetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }", "nl": "Get GeoPackage metadata by name"}}
{"translation": {"code": "public List < GeoPackageMetadata > getAll ( ) { List < GeoPackageMetadata > allMetadata = new ArrayList < GeoPackageMetadata > ( ) ; Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , null , null , null , null , null ) ; try { while ( cursor . moveToNext ( ) ) { GeoPackageMetadata metadata = createGeoPackageMetadata ( cursor ) ; allMetadata . add ( metadata ) ; } } finally { cursor . close ( ) ; } return allMetadata ; }", "nl": "Get all GeoPackage metadata"}}
{"translation": {"code": "public boolean rename ( String name , String newName ) { String whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; String [ ] whereArgs = new String [ ] { name } ; ContentValues values = new ContentValues ( ) ; values . put ( GeoPackageMetadata . COLUMN_NAME , newName ) ; int updateCount = db . update ( GeoPackageMetadata . TABLE_NAME , values , whereClause , whereArgs ) ; return updateCount > 0 ; }", "nl": "Rename the GeoPackage name to the new name"}}
{"translation": {"code": "public boolean rename ( GeoPackageMetadata metadata , String newName ) { boolean renamed = rename ( metadata . getName ( ) , newName ) ; if ( renamed ) { metadata . setName ( newName ) ; } return renamed ; }", "nl": "Rename the GeoPackage metadata to the new name"}}
{"translation": {"code": "public boolean delete ( String database ) { GeoPackageMetadata metadata = get ( database ) ; if ( metadata != null ) { TableMetadataDataSource tableDs = new TableMetadataDataSource ( db ) ; tableDs . delete ( metadata . getId ( ) ) ; } String whereClause = GeoPackageMetadata . COLUMN_NAME + \" = ?\" ; String [ ] whereArgs = new String [ ] { database } ; int deleteCount = db . delete ( GeoPackageMetadata . TABLE_NAME , whereClause , whereArgs ) ; return deleteCount > 0 ; }", "nl": "Delete the database"}}
{"translation": {"code": "public void create ( GeoPackageMetadata metadata ) { ContentValues values = new ContentValues ( ) ; values . put ( GeoPackageMetadata . COLUMN_NAME , metadata . getName ( ) ) ; values . put ( GeoPackageMetadata . COLUMN_EXTERNAL_PATH , metadata . getExternalPath ( ) ) ; long insertId = db . insert ( GeoPackageMetadata . TABLE_NAME , null , values ) ; if ( insertId == - 1 ) { throw new GeoPackageException ( \"Failed to insert GeoPackage metadata. Name: \" + metadata . getName ( ) + \", External Path: \" + metadata . getExternalPath ( ) ) ; } metadata . setId ( insertId ) ; }", "nl": "Create a new GeoPackage metadata"}}
{"translation": {"code": "public Bitmap drawTileQueryIndex ( int x , int y , int zoom ) { // Get the web mercator bounding box BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; Bitmap bitmap = null ; // Query for geometries matching the bounds in the index FeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; try { long tileCount = results . count ( ) ; // Draw if at least one geometry exists if ( tileCount > 0 ) { if ( maxFeaturesPerTile == null || tileCount <= maxFeaturesPerTile . longValue ( ) ) { // Draw the tile bitmap bitmap = drawTile ( zoom , webMercatorBoundingBox , results ) ; } else if ( maxFeaturesTileDraw != null ) { // Draw the max features tile bitmap = maxFeaturesTileDraw . drawTile ( tileWidth , tileHeight , tileCount , results ) ; } } } finally { results . close ( ) ; } return bitmap ; }", "nl": "Draw a tile bitmap from the x y and zoom level by querying features in the tile location"}}
{"translation": {"code": "public boolean isIndexed ( ) { boolean indexed = false ; Date lastIndexed = getLastIndexed ( ) ; if ( lastIndexed != null ) { Contents contents = featureDao . getGeometryColumns ( ) . getContents ( ) ; Date lastChange = contents . getLastChange ( ) ; indexed = lastIndexed . equals ( lastChange ) || lastIndexed . after ( lastChange ) ; } return indexed ; }", "nl": "Determine if the database table is indexed after database modifications"}}
{"translation": {"code": "private boolean index ( long geoPackageId , FeatureRow row , boolean possibleUpdate ) { boolean indexed = false ; GeoPackageGeometryData geomData = row . getGeometry ( ) ; if ( geomData != null ) { // Get the envelope GeometryEnvelope envelope = geomData . getEnvelope ( ) ; // If no envelope, build one from the geometry if ( envelope == null ) { Geometry geometry = geomData . getGeometry ( ) ; if ( geometry != null ) { envelope = GeometryEnvelopeBuilder . buildEnvelope ( geometry ) ; } } // Create the new index row if ( envelope != null ) { GeometryMetadata metadata = geometryMetadataDataSource . populate ( geoPackageId , featureDao . getTableName ( ) , row . getId ( ) , envelope ) ; if ( possibleUpdate ) { geometryMetadataDataSource . createOrUpdate ( metadata ) ; } else { geometryMetadataDataSource . create ( metadata ) ; } indexed = true ; } } return indexed ; }", "nl": "Index the feature row"}}
{"translation": {"code": "private TableMetadata createTableMetadata ( Cursor cursor ) { TableMetadata metadata = new TableMetadata ( ) ; metadata . setGeoPackageId ( cursor . getLong ( 0 ) ) ; metadata . setTableName ( cursor . getString ( 1 ) ) ; if ( ! cursor . isNull ( 2 ) ) { metadata . setLastIndexed ( cursor . getLong ( 2 ) ) ; } return metadata ; }", "nl": "Create a table metadata from the current cursor location"}}
{"translation": {"code": "public long getGeoPackageId ( String geoPackage ) { long id = - 1 ; GeoPackageMetadataDataSource ds = new GeoPackageMetadataDataSource ( db ) ; GeoPackageMetadata metadata = ds . get ( geoPackage ) ; if ( metadata != null ) { id = metadata . getId ( ) ; } return id ; }", "nl": "Get a GeoPackage id from the name"}}
{"translation": {"code": "public void create ( TableMetadata metadata ) { ContentValues values = new ContentValues ( ) ; values . put ( TableMetadata . COLUMN_GEOPACKAGE_ID , metadata . getGeoPackageId ( ) ) ; values . put ( TableMetadata . COLUMN_TABLE_NAME , metadata . getTableName ( ) ) ; values . put ( TableMetadata . COLUMN_LAST_INDEXED , metadata . getLastIndexed ( ) ) ; long insertId = db . insert ( TableMetadata . TABLE_NAME , null , values ) ; if ( insertId == - 1 ) { throw new GeoPackageException ( \"Failed to insert table metadata. GeoPackage Id: \" + metadata . getGeoPackageId ( ) + \", Table Name: \" + metadata . getTableName ( ) + \", Last Indexed: \" + metadata . getLastIndexed ( ) ) ; } }", "nl": "Create a new table metadata"}}
{"translation": {"code": "public boolean delete ( long geoPackageId , String tableName ) { GeometryMetadataDataSource geomDs = new GeometryMetadataDataSource ( db ) ; geomDs . delete ( geoPackageId , tableName ) ; String whereClause = TableMetadata . COLUMN_GEOPACKAGE_ID + \" = ? AND \" + TableMetadata . COLUMN_TABLE_NAME + \" = ?\" ; String [ ] whereArgs = new String [ ] { String . valueOf ( geoPackageId ) , tableName } ; int deleteCount = db . delete ( TableMetadata . TABLE_NAME , whereClause , whereArgs ) ; return deleteCount > 0 ; }", "nl": "Delete the database table name"}}
{"translation": {"code": "public TableMetadata getOrCreate ( String geoPackage , String tableName ) { GeoPackageMetadataDataSource ds = new GeoPackageMetadataDataSource ( db ) ; GeoPackageMetadata geoPackageMetadata = ds . getOrCreate ( geoPackage ) ; TableMetadata metadata = get ( geoPackageMetadata . getId ( ) , tableName ) ; if ( metadata == null ) { metadata = new TableMetadata ( ) ; metadata . setGeoPackageId ( geoPackageMetadata . getId ( ) ) ; metadata . setTableName ( tableName ) ; create ( metadata ) ; } return metadata ; }", "nl": "Get a table metadata or create if it does not exist"}}
{"translation": {"code": "private GeoPackage getOrOpen ( String name , boolean writable , boolean cache ) { GeoPackage geoPackage = get ( name ) ; if ( geoPackage == null ) { geoPackage = manager . open ( name , writable ) ; if ( cache ) { add ( geoPackage ) ; } } return geoPackage ; }", "nl": "Get the cached GeoPackage or open and cache the GeoPackage"}}
{"translation": {"code": "public int count ( BoundingBox boundingBox ) { int count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , boundingBox ) ; return count ; }", "nl": "Query for Geometry Metadata count within the bounding box projected correctly"}}
{"translation": {"code": "public boolean deleteIndex ( ) { TableMetadataDataSource tableMetadataDataSource = new TableMetadataDataSource ( db ) ; boolean deleted = tableMetadataDataSource . delete ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) ) ; return deleted ; }", "nl": "Delete the feature table index"}}
{"translation": {"code": "public Cursor query ( ) { Cursor cursor = geometryMetadataDataSource . query ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) ) ; return cursor ; }", "nl": "Query for all Geometry Metadata"}}
{"translation": {"code": "public Cursor query ( BoundingBox boundingBox ) { Cursor cursor = geometryMetadataDataSource . query ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , boundingBox ) ; return cursor ; }", "nl": "Query for Geometry Metadata within the bounding box projected correctly"}}
{"translation": {"code": "public FeatureRow getFeatureRow ( GeometryIndex geometryIndex ) { long geomId = geometryIndex . getGeomId ( ) ; // Get the row or lock for reading FeatureRow row = featureRowSync . getRowOrLock ( geomId ) ; if ( row == null ) { // Query for the row and set in the sync try { row = featureDao . queryForIdRow ( geomId ) ; } finally { featureRowSync . setRow ( geomId , row ) ; } } return row ; }", "nl": "Get the feature row for the Geometry Index"}}
{"translation": {"code": "public void setProgress ( GeoPackageProgress progress ) { featureTableIndex . setProgress ( progress ) ; featureIndexer . setProgress ( progress ) ; rTreeIndexTableDao . setProgress ( progress ) ; }", "nl": "Set the GeoPackage Progress"}}
{"translation": {"code": "public boolean deleteIndex ( FeatureIndexType type , long geomId ) { if ( type == null ) { throw new GeoPackageException ( \"FeatureIndexType is required to delete index\" ) ; } boolean deleted = false ; switch ( type ) { case GEOPACKAGE : deleted = featureTableIndex . deleteIndex ( geomId ) > 0 ; break ; case METADATA : deleted = featureIndexer . deleteIndex ( geomId ) ; break ; case RTREE : // Updated by triggers, ignore for RTree deleted = true ; break ; default : throw new GeoPackageException ( \"Unsupported FeatureIndexType: \" + type ) ; } return deleted ; }", "nl": "Delete the feature index for the geometry id"}}
{"translation": {"code": "public boolean isIndexed ( ) { boolean indexed = false ; for ( FeatureIndexType type : indexLocationQueryOrder ) { indexed = isIndexed ( type ) ; if ( indexed ) { break ; } } return indexed ; }", "nl": "Determine if the feature table is indexed"}}
{"translation": {"code": "public FeatureIndexResults query ( ) { FeatureIndexResults results = null ; switch ( getIndexedType ( ) ) { case GEOPACKAGE : long count = featureTableIndex . count ( ) ; CloseableIterator < GeometryIndex > geometryIndices = featureTableIndex . query ( ) ; results = new FeatureIndexGeoPackageResults ( featureTableIndex , count , geometryIndices ) ; break ; case METADATA : Cursor geometryMetadata = featureIndexer . query ( ) ; results = new FeatureIndexMetadataResults ( featureIndexer , geometryMetadata ) ; break ; case RTREE : UserCustomCursor cursor = rTreeIndexTableDao . queryForAll ( ) ; results = new FeatureIndexRTreeResults ( rTreeIndexTableDao , cursor ) ; break ; default : FeatureCursor featureCursor = featureDao . queryForAll ( ) ; results = new FeatureIndexFeatureResults ( featureCursor ) ; } return results ; }", "nl": "Query for all feature index results"}}
{"translation": {"code": "public long count ( ) { long count = 0 ; switch ( getIndexedType ( ) ) { case GEOPACKAGE : count = featureTableIndex . count ( ) ; break ; case METADATA : count = featureIndexer . count ( ) ; break ; case RTREE : count = rTreeIndexTableDao . count ( ) ; break ; default : count = manualFeatureQuery . countWithGeometries ( ) ; } return count ; }", "nl": "Query for all feature index count"}}
{"translation": {"code": "public FeatureIndexResults query ( BoundingBox boundingBox , Projection projection ) { FeatureIndexResults results = null ; switch ( getIndexedType ( ) ) { case GEOPACKAGE : long count = featureTableIndex . count ( boundingBox , projection ) ; CloseableIterator < GeometryIndex > geometryIndices = featureTableIndex . query ( boundingBox , projection ) ; results = new FeatureIndexGeoPackageResults ( featureTableIndex , count , geometryIndices ) ; break ; case METADATA : Cursor geometryMetadata = featureIndexer . query ( boundingBox , projection ) ; results = new FeatureIndexMetadataResults ( featureIndexer , geometryMetadata ) ; break ; case RTREE : UserCustomCursor cursor = rTreeIndexTableDao . query ( boundingBox , projection ) ; results = new FeatureIndexRTreeResults ( rTreeIndexTableDao , cursor ) ; break ; default : results = manualFeatureQuery . query ( boundingBox , projection ) ; } return results ; }", "nl": "Query for feature index results within the bounding box in the provided projection"}}
{"translation": {"code": "private FeatureIndexType getIndexedType ( ) { FeatureIndexType indexType = FeatureIndexType . NONE ; // Check for an indexed type for ( FeatureIndexType type : indexLocationQueryOrder ) { if ( isIndexed ( type ) ) { indexType = type ; break ; } } return indexType ; }", "nl": "Get the indexed type or throw an error if not indexed"}}
{"translation": {"code": "public FeatureRow getFeatureRow ( Cursor cursor ) { GeometryMetadata geometryMetadata = getGeometryMetadata ( cursor ) ; FeatureRow featureRow = getFeatureRow ( geometryMetadata ) ; return featureRow ; }", "nl": "Get the feature row for the current place in the cursor"}}
{"translation": {"code": "public GeometryMetadata getGeometryMetadata ( Cursor cursor ) { GeometryMetadata geometryMetadata = GeometryMetadataDataSource . createGeometryMetadata ( cursor ) ; return geometryMetadata ; }", "nl": "Get the Geometry Metadata for the current place in the cursor"}}
{"translation": {"code": "private BoundingBox getFeatureBoundingBox ( BoundingBox boundingBox , Projection projection ) { ProjectionTransform projectionTransform = projection . getTransformation ( featureDao . getProjection ( ) ) ; BoundingBox featureBoundingBox = boundingBox . transform ( projectionTransform ) ; return featureBoundingBox ; }", "nl": "Get the bounding box in the feature projection from the bounding box in the provided projection"}}
{"translation": {"code": "public long count ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = getFeatureBoundingBox ( boundingBox , projection ) ; long count = count ( featureBoundingBox ) ; return count ; }", "nl": "Query for Geometry Metadata count within the bounding box in the provided projection"}}
{"translation": {"code": "public Cursor query ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = getFeatureBoundingBox ( boundingBox , projection ) ; Cursor cursor = query ( featureBoundingBox ) ; return cursor ; }", "nl": "Query for Geometry Metadata within the bounding box in the provided projection"}}
{"translation": {"code": "public int count ( GeometryEnvelope envelope ) { int count = geometryMetadataDataSource . count ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , envelope ) ; return count ; }", "nl": "Query for Geometry Metadata count within the Geometry Envelope"}}
{"translation": {"code": "public Cursor query ( GeometryEnvelope envelope ) { Cursor cursor = geometryMetadataDataSource . query ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , envelope ) ; return cursor ; }", "nl": "Query for Geometry Metadata within the Geometry Envelope"}}
{"translation": {"code": "public int count ( String geoPackage , String tableName , BoundingBox boundingBox ) { return count ( getGeoPackageId ( geoPackage ) , tableName , boundingBox ) ; }", "nl": "Query for all table geometry metadata count matching the bounding box in the same projection"}}
{"translation": {"code": "public boolean deleteIndex ( long geomId ) { boolean deleted = geometryMetadataDataSource . delete ( featureDao . getDatabase ( ) , featureDao . getTableName ( ) , geomId ) ; return deleted ; }", "nl": "Delete the index for the geometry id"}}
{"translation": {"code": "private Bitmap drawTile ( int tileWidth , int tileHeight , String text ) { // Create bitmap and canvas Bitmap bitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; Canvas canvas = new Canvas ( bitmap ) ; // Draw the tile fill paint if ( tileFillPaint != null ) { canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileFillPaint ) ; } // Draw the tile border if ( tileBorderPaint != null ) { canvas . drawRect ( 0 , 0 , tileWidth , tileHeight , tileBorderPaint ) ; } // Determine the text bounds Rect textBounds = new Rect ( ) ; textPaint . getTextBounds ( text , 0 , text . length ( ) , textBounds ) ; // Determine the center of the tile int centerX = ( int ) ( bitmap . getWidth ( ) / 2.0f ) ; int centerY = ( int ) ( bitmap . getHeight ( ) / 2.0f ) ; // Draw the circle if ( circlePaint != null || circleFillPaint != null ) { int diameter = Math . max ( textBounds . width ( ) , textBounds . height ( ) ) ; float radius = diameter / 2.0f ; radius = radius + ( diameter * circlePaddingPercentage ) ; // Draw the filled circle if ( circleFillPaint != null ) { canvas . drawCircle ( centerX , centerY , radius , circleFillPaint ) ; } // Draw the circle if ( circlePaint != null ) { canvas . drawCircle ( centerX , centerY , radius , circlePaint ) ; } } // Draw the text canvas . drawText ( text , centerX - textBounds . exactCenterX ( ) , centerY - textBounds . exactCenterY ( ) , textPaint ) ; return bitmap ; }", "nl": "Draw a tile with the provided text label in the middle"}}
{"translation": {"code": "public long queryIndexedFeaturesCount ( int x , int y , int zoom ) { // Get the web mercator bounding box BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; // Query for the count of geometries matching the bounds in the index long count = queryIndexedFeaturesCount ( webMercatorBoundingBox ) ; return count ; }", "nl": "Query for feature result count in the x y and zoom"}}
{"translation": {"code": "public FeatureIndexResults queryIndexedFeatures ( BoundingBox webMercatorBoundingBox ) { // Create an expanded bounding box to handle features outside the tile // that overlap BoundingBox expandedQueryBoundingBox = expandBoundingBox ( webMercatorBoundingBox ) ; // Query for geometries matching the bounds in the index FeatureIndexResults results = indexManager . query ( expandedQueryBoundingBox , WEB_MERCATOR_PROJECTION ) ; return results ; }", "nl": "Query for feature results in the bounding box"}}
{"translation": {"code": "public long queryIndexedFeaturesCount ( BoundingBox webMercatorBoundingBox ) { // Query for geometries matching the bounds in the index FeatureIndexResults results = queryIndexedFeatures ( webMercatorBoundingBox ) ; long count = 0 ; try { count = results . count ( ) ; } finally { results . close ( ) ; } return count ; }", "nl": "Query for feature result count in the bounding box"}}
{"translation": {"code": "public TileGrid getTileGrid ( long zoomLevel ) { TileGrid tileGrid = null ; TileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; if ( tileMatrix != null ) { tileGrid = new TileGrid ( 0 , 0 , tileMatrix . getMatrixWidth ( ) - 1 , tileMatrix . getMatrixHeight ( ) - 1 ) ; } return tileGrid ; }", "nl": "Get the tile grid of the zoom level"}}
{"translation": {"code": "public TileGrid queryForTileGrid ( long zoomLevel ) { String where = buildWhere ( TileTable . COLUMN_ZOOM_LEVEL , zoomLevel ) ; String [ ] whereArgs = buildWhereArgs ( new Object [ ] { zoomLevel } ) ; Integer minX = min ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; Integer maxX = max ( TileTable . COLUMN_TILE_COLUMN , where , whereArgs ) ; Integer minY = min ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; Integer maxY = max ( TileTable . COLUMN_TILE_ROW , where , whereArgs ) ; TileGrid tileGrid = null ; if ( minX != null && maxX != null && minY != null && maxY != null ) { tileGrid = new TileGrid ( minX , minY , maxX , maxY ) ; } return tileGrid ; }", "nl": "Query for the bounding"}}
{"translation": {"code": "public BoundingBox getBoundingBox ( long zoomLevel ) { BoundingBox boundingBox = null ; TileMatrix tileMatrix = getTileMatrix ( zoomLevel ) ; if ( tileMatrix != null ) { TileGrid tileGrid = queryForTileGrid ( zoomLevel ) ; if ( tileGrid != null ) { BoundingBox matrixSetBoundingBox = getBoundingBox ( ) ; boundingBox = TileBoundingBoxUtils . getBoundingBox ( matrixSetBoundingBox , tileMatrix , tileGrid ) ; } } return boundingBox ; }", "nl": "Get the bounding box of tiles"}}
{"translation": {"code": "private void validateDatabase ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity , boolean close , boolean closeOnError ) { try { if ( validateHeader ) { validateDatabaseHeader ( sqliteDatabase ) ; } if ( validateIntegrity ) { validateDatabaseIntegrity ( sqliteDatabase ) ; } } catch ( Exception e ) { if ( closeOnError ) { sqliteDatabase . close ( ) ; } throw e ; } if ( close ) { sqliteDatabase . close ( ) ; } }", "nl": "Validate the database header and integrity . Throw an error when not valid ."}}
{"translation": {"code": "private void validateDatabaseHeader ( SQLiteDatabase sqliteDatabase ) { boolean validHeader = isDatabaseHeaderValid ( sqliteDatabase ) ; if ( ! validHeader ) { throw new GeoPackageException ( \"GeoPackage SQLite header is not valid: \" + sqliteDatabase . getPath ( ) ) ; } }", "nl": "Validate the header of the database file to verify it is a sqlite database"}}
{"translation": {"code": "private boolean isDatabaseHeaderValid ( SQLiteDatabase sqliteDatabase ) { boolean validHeader = false ; FileInputStream fis = null ; try { fis = new FileInputStream ( sqliteDatabase . getPath ( ) ) ; byte [ ] headerBytes = new byte [ 16 ] ; if ( fis . read ( headerBytes ) == 16 ) { ByteReader byteReader = new ByteReader ( headerBytes ) ; String header = byteReader . readString ( headerBytes . length ) ; String headerPrefix = header . substring ( 0 , GeoPackageConstants . SQLITE_HEADER_PREFIX . length ( ) ) ; validHeader = headerPrefix . equalsIgnoreCase ( GeoPackageConstants . SQLITE_HEADER_PREFIX ) ; } } catch ( Exception e ) { Log . e ( GeoPackageManagerImpl . class . getSimpleName ( ) , \"Failed to retrieve database header\" , e ) ; } finally { if ( fis != null ) { try { fis . close ( ) ; } catch ( IOException e ) { // eat } } } return validHeader ; }", "nl": "Determine if the header of the database file is valid"}}
{"translation": {"code": "private void validateDatabaseAndCloseOnError ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { validateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , false , true ) ; }", "nl": "Validate the database and close when validation fails . Throw an error when not valid ."}}
{"translation": {"code": "private boolean isValid ( String database , boolean validateHeader , boolean validateIntegrity ) { boolean valid = false ; if ( exists ( database ) ) { GeoPackageCursorFactory cursorFactory = new GeoPackageCursorFactory ( ) ; String path = null ; SQLiteDatabase sqlite ; GeoPackageMetadata metadata = getGeoPackageMetadata ( database ) ; if ( metadata != null && metadata . isExternal ( ) ) { path = metadata . getExternalPath ( ) ; try { sqlite = SQLiteDatabase . openDatabase ( path , cursorFactory , SQLiteDatabase . OPEN_READWRITE | SQLiteDatabase . NO_LOCALIZED_COLLATORS ) ; } catch ( Exception e ) { sqlite = SQLiteDatabase . openDatabase ( path , cursorFactory , SQLiteDatabase . OPEN_READONLY | SQLiteDatabase . NO_LOCALIZED_COLLATORS ) ; } } else { path = context . getDatabasePath ( database ) . getAbsolutePath ( ) ; sqlite = context . openOrCreateDatabase ( database , Context . MODE_PRIVATE , cursorFactory ) ; } try { valid = ( ! validateHeader || isDatabaseHeaderValid ( sqlite ) ) && ( ! validateIntegrity || sqlite . isDatabaseIntegrityOk ( ) ) ; } catch ( Exception e ) { Log . e ( GeoPackageManagerImpl . class . getSimpleName ( ) , \"Failed to validate database\" , e ) ; } finally { sqlite . close ( ) ; } } return valid ; }", "nl": "Validate the GeoPackage database"}}
{"translation": {"code": "private void validateDatabaseAndClose ( SQLiteDatabase sqliteDatabase , boolean validateHeader , boolean validateIntegrity ) { validateDatabase ( sqliteDatabase , validateHeader , validateIntegrity , true , true ) ; }", "nl": "Validate the database and close it . Throw an error when not valid ."}}
{"translation": {"code": "public GeoPackageMetadata getExternalAtPath ( String path ) { GeoPackageMetadata metadata = null ; String selection = GeoPackageMetadata . COLUMN_EXTERNAL_PATH + \" = ?\" ; String [ ] selectionArgs = new String [ ] { path } ; Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , GeoPackageMetadata . COLUMNS , selection , selectionArgs , null , null , null ) ; try { if ( cursor . moveToNext ( ) ) { metadata = createGeoPackageMetadata ( cursor ) ; } } finally { cursor . close ( ) ; } return metadata ; }", "nl": "Get external GeoPackage metadata by external path"}}
{"translation": {"code": "private GeoPackageMetadata getGeoPackageMetadataAtExternalPath ( String path ) { GeoPackageMetadata metadata = null ; GeoPackageMetadataDb metadataDb = new GeoPackageMetadataDb ( context ) ; metadataDb . open ( ) ; try { GeoPackageMetadataDataSource dataSource = new GeoPackageMetadataDataSource ( metadataDb ) ; metadata = dataSource . getExternalAtPath ( path ) ; } finally { metadataDb . close ( ) ; } return metadata ; }", "nl": "Get the GeoPackage metadata of the database at the external path"}}
{"translation": {"code": "public static Rect getRectangle ( long width , long height , BoundingBox boundingBox , BoundingBox boundingBoxSection ) { RectF rectF = getFloatRectangle ( width , height , boundingBox , boundingBoxSection ) ; Rect rect = new Rect ( Math . round ( rectF . left ) , Math . round ( rectF . top ) , Math . round ( rectF . right ) , Math . round ( rectF . bottom ) ) ; return rect ; }", "nl": "Get a rectangle using the tile width height bounding box and the bounding box section within the outer box to build the rectangle from"}}
{"translation": {"code": "public Cursor rawQuery ( String sql , String [ ] args ) { return db . rawQuery ( sql , args ) ; }", "nl": "Perform a raw database query"}}
{"translation": {"code": "private Cursor integrityCheck ( Cursor cursor ) { if ( cursor . moveToNext ( ) ) { String value = cursor . getString ( 0 ) ; if ( value . equals ( \"ok\" ) ) { cursor . close ( ) ; cursor = null ; } } return cursor ; }", "nl": "Check the cursor returned from the integrity check to see if things are ok"}}
{"translation": {"code": "private String replaceBoundingBox ( String url , BoundingBox boundingBox ) { url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_min_lat ) , String . valueOf ( boundingBox . getMinLatitude ( ) ) ) ; url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_max_lat ) , String . valueOf ( boundingBox . getMaxLatitude ( ) ) ) ; url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_min_lon ) , String . valueOf ( boundingBox . getMinLongitude ( ) ) ) ; url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_max_lon ) , String . valueOf ( boundingBox . getMaxLongitude ( ) ) ) ; return url ; }", "nl": "Replace the url parts with the bounding box"}}
{"translation": {"code": "private String replaceBoundingBox ( String url , int z , long x , long y ) { BoundingBox boundingBox = TileBoundingBoxUtils . getProjectedBoundingBox ( projection , x , y , z ) ; url = replaceBoundingBox ( url , boundingBox ) ; return url ; }", "nl": "Replace the bounding box coordinates in the url"}}
{"translation": {"code": "private String replaceXYZ ( String url , int z , long x , long y ) { url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_z ) , String . valueOf ( z ) ) ; url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_x ) , String . valueOf ( x ) ) ; url = url . replaceAll ( context . getString ( R . string . tile_generator_variable_y ) , String . valueOf ( y ) ) ; return url ; }", "nl": "Replace x y and z in the url"}}
{"translation": {"code": "private boolean hasBoundingBox ( String url ) { String replacedUrl = replaceBoundingBox ( url , boundingBox ) ; boolean hasBoundingBox = ! replacedUrl . equals ( url ) ; return hasBoundingBox ; }", "nl": "Determine if the url has bounding box variables"}}
{"translation": {"code": "private boolean hasXYZ ( String url ) { String replacedUrl = replaceXYZ ( url , 0 , 0 , 0 ) ; boolean hasXYZ = ! replacedUrl . equals ( url ) ; return hasXYZ ; }", "nl": "Determine if the url has x y or z variables"}}
{"translation": {"code": "public List < TileDao > getTileDaosForFeatureTable ( String featureTable ) { List < TileDao > tileDaos = new ArrayList < TileDao > ( ) ; List < String > tileTables = getTileTablesForFeatureTable ( featureTable ) ; for ( String tileTable : tileTables ) { if ( geoPackage . isTileTable ( tileTable ) ) { TileDao tileDao = geoPackage . getTileDao ( tileTable ) ; tileDaos . add ( tileDao ) ; } } return tileDaos ; }", "nl": "Query for the tile tables linked to a feature table and return tile DAOs to those tables"}}
{"translation": {"code": "public List < FeatureDao > getFeatureDaosForTileTable ( String tileTable ) { List < FeatureDao > featureDaos = new ArrayList < FeatureDao > ( ) ; List < String > featureTables = getFeatureTablesForTileTable ( tileTable ) ; for ( String featureTable : featureTables ) { if ( geoPackage . isFeatureTable ( featureTable ) ) { FeatureDao featureDao = geoPackage . getFeatureDao ( featureTable ) ; featureDaos . add ( featureDao ) ; } } return featureDaos ; }", "nl": "Query for the feature tables linked to a tile table and return feature DAOs to those tables"}}
{"translation": {"code": "private TileRow retrieveTileRow ( int x , int y , int zoom ) { return tileDao . queryForTile ( x , y , zoom ) ; }", "nl": "Retrieve the tile row"}}
{"translation": {"code": "private List < String > getMetadataWhereNameLike ( String like , String sortColumn , boolean notLike ) { List < String > names = new ArrayList <> ( ) ; StringBuilder where = new StringBuilder ( GeoPackageMetadata . COLUMN_NAME ) ; if ( notLike ) { where . append ( \" not\" ) ; } where . append ( \" like ?\" ) ; String [ ] whereArgs = new String [ ] { like } ; Cursor cursor = db . query ( GeoPackageMetadata . TABLE_NAME , new String [ ] { GeoPackageMetadata . COLUMN_NAME } , where . toString ( ) , whereArgs , null , null , sortColumn ) ; try { while ( cursor . moveToNext ( ) ) { names . add ( cursor . getString ( 0 ) ) ; } } finally { cursor . close ( ) ; } return names ; }", "nl": "Get metadata where the name is like or not like"}}
{"translation": {"code": "private List < String > deleteMissingDatabases ( List < String > databases ) { List < String > filesExist = new ArrayList <> ( ) ; for ( String database : databases ) { if ( exists ( database ) ) { filesExist . add ( database ) ; } } return filesExist ; }", "nl": "Delete all databases that do not exist or the database file does not exist"}}
{"translation": {"code": "public List < String > getMetadataWhereNameLike ( String like , String sortColumn ) { return getMetadataWhereNameLike ( like , sortColumn , false ) ; }", "nl": "Get metadata where the name is like"}}
{"translation": {"code": "public List < String > getMetadataWhereNameNotLike ( String notLike , String sortColumn ) { return getMetadataWhereNameLike ( notLike , sortColumn , true ) ; }", "nl": "Get metadata where the name is not like"}}
{"translation": {"code": "private TileCursor retrieveTileResults ( BoundingBox projectedRequestBoundingBox , TileMatrix tileMatrix ) { TileCursor tileResults = null ; if ( tileMatrix != null ) { // Get the tile grid TileGrid tileGrid = TileBoundingBoxUtils . getTileGrid ( tileSetBoundingBox , tileMatrix . getMatrixWidth ( ) , tileMatrix . getMatrixHeight ( ) , projectedRequestBoundingBox ) ; // Query for matching tiles in the tile grid tileResults = tileDao . queryByTileGrid ( tileGrid , tileMatrix . getZoomLevel ( ) ) ; } return tileResults ; }", "nl": "Get the tile row results of tiles needed to draw the requested bounding box tile"}}
{"translation": {"code": "public GeoPackageTile getTile ( BoundingBox requestBoundingBox ) { GeoPackageTile tile = null ; // Transform to the projection of the tiles ProjectionTransform transformRequestToTiles = requestProjection . getTransformation ( tilesProjection ) ; BoundingBox tilesBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; List < TileMatrix > tileMatrices = getTileMatrices ( tilesBoundingBox ) ; for ( int i = 0 ; tile == null && i < tileMatrices . size ( ) ; i ++ ) { TileMatrix tileMatrix = tileMatrices . get ( i ) ; TileCursor tileResults = retrieveTileResults ( tilesBoundingBox , tileMatrix ) ; if ( tileResults != null ) { try { if ( tileResults . getCount ( ) > 0 ) { BoundingBox requestProjectedBoundingBox = requestBoundingBox . transform ( transformRequestToTiles ) ; // Determine the requested tile dimensions, or use the dimensions of a single tile matrix tile int requestedTileWidth = width != null ? width : ( int ) tileMatrix . getTileWidth ( ) ; int requestedTileHeight = height != null ? height : ( int ) tileMatrix . getTileHeight ( ) ; // Determine the size of the tile to initially draw int tileWidth = requestedTileWidth ; int tileHeight = requestedTileHeight ; if ( ! sameProjection ) { tileWidth = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLongitude ( ) - requestProjectedBoundingBox . getMinLongitude ( ) ) / tileMatrix . getPixelXSize ( ) ) ; tileHeight = ( int ) Math . round ( ( requestProjectedBoundingBox . getMaxLatitude ( ) - requestProjectedBoundingBox . getMinLatitude ( ) ) / tileMatrix . getPixelYSize ( ) ) ; } // Draw the resulting bitmap with the matching tiles Bitmap tileBitmap = drawTile ( tileMatrix , tileResults , requestProjectedBoundingBox , tileWidth , tileHeight ) ; // Create the tile if ( tileBitmap != null ) { // Project the tile if needed if ( ! sameProjection ) { Bitmap reprojectTile = reprojectTile ( tileBitmap , requestedTileWidth , requestedTileHeight , requestBoundingBox , transformRequestToTiles , tilesBoundingBox ) ; tileBitmap . recycle ( ) ; tileBitmap = reprojectTile ; } try { byte [ ] tileData = BitmapConverter . toBytes ( tileBitmap , COMPRESS_FORMAT ) ; tileBitmap . recycle ( ) ; tile = new GeoPackageTile ( requestedTileWidth , requestedTileHeight , tileData ) ; } catch ( IOException e ) { Log . e ( TileCreator . class . getSimpleName ( ) , \"Failed to create tile. min lat: \" + requestBoundingBox . getMinLatitude ( ) + \", max lat: \" + requestBoundingBox . getMaxLatitude ( ) + \", min lon: \" + requestBoundingBox . getMinLongitude ( ) + \", max lon: \" + requestBoundingBox . getMaxLongitude ( ) , e ) ; } } } } finally { tileResults . close ( ) ; } } } return tile ; }", "nl": "Get the tile from the request bounding box in the request projection"}}
{"translation": {"code": "private Bitmap drawTile ( TileMatrix tileMatrix , TileCursor tileResults , BoundingBox requestProjectedBoundingBox , int tileWidth , int tileHeight ) { // Draw the resulting bitmap with the matching tiles Bitmap tileBitmap = null ; Canvas canvas = null ; Paint paint = null ; while ( tileResults . moveToNext ( ) ) { // Get the next tile TileRow tileRow = tileResults . getRow ( ) ; Bitmap tileDataBitmap = tileRow . getTileDataBitmap ( ) ; // Get the bounding box of the tile BoundingBox tileBoundingBox = TileBoundingBoxUtils . getBoundingBox ( tileSetBoundingBox , tileMatrix , tileRow . getTileColumn ( ) , tileRow . getTileRow ( ) ) ; // Get the bounding box where the requested image and // tile overlap BoundingBox overlap = requestProjectedBoundingBox . overlap ( tileBoundingBox ) ; // If the tile overlaps with the requested box if ( overlap != null ) { // Get the rectangle of the tile image to draw Rect src = TileBoundingBoxAndroidUtils . getRectangle ( tileMatrix . getTileWidth ( ) , tileMatrix . getTileHeight ( ) , tileBoundingBox , overlap ) ; // Get the rectangle of where to draw the tile in // the resulting image RectF dest = TileBoundingBoxAndroidUtils . getRoundedFloatRectangle ( tileWidth , tileHeight , requestProjectedBoundingBox , overlap ) ; // Create the bitmap first time through if ( tileBitmap == null ) { tileBitmap = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; canvas = new Canvas ( tileBitmap ) ; paint = new Paint ( Paint . ANTI_ALIAS_FLAG ) ; } // Draw the tile to the bitmap canvas . drawBitmap ( tileDataBitmap , src , dest , paint ) ; } } return tileBitmap ; }", "nl": "Draw the tile from the tile results"}}
{"translation": {"code": "private Bitmap reprojectTile ( Bitmap tile , int requestedTileWidth , int requestedTileHeight , BoundingBox requestBoundingBox , ProjectionTransform transformRequestToTiles , BoundingBox tilesBoundingBox ) { final double requestedWidthUnitsPerPixel = ( requestBoundingBox . getMaxLongitude ( ) - requestBoundingBox . getMinLongitude ( ) ) / requestedTileWidth ; final double requestedHeightUnitsPerPixel = ( requestBoundingBox . getMaxLatitude ( ) - requestBoundingBox . getMinLatitude ( ) ) / requestedTileHeight ; final double tilesDistanceWidth = tilesBoundingBox . getMaxLongitude ( ) - tilesBoundingBox . getMinLongitude ( ) ; final double tilesDistanceHeight = tilesBoundingBox . getMaxLatitude ( ) - tilesBoundingBox . getMinLatitude ( ) ; final int width = tile . getWidth ( ) ; final int height = tile . getHeight ( ) ; // Tile pixels of the tile matrix tiles int [ ] pixels = new int [ width * height ] ; tile . getPixels ( pixels , 0 , width , 0 , 0 , width , height ) ; // Projected tile pixels to draw the reprojected tile int [ ] projectedPixels = new int [ requestedTileWidth * requestedTileHeight ] ; // Retrieve each pixel in the new tile from the unprojected tile for ( int y = 0 ; y < requestedTileHeight ; y ++ ) { for ( int x = 0 ; x < requestedTileWidth ; x ++ ) { double longitude = requestBoundingBox . getMinLongitude ( ) + ( x * requestedWidthUnitsPerPixel ) ; double latitude = requestBoundingBox . getMaxLatitude ( ) - ( y * requestedHeightUnitsPerPixel ) ; ProjCoordinate fromCoord = new ProjCoordinate ( longitude , latitude ) ; ProjCoordinate toCoord = transformRequestToTiles . transform ( fromCoord ) ; double projectedLongitude = toCoord . x ; double projectedLatitude = toCoord . y ; int xPixel = ( int ) Math . round ( ( ( projectedLongitude - tilesBoundingBox . getMinLongitude ( ) ) / tilesDistanceWidth ) * width ) ; int yPixel = ( int ) Math . round ( ( ( tilesBoundingBox . getMaxLatitude ( ) - projectedLatitude ) / tilesDistanceHeight ) * height ) ; xPixel = Math . max ( 0 , xPixel ) ; xPixel = Math . min ( width - 1 , xPixel ) ; yPixel = Math . max ( 0 , yPixel ) ; yPixel = Math . min ( height - 1 , yPixel ) ; int color = pixels [ ( yPixel * width ) + xPixel ] ; projectedPixels [ ( y * requestedTileWidth ) + x ] = color ; } } // Draw the new tile bitmap Bitmap projectedTileBitmap = Bitmap . createBitmap ( requestedTileWidth , requestedTileHeight , tile . getConfig ( ) ) ; projectedTileBitmap . setPixels ( projectedPixels , 0 , requestedTileWidth , 0 , 0 , requestedTileWidth , requestedTileHeight ) ; return projectedTileBitmap ; }", "nl": "Reproject the tile to the requested projection"}}
{"translation": {"code": "public static RectF getRoundedFloatRectangle ( long width , long height , BoundingBox boundingBox , BoundingBox boundingBoxSection ) { Rect rect = getRectangle ( width , height , boundingBox , boundingBoxSection ) ; RectF rectF = new RectF ( rect ) ; return rectF ; }", "nl": "Get a rectangle with rounded floating point boundaries using the tile width height bounding box and the bounding box section within the outer box to build the rectangle from"}}
{"translation": {"code": "public static ContentValues quoteWrap ( ContentValues values ) { ContentValues quoteValues = null ; if ( values != null ) { Map < String , Object > quoteMap = new HashMap <> ( ) ; for ( Map . Entry < String , Object > value : values . valueSet ( ) ) { quoteMap . put ( CoreSQLUtils . quoteWrap ( value . getKey ( ) ) , value . getValue ( ) ) ; } Parcel parcel = Parcel . obtain ( ) ; parcel . writeMap ( quoteMap ) ; parcel . setDataPosition ( 0 ) ; quoteValues = ContentValues . CREATOR . createFromParcel ( parcel ) ; parcel . recycle ( ) ; } return quoteValues ; }", "nl": "Wrap the content values names in quotes"}}
{"translation": {"code": "private CoverageDataTileMatrixResults getResultsZoomOut ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { CoverageDataTileMatrixResults results = null ; for ( long zoomLevel = tileMatrix . getZoomLevel ( ) - 1 ; zoomLevel >= tileDao . getMinZoom ( ) ; zoomLevel -- ) { TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; if ( zoomTileMatrix != null ) { results = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; if ( results != null ) { break ; } } } return results ; }", "nl": "Get the coverage data tile results by zooming out from the provided tile matrix"}}
{"translation": {"code": "public float getPixelValue ( byte [ ] imageBytes , int x , int y ) { TIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; FileDirectory directory = tiffImage . getFileDirectory ( ) ; validateImageType ( directory ) ; Rasters rasters = directory . readRasters ( ) ; float pixelValue = rasters . getFirstPixelSample ( x , y ) . floatValue ( ) ; return pixelValue ; }", "nl": "Get the pixel value as a float from the image and the coordinate"}}
{"translation": {"code": "public Long getClosestZoomLevel ( double length ) { Long zoomLevel = TileDaoUtils . getClosestZoomLevel ( widths , heights , tileMatrices , length ) ; return zoomLevel ; }", "nl": "Get the closest zoom level for the provided width and height in the default units"}}
{"translation": {"code": "public CoverageDataTiffImage createImage ( int tileWidth , int tileHeight ) { Rasters rasters = new Rasters ( tileWidth , tileHeight , 1 , BITS_PER_SAMPLE , TiffConstants . SAMPLE_FORMAT_FLOAT ) ; int rowsPerStrip = rasters . calculateRowsPerStrip ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; FileDirectory fileDirectory = new FileDirectory ( ) ; fileDirectory . setImageWidth ( tileWidth ) ; fileDirectory . setImageHeight ( tileHeight ) ; fileDirectory . setBitsPerSample ( BITS_PER_SAMPLE ) ; fileDirectory . setCompression ( TiffConstants . COMPRESSION_NO ) ; fileDirectory . setPhotometricInterpretation ( TiffConstants . PHOTOMETRIC_INTERPRETATION_BLACK_IS_ZERO ) ; fileDirectory . setSamplesPerPixel ( SAMPLES_PER_PIXEL ) ; fileDirectory . setRowsPerStrip ( rowsPerStrip ) ; fileDirectory . setPlanarConfiguration ( TiffConstants . PLANAR_CONFIGURATION_CHUNKY ) ; fileDirectory . setSampleFormat ( TiffConstants . SAMPLE_FORMAT_FLOAT ) ; fileDirectory . setWriteRasters ( rasters ) ; CoverageDataTiffImage image = new CoverageDataTiffImage ( fileDirectory ) ; return image ; }", "nl": "Create a new image"}}
{"translation": {"code": "public void setPixelValue ( CoverageDataTiffImage image , int x , int y , float pixelValue ) { image . getRasters ( ) . setFirstPixelSample ( x , y , pixelValue ) ; }", "nl": "Set the pixel value into the image"}}
{"translation": {"code": "public double getValue ( TileRow tileRow , int x , int y ) { GriddedTile griddedTile = getGriddedTile ( tileRow . getId ( ) ) ; double value = getValue ( griddedTile , tileRow , x , y ) ; return value ; }", "nl": "Get the coverage data value of the pixel in the tile row image"}}
{"translation": {"code": "private TileMatrix getTileMatrix ( CoverageDataRequest request ) { TileMatrix tileMatrix = null ; // Check if the request overlaps coverage data bounding box if ( request . overlap ( coverageBoundingBox ) != null ) { // Get the tile distance BoundingBox projectedBoundingBox = request . getProjectedBoundingBox ( ) ; double distanceWidth = projectedBoundingBox . getMaxLongitude ( ) - projectedBoundingBox . getMinLongitude ( ) ; double distanceHeight = projectedBoundingBox . getMaxLatitude ( ) - projectedBoundingBox . getMinLatitude ( ) ; // Get the zoom level to request based upon the tile size Long zoomLevel = tileDao . getClosestZoomLevel ( distanceWidth , distanceHeight ) ; // If there is a matching zoom level if ( zoomLevel != null ) { tileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; } } return tileMatrix ; }", "nl": "Get the tile matrix for the zoom level as defined by the area of the request"}}
{"translation": {"code": "private CoverageDataTileMatrixResults getResultsZoomIn ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { CoverageDataTileMatrixResults results = null ; for ( long zoomLevel = tileMatrix . getZoomLevel ( ) + 1 ; zoomLevel <= tileDao . getMaxZoom ( ) ; zoomLevel ++ ) { TileMatrix zoomTileMatrix = tileDao . getTileMatrix ( zoomLevel ) ; if ( zoomTileMatrix != null ) { results = getResults ( requestProjectedBoundingBox , zoomTileMatrix , overlappingPixels ) ; if ( results != null ) { break ; } } } return results ; }", "nl": "Get the coverage data tile results by zooming in from the provided tile matrix"}}
{"translation": {"code": "private CoverageDataTileMatrixResults getResultsZoom ( BoundingBox requestProjectedBoundingBox , TileMatrix tileMatrix , int overlappingPixels ) { CoverageDataTileMatrixResults results = null ; if ( zoomIn && zoomInBeforeOut ) { results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; } if ( results == null && zoomOut ) { results = getResultsZoomOut ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; } if ( results == null && zoomIn && ! zoomInBeforeOut ) { results = getResultsZoomIn ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; } return results ; }", "nl": "Get the coverage data tile results by zooming in or out as needed from the provided tile matrix to find values"}}
{"translation": {"code": "private CoverageDataTileMatrixResults getResults ( CoverageDataRequest request , BoundingBox requestProjectedBoundingBox , int overlappingPixels ) { // Try to get the coverage data from the current zoom level TileMatrix tileMatrix = getTileMatrix ( request ) ; CoverageDataTileMatrixResults results = null ; if ( tileMatrix != null ) { results = getResults ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; // Try to zoom in or out to find a matching coverage data if ( results == null ) { results = getResultsZoom ( requestProjectedBoundingBox , tileMatrix , overlappingPixels ) ; } } return results ; }", "nl": "Get the coverage data tile results by finding the tile matrix with values"}}
{"translation": {"code": "public float [ ] getPixelValues ( byte [ ] imageBytes ) { TIFFImage tiffImage = TiffReader . readTiff ( imageBytes ) ; FileDirectory directory = tiffImage . getFileDirectory ( ) ; validateImageType ( directory ) ; Rasters rasters = directory . readRasters ( ) ; float [ ] pixels = new float [ rasters . getWidth ( ) * rasters . getHeight ( ) ] ; for ( int y = 0 ; y < rasters . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < rasters . getWidth ( ) ; x ++ ) { int index = rasters . getSampleIndex ( x , y ) ; pixels [ index ] = rasters . getPixelSample ( 0 , x , y ) . floatValue ( ) ; } } return pixels ; }", "nl": "Get the pixel values of the image as floats"}}
{"translation": {"code": "public int getPixelValue ( byte [ ] imageBytes , int x , int y ) { PngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; validateImageType ( reader ) ; ImageLineInt row = ( ImageLineInt ) reader . readRow ( y ) ; int pixelValue = row . getScanline ( ) [ x ] ; reader . close ( ) ; return pixelValue ; }", "nl": "Get the pixel value as a 16 bit unsigned integer value"}}
{"translation": {"code": "public int [ ] getPixelValues ( byte [ ] imageBytes ) { PngReaderInt reader = new PngReaderInt ( new ByteArrayInputStream ( imageBytes ) ) ; validateImageType ( reader ) ; int [ ] pixels = new int [ reader . imgInfo . cols * reader . imgInfo . rows ] ; int rowNumber = 0 ; while ( reader . hasMoreRows ( ) ) { ImageLineInt row = reader . readRowInt ( ) ; int [ ] rowValues = row . getScanline ( ) ; System . arraycopy ( rowValues , 0 , pixels , rowNumber * reader . imgInfo . cols , rowValues . length ) ; rowNumber ++ ; } reader . close ( ) ; return pixels ; }", "nl": "Get the pixel values of the image as 16 bit unsigned integer values"}}
{"translation": {"code": "public CoverageDataPngImage createImage ( int tileWidth , int tileHeight ) { ImageInfo imageInfo = new ImageInfo ( tileWidth , tileHeight , 16 , false , true , false ) ; CoverageDataPngImage image = new CoverageDataPngImage ( imageInfo ) ; return image ; }", "nl": "Create a new 16 bit single channel image"}}
{"translation": {"code": "public static void validateImageType ( PngReader reader ) { if ( reader == null ) { throw new GeoPackageException ( \"The image is null\" ) ; } if ( reader . imgInfo . channels != 1 || reader . imgInfo . bitDepth != 16 ) { throw new GeoPackageException ( \"The coverage data tile is expected to be a single channel 16 bit unsigned short, channels: \" + reader . imgInfo . channels + \", bits: \" + reader . imgInfo . bitDepth ) ; } }", "nl": "Validate that the image type is single channel 16 bit"}}
{"translation": {"code": "public byte [ ] getImageBytes ( ) { byte [ ] bytes = null ; if ( imageBytes != null ) { bytes = imageBytes ; } else if ( outputStream != null ) { bytes = outputStream . toByteArray ( ) ; } return bytes ; }", "nl": "Get the image bytes"}}
{"translation": {"code": "public void flushStream ( ) { if ( outputStream != null ) { if ( imageBytes == null ) { imageBytes = outputStream . toByteArray ( ) ; } try { outputStream . close ( ) ; } catch ( IOException e ) { Log . w ( CoverageDataPngImage . class . getSimpleName ( ) , \"Failed to close output stream\" , e ) ; } } }", "nl": "Flush the output stream and set the image bytes close the stream"}}
{"translation": {"code": "public int getPixel ( int x , int y ) { int pixel = - 1 ; if ( pixels == null ) { readPixels ( ) ; } if ( pixels != null ) { pixel = pixels [ y ] [ x ] ; } else { throw new GeoPackageException ( \"Could not retrieve pixel value\" ) ; } return pixel ; }", "nl": "Get the pixel at the coordinate"}}
{"translation": {"code": "private void readPixels ( ) { if ( reader != null ) { pixels = new int [ reader . imgInfo . rows ] [ reader . imgInfo . cols ] ; int rowCount = 0 ; while ( reader . hasMoreRows ( ) ) { ImageLineInt row = reader . readRowInt ( ) ; int [ ] columnValues = new int [ reader . imgInfo . cols ] ; System . arraycopy ( row . getScanline ( ) , 0 , columnValues , 0 , columnValues . length ) ; pixels [ rowCount ++ ] = columnValues ; } reader . close ( ) ; } }", "nl": "Read all the pixels from the image"}}
{"translation": {"code": "public static void validateImageType ( FileDirectory directory ) { if ( directory == null ) { throw new GeoPackageException ( \"The image is null\" ) ; } int samplesPerPixel = directory . getSamplesPerPixel ( ) ; Integer bitsPerSample = null ; if ( directory . getBitsPerSample ( ) != null && ! directory . getBitsPerSample ( ) . isEmpty ( ) ) { bitsPerSample = directory . getBitsPerSample ( ) . get ( 0 ) ; } Integer sampleFormat = null ; if ( directory . getSampleFormat ( ) != null && ! directory . getSampleFormat ( ) . isEmpty ( ) ) { sampleFormat = directory . getSampleFormat ( ) . get ( 0 ) ; } if ( samplesPerPixel != SAMPLES_PER_PIXEL || bitsPerSample == null || bitsPerSample != BITS_PER_SAMPLE || sampleFormat == null || sampleFormat != TiffConstants . SAMPLE_FORMAT_FLOAT ) { throw new GeoPackageException ( \"The coverage data tile is expected to be a single sample 32 bit float. Samples Per Pixel: \" + samplesPerPixel + \", Bits Per Sample: \" + bitsPerSample + \", Sample Format: \" + sampleFormat ) ; } }", "nl": "Validate that the image type"}}
{"translation": {"code": "private void addLineString ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , LineString lineString ) { List < Point > points = lineString . getPoints ( ) ; if ( points . size ( ) >= 2 ) { // Try to simplify the number of points in the LineString points = simplifyPoints ( simplifyTolerance , points ) ; for ( int i = 0 ; i < points . size ( ) ; i ++ ) { Point point = points . get ( i ) ; Point webMercatorPoint = transform . transform ( point ) ; float x = TileBoundingBoxUtils . getXPixel ( tileWidth , boundingBox , webMercatorPoint . getX ( ) ) ; float y = TileBoundingBoxUtils . getYPixel ( tileHeight , boundingBox , webMercatorPoint . getY ( ) ) ; if ( i == 0 ) { path . moveTo ( x , y ) ; } else { path . lineTo ( x , y ) ; } } } }", "nl": "Add the linestring to the path"}}
{"translation": {"code": "private boolean drawFeature ( int zoom , BoundingBox boundingBox , BoundingBox expandedBoundingBox , ProjectionTransform transform , FeatureTileCanvas canvas , FeatureRow row ) { boolean drawn = false ; try { GeoPackageGeometryData geomData = row . getGeometry ( ) ; if ( geomData != null ) { Geometry geometry = geomData . getGeometry ( ) ; if ( geometry != null ) { GeometryEnvelope envelope = geomData . getOrBuildEnvelope ( ) ; BoundingBox geometryBoundingBox = new BoundingBox ( envelope ) ; BoundingBox transformedBoundingBox = geometryBoundingBox . transform ( transform ) ; if ( expandedBoundingBox . intersects ( transformedBoundingBox , true ) ) { double simplifyTolerance = TileBoundingBoxUtils . toleranceDistance ( zoom , tileWidth , tileHeight ) ; drawn = drawShape ( simplifyTolerance , boundingBox , transform , canvas , row , geometry ) ; } } } } catch ( Exception e ) { Log . e ( DefaultFeatureTiles . class . getSimpleName ( ) , \"Failed to draw feature in tile. Table: \" + featureDao . getTableName ( ) , e ) ; } return drawn ; }", "nl": "Draw the feature on the canvas"}}
{"translation": {"code": "private boolean drawLinePath ( FeatureTileCanvas canvas , Path path , FeatureStyle featureStyle ) { Canvas lineCanvas = canvas . getLineCanvas ( ) ; Paint pathPaint = getLinePaint ( featureStyle ) ; lineCanvas . drawPath ( path , pathPaint ) ; return true ; }", "nl": "Draw the line path on the canvas"}}
{"translation": {"code": "private boolean drawPolygonPath ( FeatureTileCanvas canvas , Path path , FeatureStyle featureStyle ) { Canvas polygonCanvas = canvas . getPolygonCanvas ( ) ; Paint fillPaint = getPolygonFillPaint ( featureStyle ) ; if ( fillPaint != null ) { path . setFillType ( Path . FillType . EVEN_ODD ) ; polygonCanvas . drawPath ( path , fillPaint ) ; } Paint pathPaint = getPolygonPaint ( featureStyle ) ; polygonCanvas . drawPath ( path , pathPaint ) ; return true ; }", "nl": "Draw the path on the canvas"}}
{"translation": {"code": "private void addPolygon ( double simplifyTolerance , BoundingBox boundingBox , ProjectionTransform transform , Path path , Polygon polygon ) { List < LineString > rings = polygon . getRings ( ) ; if ( ! rings . isEmpty ( ) ) { // Add the polygon points LineString polygonLineString = rings . get ( 0 ) ; List < Point > polygonPoints = polygonLineString . getPoints ( ) ; if ( polygonPoints . size ( ) >= 2 ) { addRing ( simplifyTolerance , boundingBox , transform , path , polygonPoints ) ; // Add the holes for ( int i = 1 ; i < rings . size ( ) ; i ++ ) { LineString holeLineString = rings . get ( i ) ; List < Point > holePoints = holeLineString . getPoints ( ) ; if ( holePoints . size ( ) >= 2 ) { addRing ( simplifyTolerance , boundingBox , transform , path , holePoints ) ; } } } } }", "nl": "Add the polygon on the canvas"}}
{"translation": {"code": "public void setTileData ( Bitmap bitmap , CompressFormat format , int quality ) throws IOException { byte [ ] tileData = BitmapConverter . toBytes ( bitmap , format , quality ) ; setTileData ( tileData ) ; }", "nl": "Set the tile data from a bitmap"}}
{"translation": {"code": "private void readBlobValue ( UserRow row , UserColumn column ) { ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; try { byte [ ] blobChunk = new byte [ ] { 0 } ; for ( int i = 1 ; blobChunk . length > 0 ; i += CHUNK_SIZE ) { if ( i > 1 ) { byteStream . write ( blobChunk ) ; } blobChunk = new byte [ ] { } ; String query = \"select substr(\" + CoreSQLUtils . quoteWrap ( column . getName ( ) ) + \", \" + i + \", \" + CHUNK_SIZE + \") from \" + CoreSQLUtils . quoteWrap ( dao . getTableName ( ) ) + \" where \" + CoreSQLUtils . quoteWrap ( row . getPkColumn ( ) . getName ( ) ) + \" = \" + row . getId ( ) ; Cursor blobCursor = dao . getDatabaseConnection ( ) . getDb ( ) . rawQuery ( query , null ) ; try { if ( blobCursor . moveToNext ( ) ) { blobChunk = blobCursor . getBlob ( 0 ) ; } } finally { blobCursor . close ( ) ; } } byte [ ] blob = byteStream . toByteArray ( ) ; row . setValue ( column . getIndex ( ) , blob ) ; } catch ( IOException e ) { Log . e ( UserInvalidCursor . class . getSimpleName ( ) , \"Failed to read large blob value. Table: \" + dao . getTableName ( ) + \", Column: \" + column . getName ( ) + \", Position: \" + getPosition ( ) , e ) ; } finally { IOUtils . closeQuietly ( byteStream ) ; } }", "nl": "Read the blob column value in chunks"}}
{"translation": {"code": "private TResult handleCursor ( Cursor cursor , UserQuery query ) { TResult result = convertCursor ( cursor ) ; result . setQuery ( query ) ; if ( table != null ) { result . setTable ( table ) ; } return result ; }", "nl": "Convert the cursor to the result type cursor"}}
{"translation": {"code": "public TResult query ( TResult previousResult ) { UserQuery query = previousResult . getQuery ( ) ; TResult result = query ( query ) ; return result ; }", "nl": "Query using the query from a previous query result"}}
{"translation": {"code": "public TResult query ( UserQuery query ) { Cursor cursor = null ; String [ ] selectionArgs = query . getSelectionArgs ( ) ; String sql = query . getSql ( ) ; if ( sql != null ) { cursor = database . rawQuery ( sql , selectionArgs ) ; } else { String table = query . getTable ( ) ; String [ ] columns = query . getColumns ( ) ; String selection = query . getSelection ( ) ; String groupBy = query . getGroupBy ( ) ; String having = query . getHaving ( ) ; String orderBy = query . getOrderBy ( ) ; String [ ] columnsAs = query . getColumnsAs ( ) ; String limit = query . getLimit ( ) ; if ( columnsAs != null && limit != null ) { cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy , limit ) ; } else if ( columnsAs != null ) { cursor = database . query ( table , columns , columnsAs , selection , selectionArgs , groupBy , having , orderBy ) ; } else if ( limit != null ) { cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy , limit ) ; } else { cursor = database . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; } } TResult result = handleCursor ( cursor , query ) ; return result ; }", "nl": "Query using the user query arguments"}}
{"translation": {"code": "private boolean moveToNextInvalid ( ) { boolean hasNext = false ; // If requery has not been performed, a requery dao has been set, and there are invalid positions if ( invalidCursor == null && dao != null && hasInvalidPositions ( ) ) { // Close the original cursor when performing an invalid cursor query super . close ( ) ; // Set the blob columns to return as null List < TColumn > blobColumns = dao . getTable ( ) . columnsOfType ( GeoPackageDataType . BLOB ) ; String [ ] columnsAs = dao . buildColumnsAsNull ( blobColumns ) ; query . set ( UserQueryParamType . COLUMNS_AS , columnsAs ) ; // Query without blob columns and create an invalid cursor UserCursor < TColumn , TTable , TRow > requeryCursor = dao . query ( query ) ; invalidCursor = createInvalidCursor ( dao , requeryCursor , getInvalidPositions ( ) , blobColumns ) ; } if ( invalidCursor != null ) { hasNext = invalidCursor . moveToNext ( ) ; } return hasNext ; }", "nl": "Move to the next position of invalid rows to requery . Perform the requery the first time ."}}
{"translation": {"code": "public GeoPackageGeometryData getGeometry ( ) { GeoPackageGeometryData geometry = null ; int columnIndex = getTable ( ) . getGeometryColumnIndex ( ) ; int type = getType ( columnIndex ) ; if ( type != FIELD_TYPE_NULL ) { byte [ ] geometryBytes = getBlob ( columnIndex ) ; if ( geometryBytes != null ) { geometry = new GeoPackageGeometryData ( geometryBytes ) ; } } return geometry ; }", "nl": "Get the geometry"}}
{"translation": {"code": "protected List < Point > simplifyPoints ( double simplifyTolerance , List < Point > points ) { List < Point > simplifiedPoints = null ; if ( simplifyGeometries ) { // Reproject to web mercator if not in meters if ( projection != null && ! projection . isUnit ( Units . METRES ) ) { ProjectionTransform toWebMercator = projection . getTransformation ( WEB_MERCATOR_PROJECTION ) ; points = toWebMercator . transform ( points ) ; } // Simplify the points simplifiedPoints = GeometryUtils . simplifyPoints ( points , simplifyTolerance ) ; // Reproject back to the original projection if ( projection != null && ! projection . isUnit ( Units . METRES ) ) { ProjectionTransform fromWebMercator = WEB_MERCATOR_PROJECTION . getTransformation ( projection ) ; simplifiedPoints = fromWebMercator . transform ( simplifiedPoints ) ; } } else { simplifiedPoints = points ; } return simplifiedPoints ; }", "nl": "When the simplify tolerance is set simplify the points to a similar curve with fewer points ."}}
{"translation": {"code": "public boolean deleteIndex ( long geomId , List < FeatureIndexType > types ) { boolean deleted = false ; for ( FeatureIndexType type : types ) { if ( deleteIndex ( type , geomId ) ) { deleted = true ; } } return deleted ; }", "nl": "Delete the feature index for the geometry id from the index types"}}
{"translation": {"code": "public List < FeatureIndexType > getIndexedTypes ( ) { List < FeatureIndexType > indexed = new ArrayList <> ( ) ; for ( FeatureIndexType type : indexLocationQueryOrder ) { if ( isIndexed ( type ) ) { indexed . add ( type ) ; } } return indexed ; }", "nl": "Get the indexed types that are currently indexed"}}
{"translation": {"code": "public boolean deleteIndex ( FeatureRow row , List < FeatureIndexType > types ) { boolean deleted = false ; for ( FeatureIndexType type : types ) { if ( deleteIndex ( type , row ) ) { deleted = true ; } } return deleted ; }", "nl": "Delete the feature index for the feature row from the index types"}}
{"translation": {"code": "public boolean index ( FeatureRow row , List < FeatureIndexType > types ) { boolean indexed = false ; for ( FeatureIndexType type : types ) { if ( index ( type , row ) ) { indexed = true ; } } return indexed ; }", "nl": "Index the feature row for the index types . This method assumes that indexing has been completed and maintained as the last indexed time is updated ."}}
{"translation": {"code": "public int index ( boolean force , List < FeatureIndexType > types ) { int count = 0 ; for ( FeatureIndexType type : types ) { int typeCount = index ( type , force ) ; count = Math . max ( count , typeCount ) ; } return count ; }", "nl": "Index the feature tables for the index types"}}
{"translation": {"code": "public boolean deleteIndex ( Collection < FeatureIndexType > types ) { boolean deleted = false ; for ( FeatureIndexType type : types ) { if ( deleteIndex ( type ) ) { deleted = true ; } } return deleted ; }", "nl": "Delete the feature index from the index types"}}
{"translation": {"code": "public static CoverageData < ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao , Projection requestProjection ) { return getCoverageData ( geoPackage , tileDao , null , null , requestProjection ) ; }", "nl": "Get a Tiled Gridded Coverage Data use the coverage data pixel tile size as the request size width and height request as the specified projection"}}
{"translation": {"code": "public static CoverageData < ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao ) { return getCoverageData ( geoPackage , tileDao , null , null , tileDao . getProjection ( ) ) ; }", "nl": "Get a Tiled Gridded Coverage Data use the coverage data pixel tile size as the request size width and height"}}
{"translation": {"code": "public static CoverageData < ? > getCoverageData ( GeoPackage geoPackage , TileDao tileDao , Integer width , Integer height , Projection requestProjection ) { TileMatrixSet tileMatrixSet = tileDao . getTileMatrixSet ( ) ; GriddedCoverageDao griddedCoverageDao = geoPackage . getGriddedCoverageDao ( ) ; GriddedCoverage griddedCoverage = null ; try { if ( griddedCoverageDao . isTableExists ( ) ) { griddedCoverage = griddedCoverageDao . query ( tileMatrixSet ) ; } } catch ( SQLException e ) { throw new GeoPackageException ( \"Failed to get Gridded Coverage for table name: \" + tileMatrixSet . getTableName ( ) , e ) ; } CoverageData < ? > coverageData = null ; GriddedCoverageDataType dataType = griddedCoverage . getDataType ( ) ; switch ( dataType ) { case INTEGER : coverageData = new CoverageDataPng ( geoPackage , tileDao , width , height , requestProjection ) ; break ; case FLOAT : coverageData = new CoverageDataTiff ( geoPackage , tileDao , width , height , requestProjection ) ; break ; default : throw new GeoPackageException ( \"Unsupported Gridded Coverage Data Type: \" + dataType ) ; } return coverageData ; }", "nl": "Get a Tiled Gridded Coverage Data"}}
{"translation": {"code": "public Long getApproximateZoomLevel ( double length ) { Long zoomLevel = TileDaoUtils . getApproximateZoomLevel ( widths , heights , tileMatrices , length ) ; return zoomLevel ; }", "nl": "Get the approximate zoom level for the provided length in the default units . Tiles may or may not exist for the returned zoom level . The approximate zoom level is determined using a factor of 2 from the zoom levels with tiles ."}}
{"translation": {"code": "public List < Long > getMappingsForRelated ( ExtendedRelation extendedRelation , long relatedId ) { return getMappingsForRelated ( extendedRelation . getMappingTableName ( ) , relatedId ) ; }", "nl": "Get the base id mappings for the related id"}}
{"translation": {"code": "protected int count ( UserCustomCursor cursor ) { int count = 0 ; try { count = cursor . getCount ( ) ; } finally { cursor . close ( ) ; } return count ; }", "nl": "Get the count of the cursor and close it"}}
{"translation": {"code": "public int deleteByBaseId ( long baseId ) { StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( UserMappingTable . COLUMN_BASE_ID , baseId ) ) ; String [ ] whereArgs = buildWhereArgs ( new Object [ ] { baseId } ) ; int deleted = delete ( where . toString ( ) , whereArgs ) ; return deleted ; }", "nl": "Delete user mappings by base id"}}
{"translation": {"code": "public UserCustomCursor queryByIds ( long baseId , long relatedId ) { return query ( buildWhereIds ( baseId , relatedId ) , buildWhereIdsArgs ( baseId , relatedId ) ) ; }", "nl": "Query by both base id and related id"}}
{"translation": {"code": "private String buildWhereIds ( long baseId , long relatedId ) { StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( UserMappingTable . COLUMN_BASE_ID , baseId ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( UserMappingTable . COLUMN_RELATED_ID , relatedId ) ) ; return where . toString ( ) ; }", "nl": "Build the where ids clause"}}
{"translation": {"code": "public int deleteByIds ( long baseId , long relatedId ) { return delete ( buildWhereIds ( baseId , relatedId ) , buildWhereIdsArgs ( baseId , relatedId ) ) ; }", "nl": "Delete user mappings by both base id and related id"}}
{"translation": {"code": "public int deleteByRelatedId ( long relatedId ) { StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( UserMappingTable . COLUMN_RELATED_ID , relatedId ) ) ; String [ ] whereArgs = buildWhereArgs ( new Object [ ] { relatedId } ) ; int deleted = delete ( where . toString ( ) , whereArgs ) ; return deleted ; }", "nl": "Delete user mappings by related id"}}
{"translation": {"code": "public static UserCustomDao readTable ( GeoPackage geoPackage , String tableName ) { UserCustomConnection userDb = new UserCustomConnection ( geoPackage . getConnection ( ) ) ; final UserCustomTable userCustomTable = UserCustomTableReader . readTable ( geoPackage . getConnection ( ) , tableName ) ; UserCustomDao dao = new UserCustomDao ( geoPackage . getName ( ) , geoPackage . getConnection ( ) , userDb , userCustomTable ) ; dao . registerCursorWrapper ( geoPackage ) ; return dao ; }", "nl": "Read the database table and create a DAO"}}
{"translation": {"code": "public List < Long > getMappingsForBase ( ExtendedRelation extendedRelation , long baseId ) { return getMappingsForBase ( extendedRelation . getMappingTableName ( ) , baseId ) ; }", "nl": "Get the related id mappings for the base id"}}
{"translation": {"code": "public SimpleAttributesDao getSimpleAttributesDao ( String tableName ) { SimpleAttributesDao simpleAttributesDao = new SimpleAttributesDao ( getUserDao ( tableName ) ) ; simpleAttributesDao . registerCursorWrapper ( getGeoPackage ( ) ) ; setContents ( simpleAttributesDao . getTable ( ) ) ; return simpleAttributesDao ; }", "nl": "Get a related simple attributes table DAO"}}
{"translation": {"code": "public UserMappingDao getMappingDao ( String tableName ) { UserMappingDao userMappingDao = new UserMappingDao ( getUserDao ( tableName ) ) ; userMappingDao . registerCursorWrapper ( getGeoPackage ( ) ) ; return userMappingDao ; }", "nl": "Get a User Mapping DAO from a table name"}}
{"translation": {"code": "public List < SimpleAttributesRow > getRows ( List < Long > ids ) { List < SimpleAttributesRow > simpleAttributesRows = new ArrayList <> ( ) ; for ( long id : ids ) { UserCustomRow userCustomRow = queryForIdRow ( id ) ; if ( userCustomRow != null ) { simpleAttributesRows . add ( getRow ( userCustomRow ) ) ; } } return simpleAttributesRows ; }", "nl": "Get the simple attributes rows that exist with the provided ids"}}
{"translation": {"code": "public static UserCustomTable readTable ( GeoPackageConnection connection , String tableName ) { UserCustomTableReader tableReader = new UserCustomTableReader ( tableName ) ; UserCustomTable customTable = tableReader . readTable ( new UserCustomWrapperConnection ( connection ) ) ; return customTable ; }", "nl": "Read the table"}}
{"translation": {"code": "public void registerCursorWrapper ( GeoPackage geoPackage ) { geoPackage . registerCursorWrapper ( getTableName ( ) , new GeoPackageCursorWrapper ( ) { @ Override public Cursor wrapCursor ( Cursor cursor ) { return new UserCustomCursor ( getTable ( ) , cursor ) ; } } ) ; }", "nl": "Register the cursor wrapper into the GeoPackage"}}
{"translation": {"code": "public static byte [ ] toBytes ( Bitmap bitmap , CompressFormat format , int quality ) throws IOException { byte [ ] bytes = null ; ByteArrayOutputStream byteStream = new ByteArrayOutputStream ( ) ; try { bitmap . compress ( format , quality , byteStream ) ; bytes = byteStream . toByteArray ( ) ; } finally { byteStream . close ( ) ; } return bytes ; }", "nl": "Compress the bitmap to a byte array"}}
{"translation": {"code": "public static Bitmap toBitmap ( byte [ ] bytes , Options options ) { Bitmap bitmap = BitmapFactory . decodeByteArray ( bytes , 0 , bytes . length , options ) ; return bitmap ; }", "nl": "Decode the bytes to a bitmap with options"}}
{"translation": {"code": "public UserCustomCursor query ( GeometryEnvelope envelope ) { return query ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) , envelope . getMaxY ( ) ) ; }", "nl": "Query for rows within the geometry envelope"}}
{"translation": {"code": "public long count ( double minX , double minY , double maxX , double maxY ) { return query ( minX , minY , maxX , maxY ) . count ( ) ; }", "nl": "Manually count the rows within the bounds"}}
{"translation": {"code": "public Extensions create ( ) { Extensions extension = null ; if ( ! has ( ) ) { extension = rTree . create ( featureDao . getTable ( ) ) ; if ( progress != null ) { progress . addProgress ( count ( ) ) ; } } return extension ; }", "nl": "Create the RTree extension for the feature table"}}
{"translation": {"code": "public FeatureRow getFeatureRow ( UserCustomCursor cursor ) { RTreeIndexTableRow row = getRow ( cursor ) ; return getFeatureRow ( row ) ; }", "nl": "Get the feature row from the RTree Index Table row"}}
{"translation": {"code": "public UserCustomCursor query ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = projectBoundingBox ( boundingBox , projection ) ; return query ( featureBoundingBox ) ; }", "nl": "Query for rows within the bounding box in the provided projection"}}
{"translation": {"code": "public UserCustomCursor query ( double minX , double minY , double maxX , double maxY ) { String where = buildWhere ( minX , minY , maxX , maxY ) ; String [ ] whereArgs = buildWhereArgs ( minX , minY , maxX , maxY ) ; return query ( where , whereArgs ) ; }", "nl": "Query for rows within the bounds"}}
{"translation": {"code": "private String buildWhere ( double minX , double minY , double maxX , double maxY ) { StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( RTreeIndexExtension . COLUMN_MIN_X , maxX , \"<=\" ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( RTreeIndexExtension . COLUMN_MIN_Y , maxY , \"<=\" ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( RTreeIndexExtension . COLUMN_MAX_X , minX , \">=\" ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( RTreeIndexExtension . COLUMN_MAX_Y , minY , \">=\" ) ) ; return where . toString ( ) ; }", "nl": "Build a where clause from the bounds for overlapping ranges"}}
{"translation": {"code": "public long count ( GeometryEnvelope envelope ) { return count ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) , envelope . getMaxY ( ) ) ; }", "nl": "Count the rows within the geometry envelope"}}
{"translation": {"code": "public RTreeIndexTableDao getTableDao ( FeatureDao featureDao ) { GeoPackageConnection connection = getGeoPackage ( ) . getConnection ( ) ; UserCustomConnection userDb = new UserCustomConnection ( connection ) ; UserCustomTable userCustomTable = getRTreeTable ( featureDao . getTable ( ) ) ; UserCustomDao userCustomDao = new UserCustomDao ( geoPackage . getName ( ) , connection , userDb , userCustomTable ) ; return new RTreeIndexTableDao ( this , userCustomDao , featureDao ) ; }", "nl": "Get a RTree Index Table DAO for the feature dao"}}
{"translation": {"code": "public long count ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = featureDao . projectBoundingBox ( boundingBox , projection ) ; return count ( featureBoundingBox ) ; }", "nl": "Manually count the rows within the bounding box in the provided projection"}}
{"translation": {"code": "public ManualFeatureQueryResults query ( GeometryEnvelope envelope ) { return query ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) , envelope . getMaxY ( ) ) ; }", "nl": "Manually query for rows within the geometry envelope"}}
{"translation": {"code": "public ManualFeatureQueryResults query ( double minX , double minY , double maxX , double maxY ) { List < Long > featureIds = new ArrayList <> ( ) ; long offset = 0 ; boolean hasResults = true ; minX -= tolerance ; maxX += tolerance ; minY -= tolerance ; maxY += tolerance ; while ( hasResults ) { hasResults = false ; FeatureCursor featureCursor = featureDao . queryForChunk ( chunkLimit , offset ) ; try { while ( featureCursor . moveToNext ( ) ) { hasResults = true ; FeatureRow featureRow = featureCursor . getRow ( ) ; GeometryEnvelope envelope = featureRow . getGeometryEnvelope ( ) ; if ( envelope != null ) { double minXMax = Math . max ( minX , envelope . getMinX ( ) ) ; double maxXMin = Math . min ( maxX , envelope . getMaxX ( ) ) ; double minYMax = Math . max ( minY , envelope . getMinY ( ) ) ; double maxYMin = Math . min ( maxY , envelope . getMaxY ( ) ) ; if ( minXMax <= maxXMin && minYMax <= maxYMin ) { featureIds . add ( featureRow . getId ( ) ) ; } } } } finally { featureCursor . close ( ) ; } offset += chunkLimit ; } ManualFeatureQueryResults results = new ManualFeatureQueryResults ( featureDao , featureIds ) ; return results ; }", "nl": "Manually query for rows within the bounds"}}
{"translation": {"code": "public ManualFeatureQueryResults query ( BoundingBox boundingBox , Projection projection ) { BoundingBox featureBoundingBox = featureDao . projectBoundingBox ( boundingBox , projection ) ; return query ( featureBoundingBox ) ; }", "nl": "Manually query for rows within the bounding box in the provided projection"}}
{"translation": {"code": "public BoundingBox getBoundingBox ( ) { BoundingBox bounds = null ; switch ( getIndexedType ( ) ) { case GEOPACKAGE : bounds = featureTableIndex . getBoundingBox ( ) ; break ; case METADATA : bounds = featureIndexer . getBoundingBox ( ) ; break ; case RTREE : bounds = rTreeIndexTableDao . getBoundingBox ( ) ; break ; default : bounds = manualFeatureQuery . getBoundingBox ( ) ; } return bounds ; }", "nl": "Query for the feature index bounds"}}
{"translation": {"code": "public CursorResult wrapQuery ( String sql , String [ ] selectionArgs ) { return new CursorResult ( rawQuery ( sql , selectionArgs ) ) ; }", "nl": "Perform the query and wrap as a result"}}
{"translation": {"code": "public UserCustomCursor rawQuery ( String sql , String [ ] selectionArgs ) { validateRTree ( ) ; Cursor cursor = database . rawQuery ( sql , selectionArgs ) ; UserCustomCursor customCursor = new UserCustomCursor ( getTable ( ) , cursor ) ; return customCursor ; }", "nl": "Perform a raw query"}}
{"translation": {"code": "public org . sqlite . database . sqlite . SQLiteDatabase openOrGetBindingsDb ( ) { if ( bindingsDb == null ) { synchronized ( db ) { if ( bindingsDb == null ) { System . loadLibrary ( \"sqliteX\" ) ; bindingsDb = org . sqlite . database . sqlite . SQLiteDatabase . openDatabase ( db . getPath ( ) , null , org . sqlite . database . sqlite . SQLiteDatabase . OPEN_READWRITE ) ; } } } return bindingsDb ; }", "nl": "Open or get a connection using the SQLite Android Bindings connection"}}
{"translation": {"code": "public void setHeight ( Double height ) { if ( height != null && height < 0.0 ) { throw new GeoPackageException ( \"Height must be greater than or equal to 0.0, invalid value: \" + height ) ; } setValue ( getHeightColumnIndex ( ) , height ) ; }", "nl": "Set the height"}}
{"translation": {"code": "public void setIcon ( IconRow iconRow , GeometryType geometryType ) { if ( geometryType != null ) { if ( iconRow != null ) { icons . put ( geometryType , iconRow ) ; } else { icons . remove ( geometryType ) ; } } else { defaultIcon = iconRow ; } }", "nl": "Set the icon for the geometry type"}}
{"translation": {"code": "private Color createColor ( String hexColor , Double opacity ) { Color color = null ; if ( hexColor != null || opacity != null ) { color = new Color ( ) ; if ( hexColor != null ) { color . setColor ( hexColor ) ; } if ( opacity != null ) { color . setOpacity ( opacity . floatValue ( ) ) ; } } return color ; }", "nl": "Create a color from the hex color and opacity"}}
{"translation": {"code": "public GeometryType getGeometryType ( ) { GeometryType geometryType = null ; String geometryTypeName = getGeometryTypeName ( ) ; if ( geometryTypeName != null ) { geometryType = GeometryType . fromName ( geometryTypeName ) ; } return geometryType ; }", "nl": "Get the geometry type"}}
{"translation": {"code": "public void setWidth ( Double width ) { if ( width != null && width < 0.0 ) { throw new GeoPackageException ( \"Width must be greater than or equal to 0.0, invalid value: \" + width ) ; } setValue ( getWidthColumnIndex ( ) , width ) ; }", "nl": "Set the width"}}
{"translation": {"code": "private String validateColor ( String color ) { String validated = color ; if ( color != null ) { if ( ! color . startsWith ( \"#\" ) ) { validated = \"#\" + color ; } if ( ! colorPattern . matcher ( validated ) . matches ( ) ) { throw new GeoPackageException ( \"Color must be in hex format #RRGGBB or #RGB, invalid value: \" + color ) ; } validated = validated . toUpperCase ( ) ; } return validated ; }", "nl": "Validate and adjust the color value"}}
{"translation": {"code": "public IconRow getIcon ( GeometryType geometryType ) { IconRow iconRow = null ; if ( geometryType != null && ! icons . isEmpty ( ) ) { List < GeometryType > geometryTypes = GeometryUtils . parentHierarchy ( geometryType ) ; geometryTypes . add ( 0 , geometryType ) ; for ( GeometryType type : geometryTypes ) { iconRow = icons . get ( type ) ; if ( iconRow != null ) { break ; } } } if ( iconRow == null ) { iconRow = defaultIcon ; } if ( iconRow == null && geometryType == null && icons . size ( ) == 1 ) { iconRow = icons . values ( ) . iterator ( ) . next ( ) ; } return iconRow ; }", "nl": "Get the icon for the geometry type"}}
{"translation": {"code": "public void setGeometryType ( GeometryType geometryType ) { String geometryTypeName = null ; if ( geometryType != null ) { geometryTypeName = geometryType . getName ( ) ; } setValue ( getGeometryTypeNameColumnIndex ( ) , geometryTypeName ) ; }", "nl": "Set the geometry type"}}
{"translation": {"code": "public StyleRow queryForRow ( StyleMappingRow styleMappingRow ) { StyleRow styleRow = null ; AttributesRow attributesRow = queryForIdRow ( styleMappingRow . getRelatedId ( ) ) ; if ( attributesRow != null ) { styleRow = getRow ( attributesRow ) ; } return styleRow ; }", "nl": "Query for the style row from a style mapping row"}}
{"translation": {"code": "public Styles getCachedTableStyles ( ) { Styles styles = cachedTableFeatureStyles . getStyles ( ) ; if ( styles == null ) { synchronized ( cachedTableFeatureStyles ) { styles = cachedTableFeatureStyles . getStyles ( ) ; if ( styles == null ) { styles = getTableStyles ( ) ; if ( styles == null ) { styles = new Styles ( ) ; } cachedTableFeatureStyles . setStyles ( styles ) ; } } } if ( styles . isEmpty ( ) ) { styles = null ; } return styles ; }", "nl": "Get the cached table styles querying and caching if needed"}}
{"translation": {"code": "public void setStyles ( FeatureRow featureRow , Styles styles ) { setStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , styles ) ; }", "nl": "Set the styles for the feature row"}}
{"translation": {"code": "public void setFeatureStyles ( String featureTable , long featureId , FeatureStyles featureStyles ) { if ( featureStyles != null ) { setStyles ( featureTable , featureId , featureStyles . getStyles ( ) ) ; setIcons ( featureTable , featureId , featureStyles . getIcons ( ) ) ; } else { deleteStyles ( featureTable , featureId ) ; deleteIcons ( featureTable , featureId ) ; } }", "nl": "Set the feature styles for the feature table and feature id"}}
{"translation": {"code": "public void setFeatureStyles ( FeatureRow featureRow , FeatureStyles featureStyles ) { setFeatureStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , featureStyles ) ; }", "nl": "Set the feature styles for the feature row"}}
{"translation": {"code": "public void setTableIcons ( String featureTable , Icons icons ) { deleteTableIcons ( featureTable ) ; if ( icons != null ) { if ( icons . getDefault ( ) != null ) { setTableIconDefault ( featureTable , icons . getDefault ( ) ) ; } for ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { setTableIcon ( featureTable , icon . getKey ( ) , icon . getValue ( ) ) ; } } }", "nl": "Set the feature table default icons"}}
{"translation": {"code": "public void setTableStyles ( String featureTable , Styles styles ) { deleteTableStyles ( featureTable ) ; if ( styles != null ) { if ( styles . getDefault ( ) != null ) { setTableStyleDefault ( featureTable , styles . getDefault ( ) ) ; } for ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { setTableStyle ( featureTable , style . getKey ( ) , style . getValue ( ) ) ; } } }", "nl": "Set the feature table default styles"}}
{"translation": {"code": "public void setTableFeatureStyles ( String featureTable , FeatureStyles featureStyles ) { if ( featureStyles != null ) { setTableStyles ( featureTable , featureStyles . getStyles ( ) ) ; setTableIcons ( featureTable , featureStyles . getIcons ( ) ) ; } else { deleteTableFeatureStyles ( featureTable ) ; } }", "nl": "Set the feature table default feature styles"}}
{"translation": {"code": "private Icons getIcons ( long featureId , StyleMappingDao mappingDao ) { Icons icons = null ; if ( mappingDao != null ) { IconDao iconDao = getIconDao ( ) ; if ( iconDao != null ) { List < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; if ( ! styleMappingRows . isEmpty ( ) ) { for ( StyleMappingRow styleMappingRow : styleMappingRows ) { IconRow iconRow = iconDao . queryForRow ( styleMappingRow ) ; if ( iconRow != null ) { if ( icons == null ) { icons = new Icons ( ) ; } icons . setIcon ( iconRow , styleMappingRow . getGeometryType ( ) ) ; } } } } } return icons ; }", "nl": "Get the icons for feature id from the icon mapping dao"}}
{"translation": {"code": "public Icons getCachedTableIcons ( ) { Icons icons = cachedTableFeatureStyles . getIcons ( ) ; if ( icons == null ) { synchronized ( cachedTableFeatureStyles ) { icons = cachedTableFeatureStyles . getIcons ( ) ; if ( icons == null ) { icons = getTableIcons ( ) ; if ( icons == null ) { icons = new Icons ( ) ; } cachedTableFeatureStyles . setIcons ( icons ) ; } } } if ( icons . isEmpty ( ) ) { icons = null ; } return icons ; }", "nl": "Get the cached table icons querying and caching if needed"}}
{"translation": {"code": "public Icons getIcons ( FeatureRow featureRow ) { return getIcons ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) ) ; }", "nl": "Get the icons for the feature row"}}
{"translation": {"code": "public Styles getStyles ( FeatureRow featureRow ) { return getStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) ) ; }", "nl": "Get the styles for the feature row"}}
{"translation": {"code": "public FeatureStyles getFeatureStyles ( String featureTable , long featureId ) { Styles styles = getStyles ( featureTable , featureId ) ; Icons icons = getIcons ( featureTable , featureId ) ; FeatureStyles featureStyles = null ; if ( styles != null || icons != null ) { featureStyles = new FeatureStyles ( styles , icons ) ; } return featureStyles ; }", "nl": "Get the feature styles for the feature table and feature id"}}
{"translation": {"code": "public FeatureStyles getFeatureStyles ( FeatureRow featureRow ) { return getFeatureStyles ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) ) ; }", "nl": "Get the feature styles for the feature row"}}
{"translation": {"code": "public IconRow getTableIcon ( String featureTable , GeometryType geometryType ) { IconRow iconRow = null ; Icons tableIcons = getTableIcons ( featureTable ) ; if ( tableIcons != null ) { iconRow = tableIcons . getIcon ( geometryType ) ; } return iconRow ; }", "nl": "Get the icon of the feature table and geometry type"}}
{"translation": {"code": "public Icons getTableIcons ( String featureTable ) { Icons icons = null ; Long id = contentsId . getId ( featureTable ) ; if ( id != null ) { icons = getTableIcons ( featureTable , id ) ; } return icons ; }", "nl": "Get the feature table default icons"}}
{"translation": {"code": "public StyleRow getTableStyle ( String featureTable , GeometryType geometryType ) { StyleRow styleRow = null ; Styles tableStyles = getTableStyles ( featureTable ) ; if ( tableStyles != null ) { styleRow = tableStyles . getStyle ( geometryType ) ; } return styleRow ; }", "nl": "Get the style of the feature table and geometry type"}}
{"translation": {"code": "public Styles getTableStyles ( String featureTable ) { Styles styles = null ; Long id = contentsId . getId ( featureTable ) ; if ( id != null ) { styles = getTableStyles ( featureTable , id ) ; } return styles ; }", "nl": "Get the feature table default styles"}}
{"translation": {"code": "public FeatureStyles getTableFeatureStyles ( String featureTable ) { FeatureStyles featureStyles = null ; Long id = contentsId . getId ( featureTable ) ; if ( id != null ) { Styles styles = getTableStyles ( featureTable , id ) ; Icons icons = getTableIcons ( featureTable , id ) ; if ( styles != null || icons != null ) { featureStyles = new FeatureStyles ( styles , icons ) ; } } return featureStyles ; }", "nl": "Get the feature table default feature styles"}}
{"translation": {"code": "public IconDao getIconDao ( ) { IconDao iconDao = null ; if ( geoPackage . isTable ( IconTable . TABLE_NAME ) ) { iconDao = new IconDao ( relatedTables . getUserDao ( IconTable . TABLE_NAME ) ) ; relatedTables . setContents ( iconDao . getTable ( ) ) ; } return iconDao ; }", "nl": "Get a icon DAO"}}
{"translation": {"code": "public StyleDao getStyleDao ( ) { StyleDao styleDao = null ; if ( geoPackage . isTable ( StyleTable . TABLE_NAME ) ) { AttributesDao attributesDao = getGeoPackage ( ) . getAttributesDao ( StyleTable . TABLE_NAME ) ; styleDao = new StyleDao ( attributesDao ) ; relatedTables . setContents ( styleDao . getTable ( ) ) ; } return styleDao ; }", "nl": "Get a style DAO"}}
{"translation": {"code": "private StyleMappingDao getMappingDao ( String tablePrefix , String featureTable ) { String tableName = tablePrefix + featureTable ; StyleMappingDao dao = null ; if ( geoPackage . isTable ( tableName ) ) { dao = new StyleMappingDao ( relatedTables . getUserDao ( tableName ) ) ; } return dao ; }", "nl": "Get a Style Mapping DAO from a table name"}}
{"translation": {"code": "public List < StyleMappingRow > queryByBaseFeatureId ( long id ) { List < StyleMappingRow > rows = new ArrayList <> ( ) ; UserCustomCursor cursor = queryByBaseId ( id ) ; try { while ( cursor . moveToNext ( ) ) { rows . add ( getRow ( cursor ) ) ; } } finally { cursor . close ( ) ; } return rows ; }", "nl": "Query for style mappings by base id"}}
{"translation": {"code": "public int deleteByBaseId ( long id , GeometryType geometryType ) { String geometryTypeName = null ; if ( geometryType != null ) { geometryTypeName = geometryType . getName ( ) ; } StringBuilder where = new StringBuilder ( ) ; where . append ( buildWhere ( StyleMappingTable . COLUMN_BASE_ID , id ) ) ; where . append ( \" AND \" ) ; where . append ( buildWhere ( StyleMappingTable . COLUMN_GEOMETRY_TYPE_NAME , geometryTypeName ) ) ; List < Object > whereArguments = new ArrayList <> ( ) ; whereArguments . add ( id ) ; if ( geometryTypeName != null ) { whereArguments . add ( geometryTypeName ) ; } String [ ] whereArgs = buildWhereArgs ( whereArguments ) ; int deleted = delete ( where . toString ( ) , whereArgs ) ; return deleted ; }", "nl": "Delete by base is and geometry type"}}
{"translation": {"code": "public boolean hasMapping ( String tableName , long baseId , long relatedId ) { boolean has = false ; UserMappingDao userMappingDao = getMappingDao ( tableName ) ; UserCustomCursor cursor = userMappingDao . queryByIds ( baseId , relatedId ) ; try { has = cursor . getCount ( ) > 0 ; } finally { cursor . close ( ) ; } return has ; }", "nl": "Determine if the base id and related id mapping exists"}}
{"translation": {"code": "public void setStyles ( String featureTable , long featureId , Styles styles ) { deleteStyles ( featureTable , featureId ) ; if ( styles != null ) { if ( styles . getDefault ( ) != null ) { setStyleDefault ( featureTable , featureId , styles . getDefault ( ) ) ; } for ( Entry < GeometryType , StyleRow > style : styles . getStyles ( ) . entrySet ( ) ) { setStyle ( featureTable , featureId , style . getKey ( ) , style . getValue ( ) ) ; } } }", "nl": "Set the styles for the feature table and feature id"}}
{"translation": {"code": "public void setStyle ( FeatureRow featureRow , StyleRow style ) { setStyle ( featureRow , featureRow . getGeometryType ( ) , style ) ; }", "nl": "Set the style of the feature row"}}
{"translation": {"code": "private Styles getStyles ( long featureId , StyleMappingDao mappingDao ) { Styles styles = null ; if ( mappingDao != null ) { StyleDao styleDao = getStyleDao ( ) ; if ( styleDao != null ) { List < StyleMappingRow > styleMappingRows = mappingDao . queryByBaseFeatureId ( featureId ) ; if ( ! styleMappingRows . isEmpty ( ) ) { for ( StyleMappingRow styleMappingRow : styleMappingRows ) { StyleRow styleRow = styleDao . queryForRow ( styleMappingRow ) ; if ( styleRow != null ) { if ( styles == null ) { styles = new Styles ( ) ; } styles . setStyle ( styleRow , styleMappingRow . getGeometryType ( ) ) ; } } } } } return styles ; }", "nl": "Get the styles for feature id from the style mapping dao"}}
{"translation": {"code": "public void setStyleDefault ( String featureTable , long featureId , StyleRow style ) { setStyle ( featureTable , featureId , null , style ) ; }", "nl": "Set the default style of the feature"}}
{"translation": {"code": "private void deleteMapping ( StyleMappingDao mappingDao , long featureId , GeometryType geometryType ) { if ( mappingDao != null ) { mappingDao . deleteByBaseId ( featureId , geometryType ) ; } }", "nl": "Delete the style mapping with the geometry type value"}}
{"translation": {"code": "private void deleteTableMapping ( StyleMappingDao mappingDao , String featureTable , GeometryType geometryType ) { if ( mappingDao != null ) { Long featureContentsId = contentsId . getId ( featureTable ) ; if ( featureContentsId != null ) { mappingDao . deleteByBaseId ( featureContentsId , geometryType ) ; } } }", "nl": "Delete the table style mapping with the geometry type value"}}
{"translation": {"code": "private void deleteTableMappings ( StyleMappingDao mappingDao , String featureTable ) { if ( mappingDao != null ) { Long featureContentsId = contentsId . getId ( featureTable ) ; if ( featureContentsId != null ) { mappingDao . deleteByBaseId ( featureContentsId ) ; } } }", "nl": "Delete the table style mappings"}}
{"translation": {"code": "public void deleteTableIcon ( String featureTable , GeometryType geometryType ) { deleteTableMapping ( getTableIconMappingDao ( featureTable ) , featureTable , geometryType ) ; }", "nl": "Delete the feature table icon for the geometry type"}}
{"translation": {"code": "public void deleteTableStyle ( String featureTable , GeometryType geometryType ) { deleteTableMapping ( getTableStyleMappingDao ( featureTable ) , featureTable , geometryType ) ; }", "nl": "Delete the feature table style for the geometry type"}}
{"translation": {"code": "public void setStyleDefault ( FeatureRow featureRow , StyleRow style ) { setStyle ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , style ) ; }", "nl": "Set the default style of the feature row"}}
{"translation": {"code": "private long getOrInsertIcon ( IconRow icon ) { long iconId ; if ( icon . hasId ( ) ) { iconId = icon . getId ( ) ; } else { IconDao iconDao = getIconDao ( ) ; iconId = iconDao . create ( icon ) ; } return iconId ; }", "nl": "Get the icon id either from the existing icon or by inserting a new one"}}
{"translation": {"code": "private void insertStyleMapping ( StyleMappingDao mappingDao , long baseId , long relatedId , GeometryType geometryType ) { StyleMappingRow row = mappingDao . newRow ( ) ; row . setBaseId ( baseId ) ; row . setRelatedId ( relatedId ) ; row . setGeometryType ( geometryType ) ; mappingDao . insert ( row ) ; }", "nl": "Insert a style mapping row"}}
{"translation": {"code": "public void setIconDefault ( String featureTable , long featureId , IconRow icon ) { setIcon ( featureTable , featureId , null , icon ) ; }", "nl": "Set the default icon of the feature"}}
{"translation": {"code": "public void setIconDefault ( FeatureRow featureRow , IconRow icon ) { setIcon ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , null , icon ) ; }", "nl": "Set the default icon of the feature row"}}
{"translation": {"code": "public void setIcon ( FeatureRow featureRow , IconRow icon ) { setIcon ( featureRow , featureRow . getGeometryType ( ) , icon ) ; }", "nl": "Set the icon of the feature row"}}
{"translation": {"code": "public void setIcons ( String featureTable , long featureId , Icons icons ) { deleteIcons ( featureTable , featureId ) ; if ( icons != null ) { if ( icons . getDefault ( ) != null ) { setIconDefault ( featureTable , featureId , icons . getDefault ( ) ) ; } for ( Entry < GeometryType , IconRow > icon : icons . getIcons ( ) . entrySet ( ) ) { setIcon ( featureTable , featureId , icon . getKey ( ) , icon . getValue ( ) ) ; } } }", "nl": "Set the icons for the feature table and feature id"}}
{"translation": {"code": "public void setIcons ( FeatureRow featureRow , Icons icons ) { setIcons ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) , icons ) ; }", "nl": "Set the icons for the feature row"}}
{"translation": {"code": "private long getOrInsertStyle ( StyleRow style ) { long styleId ; if ( style . hasId ( ) ) { styleId = style . getId ( ) ; } else { StyleDao styleDao = getStyleDao ( ) ; styleId = styleDao . create ( style ) ; } return styleId ; }", "nl": "Get the style id either from the existing style or by inserting a new one"}}