{"translation": {"code": "public Bitmap put ( IconRow iconRow , Bitmap bitmap ) { return put ( iconRow . getId ( ) , bitmap ) ; }", "nl": "Cache the icon bitmap for the icon row"}}
{"translation": {"code": "protected Paint getPolygonFillPaint ( FeatureStyle featureStyle ) { Paint paint = null ; boolean hasStyleColor = false ; if ( featureStyle != null ) { StyleRow style = featureStyle . getStyle ( ) ; if ( style != null ) { if ( style . hasFillColor ( ) ) { paint = getStylePaint ( style , FeatureDrawType . FILL ) ; } else { hasStyleColor = style . hasColor ( ) ; } } } if ( paint == null && ! hasStyleColor && fillPolygon ) { paint = polygonFillPaint ; } return paint ; }", "nl": "Get the polygon fill paint for the feature style or return the default paint"}}
{"translation": {"code": "private Paint getStylePaint ( StyleRow style , FeatureDrawType drawType ) { Paint paint = featurePaintCache . getPaint ( style , drawType ) ; if ( paint == null ) { Color color = null ; Style paintStyle = null ; Float strokeWidth = null ; switch ( drawType ) { case CIRCLE : color = style . getColorOrDefault ( ) ; paintStyle = Style . FILL ; break ; case STROKE : color = style . getColorOrDefault ( ) ; paintStyle = Style . STROKE ; strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; break ; case FILL : color = style . getFillColor ( ) ; paintStyle = Style . FILL ; strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; break ; default : throw new GeoPackageException ( \"Unsupported Draw Type: \" + drawType ) ; } Paint stylePaint = new Paint ( ) ; stylePaint . setAntiAlias ( true ) ; stylePaint . setStyle ( paintStyle ) ; stylePaint . setColor ( color . getColorWithAlpha ( ) ) ; if ( strokeWidth != null ) { stylePaint . setStrokeWidth ( strokeWidth ) ; } synchronized ( featurePaintCache ) { paint = featurePaintCache . getPaint ( style , drawType ) ; if ( paint == null ) { featurePaintCache . setPaint ( style , drawType , stylePaint ) ; paint = stylePaint ; } } } return paint ; }", "nl": "Get the style paint from cache or create and cache it"}}
{"translation": {"code": "public List < Long > uniqueRelatedIds ( ) { return querySingleColumnTypedResults ( \"SELECT DISTINCT \" + CoreSQLUtils . quoteWrap ( UserMappingTable . COLUMN_RELATED_ID ) + \" FROM \" + CoreSQLUtils . quoteWrap ( getTableName ( ) ) , null ) ; }", "nl": "Get the unique related ids"}}
{"translation": {"code": "public List < Long > getAllIconIds ( String featureTable ) { List < Long > iconIds = null ; StyleMappingDao mappingDao = getIconMappingDao ( featureTable ) ; if ( mappingDao != null ) { iconIds = mappingDao . uniqueRelatedIds ( ) ; } return iconIds ; }", "nl": "Get all the unique icon row ids the features map to"}}
{"translation": {"code": "public double [ ] getDerivedDimensions ( ) { Double width = getWidth ( ) ; Double height = getHeight ( ) ; if ( width == null || height == null ) { BitmapFactory . Options options = getDataBounds ( ) ; int dataWidth = options . outWidth ; int dataHeight = options . outHeight ; if ( width == null ) { width = ( double ) dataWidth ; if ( height != null ) { width *= ( height / dataHeight ) ; } } if ( height == null ) { height = ( double ) dataHeight ; if ( width != null ) { height *= ( width / dataWidth ) ; } } } return new double [ ] { width , height } ; }", "nl": "Get the derived width and height from the values and icon data scaled as needed"}}
{"translation": {"code": "private Canvas getCanvas ( int layer ) { Canvas canvas = layeredCanvas [ layer ] ; if ( canvas == null ) { createBitmapAndCanvas ( layer ) ; canvas = layeredCanvas [ layer ] ; } return canvas ; }", "nl": "Get the canvas for the layer index"}}
{"translation": {"code": "public void recycle ( ) { for ( int layer = 0 ; layer < 4 ; layer ++ ) { Bitmap bitmap = layeredBitmap [ layer ] ; if ( bitmap != null ) { bitmap . recycle ( ) ; layeredBitmap [ layer ] = null ; layeredCanvas [ layer ] = null ; } } }", "nl": "Recycle the layered bitmaps"}}
{"translation": {"code": "private Bitmap getBitmap ( int layer ) { Bitmap bitmap = layeredBitmap [ layer ] ; if ( bitmap == null ) { createBitmapAndCanvas ( layer ) ; bitmap = layeredBitmap [ layer ] ; } return bitmap ; }", "nl": "Get the bitmap for the layer index"}}
{"translation": {"code": "private void createBitmapAndCanvas ( int layer ) { layeredBitmap [ layer ] = Bitmap . createBitmap ( tileWidth , tileHeight , Bitmap . Config . ARGB_8888 ) ; layeredCanvas [ layer ] = new Canvas ( layeredBitmap [ layer ] ) ; }", "nl": "Create a new empty Bitmap and Canvas"}}
{"translation": {"code": "public Paint getPaint ( StyleRow styleRow , FeatureDrawType type ) { return getPaint ( styleRow . getId ( ) , type ) ; }", "nl": "Get the paint for the style row and draw type"}}
{"translation": {"code": "private static BoundingBox getBoundingBox ( GeoPackage geoPackage , FeatureTiles featureTiles , BoundingBox boundingBox , Projection projection ) { String tableName = featureTiles . getFeatureDao ( ) . getTableName ( ) ; boolean manualQuery = boundingBox == null ; BoundingBox featureBoundingBox = geoPackage . getBoundingBox ( projection , tableName , manualQuery ) ; if ( featureBoundingBox != null ) { if ( boundingBox == null ) { boundingBox = featureBoundingBox ; } else { boundingBox = boundingBox . overlap ( featureBoundingBox ) ; } } if ( boundingBox != null ) { boundingBox = featureTiles . expandBoundingBox ( boundingBox , projection ) ; } return boundingBox ; }", "nl": "Get the bounding box for the feature tile generator from the provided and from the feature table"}}
{"translation": {"code": "public FeatureRow remove ( FeatureRow featureRow ) { return remove ( featureRow . getTable ( ) . getTableName ( ) , featureRow . getId ( ) ) ; }", "nl": "Remove the cached feature row"}}
{"translation": {"code": "public void clearAndResize ( int maxCacheSize ) { setMaxCacheSize ( maxCacheSize ) ; for ( FeatureCache cache : tableCache . values ( ) ) { cache . clearAndResize ( maxCacheSize ) ; } }", "nl": "Clear and resize all caches and update the max cache size"}}
{"translation": {"code": "public static float tileDensity ( float density , int tileWidth , int tileHeight ) { return tileDensity ( density , Math . min ( tileWidth , tileHeight ) ) ; }", "nl": "Get the tile density based upon the display density scale and tile dimensions"}}
{"translation": {"code": "public void setDensity ( float density ) { this . density = density ; linePaint . setStrokeWidth ( this . density * lineStrokeWidth ) ; polygonPaint . setStrokeWidth ( this . density * polygonStrokeWidth ) ; featurePaintCache . clear ( ) ; }", "nl": "Set the density"}}