{"translation": {"code": "public void createObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Creating Pool for \" + profileTable ) ; } createObjectPool ( profileTable ) ; if ( sleeTransactionManager != null ) { // add a rollback action to remove sbb object pool TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Due to tx rollback, removing pool for \" + profileTable ) ; } try { removeObjectPool ( profileTable ) ; } catch ( Throwable e ) { logger . error ( \"Failed to remove table's \" + profileTable + \" object pool\" , e ) ; } } } ; sleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; } }", "nl": "Creates an object pool for the specified profile table . If a transaction manager is used then and if the tx rollbacks the pool will be removed ."}}
{"translation": {"code": "public static void passivateProfileObjectOnTxEnd ( SleeTransactionManager txManager , final ProfileObjectImpl profileObject , final ProfileObjectPool pool ) { TransactionalAction afterRollbackAction = new TransactionalAction ( ) { public void execute ( ) { profileObject . invalidateObject ( ) ; pool . returnObject ( profileObject ) ; } } ; TransactionalAction beforeCommitAction = new TransactionalAction ( ) { public void execute ( ) { if ( profileObject . getState ( ) == ProfileObjectState . READY ) { if ( ! profileObject . getProfileEntity ( ) . isRemove ( ) ) { profileObject . fireAddOrUpdatedEventIfNeeded ( ) ; profileObject . profilePassivate ( ) ; } else { profileObject . profileRemove ( true , false ) ; } pool . returnObject ( profileObject ) ; } } } ; final TransactionContext txContext = txManager . getTransactionContext ( ) ; txContext . getAfterRollbackActions ( ) . add ( afterRollbackAction ) ; txContext . getBeforeCommitActions ( ) . add ( beforeCommitAction ) ; }", "nl": "Adds transactional actions to the active transaction to passivate a profile object ."}}
{"translation": {"code": "public void remove ( boolean isUninstall ) throws SLEEException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"removeProfileTable: removing profileTable=\" + profileTableName ) ; } // remove the table profiles, at this stage they may use notification source, lets leave it. for ( ProfileID profileID : getProfiles ( ) ) { // don't invoke the profile concrete object, to avoid evil profile lifecycle impls  // that rollbacks tx, as Test1110251Test this . removeProfile ( profileID . getProfileName ( ) , false , isUninstall ) ; } // remove default profile if ( getDefaultProfileEntity ( ) != null ) { this . removeProfile ( null , false , false ) ; } // add action after commit to remove tracer and close uncommitted mbeans TransactionalAction commitAction = new TransactionalAction ( ) { public void execute ( ) { // remove notification sources for profile table final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; traceMBeanImpl . deregisterNotificationSource ( new ProfileTableNotification ( profileTableName ) ) ; // close uncommitted mbeans closeUncommittedProfileMBeans ( ) ; } } ; sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( commitAction ) ; if ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { endActivity ( ) ; } // unregister mbean unregisterUsageMBean ( ) ; // remove object pool profileManagement . getObjectPoolManagement ( ) . removeObjectPool ( this , sleeContainer . getTransactionManager ( ) ) ; }", "nl": "Triggers remove operation on this profile table ."}}
{"translation": {"code": "public void fireAddOrUpdatedEventIfNeeded ( ) { if ( state == ProfileObjectState . READY ) { if ( profileEntity . isDirty ( ) ) { // check the table fires events and the object is not assigned to a default profile if ( profileTable . doesFireEvents ( ) && profileEntity . getProfileName ( ) != null && profileTable . getSleeContainer ( ) . getSleeState ( ) == SleeState . RUNNING ) { // Fire a Profile Added or Updated Event ActivityContext ac = profileTable . getActivityContext ( ) ; AbstractProfileEvent event = null ; if ( profileEntity . isCreate ( ) ) { if ( persisted ) { event = new ProfileAddedEventImpl ( profileEntity , profileTable . getProfileManagement ( ) ) ; persisted = false ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"firing profile added event for profile named \" + profileEntity ) ; } } else { return ; } } else { event = new ProfileUpdatedEventImpl ( profileEntitySnapshot , profileEntity , profileTable . getProfileManagement ( ) ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"firing profile updated event for profile named \" + profileEntity ) ; } } ac . fireEvent ( event . getEventTypeID ( ) , event , event . getProfileAddress ( ) , null , null , null , null ) ; } } } }", "nl": "Fires a profile added or updated event if the profile object state is ready and the persistent state is dirty"}}
{"translation": {"code": "ProfileObjectImpl getProfileObjectValidInCurrentTransaction ( ProfileEntity profileEntity ) throws TransactionRequiredLocalException { // check tx\r final SleeTransactionManager txManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; txManager . mandateTransaction ( ) ; // look for an assigned object in local map\r if ( txData == null ) { txData = new HashMap < ProfileEntity , ProfileObjectImpl > ( ) ; } ProfileObjectImpl profileObject = ( ProfileObjectImpl ) txData . get ( profileEntity ) ; if ( profileObject == null ) { // get an object from the table\r profileEntity . setReadOnly ( true ) ; profileEntity . setDirty ( false ) ; ProfileObjectPool pool = profileManagement . getObjectPoolManagement ( ) . getObjectPool ( profileEntity . getTableName ( ) ) ; profileObject = pool . borrowObject ( ) ; profileObject . profileActivate ( profileEntity ) ; ProfileTableTransactionView . passivateProfileObjectOnTxEnd ( txManager , profileObject , pool ) ; txData . put ( profileEntity , profileObject ) ; } return profileObject ; }", "nl": "Retrieves a local object valid for thus current transaction ."}}
{"translation": {"code": "boolean isProfileClassVisible ( ) { try { Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileAfterAction . getClass ( ) . getName ( ) ) ; return true ; } catch ( Throwable e ) { return false ; } }", "nl": "Verifies if the specified class can be loaded by current thread class loader"}}
{"translation": {"code": "public static Object getUsageParameterSet ( ProfileObjectImpl profileObject , String name ) throws UnrecognizedUsageParameterSetNameException { if ( logger . isDebugEnabled ( ) ) { logger . info ( \"[getUsageParameterSet(\" + name + \")] @ \" + profileObject ) ; } if ( name == null ) { throw new NullPointerException ( \"UsageParameterSet name must not be null.\" ) ; } ProfileTableImpl profileTable = profileObject . getProfileTable ( ) ; Object result = profileTable . getProfileTableUsageMBean ( ) . getInstalledUsageParameterSet ( name ) ; if ( result == null ) { throw new UnrecognizedUsageParameterSetNameException ( ) ; } else { return result ; } }", "nl": "Usage methods . Here we can be static for sure . Rest must be tested ."}}
{"translation": {"code": "public AbstractProfileCmpSlee10Wrapper getProfileCmpSlee10Wrapper ( ) { if ( profileCmpSlee10Wrapper == null ) { try { profileCmpSlee10Wrapper = ( AbstractProfileCmpSlee10Wrapper ) profileTable . getProfileSpecificationComponent ( ) . getProfileCmpSlee10WrapperClass ( ) . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } return profileCmpSlee10Wrapper ; }", "nl": "Retrieves the profile cmp slee 1 . 0 wrapper for this profile object"}}
{"translation": {"code": "private void generateNamedUsageParameterGetter ( CtClass profileConcreteClass ) { String methodName = \"getUsageParameterSet\" ; for ( CtMethod ctMethod : profileConcreteClass . getMethods ( ) ) { if ( ctMethod . getName ( ) . equals ( methodName ) ) { try { // copy method, we can't just add body becase it is in super\r // class and does not sees profileObject field\r CtMethod ctMethodCopy = CtNewMethod . copy ( ctMethod , profileConcreteClass , null ) ; // create the method body\r String methodBody = \"{ return ($r)\" + ClassGeneratorUtils . MANAGEMENT_HANDLER + \".getUsageParameterSet(profileObject,$1); }\" ; if ( logger . isTraceEnabled ( ) ) logger . trace ( \"Implemented method \" + methodName + \" , body = \" + methodBody ) ; ctMethodCopy . setBody ( methodBody ) ; profileConcreteClass . addMethod ( ctMethodCopy ) ; } catch ( CannotCompileException e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } } }", "nl": "Create a named usage parameter getter ."}}
{"translation": {"code": "public ProfileLocalObject getProfileLocalObject ( ) { final Class < ? > profileLocalObjectConcreteClass = profileTable . getProfileSpecificationComponent ( ) . getProfileLocalObjectConcreteClass ( ) ; ProfileLocalObject profileLocalObject = null ; if ( profileLocalObjectConcreteClass == null ) { profileLocalObject = new ProfileLocalObjectImpl ( this ) ; } else { try { profileLocalObject = ( ProfileLocalObject ) profileLocalObjectConcreteClass . getConstructor ( ProfileObjectImpl . class ) . newInstance ( this ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } return profileLocalObject ; }", "nl": "Retrieves the local representation for this profile object"}}
{"translation": {"code": "public ProfileTableActivity getProfileTableActivity ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"getProfileTableActivity( profileTableName = \" + profileTableName + \" )\" ) ; } final SleeTransactionManager sleeTransactionManager = profileManagement . getSleeContainer ( ) . getTransactionManager ( ) ; boolean terminateTx = sleeTransactionManager . requireTransaction ( ) ; try { return profileManagement . getProfileTable ( profileTableName ) . getActivity ( ) ; } catch ( NullPointerException e ) { throw e ; } catch ( UnrecognizedProfileTableNameException e ) { throw e ; } catch ( Throwable e ) { throw new FacilityException ( \"Failed to obtain profile table.\" , e ) ; } finally { // never rollback\r try { sleeTransactionManager . requireTransactionEnd ( terminateTx , false ) ; } catch ( Throwable e ) { throw new FacilityException ( e . getMessage ( ) , e ) ; } } }", "nl": "Get a ProfileTableActivity object for a profile table ."}}
{"translation": {"code": "public void setProfileContext ( ProfileContextImpl profileContext ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"[setProfileContext] \" + this ) ; } if ( profileContext == null ) { throw new NullPointerException ( \"Passed context must not be null.\" ) ; } if ( state != ProfileObjectState . DOES_NOT_EXIST ) { throw new IllegalStateException ( \"Wrong state: \" + this . state + \",on profile set context operation, for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) ) ; } this . profileContext = profileContext ; this . profileContext . setProfileObject ( this ) ; if ( profileConcreteClassInfo . isInvokeSetProfileContext ( ) ) { final ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; try { final ClassLoader cl = this . profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; if ( System . getSecurityManager ( ) != null ) { AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Object run ( ) { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; return null ; } } ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; } try { if ( isSlee11 ) { try { profileConcrete . setProfileContext ( profileContext ) ; } catch ( RuntimeException e ) { runtimeExceptionOnProfileInvocation ( e ) ; } } } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( \"Exception encountered while setting profile context for profile table: \" + this . profileTable . getProfileTableName ( ) + \" with specification: \" + this . profileTable . getProfileSpecificationComponent ( ) . getProfileSpecificationID ( ) , e ) ; } } finally { if ( System . getSecurityManager ( ) != null ) { AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Object run ( ) { Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; return null ; } } ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; } } } state = ProfileObjectState . POOLED ; }", "nl": "Invoked from pool ."}}
{"translation": {"code": "public static CtClass createClass ( String className , String [ ] interfaces ) throws Exception { if ( className == null ) { throw new NullPointerException ( \"Class name cannot be null\" ) ; } CtClass clazz = classPool . makeClass ( className ) ; if ( interfaces != null && interfaces . length > 0 ) { clazz . setInterfaces ( classPool . get ( interfaces ) ) ; } return clazz ; }", "nl": "Creates a class with the desired name and linked to the mentioned interfaces ."}}
{"translation": {"code": "public void displayResult ( ) { //default impl of display;\r if ( ! context . isQuiet ( ) ) { // Translate the result to text\r String resultText = prepareResultText ( ) ; // render results to out\r PrintWriter out = context . getWriter ( ) ; out . println ( resultText ) ; out . flush ( ) ; } }", "nl": "Method to display result of operation ."}}
{"translation": {"code": "protected void makeGetter ( ) { if ( fieldClass . equals ( boolean . class ) || fieldClass . equals ( Boolean . class ) ) { super . operationName = \"is\" + this . beanFieldName ; } else { super . operationName = \"get\" + this . beanFieldName ; } }", "nl": "User should overide it to provide different name for instance for boolean \\ is \\ prefix"}}
{"translation": {"code": "private String extractMessage ( String result ) { // Fix:\r // Firefox 2 encapsulates the text inside <pre> tag\r String startPreTag = \"<pre>\" ; String endPreTag = \"</pre>\" ; result = result . trim ( ) ; if ( result . startsWith ( startPreTag ) && result . endsWith ( endPreTag ) ) { result = result . substring ( startPreTag . length ( ) , result . length ( ) - endPreTag . length ( ) ) ; } return result ; }", "nl": "protected DeployableUnitsCard deployableUnitsCard ;"}}
{"translation": {"code": "public void clearLoggers ( String name ) throws ManagementConsoleException { try { this . mbeanServer . invoke ( logMgmtMBeanName , \"clearLoggers\" , new Object [ ] { name } , new String [ ] { \"java.lang.String\" } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "Removes all loggers under certain branch ."}}
{"translation": {"code": "public void resetLoggerLevels ( ) throws ManagementConsoleException { try { this . mbeanServer . invoke ( logMgmtMBeanName , \"resetLoggerLevels\" , null , null ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "Resets all loggers level to default one"}}
{"translation": {"code": "private static String toTTL ( String lastAccess , long timeout ) { Long ttl = timeout - ( ( System . currentTimeMillis ( ) - Long . parseLong ( lastAccess ) ) / 1000 ) ; return ttl . toString ( ) ; }", "nl": "Calculates the Activity TTL"}}
{"translation": {"code": "public void addSocketHandler ( String loggerName , Level handlerLevel , String handlerName , String formaterClassName , String filterClassName , String host , int port ) throws ManagementConsoleException { try { this . mbeanServer . invoke ( logMgmtMBeanName , \"addSocketHandler\" , new Object [ ] { loggerName , handlerLevel , handlerName , formaterClassName , filterClassName , host , port } , new String [ ] { \"java.lang.String\" , \"java.util.logging.Level\" , \"java.lang.String\" , \"java.lang.String\" , \"java.lang.String\" , \"java.lang.String\" , \"int\" } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "Adds SocketHandler to certain logger this logger must exist prior this function is called"}}
{"translation": {"code": "public boolean removeHandler ( String loggerName , String handlerName ) throws ManagementConsoleException { try { return ( ( Boolean ) this . mbeanServer . invoke ( logMgmtMBeanName , \"removeHandler\" , new Object [ ] { loggerName , handlerName } , new String [ ] { \"java.lang.String\" , \"java.lang.String\" } ) ) . booleanValue ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "Tries to remove handler from logger ."}}
{"translation": {"code": "public static ObjectName getObjectName ( String profileTableName , String profileName ) { // FIXME use only the \"quoted\" version when issue is fully solved at the JMX Console side try { return new ObjectName ( ProfileMBean . BASE_OBJECT_NAME + ' ' + ProfileMBean . PROFILE_TABLE_NAME_KEY + ' ' + profileTableName + ' ' + ProfileMBean . PROFILE_NAME_KEY + ' ' + ( profileName != null ? profileName : \"\" ) ) ; } catch ( Throwable e ) { try { return new ObjectName ( ProfileMBean . BASE_OBJECT_NAME + ' ' + ProfileMBean . PROFILE_TABLE_NAME_KEY + ' ' + ObjectName . quote ( profileTableName ) + ' ' + ProfileMBean . PROFILE_NAME_KEY + ' ' + ObjectName . quote ( profileName != null ? profileName : \"\" ) ) ; } catch ( Throwable f ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } }", "nl": "Retrieves the JMX ObjectName for a profile given its profile name and profile table name"}}
{"translation": {"code": "protected void beforeSetCmpField ( ) throws ManagementException , InvalidStateException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"beforeSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } if ( isProfileWriteable ( ) ) { try { sleeContainer . getTransactionManager ( ) . resume ( transaction ) ; } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } } else { throw new InvalidStateException ( ) ; } }", "nl": "Logic to execute before invoking a cmp setter method on the mbean"}}
{"translation": {"code": "protected boolean beforeManagementMethodInvocation ( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"beforeManagementMethodInvocation() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } jndiManagement = sleeContainer . getJndiManagement ( ) ; jndiManagement . pushJndiContext ( profileTable . getProfileSpecificationComponent ( ) ) ; return beforeNonSetCmpField ( ) ; }", "nl": "Logic to execute before invoking a management method on the mbean"}}
{"translation": {"code": "public static void close ( String profileTableName , String profileName ) { final ObjectName objectName = getObjectName ( profileTableName , profileName ) ; if ( sleeContainer . getMBeanServer ( ) . isRegistered ( objectName ) ) { Runnable r = new Runnable ( ) { public void run ( ) { try { sleeContainer . getMBeanServer ( ) . invoke ( objectName , \"close\" , new Object [ ] { } , new String [ ] { } ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } ; Thread t = new Thread ( r ) ; t . start ( ) ; } }", "nl": "Closes and unregisters the mbean for the specified profile if exists"}}