{"translation": {"code": "public boolean decorateAbstractSbb ( ) throws DeploymentException { ClassPool pool = component . getClassPool ( ) ; String sbbAbstractClassName = component . getDescriptor ( ) . getSbbAbstractClass ( ) . getSbbAbstractClassName ( ) ; try { sbbAbstractClass = pool . get ( sbbAbstractClassName ) ; } catch ( NotFoundException nfe ) { throw new DeploymentException ( \"Could not find Abstract Sbb Class: \" + sbbAbstractClassName , nfe ) ; } // populate the list of concrete methods. It will be needed by the\r // decorating methods.\r concreteMethods = new HashMap ( ) ; CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { int mods = methods [ i ] . getModifiers ( ) ; if ( ! Modifier . isAbstract ( mods ) && ! Modifier . isNative ( mods ) ) { concreteMethods . put ( methods [ i ] . getName ( ) + methods [ i ] . getSignature ( ) , methods [ i ] ) ; } } decorateENCBindCalls ( ) ; decorateNewThreadCalls ( ) ; if ( isAbstractSbbClassDecorated ) { try { String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; sbbAbstractClass . writeFile ( deployDir ) ; sbbAbstractClass . detach ( ) ; // the file on disk is now in sync with the latest in-memory version\r if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Modified Abstract Class \" + sbbAbstractClass . getName ( ) + \" generated in the following path \" + deployDir ) ; } //} catch (NotFoundException e) {\r //    String s = \"Error writing modified abstract sbb class\";\r //    logger.error(s,e);\r //    throw new DeploymentException (s,e);\r } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } finally { sbbAbstractClass . defrost ( ) ; } return true ; } else { return false ; } }", "nl": "Decorate the abstract sbb Class"}}
{"translation": {"code": "protected final void add ( QueryExpression expr ) throws NullPointerException , IllegalArgumentException { if ( expr == null ) throw new NullPointerException ( \"expr is null\" ) ; // check for cycles if ( expr instanceof CompositeQueryExpression ) { ( ( CompositeQueryExpression ) expr ) . checkForCycles ( this ) ; } else if ( expr instanceof Not ) { ( ( Not ) expr ) . checkForCycles ( this ) ; } // no cycles, so add the expression to the list exprs . add ( expr ) ; }", "nl": "Add a query expression to this composite expression ."}}
{"translation": {"code": "private Object readResolve ( ) throws StreamCorruptedException { if ( level == LEVEL_OFF ) return OFF ; if ( level == LEVEL_SEVERE ) return SEVERE ; if ( level == LEVEL_WARNING ) return WARNING ; if ( level == LEVEL_INFO ) return INFO ; if ( level == LEVEL_CONFIG ) return CONFIG ; if ( level == LEVEL_FINE ) return FINE ; if ( level == LEVEL_FINER ) return FINER ; if ( level == LEVEL_FINEST ) return FINEST ; throw new StreamCorruptedException ( \"Invalid internal state found\" ) ; }", "nl": "Resolve deserialisation references so that the singleton property of each enumerated object is preserved ."}}
{"translation": {"code": "public boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( \"other is null\" ) ; return this . level < other . level ; }", "nl": "Determine if this TraceLevel object represents a level that is higher than some other TraceLevel object . For the purposes of the comparison OFF is considered a higher level than SEVERE and FINEST is the lowest level ."}}
{"translation": {"code": "public boolean isHigherLevel ( Level other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( \"other is null\" ) ; return this . level < other . level ; }", "nl": "Determine if this Level object represents a level that is higher or more severe that some other Level object . For the purposes of the comparison OFF is considered a higher level than SEVERE ."}}
{"translation": {"code": "public final void setProfileID ( String profileTableName , String profileName ) throws NullPointerException , IllegalArgumentException { if ( profileTableName == null ) throw new NullPointerException ( \"profileTableName is null\" ) ; if ( profileName == null ) throw new NullPointerException ( \"profileName is null\" ) ; if ( profileTableName . indexOf ( ' ' ) >= 0 ) throw new IllegalArgumentException ( \"profileTableName cannot contain the '/' character\" ) ; this . profileTableName = profileTableName ; this . profileName = profileName ; this . address = null ; }", "nl": "Set the profile table and profile referenced by this profile identifier to new values ."}}
{"translation": {"code": "public static Object readObject ( ObjectInputStream in , boolean vendorDataDeserializationEnabled ) throws IOException , ClassNotFoundException { // read non-transient fields in . defaultReadObject ( ) ; // read any possible marshalled vendor data from the stream MarshalledObject vendorData = in . readBoolean ( ) ? ( MarshalledObject ) in . readObject ( ) : null ; // now figure out what to return return ( vendorData != null && vendorDataDeserializationEnabled ) ? vendorData . get ( ) : null ; }", "nl": "Read the current object in the input stream from the stream optionally deserializing any vendor - specific data in the stream ."}}
{"translation": {"code": "public static void writeObject ( ObjectOutputStream out , Object vendorData ) throws IOException { // write non-transient fields out . defaultWriteObject ( ) ; // check if should we serialize vendor data? if ( vendorData != null ) { // serialize the vendor data out . writeBoolean ( true ) ; // write the vendor data in a marshalled object so deserialization can be deferred out . writeObject ( new MarshalledObject ( vendorData ) ) ; } else out . writeBoolean ( false ) ; }", "nl": "Write the current object and vendor - specific data to the output stream ."}}
{"translation": {"code": "protected void executeAfterRollbackActions ( ) { if ( afterRollbackActions != null ) { if ( trace ) { logger . trace ( \"Executing rollback actions\" ) ; } executeActions ( afterRollbackActions , trace ) ; afterRollbackActions = null ; } }", "nl": "Executes actions scheduled for after a rollback"}}
{"translation": {"code": "protected void executeBeforeCommitActions ( ) { if ( beforeCommitActions != null ) { if ( trace ) { logger . trace ( \"Executing before commit actions\" ) ; } executeActions ( beforeCommitActions , trace ) ; beforeCommitActions = null ; } }", "nl": "Executes actions scheduled for before commit"}}
{"translation": {"code": "protected void executeAfterCommitActions ( ) { if ( afterCommitActions != null ) { if ( trace ) { logger . trace ( \"Executing after commit actions\" ) ; } executeActions ( afterCommitActions , trace ) ; afterCommitActions = null ; } }", "nl": "Executes actions scheduled after commit succeeds"}}
{"translation": {"code": "protected void executeAfterCommitPriorityActions ( ) { if ( afterCommitPriorityActions != null ) { if ( trace ) { logger . trace ( \"Executing after commit priority actions\" ) ; } executeActions ( afterCommitPriorityActions , trace ) ; afterCommitPriorityActions = null ; } }", "nl": "Executes actions scheduled to run first after commit succeeds"}}
{"translation": {"code": "private void buildProfileAttributeMap ( ) throws DeploymentException { HashMap < String , ProfileAttribute > map = new HashMap < String , ProfileAttribute > ( ) ; Class < ? > cmpInterface = getProfileCmpInterfaceClass ( ) ; String attributeGetterMethodPrefix = \"get\" ; for ( Method method : cmpInterface . getMethods ( ) ) { if ( ! method . getDeclaringClass ( ) . equals ( Object . class ) && method . getName ( ) . startsWith ( attributeGetterMethodPrefix ) ) { String attributeName = method . getName ( ) . substring ( attributeGetterMethodPrefix . length ( ) ) ; switch ( attributeName . length ( ) ) { case 0 : throw new DeploymentException ( \"the profile cmp interface class has an invalid attribute getter method name > \" + method . getName ( ) ) ; case 1 : attributeName = attributeName . toLowerCase ( ) ; break ; default : attributeName = attributeName . substring ( 0 , 1 ) . toLowerCase ( ) + attributeName . substring ( 1 ) ; break ; } ProfileAttributeImpl profileAttribute = null ; try { profileAttribute = new ProfileAttributeImpl ( attributeName , method . getReturnType ( ) ) ; } catch ( Throwable e ) { throw new DeploymentException ( \"Invalid profile cmp interface attribute getter method definition ( name = \" + attributeName + \" , type = \" + method . getReturnType ( ) + \" )\" , e ) ; } if ( isSlee11 ( ) ) { for ( ProfileCMPFieldDescriptor cmpField : getDescriptor ( ) . getProfileCMPInterface ( ) . getCmpFields ( ) ) { if ( cmpField . getCmpFieldName ( ) . equals ( attributeName ) ) { // TODO add index hints ?\r profileAttribute . setUnique ( cmpField . isUnique ( ) ) ; } } } else { for ( ProfileIndexDescriptor profileIndex : getDescriptor ( ) . getIndexedAttributes ( ) ) { if ( profileIndex . getName ( ) . equals ( attributeName ) ) { profileAttribute . setIndex ( true ) ; profileAttribute . setUnique ( profileIndex . getUnique ( ) ) ; } } } map . put ( attributeName , profileAttribute ) ; } } profileAttributeMap = Collections . unmodifiableMap ( map ) ; }", "nl": "Builds the profile attribute map using the cmp interface class"}}
{"translation": {"code": "public static Map < String , Method > getAllInterfacesMethods ( Class xInterfaceClass , Set < String > ignore ) { HashMap < String , Method > abstractMethods = new HashMap < String , Method > ( ) ; Method [ ] methods = null ; Class [ ] superInterfaces ; superInterfaces = xInterfaceClass . getInterfaces ( ) ; for ( Class superInterface : superInterfaces ) { if ( ! ignore . contains ( superInterface . getName ( ) ) ) abstractMethods . putAll ( getAllInterfacesMethods ( superInterface , ignore ) ) ; } methods = xInterfaceClass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { abstractMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; } return abstractMethods ; }", "nl": "Returns methods of this interface and all super interfaces"}}
{"translation": {"code": "public static Class checkInterfaces ( Class classOrInterfaceWithInterfaces , String interfaceSearched ) { Class returnValue = null ; if ( classOrInterfaceWithInterfaces . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { return classOrInterfaceWithInterfaces ; } // we do check only on get interfaces for ( Class iface : classOrInterfaceWithInterfaces . getInterfaces ( ) ) { if ( iface . getName ( ) . compareTo ( interfaceSearched ) == 0 ) { returnValue = iface ; } else { returnValue = checkInterfaces ( iface , interfaceSearched ) ; } if ( returnValue != null ) break ; } if ( ! classOrInterfaceWithInterfaces . isInterface ( ) && returnValue == null ) { Class superClass = classOrInterfaceWithInterfaces . getSuperclass ( ) ; if ( superClass != null ) { returnValue = checkInterfaces ( superClass , interfaceSearched ) ; } } return returnValue ; }", "nl": "Searches for provided interface in passed Class object - it can be class or interface . If it finds it return instance of it ."}}
{"translation": {"code": "private void beforeAsyncOperation ( ) throws IllegalStateException , SecurityException { try { int status = transaction . getStatus ( ) ; if ( asyncOperationInitiated . getAndSet ( true ) || ( status != Status . STATUS_ACTIVE && status != Status . STATUS_MARKED_ROLLBACK ) ) { throw new IllegalStateException ( \"There is no active tx, tx is in state: \" + status ) ; } suspendIfAssoaciatedWithThread ( ) ; } catch ( SystemException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Verifies if the wrapped transaction is active and if dissociates it from the thread if needed"}}
{"translation": {"code": "public void setDeployableUnit ( DeployableUnit deployableUnit ) throws AlreadyDeployedException { if ( this . deployableUnit != null ) { throw new IllegalStateException ( \"deployable unit already set. du = \" + this . deployableUnit ) ; } this . deployableUnit = deployableUnit ; if ( ! addToDeployableUnit ( ) ) { throw new AlreadyDeployedException ( \"unable to install du having multiple components with id \" + getComponentID ( ) ) ; } }", "nl": "Specifies the the Deployable Unit this component belongs . This method also sets the reverse relation adding the component to the deployable unit"}}
{"translation": {"code": "private void pipeStream ( InputStream is , OutputStream os ) throws IOException { synchronized ( buffer ) { try { for ( int bytesRead = is . read ( buffer ) ; bytesRead != - 1 ; bytesRead = is . read ( buffer ) ) os . write ( buffer , 0 , bytesRead ) ; is . close ( ) ; os . close ( ) ; } catch ( IOException ioe ) { try { is . close ( ) ; } catch ( Exception ioexc ) { /* do sth? */ } try { os . close ( ) ; } catch ( Exception ioexc ) { /* do sth? */ } throw ioe ; } } }", "nl": "Pipes data from the input stream into the output stream ."}}
{"translation": {"code": "private void extractJar ( JarFile jarFile , File dstDir ) throws DeploymentException { // Extract jar contents to a classpath location JarInputStream jarIs = null ; try { jarIs = new JarInputStream ( new BufferedInputStream ( new FileInputStream ( jarFile . getName ( ) ) ) ) ; for ( JarEntry entry = jarIs . getNextJarEntry ( ) ; jarIs . available ( ) > 0 && entry != null ; entry = jarIs . getNextJarEntry ( ) ) { logger . trace ( \"jar entry = \" + entry . getName ( ) ) ; if ( entry . isDirectory ( ) ) { // Create jar directories. File dir = new File ( dstDir , entry . getName ( ) ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { logger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; throw new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; } } else logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; } else // unzip files { File file = new File ( dstDir , entry . getName ( ) ) ; File dir = file . getParentFile ( ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { logger . debug ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; throw new IOException ( \"Failed to create directory \" + dir . getAbsolutePath ( ) ) ; } else logger . trace ( \"Created directory\" + dir . getAbsolutePath ( ) ) ; } pipeStream ( jarFile . getInputStream ( entry ) , new FileOutputStream ( file ) ) ; } } } catch ( Exception e ) { throw new DeploymentException ( \"failed to extract jar file \" + jarFile . getName ( ) ) ; } finally { if ( jarIs != null ) { try { jarIs . close ( ) ; } catch ( IOException e ) { logger . error ( \"failed to close jar input stream\" , e ) ; } } } }", "nl": "This method will extract all the files in the jar file"}}
{"translation": {"code": "public List < ServiceComponentImpl > buildComponents ( String serviceDescriptorFileName , JarFile deployableUnitJar ) throws DeploymentException { // make component jar entry JarEntry componentDescriptor = deployableUnitJar . getJarEntry ( serviceDescriptorFileName ) ; InputStream componentDescriptorInputStream = null ; List < ServiceComponentImpl > result = new ArrayList < ServiceComponentImpl > ( ) ; try { componentDescriptorInputStream = deployableUnitJar . getInputStream ( componentDescriptor ) ; ServiceDescriptorFactoryImpl descriptorFactory = componentManagement . getComponentDescriptorFactory ( ) . getServiceDescriptorFactory ( ) ; for ( ServiceDescriptorImpl descriptor : descriptorFactory . parse ( componentDescriptorInputStream ) ) { result . add ( new ServiceComponentImpl ( descriptor ) ) ; } } catch ( IOException e ) { throw new DeploymentException ( \"failed to parse service descriptor from \" + componentDescriptor . getName ( ) , e ) ; } finally { if ( componentDescriptorInputStream != null ) { try { componentDescriptorInputStream . close ( ) ; } catch ( IOException e ) { logger . error ( \"failed to close inputstream of descriptor for jar \" + componentDescriptor . getName ( ) ) ; } } } return result ; }", "nl": "Builds a service component contained in the specified du jar file with the specified and adds it to the specified deployable unit ."}}
{"translation": {"code": "private void checkDependencies ( SleeComponent sleeComponent , DeployableUnitImpl deployableUnit ) throws DependencyException { for ( ComponentID componentID : sleeComponent . getDependenciesSet ( ) ) { if ( componentID instanceof EventTypeID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( EventTypeID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof LibraryID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( LibraryID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof ProfileSpecificationID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ProfileSpecificationID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof ResourceAdaptorID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof ResourceAdaptorTypeID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( ResourceAdaptorTypeID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof SbbID ) { if ( deployableUnit . getDeployableUnitRepository ( ) . getComponentByID ( ( SbbID ) componentID ) == null ) { throw new DependencyException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } else if ( componentID instanceof ServiceID ) { throw new SLEEException ( \"Component \" + sleeComponent . getComponentID ( ) + \" depends on a service component \" + componentID + \" which is not available in the component repository or in the deployable unit\" ) ; } } }", "nl": "Checks if all dependencies of a DU component exists"}}
{"translation": {"code": "private File createTempDUDeploymentDir ( File deploymentRoot , DeployableUnitID deployableUnitID ) { try { // first create a dummy file to gurantee uniqueness. I would have\r // been nice if the File class had a createTempDir() method\r // IVELIN -- do not use jarName here because windows cannot see the\r // path (exceeds system limit)\r File tempFile = File . createTempFile ( \"restcomm-slee-du-\" , \"\" , deploymentRoot ) ; File tempDUDeploymentDir = new File ( tempFile . getAbsolutePath ( ) + \"-contents\" ) ; if ( ! tempDUDeploymentDir . exists ( ) ) { tempDUDeploymentDir . mkdirs ( ) ; } else { throw new SLEEException ( \"Dir \" + tempDUDeploymentDir + \" already exists, unable to create deployment dir for DU \" + deployableUnitID ) ; } tempFile . delete ( ) ; return tempDUDeploymentDir ; } catch ( IOException e ) { throw new SLEEException ( \"Failed to create deployment dir for DU \" + deployableUnitID , e ) ; } }", "nl": "Creates the directory that will be used for unpacking the child jars for a given DU ."}}
{"translation": {"code": "public Set < SleeComponent > getReferringComponents ( SleeComponent component ) { Set < SleeComponent > result = new HashSet < SleeComponent > ( ) ; for ( EventTypeComponent otherComponent : eventTypeComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( LibraryComponent otherComponent : libraryComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( ProfileSpecificationComponent otherComponent : profileSpecificationComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( ResourceAdaptorComponent otherComponent : resourceAdaptorComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( ResourceAdaptorTypeComponent otherComponent : resourceAdaptorTypeComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( SbbComponent otherComponent : sbbComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } for ( ServiceComponent otherComponent : serviceComponents . values ( ) ) { if ( ! otherComponent . getComponentID ( ) . equals ( component . getComponentID ( ) ) ) { if ( otherComponent . getDependenciesSet ( ) . contains ( component . getComponentID ( ) ) ) { result . add ( otherComponent ) ; } } } return result ; }", "nl": "Retrieves the component ids for components that refers the specified component"}}
{"translation": {"code": "public javax . slee . management . EventTypeDescriptor getSpecsDescriptor ( ) { if ( specsDescriptor == null ) { specsDescriptor = new javax . slee . management . EventTypeDescriptor ( getEventTypeID ( ) , getDeployableUnit ( ) . getDeployableUnitID ( ) , getDeploymentUnitSource ( ) , descriptor . getLibraryRefs ( ) . toArray ( new LibraryID [ descriptor . getLibraryRefs ( ) . size ( ) ] ) , getDescriptor ( ) . getEventClassName ( ) ) ; } return specsDescriptor ; }", "nl": "Retrieves the JAIN SLEE specs event type descriptor"}}
{"translation": {"code": "public ClassPool getClassPool ( ) { if ( classPool == null ) { if ( classLoader == null ) { throw new IllegalStateException ( \"can't init javassit classpool, there is no class loader set for the component\" ) ; } classPool = new ClassPool ( ) ; // add class path for domain and dependencies classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain ) ) ; for ( ClassLoader domainDependencies : classLoaderDomain . getAllDependencies ( ) ) { classPool . appendClassPath ( new LoaderClassPath ( domainDependencies ) ) ; } // add class path also for slee  classPool . appendClassPath ( new LoaderClassPath ( classLoaderDomain . getParent ( ) ) ) ; } return classPool ; }", "nl": "Retrieves the component javassist class pool"}}
{"translation": {"code": "public void clean ( ) { for ( ClassPath classPath : classPaths ) { classPool . removeClassPath ( classPath ) ; } for ( String classMade : classesMade ) { try { classPool . get ( classMade ) . detach ( ) ; } catch ( NotFoundException e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Failed to detach class \" + classMade + \" from class pool\" , e ) ; } } } }", "nl": "cleans up the class pool cache"}}
{"translation": {"code": "public Set < SbbID > getSbbIDs ( ComponentRepository componentRepository ) { Set < SbbID > result = new HashSet < SbbID > ( ) ; buildSbbTree ( descriptor . getRootSbbID ( ) , result , componentRepository ) ; return result ; }", "nl": "Retrieves the set of sbbs used by this service"}}
{"translation": {"code": "public void setAsText ( String text ) { if ( text == null || text . equals ( \"\" ) ) { super . setValue ( new ComponentID [ 0 ] ) ; } else { java . util . ArrayList results = new java . util . ArrayList ( ) ; // the format for component ID is name vendor version.\r java . util . StringTokenizer st = new java . util . StringTokenizer ( text , CID_SEPARATOR , true ) ; ComponentIDPropertyEditor cidPropEditor = new ComponentIDPropertyEditor ( ) ; while ( st . hasMoreTokens ( ) ) { cidPropEditor . setAsText ( st . nextToken ( ) ) ; if ( st . hasMoreTokens ( ) ) { st . nextToken ( ) ; } results . add ( cidPropEditor . getValue ( ) ) ; } ComponentID [ ] cid = new ComponentID [ results . size ( ) ] ; results . toArray ( cid ) ; this . setValue ( cid ) ; } }", "nl": "Set the element as text value parse it and setValue . The separator is CID_SEPARATOR"}}
{"translation": {"code": "public void register ( ) { PropertyEditorManager . registerEditor ( ComponentID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( EventTypeID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( LibraryID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ProfileSpecificationID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ResourceAdaptorID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ResourceAdaptorTypeID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( SbbID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ServiceID . class , ComponentIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ComponentID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( EventTypeID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( LibraryID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ProfileSpecificationID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ResourceAdaptorID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ResourceAdaptorTypeID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( SbbID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ServiceID [ ] . class , ComponentIDArrayPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( DeployableUnitID . class , DeployableUnitIDPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( Level . class , LevelPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( TraceLevel . class , TraceLevelPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ConfigProperties . class , ConfigPropertiesPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( NotificationSource . class , NotificationSourcePropertyEditor . class ) ; PropertyEditorManager . registerEditor ( Object . class , ObjectPropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ServiceState . class , ServiceStatePropertyEditor . class ) ; PropertyEditorManager . registerEditor ( ResourceAdaptorEntityState . class , ResourceAdaptorEntityStatePropertyEditor . class ) ; PropertyEditorManager . registerEditor ( Address . class , AddressPropertyEditor . class ) ; }", "nl": "Register the property editors for jboss jmx console so non string SLEE api types can be used in specs mbeans methods as args"}}
{"translation": {"code": "private void deletePath ( File path ) { if ( path . isDirectory ( ) ) { File [ ] files = path . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { deletePath ( file ) ; } } } path . delete ( ) ; }", "nl": "deletes the whole path going through directories"}}
{"translation": {"code": "private void suspendIfAssoaciatedWithThread ( ) throws SystemException { // if there is a tx associated with this thread and it is this one // then suspend it to dissociate the thread (dumb feature?!?! of jboss ts) final SleeTransaction currentThreadTransaction = transactionManager . getSleeTransaction ( ) ; if ( currentThreadTransaction != null && currentThreadTransaction . equals ( this ) ) { // lets use the real tx manager directly, to avoid any other procedures transactionManager . getRealTransactionManager ( ) . suspend ( ) ; } }", "nl": "Some operations require that the transaction be suspended"}}
{"translation": {"code": "protected void executeBeforeCommitPriorityActions ( ) { if ( beforeCommitPriorityActions != null ) { if ( trace ) { logger . trace ( \"Executing before commit priority actions\" ) ; } executeActions ( beforeCommitPriorityActions , trace ) ; beforeCommitPriorityActions = null ; } }", "nl": "Executes actions scheduled for before commit at first"}}
{"translation": {"code": "public boolean decorateAbstractClass ( ) throws DeploymentException { ClassPool pool = component . getClassPool ( ) ; ProfileAbstractClassDescriptor abstractClass = component . getDescriptor ( ) . getProfileAbstractClass ( ) ; if ( abstractClass == null ) { return false ; } String abstractClassName = abstractClass . getProfileAbstractClassName ( ) ; try { ctClass = pool . get ( abstractClassName ) ; } catch ( NotFoundException nfe ) { throw new DeploymentException ( \"Could not find Abstract Class: \" + abstractClassName , nfe ) ; } decorateClassJNDIAddToEnvironmentCalls ( ) ; if ( isAbstractClassDecorated ) { try { String deployDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; ctClass . writeFile ( deployDir ) ; ctClass . detach ( ) ; // the file on disk is now in sync with the latest in-memory version\r if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Modified Abstract Class \" + ctClass . getName ( ) + \" generated in the following path \" + deployDir ) ; } } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } finally { ctClass . defrost ( ) ; } return true ; } else { return false ; } }", "nl": "Decorate the abstract Class"}}
{"translation": {"code": "public String getCodeSources ( ) { List < String > css = new ArrayList < String > ( ) ; for ( PolicyHolderEntry phe : this . currentPolicy . get ( ) . policyHolderEntries ) { css . add ( phe . getCodeSource ( ) . getLocation ( ) == null ? \"default\" : phe . getCodeSource ( ) . getLocation ( ) . toString ( ) ) ; } return Arrays . toString ( css . toArray ( ) ) ; }", "nl": "Some methods to expose info about what is goign on ."}}
{"translation": {"code": "private Permissions getPermissions ( Permissions permissions , final CodeSource cs , Principal [ ] principals ) { List < PolicyHolderEntry > entries = this . currentPolicy . get ( ) . policyHolderEntries ; for ( PolicyHolderEntry phe : entries ) { // general selectPermissions ( permissions , cs , principals , phe ) ; // FIXME: certs? } return permissions ; }", "nl": "generic for all calls"}}
{"translation": {"code": "public void undeployed ( ) { classLoader = null ; if ( classLoaderDomain != null ) { classLoaderDomain . clear ( ) ; classLoaderDomain = null ; } if ( classPool != null ) { classPool . clean ( ) ; classPool = null ; } if ( permissions != null ) { permissions . clear ( ) ; permissions = null ; } }", "nl": "Indicates that the component was undeployed and thus should clean up any resources"}}
{"translation": {"code": "public Set < String > getResourceAdaptorEntityLinks ( ComponentRepository componentRepository ) { Set < String > result = new HashSet < String > ( ) ; for ( SbbID sbbID : getSbbIDs ( componentRepository ) ) { SbbComponent sbbComponent = componentRepository . getComponentByID ( sbbID ) ; for ( ResourceAdaptorTypeBindingDescriptor raTypeBinding : sbbComponent . getDescriptor ( ) . getResourceAdaptorTypeBindings ( ) ) { for ( ResourceAdaptorEntityBindingDescriptor raEntityBinding : raTypeBinding . getResourceAdaptorEntityBinding ( ) ) { result . add ( raEntityBinding . getResourceAdaptorEntityLink ( ) ) ; } } } return result ; }", "nl": "Retrieves the set of ra entity links referenced by the sbbs related with the service ."}}
{"translation": {"code": "public void removeReplicateData ( ) { if ( replicatedDataWithFailover != null ) { replicatedDataWithFailover . remove ( ) ; replicatedDataWithFailover = null ; } if ( replicatedData != null ) { replicatedData . remove ( ) ; replicatedData = null ; } }", "nl": "Removes all replicated data"}}
{"translation": {"code": "public void endActivity ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Ending activity context with handle \" + getActivityContextHandle ( ) ) ; } if ( cacheData . setEnding ( true ) ) { fireEvent ( sleeContainer . getEventContextFactory ( ) . createActivityEndEventContext ( this , new ActivityEndEventUnreferencedCallback ( getActivityContextHandle ( ) , factory ) ) , sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ) ; } }", "nl": "Ends the activity context ."}}
{"translation": {"code": "public Set < SbbEntityID > getSortedSbbAttachmentSet ( Set < SbbEntityID > excludeSet ) { final Set < SbbEntityID > sbbAttachementSet = cacheData . getSbbEntitiesAttached ( ) ; Set < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; for ( SbbEntityID sbbEntityId : sbbAttachementSet ) { if ( ! excludeSet . contains ( sbbEntityId ) ) { result . add ( sbbEntityId ) ; } } if ( result . size ( ) > 1 ) { result = sleeContainer . getSbbEntityFactory ( ) . sortByPriority ( result ) ; } return result ; }", "nl": "get an ordered copy of the set of SBBs attached to this ac . The ordering is by SBB priority ."}}
{"translation": {"code": "public void detachSbbEntity ( SbbEntityID sbbEntityId ) throws javax . slee . TransactionRequiredLocalException { boolean detached = cacheData . detachSbbEntity ( sbbEntityId ) ; if ( detached && acReferencesHandler != null && ! isEnding ( ) ) { acReferencesHandler . sbbeReferenceRemoved ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Detached sbb entity \" + sbbEntityId + \" from AC with handle \" + getActivityContextHandle ( ) ) ; } } }", "nl": "Detach the sbb entity"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Object putObject ( Object key , Object value ) { return getNode ( ) . put ( key , value ) ; }", "nl": "Puts an object in cache data"}}
{"translation": {"code": "public boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { final Node node = getAttachedSbbsNode ( true ) ; if ( ! node . hasChild ( sbbEntityId ) ) { node . addChild ( Fqn . fromElements ( sbbEntityId ) ) ; return true ; } else { return false ; } }", "nl": "Tries to attaches an sbb entity"}}
{"translation": {"code": "public boolean attachTimer ( TimerID timerID ) { if ( cacheData . attachTimer ( timerID ) ) { if ( acReferencesHandler != null ) { acReferencesHandler . timerReferenceCreated ( ) ; } return true ; } else { return false ; } }", "nl": "attach the given timer to the current activity context ."}}
{"translation": {"code": "private void removeNamingBindings ( ) { ActivityContextNamingFacility acf = sleeContainer . getActivityContextNamingFacility ( ) ; for ( Object obj : cacheData . getNamesBoundCopy ( ) ) { String aciName = ( String ) obj ; try { acf . removeName ( aciName ) ; } catch ( Exception e ) { logger . warn ( \"failed to unbind name: \" + aciName + \" from ac:\" + getActivityContextHandle ( ) , e ) ; } } }", "nl": "This is called to release all the name bindings after the activity end event is delivered to the sbb ."}}
{"translation": {"code": "public void addNameBinding ( String aciName ) { cacheData . nameBound ( aciName ) ; if ( acReferencesHandler != null ) { acReferencesHandler . nameReferenceCreated ( ) ; } }", "nl": "add a naming binding to this activity context ."}}
{"translation": {"code": "public void setDataAttribute ( String key , Object newValue ) { cacheData . setCmpAttribute ( key , newValue ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Activity context with handle \" + getActivityContextHandle ( ) + \" set cmp attribute named \" + key + \" to value \" + newValue ) ; } }", "nl": "Set a shared data item for the ACI"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Set < ActivityContextHandle > getActivityContextHandles ( ) { final Node node = getNode ( ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }", "nl": "Retrieves a set containing all activity context handles in the factory s cache data"}}
{"translation": {"code": "private void removeFromTimers ( ) { TimerFacility timerFacility = sleeContainer . getTimerFacility ( ) ; // Iterate through the attached timers, telling the timer facility to // remove them for ( Object obj : cacheData . getAttachedTimers ( ) ) { timerFacility . cancelTimer ( ( TimerID ) obj , false ) ; } }", "nl": "End Event has been delivered on the Activity Context ."}}
{"translation": {"code": "public boolean removeNameBinding ( String aciName ) { boolean removed = cacheData . nameUnbound ( aciName ) ; if ( removed && acReferencesHandler != null ) { acReferencesHandler . nameReferenceRemoved ( ) ; } return removed ; }", "nl": "Add the given name to the set of activity context names that we are bound to . The AC Naming facility implicitly ends the activity after all names are unbound ."}}
{"translation": {"code": "public boolean attachSbbEntity ( SbbEntityID sbbEntityId ) { boolean attached = cacheData . attachSbbEntity ( sbbEntityId ) ; if ( attached ) { if ( acReferencesHandler != null ) { acReferencesHandler . sbbeReferenceCreated ( false ) ; } } if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Attachement from sbb entity \" + sbbEntityId + \" to AC \" + getActivityContextHandle ( ) + \" result: \" + attached ) ; } return attached ; }", "nl": "attach an sbb entity to this AC ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Map getCmpAttributesCopy ( ) { final Node node = getCmpAttributesNode ( false ) ; if ( node == null ) { return Collections . emptyMap ( ) ; } else { Map result = new HashMap ( ) ; Node cmpNode = null ; for ( Object obj : node . getChildren ( ) ) { cmpNode = ( Node ) obj ; result . put ( cmpNode . getFqn ( ) . getLastElement ( ) , cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ) ; } return result ; } }", "nl": "Retrieves a map copy of the aci attributes set"}}
{"translation": {"code": "public boolean attachTimer ( TimerID timerID ) { final Node node = getAttachedTimersNode ( true ) ; if ( ! node . hasChild ( timerID ) ) { node . addChild ( Fqn . fromElements ( timerID ) ) ; return true ; } else { return false ; } }", "nl": "Attaches a timer"}}
{"translation": {"code": "public boolean noTimersAttached ( ) { final Node node = getAttachedTimersNode ( false ) ; return node != null ? node . getChildrenNames ( ) . isEmpty ( ) : true ; }", "nl": "Verifies if there at least one timer attached"}}
{"translation": {"code": "public Set getAttachedTimers ( ) { final Node node = getAttachedTimersNode ( false ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }", "nl": "Returns the set of timers attached to the ac"}}
{"translation": {"code": "public void nameBound ( String name ) { final Node node = getNamesBoundNode ( true ) ; if ( ! node . hasChild ( name ) ) { node . addChild ( Fqn . fromElements ( name ) ) ; } }", "nl": "Adds the specified name to the set of names bound to the ac"}}
{"translation": {"code": "public boolean nameUnbound ( String name ) { final Node node = getNamesBoundNode ( false ) ; return node != null ? node . removeChild ( name ) : false ; }", "nl": "Removes the specified name from the set of names bound to the ac"}}
{"translation": {"code": "public boolean noNamesBound ( ) { final Node node = getNamesBoundNode ( false ) ; return node != null ? node . getChildrenNames ( ) . isEmpty ( ) : true ; }", "nl": "Verifies if there at least one name bound to the ac"}}
{"translation": {"code": "public Set getNamesBoundCopy ( ) { final Node node = getNamesBoundNode ( false ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }", "nl": "Returns the set of names bound to the ac"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public void setCmpAttribute ( String attrName , Object attrValue ) { final Node node = getCmpAttributesNode ( true ) ; Node cmpNode = node . getChild ( attrName ) ; if ( cmpNode == null ) { cmpNode = node . addChild ( Fqn . fromElements ( attrName ) ) ; } cmpNode . put ( CMP_ATTRIBUTES_NODE_MAP_KEY , attrValue ) ; }", "nl": "Sets the aci cmp attribute"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Object getCmpAttribute ( String attrName ) { final Node node = getCmpAttributesNode ( false ) ; if ( node == null ) { return null ; } else { final Node cmpNode = node . getChild ( attrName ) ; if ( cmpNode != null ) { return cmpNode . get ( CMP_ATTRIBUTES_NODE_MAP_KEY ) ; } else { return null ; } } }", "nl": "Retrieves the aci cmp attribute"}}
{"translation": {"code": "public boolean detachTimer ( TimerID timerID ) { final Node node = getAttachedTimersNode ( false ) ; return node != null ? node . removeChild ( timerID ) : false ; }", "nl": "Detaches a timer"}}
{"translation": {"code": "public boolean detachSbbEntity ( SbbEntityID sbbEntityId ) { final Node node = getAttachedSbbsNode ( false ) ; return node != null ? node . removeChild ( sbbEntityId ) : false ; }", "nl": "Detaches an sbb entity"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Set < SbbEntityID > getSbbEntitiesAttached ( ) { final Node node = getAttachedSbbsNode ( false ) ; return node != null ? node . getChildrenNames ( ) : Collections . emptySet ( ) ; }", "nl": "Return a set with all sbb entities attached ."}}
{"translation": {"code": "public boolean noSbbEntitiesAttached ( ) { final Node node = getAttachedSbbsNode ( false ) ; return node != null ? node . getChildrenNames ( ) . isEmpty ( ) : true ; }", "nl": "Verifies if there at least one sbb entity attached"}}
{"translation": {"code": "public void createObjectPool ( final ServiceID serviceID , final SbbComponent sbbComponent , final SleeTransactionManager sleeTransactionManager ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Creating Pool for  \" + serviceID + \" and \" + sbbComponent ) ; } createObjectPool ( serviceID , sbbComponent ) ; if ( sleeTransactionManager != null && sleeTransactionManager . getTransactionContext ( ) != null ) { // add a rollback action to remove sbb object pool TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Due to tx rollback, removing pool for \" + serviceID + \" and \" + sbbComponent ) ; } try { removeObjectPool ( serviceID , sbbComponent . getSbbID ( ) ) ; } catch ( Throwable e ) { logger . error ( \"Failed to remove \" + serviceID + \" and \" + sbbComponent + \" object pool\" , e ) ; } } } ; sleeTransactionManager . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( action ) ; } }", "nl": "Creates an object pool for the specified service and sbb . If a transaction manager is used then and if the tx rollbacks the pool will be removed ."}}
{"translation": {"code": "public boolean contains ( Object object ) { if ( ! ( object instanceof SbbLocalObject ) ) return false ; final SbbLocalObjectImpl sbblocal = ( SbbLocalObjectImpl ) object ; final SbbEntityID sbbEntityId = sbblocal . getSbbEntityId ( ) ; if ( ! idBelongsToChildRelation ( sbbEntityId ) ) { return false ; } return new SbbEntityCacheData ( sbbEntityId , sleeContainer . getCluster ( ) . getMobicentsCache ( ) ) . exists ( ) ; }", "nl": "The contains method . This method returns true if the SBB entity represented by the SBB local object specified by the input argument is a member of this child relation . If the method argument is not an SBB local object is an invalid SBB local object or is an SBB local object whose underlying SBB entity is not a member of this child relation then this method returns false ."}}
{"translation": {"code": "private String tracerNameToLog4JLoggerName ( String tracerName , NotificationSource notificationSource ) { final StringBuilder sb = new StringBuilder ( \"javax.slee.\" ) . append ( notificationSource . toString ( ) ) ; if ( ! tracerName . equals ( ROOT_TRACER_NAME ) ) { sb . append ( ' ' ) . append ( tracerName ) ; } return sb . toString ( ) ; }", "nl": "Generates the log4j logger name for the tracer with specified named and notification source ."}}
{"translation": {"code": "public Class generateSbbLocalObjectConcreteClass ( ) { //Generates the implements link if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"generateSbbLocalObjectConcreteClass: sbbLocalObjectInterface = \" + sbbLocalObjectName + \" deployPath = \" + deployPath ) ; } try { concreteSbbLocalObject = pool . makeClass ( ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_PREFIX + sbbLocalObjectName + ConcreteClassGeneratorUtils . SBB_LOCAL_OBJECT_CLASS_NAME_SUFFIX ) ; try { sleeSbbLocalObject = pool . get ( SbbLocalObjectImpl . class . getName ( ) ) ; sbbLocalObjectInterface = pool . get ( sbbLocalObjectName ) ; } catch ( NotFoundException nfe ) { nfe . printStackTrace ( ) ; String s = \"Problem with pool \" ; logger . error ( s , nfe ) ; throw new RuntimeException ( s , nfe ) ; } // This is our implementation interface. CtClass concreteClassInterface ; try { concreteClassInterface = pool . get ( SbbLocalObjectConcrete . class . getName ( ) ) ; } catch ( NotFoundException nfe ) { nfe . printStackTrace ( ) ; String s = \"Problem with the pool! \" ; logger . error ( s , nfe ) ; throw new RuntimeException ( s , nfe ) ; } ConcreteClassGeneratorUtils . createInterfaceLinks ( concreteSbbLocalObject , new CtClass [ ] { sbbLocalObjectInterface , concreteClassInterface } ) ; //Generates an inheritance link to the slee implementation of the // SbbLocalObject interface ConcreteClassGeneratorUtils . createInheritanceLink ( concreteSbbLocalObject , sleeSbbLocalObject ) ; //Generates the methods to implement from the interface Map interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( sbbLocalObjectInterface ) ; generateConcreteMethods ( interfaceMethods , sbbAbstractClassName ) ; try { concreteSbbLocalObject . writeFile ( deployPath ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Concrete Class \" + concreteSbbLocalObject . getName ( ) + \" generated in the following path \" + deployPath ) ; } } catch ( CannotCompileException e ) { String s = \" Unexpected exception ! \" ; logger . fatal ( s , e ) ; throw new RuntimeException ( s , e ) ; } catch ( IOException e ) { String s = \"IO Exception!\" ; logger . error ( s , e ) ; return null ; } //load the class try { return Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( concreteSbbLocalObject . getName ( ) ) ; } catch ( ClassNotFoundException e ) { logger . error ( \"unable to load sbb local object impl class\" , e ) ; return null ; } } finally { if ( this . concreteSbbLocalObject != null ) this . concreteSbbLocalObject . defrost ( ) ; } }", "nl": "Generate the Sbb Local Object Class"}}
{"translation": {"code": "void _fireEvent ( ActivityHandle realHandle , ActivityHandle refHandle , FireableEventType eventType , Object event , Address address , ReceivableService receivableService , int eventFlags , final SleeTransaction barrierTx ) throws ActivityIsEndingException , SLEEException { final ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , refHandle ) ; // get ac final ActivityContext ac = acFactory . getActivityContext ( ach ) ; if ( ac == null ) { throw new UnrecognizedActivityHandleException ( \"Unable to fire \" + eventType . getEventType ( ) + \" on activity handle \" + realHandle + \" , the handle is not mapped to an activity context\" ) ; } else { // suspend activity if needed if ( barrierTx != null ) { final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; aeqm . createBarrier ( barrierTx ) ; TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { aeqm . removeBarrier ( barrierTx ) ; } } ; final TransactionContext tc = barrierTx . getTransactionContext ( ) ; tc . getAfterCommitActions ( ) . add ( action ) ; tc . getAfterRollbackActions ( ) . add ( action ) ; } final EventProcessingCallbacks callbacks = new EventProcessingCallbacks ( realHandle , eventType , event , address , receivableService , eventFlags , raEntity ) ; final EventProcessingSucceedCallback succeedCallback = EventFlags . hasRequestProcessingSuccessfulCallback ( eventFlags ) ? callbacks : null ; final EventProcessingFailedCallback failedCallback = EventFlags . hasRequestProcessingFailedCallback ( eventFlags ) ? callbacks : null ; final EventUnreferencedCallback unreferencedCallback = EventFlags . hasRequestEventReferenceReleasedCallback ( eventFlags ) ? callbacks : null ; ac . fireEvent ( eventType . getEventType ( ) , event , address , receivableService == null ? null : receivableService . getService ( ) , succeedCallback , failedCallback , unreferencedCallback ) ; } }", "nl": "Event firing logic independent of transaction management ."}}
{"translation": {"code": "private void checkFireEventPreconditions ( ActivityHandle handle , FireableEventType eventType , Object event ) throws NullPointerException , IllegalEventException , IllegalStateException { if ( event == null ) throw new NullPointerException ( \"event is null\" ) ; if ( handle == null ) throw new NullPointerException ( \"handle is null\" ) ; if ( eventType == null ) { throw new NullPointerException ( \"eventType is null\" ) ; } final EventTypeComponent eventTypeComponent = componentRepository . getComponentByID ( eventType . getEventType ( ) ) ; if ( eventTypeComponent == null ) { throw new IllegalEventException ( \"event type not installed (more on SLEE 1.1 specs 15.14.8)\" ) ; } if ( ! eventTypeComponent . getEventTypeClass ( ) . isAssignableFrom ( event . getClass ( ) ) ) { throw new IllegalEventException ( \"the class of the event object fired is not assignable to the event class of the event type (more on SLEE 1.1 specs 15.14.8) \" ) ; } if ( eventType . getClass ( ) != FireableEventTypeImpl . class ) { throw new IllegalEventException ( \"unknown implementation of FireableEventType\" ) ; } if ( raEntity . getAllowedEventTypes ( ) != null && ! raEntity . getAllowedEventTypes ( ) . contains ( eventType . getEventType ( ) ) ) { throw new IllegalEventException ( \"Resource Adaptor configured to not ignore ra type event checking and the event \" + eventType . getEventType ( ) + \" does not belongs to any of the ra types implemented by the resource adaptor\" ) ; } }", "nl": "Checks that fire event methods can be invoked"}}
{"translation": {"code": "void resumeTransaction ( SleeTransaction transaction ) throws SLEEException { if ( transaction != null ) { try { txManager . resume ( transaction ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } }", "nl": "Resumes the specified tx . If it is null nothing is done ."}}
{"translation": {"code": "public String [ ] getDefinedTracerNames ( ) { Set < String > names = new HashSet < String > ( ) ; for ( TracerImpl t : this . tracers . values ( ) ) { if ( t . isExplicitlySetTracerLevel ( ) ) names . add ( t . getTracerName ( ) ) ; } if ( names . isEmpty ( ) ) return new String [ 0 ] ; return names . toArray ( new String [ names . size ( ) ] ) ; }", "nl": "This method returns tracer names that have been defined explicitly via setTraceLevel from TraceMBean"}}
{"translation": {"code": "public Tracer createTracer ( String tracerName , boolean requestedBySource ) { TracerImpl tparent = null ; TracerImpl t = tracers . get ( tracerName ) ; if ( t == null ) { String [ ] split = tracerName . split ( \"\\\\.\" ) ; String currentName = \"\" ; for ( String s : split ) { if ( tparent == null ) { // first loop tparent = rootTracer ; currentName = s ; } else { currentName = currentName + \".\" + s ; } t = tracers . get ( currentName ) ; if ( t == null ) { t = new TracerImpl ( currentName , tparent , this . notificationSource , this . traceFacility ) ; final TracerImpl u = tracers . putIfAbsent ( t . getTracerName ( ) , t ) ; if ( u != null ) { t = u ; } } tparent = t ; } } if ( requestedBySource ) t . setRequestedBySource ( requestedBySource ) ; return t ; }", "nl": "This method can be called multiple times ."}}
{"translation": {"code": "public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws NullPointerException , InvalidArgumentException { if ( tracerName . equals ( \"\" ) ) { // This is root\r return ; } StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; String lastToken = null ; while ( stringTokenizer . hasMoreTokens ( ) ) { String token = stringTokenizer . nextToken ( ) ; if ( lastToken == null ) { // this is start\r lastToken = token ; } if ( lastToken . equals ( token ) && token . equals ( \".\" ) ) { throw new InvalidArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } lastToken = token ; } if ( lastToken . equals ( \".\" ) ) { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } }", "nl": "This checks if the specified tracer name is ok ."}}
{"translation": {"code": "void sendNotification ( javax . slee . facilities . TraceLevel level , String message , Throwable t ) { if ( ! isTraceable ( level ) ) { return ; } traceMBean . sendNotification ( new TraceNotification ( notificationSource . getNotificationSource ( ) . getTraceNotificationType ( ) , traceMBean , notificationSource . getNotificationSource ( ) , getTracerName ( ) , level , message , t , notificationSource . getNextSequence ( ) , System . currentTimeMillis ( ) ) ) ; }", "nl": "THis is internaly called by 1 . 1 tracers"}}
{"translation": {"code": "public void process ( SleeComponentWithUsageParametersInterface component ) throws DeploymentException { ClassPool classPool = component . getClassPool ( ) ; String deploymentDir = component . getDeploymentDir ( ) . getAbsolutePath ( ) ; Class < ? > usageParametersInterface = component . getUsageParametersInterface ( ) ; if ( usageParametersInterface != null ) { try { // generate the concrete usage param set class component . setUsageParametersConcreteClass ( new ConcreteUsageParameterClassGenerator ( usageParametersInterface . getName ( ) , deploymentDir , classPool ) . generateConcreteUsageParameterClass ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"Generated usage parameter impl class for \" + component ) ; } // generate the mbeans new ConcreteUsageParameterMBeanGenerator ( component ) . generateConcreteUsageParameterMBean ( ) ; if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( \"Generated usage mbean (interface and impl) for \" + component ) ; } } catch ( DeploymentException ex ) { throw ex ; } catch ( Exception ex ) { throw new DeploymentException ( \"Failed to generate \" + component + \" usage parameter class\" , ex ) ; } } }", "nl": "Generates classes for a slee component which defines usage parameters"}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public boolean containsAll ( Collection c ) { if ( c == null ) throw new NullPointerException ( \"null collection!\" ) ; for ( Iterator it = c . iterator ( ) ; it . hasNext ( ) ; ) { if ( ! contains ( it . next ( ) ) ) { return false ; } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"containsAll : collection = \" + c + \" > all in child relation\" ) ; } return true ; }", "nl": "This method returns true if all SBB entities represented by the SBB local objects in the collection specified by the input argument are members of this child relation . If the collection contains an object that is not an SBB local object an SBB local object that is invalid or an SBB local object whose underlying SBB entity is not a member of this child relation then this method returns false ."}}
{"translation": {"code": "void _endActivity ( ActivityHandle handle , final SleeTransaction barrierTx ) throws UnrecognizedActivityHandleException { final ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; // get ac final ActivityContext ac = acFactory . getActivityContext ( ach ) ; if ( ac != null ) { // suspend activity if needed if ( barrierTx != null ) { final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; aeqm . createBarrier ( barrierTx ) ; TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { aeqm . removeBarrier ( barrierTx ) ; } } ; final TransactionContext tc = barrierTx . getTransactionContext ( ) ; tc . getAfterCommitActions ( ) . add ( action ) ; tc . getAfterRollbackActions ( ) . add ( action ) ; } // end the activity ac . endActivity ( ) ; } else { throw new UnrecognizedActivityHandleException ( handle . toString ( ) ) ; } }", "nl": "End activity logic independent of transaction management ."}}
{"translation": {"code": "private void validateStateTransition ( SleeState oldState , SleeState newState ) throws InvalidStateException { if ( oldState == SleeState . STOPPED ) { if ( newState == SleeState . STARTING ) { return ; } } else if ( oldState == SleeState . STARTING ) { if ( newState == SleeState . RUNNING || newState == SleeState . STOPPING ) { return ; } } else if ( oldState == SleeState . RUNNING ) { if ( newState == SleeState . STOPPING ) { return ; } } else if ( oldState == SleeState . STOPPING ) { if ( newState == SleeState . STOPPED ) { return ; } } throw new InvalidStateException ( \"illegal slee state transition: \" + oldState + \" -> \" + newState ) ; }", "nl": "Ensures the standard SLEE lifecycle ."}}
{"translation": {"code": "void execute ( final ActivityHandle handle ) throws UnrecognizedActivityHandleException { final SleeTransaction tx = super . suspendTransaction ( ) ; try { sleeEndpoint . _endActivity ( handle , tx ) ; } finally { if ( tx != null ) { super . resumeTransaction ( tx ) ; } } }", "nl": "Executes a non transacted End Activity operation ."}}
{"translation": {"code": "public SbbObjectPoolImpl getObjectPool ( ServiceID serviceID , SbbID sbbID ) { return pools . get ( new ObjectPoolMapKey ( serviceID , sbbID ) ) ; }", "nl": "Retrieves the object pool for the specified sbb and service ."}}
{"translation": {"code": "private void createSbbEntityGetterAndSetter ( CtClass sbbConcrete ) throws DeploymentException { try { CtMethod getSbbEntity = CtNewMethod . make ( \"public \" + SbbEntity . class . getName ( ) + \" getSbbEntity() { return this.sbbEntity; }\" , sbbConcrete ) ; getSbbEntity . setModifiers ( Modifier . PUBLIC ) ; sbbConcrete . addMethod ( getSbbEntity ) ; CtMethod setSbbEntity = CtNewMethod . make ( \"public void setSbbEntity ( \" + SbbEntity . class . getName ( ) + \" sbbEntity )\" + \"{\" + \"this.sbbEntity = sbbEntity;\" + \"}\" , sbbConcrete ) ; setSbbEntity . setModifiers ( Modifier . PUBLIC ) ; sbbConcrete . addMethod ( setSbbEntity ) ; } catch ( Exception e ) { throw new DeploymentException ( e . getMessage ( ) , e ) ; } }", "nl": "Create a method to retrive the entity from the SbbObject ."}}
{"translation": {"code": "public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { if ( tracerName . compareTo ( \"\" ) == 0 ) { // This is root\r return ; } // String[] splitName = tracerName.split(\"\\\\.\");\r StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; int fqdnPartIndex = 0 ; // if(splitName.length==0)\r // {\r // throw new IllegalArgumentException(\"Passed tracer:\" + tracerName +\r // \", name for source: \" + notificationSource + \", is illegal\");\r // }\r String lastToken = null ; while ( stringTokenizer . hasMoreTokens ( ) ) { String token = stringTokenizer . nextToken ( ) ; if ( lastToken == null ) { // this is start\r lastToken = token ; } if ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } if ( token . compareTo ( \".\" ) != 0 ) { for ( int charIndex = 0 ; charIndex < token . length ( ) ; charIndex ++ ) { Character c = token . charAt ( charIndex ) ; if ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { // Its ok?\r } else { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; } } fqdnPartIndex ++ ; } lastToken = token ; } if ( lastToken . compareTo ( \".\" ) == 0 ) { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } }", "nl": "This checks if tracer name is ok . It must not be null ;"}}
{"translation": {"code": "public static Object makeSafeProxyCall ( final Object proxy , final String methodToCallname , final Class [ ] signature , final Object [ ] values ) throws PrivilegedActionException { //Here we execute in sbb/profile or any other slee component domain // so no security calls can be made try { //AccessControlContext acc = new AccessControlContext(new ProtectionDomain[]{proxy.getClass().getProtectionDomain()}); return AccessController . doPrivileged ( new PrivilegedExceptionAction ( ) { public Object run ( ) throws Exception { final Method m = proxy . getClass ( ) . getMethod ( methodToCallname , signature ) ; //Here we cross to org.mobicents domain, with all perms, once m.invoke is called, we go into proxy object domain, effective rightsd are cross section of All + proxy object domain permissions //This is used when isolate security permissions is set to true; return m . invoke ( proxy , values ) ; //}},acc); } } ) ; } catch ( SecurityException e ) { // TODO Auto-generated catch block e . printStackTrace ( ) ; } catch ( PrivilegedActionException e ) { e . printStackTrace ( ) ; } return null ; }", "nl": "Its used to embed calls in AccessController in case of insturmented code cause javassist does not support anonmous inner class ."}}
{"translation": {"code": "private void createDefaultUsageParameterGetter ( CtClass sbbConcrete ) throws DeploymentException { String methodName = \"getDefaultSbbUsageParameterSet\" ; CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; if ( method == null ) { method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; } if ( method != null ) { try { // copy method from abstract to concrete class CtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; // create the method body String concreteMethodBody = \"{ return ($r)\" + SbbAbstractMethodHandler . class . getName ( ) + \".getDefaultSbbUsageParameterSet(sbbEntity); }\" ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; } concreteMethod . setBody ( concreteMethodBody ) ; sbbConcreteClass . addMethod ( concreteMethod ) ; } catch ( CannotCompileException cce ) { throw new SLEEException ( \"Cannot compile method \" + method . getName ( ) , cce ) ; } } }", "nl": "Create a default usage parameter getter and setter ."}}
{"translation": {"code": "public Object getFieldValue ( String fieldName , Class < ? > returnType ) { String realFieldName = getRealFieldName ( fieldName ) ; Object value = aciImpl . getActivityContext ( ) . getDataAttribute ( realFieldName ) ; if ( value == null ) { if ( returnType . isPrimitive ( ) ) { if ( returnType . equals ( Integer . TYPE ) ) { return Integer . valueOf ( 0 ) ; } else if ( returnType . equals ( Boolean . TYPE ) ) { return Boolean . FALSE ; } else if ( returnType . equals ( Long . TYPE ) ) { return Long . valueOf ( 0 ) ; } else if ( returnType . equals ( Double . TYPE ) ) { return Double . valueOf ( 0 ) ; } else if ( returnType . equals ( Float . TYPE ) ) { return Float . valueOf ( 0 ) ; } } } return value ; }", "nl": "Retrieves an sbb aci data field value"}}
{"translation": {"code": "protected ActivityContextInterface getACI ( Object activity ) throws NullPointerException , UnrecognizedActivityException , FactoryException { if ( activity == null ) { throw new NullPointerException ( \"null activity object\" ) ; } ActivityHandle handle = null ; for ( ResourceAdaptorEntity raEntity : sleeContainer . getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { handle = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( activity ) ; if ( handle != null ) { ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; ActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; if ( ac != null ) { return ac . getActivityContextInterface ( ) ; } break ; } } throw new UnrecognizedActivityException ( activity . toString ( ) ) ; }", "nl": "This method returns the aci for the specified activity if exists it should be invoked by each impl of methods of an ra type aci factory ."}}
{"translation": {"code": "private boolean hasReferringDU ( ) throws Exception { // Get SleeContainer instance from JNDI\r SleeContainer sC = SleeContainer . lookupFromJndi ( ) ; for ( String componentIdString : this . getComponents ( ) ) { ComponentIDPropertyEditor cidpe = new ComponentIDPropertyEditor ( ) ; cidpe . setAsText ( componentIdString ) ; ComponentID componentId = ( ComponentID ) cidpe . getValue ( ) ; for ( ComponentID referringComponentId : sC . getComponentRepository ( ) . getReferringComponents ( componentId ) ) { ComponentIDPropertyEditor rcidpe = new ComponentIDPropertyEditor ( ) ; rcidpe . setValue ( referringComponentId ) ; String referringComponentIdString = rcidpe . getAsText ( ) ; if ( ! this . getComponents ( ) . contains ( referringComponentIdString ) ) { return true ; } } } return false ; }", "nl": "Method for checking if this DU components are referred by any others ."}}
{"translation": {"code": "protected void createGetSbbActivityContextInterfaceMethod ( CtClass activityContextInterface , Class < ? > concreteActivityContextInterfaceClass ) throws DeploymentException { String methodToAdd = \"public \" + activityContextInterface . getName ( ) + \" asSbbActivityContextInterface(javax.slee.ActivityContextInterface aci) {\" + \"if(aci==null)\" + \"     throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Passed argument can not be of null value.\\\");\" + \" if(sbbEntity == null || sbbEntity.getSbbObject().getState() != \" + SbbObjectState . class . getName ( ) + \".READY) { throw new \" + IllegalStateException . class . getName ( ) + \"(\\\"Cannot call asSbbActivityContextInterface\\\"); } \" + \"else if ( aci instanceof \" + concreteActivityContextInterfaceClass . getName ( ) + \") return aci;\" + \"else return  new \" + concreteActivityContextInterfaceClass . getName ( ) + \" ( (\" + ActivityContextInterface . class . getName ( ) + \") $1, \" + \"sbbEntity.getSbbComponent());\" + \"}\" ; CtMethod methodTest ; try { methodTest = CtNewMethod . make ( methodToAdd , sbbConcreteClass ) ; sbbConcreteClass . addMethod ( methodTest ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Method \" + methodToAdd + \" added\" ) ; } } catch ( CannotCompileException e ) { throw new DeploymentException ( e . getMessage ( ) , e ) ; } }", "nl": "Create the narrow method to get the activity context interface"}}
{"translation": {"code": "public Collection < ManagementAction > getUninstallActions ( ) { Collection < ManagementAction > uActions = new ArrayList < ManagementAction > ( uninstallActions ) ; // ensures uninstall is the last action related with DU components\r uActions . add ( new UninstallDeployableUnitAction ( diURL . toString ( ) , sleeContainerDeployer . getDeploymentMBean ( ) ) ) ; // if we have some remaining uninstall actions it means it is actions related with components not in DU\r // thus should be executed last\r if ( ! preUninstallActions . values ( ) . isEmpty ( ) ) { for ( String componentId : preUninstallActions . keySet ( ) ) { uActions . addAll ( preUninstallActions . get ( componentId ) ) ; } } return uActions ; }", "nl": "Getter for the Uninstall Actions ."}}
{"translation": {"code": "public void setFieldValue ( String fieldName , Object value ) { String realFieldName = getRealFieldName ( fieldName ) ; aciImpl . getActivityContext ( ) . setDataAttribute ( realFieldName , value ) ; }", "nl": "Sets an sbb aci data field value"}}
{"translation": {"code": "private String getRealFieldName ( String fieldName ) { String realFieldName = sbbComponent . getDescriptor ( ) . getActivityContextAttributeAliases ( ) . get ( fieldName ) ; if ( realFieldName == null ) { // not there then it has no alias, lets set one based on sbb id realFieldName = sbbComponent . getSbbID ( ) . toString ( ) + \".\" + fieldName ; final Map < String , String > aliases = sbbComponent . getDescriptor ( ) . getActivityContextAttributeAliases ( ) ; synchronized ( aliases ) { aliases . put ( fieldName , realFieldName ) ; } } return realFieldName ; }", "nl": "Computes the real aci data field name"}}
{"translation": {"code": "public Collection < ManagementAction > getInstallActions ( ) { ArrayList < ManagementAction > iActions = new ArrayList < ManagementAction > ( ) ; // if we have some remaining post install actions it means it is actions related with components already installed\r // thus should be executed first\r if ( ! postInstallActions . values ( ) . isEmpty ( ) ) { for ( String componentId : postInstallActions . keySet ( ) ) { iActions . addAll ( postInstallActions . get ( componentId ) ) ; } } iActions . addAll ( installActions ) ; return iActions ; }", "nl": "Getter for the Install Actions ."}}
{"translation": {"code": "@ SuppressWarnings ( \"rawtypes\" ) public boolean removeAll ( Collection c ) { boolean flag = true ; if ( c == null ) throw new NullPointerException ( \" null collection ! \" ) ; for ( Iterator it = c . iterator ( ) ; it . hasNext ( ) ; ) { flag &= this . remove ( it . next ( ) ) ; } return flag ; }", "nl": "Removing an SBB entity from a child relation initiates a cascading removal of the SBB entity tree rooted by the SBB entity similar to invoking the remove method on an SBB local object that represents the SBB entity ."}}
{"translation": {"code": "public boolean hasDuplicates ( ) { ArrayList < String > duplicates = new ArrayList < String > ( ) ; // For each component in the DU ..\r for ( String componentId : componentIDs ) { // Check if it is already deployed\r if ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) . contains ( componentId ) ) { duplicates . add ( componentId ) ; } } if ( ! duplicates . isEmpty ( ) ) { logger . warn ( \"The deployable unit '\" + this . diShortName + \"' contains components that are already deployed. The following are already installed:\" ) ; for ( String dupComponent : duplicates ) { logger . warn ( \" - \" + dupComponent ) ; } return true ; } // If we got here, there's no dups.\r return false ; }", "nl": "Method for checking if this DU contains any component that is already deployed ."}}
{"translation": {"code": "public Collection < String > getExternalDependencies ( ) { // Take all dependencies...\r Collection < String > externalDependencies = new HashSet < String > ( dependencies ) ; // Remove those which are contained in this DU\r externalDependencies . removeAll ( componentIDs ) ; // Return what's left.\r return externalDependencies ; }", "nl": "Method for obtaining the external dependencies for this DU if any ."}}
{"translation": {"code": "public void addComponent ( DeployableComponent dc ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( \"Adding Component \" + dc . getComponentKey ( ) ) ; // Add the component ..\r components . add ( dc ) ; // .. the key ..\r componentIDs . add ( dc . getComponentKey ( ) ) ; // .. the dependencies ..\r dependencies . addAll ( dc . getDependencies ( ) ) ; // .. the install actions to be taken ..\r installActions . addAll ( dc . getInstallActions ( ) ) ; // .. post-install actions (if any) ..\r Collection < ManagementAction > postInstallActionsStrings = postInstallActions . remove ( dc . getComponentKey ( ) ) ; if ( postInstallActionsStrings != null && ! postInstallActionsStrings . isEmpty ( ) ) { installActions . addAll ( postInstallActionsStrings ) ; } // .. pre-uninstall actions (if any) ..\r Collection < ManagementAction > preUninstallActionsStrings = preUninstallActions . remove ( dc . getComponentKey ( ) ) ; if ( preUninstallActionsStrings != null ) uninstallActions . addAll ( preUninstallActionsStrings ) ; // .. and finally the uninstall actions to the DU.\r uninstallActions . addAll ( dc . getUninstallActions ( ) ) ; }", "nl": "Adder method for a Deployable Component ."}}
{"translation": {"code": "public void invokeAndReturnvoid ( SbbConcrete proxy , String methodName , Object [ ] args , Class < ? > [ ] argTypes ) throws Exception { invokeAndReturnObject ( proxy , methodName , args , argTypes ) ; }", "nl": "Invokers for the simple types"}}
{"translation": {"code": "private void generateConcreteMethods ( Map interfaceMethods ) { if ( interfaceMethods == null ) return ; Iterator it = interfaceMethods . values ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { CtMethod interfaceMethod = ( CtMethod ) it . next ( ) ; if ( interfaceMethod != null //&& isBaseInterfaceMethod(interfaceMethod.getName()))\r && ( interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( javax . slee . ActivityContextInterface . class . getName ( ) ) || interfaceMethod . getDeclaringClass ( ) . getName ( ) . equals ( ActivityContextInterfaceExt . class . getName ( ) ) ) ) continue ; // @todo: need to check args also\r try { // copy method from abstract to concrete class\r CtMethod concreteMethod = CtNewMethod . copy ( interfaceMethod , concreteActivityContextInterface , null ) ; // create the method body\r String fieldName = interfaceMethod . getName ( ) . substring ( 3 ) ; fieldName = fieldName . substring ( 0 , 1 ) . toLowerCase ( ) + fieldName . substring ( 1 ) ; String concreteMethodBody = null ; if ( interfaceMethod . getName ( ) . startsWith ( \"get\" ) ) { concreteMethodBody = \"{ return ($r)getFieldValue(\\\"\" + fieldName + \"\\\",\" + concreteMethod . getReturnType ( ) . getName ( ) + \".class); }\" ; } else if ( interfaceMethod . getName ( ) . startsWith ( \"set\" ) ) { concreteMethodBody = \"{ setFieldValue(\\\"\" + fieldName + \"\\\",$1); }\" ; } else { throw new SLEEException ( \"unexpected method name <\" + interfaceMethod . getName ( ) + \"> to implement in sbb aci interface\" ) ; } if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Generated method \" + interfaceMethod . getName ( ) + \" , body = \" + concreteMethodBody ) ; } concreteMethod . setBody ( concreteMethodBody ) ; concreteActivityContextInterface . addMethod ( concreteMethod ) ; } catch ( Exception cce ) { throw new SLEEException ( \"Cannot compile method \" + interfaceMethod . getName ( ) , cce ) ; } } }", "nl": "Generates the concrete methods of the class It generates a specific method implementation for the javax . slee . ActivityContextInterface methods for the methods coming from the ActivityContextInterface developer the call is routed to the base asbtract class"}}
{"translation": {"code": "public Class generateActivityContextInterfaceConcreteClass ( ) throws DeploymentException { String tmpClassName = ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_PREFIX + activityContextInterfaceName + ConcreteClassGeneratorUtils . CONCRETE_ACTIVITY_INTERFACE_CLASS_NAME_SUFFIX ; concreteActivityContextInterface = pool . makeClass ( tmpClassName ) ; CtClass sbbActivityContextInterface = null ; try { activityContextInterface = pool . get ( activityContextInterfaceName ) ; sbbActivityContextInterface = pool . get ( SbbActivityContextInterfaceImpl . class . getName ( ) ) ; } catch ( NotFoundException nfe ) { throw new DeploymentException ( \"Could not find aci \" + activityContextInterfaceName , nfe ) ; } // Generates the extends link\r ConcreteClassGeneratorUtils . createInheritanceLink ( concreteActivityContextInterface , sbbActivityContextInterface ) ; // Generates the implements link\r ConcreteClassGeneratorUtils . createInterfaceLinks ( concreteActivityContextInterface , new CtClass [ ] { activityContextInterface } ) ; // Generates the methods to implement from the interface\r Map interfaceMethods = ClassUtils . getInterfaceMethodsFromInterface ( activityContextInterface ) ; generateConcreteMethods ( interfaceMethods ) ; // generates the class\r String sbbDeploymentPathStr = deployDir ; try { concreteActivityContextInterface . writeFile ( sbbDeploymentPathStr ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Concrete Class \" + tmpClassName + \" generated in the following path \" + sbbDeploymentPathStr ) ; } } catch ( Exception e ) { logger . error ( \"problem generating concrete class\" , e ) ; throw new DeploymentException ( \"problem generating concrete class! \" , e ) ; } // load the class\r Class clazz = null ; try { clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( tmpClassName ) ; } catch ( Exception e1 ) { logger . error ( \"problem loading generated class\" , e1 ) ; throw new DeploymentException ( \"problem loading the generated class! \" , e1 ) ; } this . concreteActivityContextInterface . defrost ( ) ; return clazz ; }", "nl": "Generate the Activity Context Interface Class"}}
{"translation": {"code": "void execute ( final ActivityHandle handle , final int activityFlags , boolean suspendActivity ) throws SLEEException { final SleeTransaction tx = super . suspendTransaction ( ) ; ActivityContextHandle ach = null ; try { ach = sleeEndpoint . _startActivity ( handle , activityFlags , suspendActivity ? tx : null ) ; } finally { if ( tx != null ) { super . resumeTransaction ( tx ) ; // the activity was started out of the tx but it will be suspended, if the flags request the unreferenced callback then // we can load the ac now, which will schedule a check for references in the end of the tx, this ensures that the callback is received if no events are fired or  // events are fired but not handled, that is, no reference is ever ever created if ( ach != null && ActivityFlags . hasRequestSleeActivityGCCallback ( activityFlags ) ) { acFactory . getActivityContext ( ach ) ; } } } }", "nl": "Executes a non transacted start activity operation ."}}
{"translation": {"code": "protected void createFireEventMethods ( Collection < EventEntryDescriptor > mEventEntries ) { if ( mEventEntries == null ) return ; for ( EventEntryDescriptor mEventEntry : mEventEntries ) { if ( mEventEntry . isFired ( ) ) { String methodName = \"fire\" + mEventEntry . getEventName ( ) ; CtMethod method = ( CtMethod ) abstractMethods . get ( methodName ) ; if ( method == null ) { method = ( CtMethod ) superClassesAbstractMethods . get ( methodName ) ; } if ( method != null ) { try { // copy method from abstract to concrete class CtMethod concreteMethod = CtNewMethod . copy ( method , sbbConcreteClass , null ) ; // create the method body String concreteMethodBody = \"{\" ; concreteMethodBody += getEventTypeIDInstantionString ( mEventEntry ) ; concreteMethodBody += SbbAbstractMethodHandler . class . getName ( ) + \".fireEvent(sbbEntity,eventTypeID\" ; for ( int i = 0 ; i < method . getParameterTypes ( ) . length ; i ++ ) { concreteMethodBody += \",$\" + ( i + 1 ) ; } concreteMethodBody += \");}\" ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Generated method \" + methodName + \" , body = \" + concreteMethodBody ) ; } concreteMethod . setBody ( concreteMethodBody ) ; sbbConcreteClass . addMethod ( concreteMethod ) ; } catch ( Exception e ) { throw new SLEEException ( \"Cannot compile method \" + method . getName ( ) , e ) ; } } } } }", "nl": "Create the implementation of the fire event methods"}}
{"translation": {"code": "public void start ( ) throws InvalidStateException , ManagementException { try { // request to change to STARTING\r final SleeStateChangeRequest startingRequest = new SleeStateChangeRequest ( ) { @ Override public void stateChanged ( SleeState oldState ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( generateMessageWithLogo ( \"starting\" ) ) ; } notifyStateChange ( oldState , getNewState ( ) ) ; } @ Override public void requestCompleted ( ) { // inner request, executed when the parent completes, to change to RUNNING\r final SleeStateChangeRequest runningRequest = new SleeStateChangeRequest ( ) { private SleeState oldState ; @ Override public void stateChanged ( SleeState oldState ) { logger . info ( generateMessageWithLogo ( \"started\" ) ) ; this . oldState = oldState ; } @ Override public void requestCompleted ( ) { notifyStateChange ( oldState , getNewState ( ) ) ; } @ Override public boolean isBlockingRequest ( ) { return true ; } @ Override public SleeState getNewState ( ) { return SleeState . RUNNING ; } } ; try { sleeContainer . setSleeState ( runningRequest ) ; } catch ( Throwable e ) { logger . error ( \"Failed to set container in RUNNING state\" , e ) ; try { stop ( false ) ; } catch ( Throwable f ) { logger . error ( \"Failed to set container in STOPPED state, after failure to set in RUNNING state\" , e ) ; } } } @ Override public boolean isBlockingRequest ( ) { // should be false, but the tck doesn't like it\r return true ; } @ Override public SleeState getNewState ( ) { return SleeState . STARTING ; } } ; sleeContainer . setSleeState ( startingRequest ) ; } catch ( InvalidStateException ex ) { throw ex ; } catch ( Exception ex ) { throw new ManagementException ( ex . getMessage ( ) , ex ) ; } }", "nl": "Start the SLEE container"}}
{"translation": {"code": "public static ClassLoader switchSafelyClassLoader ( final ClassLoader cl , final ProfileObject po ) { ClassLoader _cl = null ; if ( System . getSecurityManager ( ) != null ) { _cl = ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return _switchSafelyClassLoader ( cl , po ) ; } } ) ; } else { _cl = _switchSafelyClassLoader ( cl , po ) ; } return _cl ; }", "nl": "This method depending if SecurityManger is present switches class loader using priviledged action this is requried as some action may be initiated by unsecure domains ."}}
{"translation": {"code": "public boolean hasDependenciesSatisfied ( boolean showMissing ) { // First of all check if it is self-sufficient\r if ( isSelfSufficient ( ) ) return true ; // If not self-sufficient, get the remaining dependencies\r Collection < String > externalDependencies = getExternalDependencies ( ) ; // Remove those that are already installed...\r externalDependencies . removeAll ( sleeContainerDeployer . getDeploymentManager ( ) . getDeployedComponents ( ) ) ; // Some remaining?\r if ( ! externalDependencies . isEmpty ( ) ) { if ( showMissing ) { // List them to the user...\r String missingDepList = \"\" ; for ( String missingDep : externalDependencies ) missingDepList += \" \\ r \\ n + -- \" + missingDep ; logger . info ( \"Missing dependencies for \" + this . diShortName + \":\" + missingDepList ) ; } // Return dependencies not satified.\r return false ; } // OK, dependencies satisfied!\r return true ; }", "nl": "Method for checking if the DU has all the dependencies needed to be deployed ."}}
{"translation": {"code": "protected void createDefaultConstructor ( ) throws DeploymentException { CtConstructor defaultConstructor = new CtConstructor ( null , sbbConcreteClass ) ; // We need a \"do nothing\" constructor because the // convergence name creation method may need to actually // create the object instance to run the method that // creates the convergence name. String constructorBody = \"{ }\" ; try { defaultConstructor . setBody ( constructorBody ) ; sbbConcreteClass . addConstructor ( defaultConstructor ) ; logger . trace ( \"DefaultConstructor created\" ) ; } catch ( CannotCompileException e ) { throw new DeploymentException ( e . getMessage ( ) , e ) ; } }", "nl": "Create a default constructor on the Sbb Concrete Class"}}
{"translation": {"code": "ActivityContextHandle _startActivity ( ActivityHandle handle , int activityFlags , final SleeTransaction barrierTx ) { ActivityContext ac = null ; if ( raEntity . getHandleReferenceFactory ( ) != null && ! ActivityFlags . hasSleeMayMarshal ( activityFlags ) ) { final ActivityHandleReference reference = raEntity . getHandleReferenceFactory ( ) . createActivityHandleReference ( handle ) ; try { // create activity context with ref instead ac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , reference ) , activityFlags ) ; } catch ( ActivityAlreadyExistsException e ) { throw e ; } catch ( RuntimeException e ) { raEntity . getHandleReferenceFactory ( ) . removeActivityHandleReference ( reference ) ; throw e ; } } else { // create activity context ac = acFactory . createActivityContext ( new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) , activityFlags ) ; } // suspend activity if needed if ( barrierTx != null && ac != null ) { final ActivityEventQueueManager aeqm = ac . getLocalActivityContext ( ) . getEventQueueManager ( ) ; aeqm . createBarrier ( barrierTx ) ; TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { aeqm . removeBarrier ( barrierTx ) ; } } ; final TransactionContext tc = barrierTx . getTransactionContext ( ) ; tc . getAfterCommitActions ( ) . add ( action ) ; tc . getAfterRollbackActions ( ) . add ( action ) ; } return ac . getActivityContextHandle ( ) ; }", "nl": "Start activity logic independent of transaction management ."}}
{"translation": {"code": "private void scheduleAllActivitiesEnd ( ) throws TransactionRequiredLocalException { // schedule the end of all activities if the node is the single member of the cluster\r boolean skipActivityEnding = ! sleeContainer . getCluster ( ) . isSingleMember ( ) ; if ( ! skipActivityEnding && hasActivities ( ) ) { logger . info ( \"RA entity \" + name + \" activities end scheduled.\" ) ; timerTask = new EndAllActivitiesRAEntityTimerTask ( this , sleeContainer ) ; } else { allActivitiesEnded ( ) ; } }", "nl": "schedules the ending of all the entity activities this is needed on ra entity deactivation or slee container stop once the process ends it will invoke allActivitiesEnded to complete those processes"}}
{"translation": {"code": "public void remove ( ) throws InvalidStateException { if ( ! this . state . isInactive ( ) ) { throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; } object . raUnconfigure ( ) ; if ( object . isFaultTolerant ( ) ) { object . unsetFaultTolerantResourceAdaptorContext ( ) ; ftResourceAdaptorContext . shutdown ( ) ; } object . unsetResourceAdaptorContext ( ) ; this . sleeContainer . getTraceManagement ( ) . deregisterNotificationSource ( this . getNotificationSource ( ) ) ; state = null ; }", "nl": "Removes the entity it will unconfigure and unset the ra context the entity object can not be reused"}}
{"translation": {"code": "public void bindName ( Object ach , String name ) throws NameAlreadyBoundException { final Node node = getNode ( ) ; if ( node . hasChild ( name ) ) { throw new NameAlreadyBoundException ( \"name already bound\" ) ; } else { node . addChild ( Fqn . fromElements ( name ) ) . put ( CACHE_NODE_MAP_KEY , ach ) ; } }", "nl": "Binds the specified aci name with the specified activity context handle"}}
{"translation": {"code": "public void deactivate ( ) throws InvalidStateException , TransactionRequiredLocalException { if ( ! this . state . isActive ( ) ) { throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; } this . state = ResourceAdaptorEntityState . STOPPING ; if ( object . getState ( ) == ResourceAdaptorObjectState . ACTIVE ) { object . raStopping ( ) ; } // tck requires that the method returns with stopping state so do\r // all deactivation logic half a sec later\r TimerTask t = new TimerTask ( ) { @ Override public void run ( ) { try { cancel ( ) ; if ( state == ResourceAdaptorEntityState . STOPPING ) { if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { scheduleAllActivitiesEnd ( ) ; } else { allActivitiesEnded ( ) ; } } } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } ; resourceAdaptorContext . getTimer ( ) . schedule ( t , 500 ) ; }", "nl": "Deactivates the ra entity"}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public void activate ( ) throws InvalidStateException { if ( ! this . state . isInactive ( ) ) { throw new InvalidStateException ( \"entity \" + name + \" is in state: \" + this . state ) ; } this . state = ResourceAdaptorEntityState . ACTIVE ; // if slee is running then activate ra object\r if ( sleeContainer . getSleeState ( ) == SleeState . RUNNING ) { if ( setFTContext ) { setFTContext = false ; if ( object . isFaultTolerant ( ) ) { // set fault tolerant context, it is a ft ra\r try { this . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; object . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; } catch ( Throwable t ) { logger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; } } } try { object . raActive ( ) ; } catch ( Throwable t ) { logger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; } } }", "nl": "Activates the ra entity"}}
{"translation": {"code": "public void sleeStopping ( ) throws InvalidStateException , TransactionRequiredLocalException { if ( state != null && state . isActive ( ) ) { try { object . raStopping ( ) ; } catch ( Throwable t ) { logger . error ( \"Got exception from RA object\" , t ) ; } scheduleAllActivitiesEnd ( ) ; } }", "nl": "Signals that the container is in STOPPING state"}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) public void sleeRunning ( ) throws InvalidStateException { // if entity is active then activate the ra object\r if ( this . state . isActive ( ) ) { if ( setFTContext ) { setFTContext = false ; if ( object . isFaultTolerant ( ) ) { // set fault tolerant context, it is a ft ra\r try { this . ftResourceAdaptorContext = new FaultTolerantResourceAdaptorContextImpl ( name , sleeContainer , ( FaultTolerantResourceAdaptor ) object . getResourceAdaptorObject ( ) ) ; object . setFaultTolerantResourceAdaptorContext ( ftResourceAdaptorContext ) ; } catch ( Throwable t ) { logger . error ( \"Got exception invoking setFaultTolerantResourceAdaptorContext(...) for entity \" + name , t ) ; } } } try { object . raActive ( ) ; } catch ( Throwable t ) { logger . error ( \"Got exception invoking raActive() for entity \" + name , t ) ; } } }", "nl": "Signals that the container is in RUNNING state"}}
{"translation": {"code": "public void updateConfigurationProperties ( ConfigProperties properties ) throws InvalidConfigurationException , InvalidStateException { if ( ! component . getDescriptor ( ) . getSupportsActiveReconfiguration ( ) && ( sleeContainer . getSleeState ( ) != SleeState . STOPPED ) && ( state == ResourceAdaptorEntityState . ACTIVE || state == ResourceAdaptorEntityState . STOPPING ) ) { throw new InvalidStateException ( \"the value of the supports-active-reconfiguration attribute of the resource-adaptor-class element in the deployment descriptor of the Resource Adaptor of the resource adaptor entity is False and the resource adaptor entity is in the Active or Stopping state and the SLEE is in the Starting, Running, or Stopping state\" ) ; } else { object . raConfigurationUpdate ( properties ) ; } }", "nl": "Updates the ra entity config properties"}}
{"translation": {"code": "public static void copyMethods ( CtMethod [ ] methods , CtClass destination , CtClass [ ] exceptions ) { CtMethod methodCopy = null ; for ( CtMethod method : methods ) { try { methodCopy = new CtMethod ( method , destination , null ) ; if ( exceptions != null ) { try { methodCopy . setExceptionTypes ( exceptions ) ; } catch ( NotFoundException e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } destination . addMethod ( methodCopy ) ; } catch ( CannotCompileException e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } } }", "nl": "Copy methods to a class"}}
{"translation": {"code": "public Set < SbbEntityID > getSbbEntities ( ) { final Node node = getNode ( ) ; if ( node == null ) { return Collections . emptySet ( ) ; } HashSet < SbbEntityID > result = new HashSet < SbbEntityID > ( ) ; ServiceID serviceID = null ; for ( Object obj : node . getChildrenNames ( ) ) { serviceID = ( ServiceID ) obj ; for ( SbbEntityID sbbEntityID : getRootSbbEntityIDs ( serviceID ) ) { result . add ( sbbEntityID ) ; collectSbbEntities ( sbbEntityID , result ) ; } } return result ; }", "nl": "Retrieves a set containing sbb entity ids in the factory cache data"}}
{"translation": {"code": "private Logger getLogger ( LogRecord record ) { String loggerName = record . getLoggerName ( ) ; Logger logger = loggerCache . get ( loggerName ) ; if ( logger == null ) { logger = Logger . getLogger ( loggerName ) ; loggerCache . put ( loggerName , logger ) ; } return logger ; }", "nl": "get the Log4J logger corresponding to the java . util . logger . LogRecord"}}
{"translation": {"code": "private void removeSbbEntityWithCurrentClassLoader ( final SbbEntity sbbEntity ) { // remove entity\r sbbEntity . remove ( ) ; // remove from tx data\r final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; final SbbEntityID sbbEntityID = sbbEntity . getSbbEntityId ( ) ; txContext . getData ( ) . remove ( sbbEntityID ) ; // if sbb entity is root add a tx action to ensure lock is removed\r if ( sbbEntityID . isRootSbbEntity ( ) ) { TransactionalAction txAction = new TransactionalAction ( ) { @ Override public void execute ( ) { lockFacility . remove ( sbbEntityID ) ; } } ; txContext . getAfterCommitActions ( ) . add ( txAction ) ; } }", "nl": "Removes the specified sbb entity but without changing to sbb s class loader first ."}}
{"translation": {"code": "public boolean getNotificationsEnabled ( String paramName ) { Boolean areNotificationsEnabled = paramNames . get ( paramName ) ; if ( ! isSlee11 ) { if ( areNotificationsEnabled == null || areNotificationsEnabled . booleanValue ( ) ) { // considering that notifications are enabled, by default, for each // param return true ; } else { return false ; } } else { if ( areNotificationsEnabled != null && areNotificationsEnabled . booleanValue ( ) ) { // considering that notifications are enabled, by default, for each // param return true ; } else { return false ; } } }", "nl": "Indicates if notifications are enabled for the specified parameter name"}}
{"translation": {"code": "public Set < String > getReferencedRAEntityLinksWhichNotExists ( ServiceComponent serviceComponent ) { Set < String > result = new HashSet < String > ( ) ; Set < String > raLinkNames = sleeContainer . getResourceManagement ( ) . getLinkNamesSet ( ) ; for ( String raLink : serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) ) { if ( ! raLinkNames . contains ( raLink ) ) { result . add ( raLink ) ; } } return result ; }", "nl": "Retrieves the set of ra entity link names referenced by the service componen which do not exist"}}
{"translation": {"code": "public void installService ( final ServiceComponent serviceComponent ) throws Exception { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Installing Service \" + serviceComponent ) ; } // creates and registers the service usage mbean final ServiceUsageMBean serviceUsageMBean = sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; // add rollback action to remove state created TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { try { serviceUsageMBean . remove ( ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } ; final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; txContext . getAfterRollbackActions ( ) . add ( action ) ; // register notification sources for all sbbs // final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; for ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { // Tracer must be available for both 1.1 and 1.0 sbb components // SbbComponent sbbComponent = // componentRepositoryImpl.getComponentByID(sbbID); // if(sbbComponent.isSlee11()) { traceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; // add rollback action to remove state created action = new TransactionalAction ( ) { public void execute ( ) { // remove notification sources for all sbbs traceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; } } ; txContext . getAfterRollbackActions ( ) . add ( action ) ; } // this might be used not only by 1.1 sbbs... NotificationSourceWrapperImpl sbbMNotificationSource = new NotificationSourceWrapperImpl ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; serviceComponent . getAlarmNotificationSources ( ) . putIfAbsent ( sbbID , sbbMNotificationSource ) ; } sleeContainer . getSbbManagement ( ) . serviceInstall ( serviceComponent ) ; }", "nl": "Install a service into SLEE"}}
{"translation": {"code": "public Object getResourceAdaptorInterface ( ResourceAdaptorTypeID raType ) { return object . getResourceAdaptorInterface ( sleeContainer . getComponentRepository ( ) . getComponentByID ( raType ) . getDescriptor ( ) . getResourceAdaptorInterface ( ) ) ; }", "nl": "Retrieves the ra interface for this entity and the specified ra type"}}
{"translation": {"code": "public void uninstallService ( final ServiceComponent serviceComponent ) throws SystemException , UnrecognizedServiceException , InstanceNotFoundException , MBeanRegistrationException , NullPointerException , UnrecognizedResourceAdaptorEntityException , ManagementException , InvalidStateException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Uninstalling service with id \" + serviceComponent . getServiceID ( ) ) ; } if ( serviceComponent . getServiceState ( ) . isStopping ( ) ) { // let's be friendly and give it a few secs for ( int i = 0 ; i < 15 ; i ++ ) { try { Thread . sleep ( 1000 ) ; logger . info ( \"Waiting for \" + serviceComponent . getServiceID ( ) + \" to stop, current state is \" + serviceComponent . getServiceState ( ) ) ; if ( serviceComponent . getServiceState ( ) . isInactive ( ) ) { break ; } } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } if ( ! serviceComponent . getServiceState ( ) . isInactive ( ) ) { throw new InvalidStateException ( serviceComponent . toString ( ) + \" is not inactive\" ) ; } final TransactionContext txContext = sleeContainer . getTransactionManager ( ) . getTransactionContext ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Closing Usage MBean of service \" + serviceComponent . getServiceID ( ) ) ; } ServiceUsageMBean serviceUsageMBean = serviceComponent . getServiceUsageMBean ( ) ; if ( serviceUsageMBean != null ) { serviceUsageMBean . remove ( ) ; // add rollback action to re-create the mbean // FIXME this doesn't make sense, this restore looses all old data, // it shoudl only remove on // commit but as it is right now, the needed sbb components are // already removed TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { try { sleeContainer . getUsageParametersManagement ( ) . newServiceUsageMBean ( serviceComponent ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } ; txContext . getAfterRollbackActions ( ) . add ( action ) ; } // register notification sources for all sbbs final TraceManagement traceMBeanImpl = sleeContainer . getTraceManagement ( ) ; for ( final SbbID sbbID : serviceComponent . getSbbIDs ( componentRepositoryImpl ) ) { // Tracer must be available for both 1.1 and 1.0 sbb components // SbbComponent sbbComponent = // componentRepositoryImpl.getComponentByID(sbbID); // if(sbbComponent.isSlee11()) { traceMBeanImpl . deregisterNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; // add rollback action to re-add state removed TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { // remove notification sources for all sbbs traceMBeanImpl . registerNotificationSource ( new SbbNotification ( serviceComponent . getServiceID ( ) , sbbID ) ) ; } } ; txContext . getAfterRollbackActions ( ) . add ( action ) ; } } // warn sbb management that the service is being uninstalled, giving it // the option to clear any related resources sleeContainer . getSbbManagement ( ) . serviceUninstall ( serviceComponent ) ; }", "nl": "uninstall a service ."}}
{"translation": {"code": "public boolean isLoggable ( LogRecord record ) { Logger logger = getLogger ( record ) ; if ( record . getThrown ( ) != null ) { logWithThrowable ( logger , record ) ; } else { logWithoutThrowable ( logger , record ) ; } return false ; }", "nl": "If the message should be logged convert the JDK 1 . 4 LogRecord to a Log4J message ."}}
{"translation": {"code": "public String showStatus ( ) { // Update the currently deployed components. updateDeployedComponents ( ) ; String output = \"\" ; output += \"<p>Deployable Units Waiting For Install:</p>\" ; for ( DeployableUnit waitingDU : waitingForInstallDUs ) { output += \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; for ( String dependency : waitingDU . getExternalDependencies ( ) ) { if ( ! deployedComponents . contains ( dependency ) ) dependency += \" <strong>MISSING!</strong>\" ; output += \"  +-- depends on \" + dependency + \"<br>\" ; } } output += \"<p>Deployable Units Waiting For Uninstall:</p>\" ; for ( DeployableUnit waitingDU : waitingForUninstallDUs ) { output += \"+-- \" + waitingDU . getDeploymentInfoShortName ( ) + \"<br>\" ; } return output ; }", "nl": "Method for showing current status of the Deployment Manager ."}}
{"translation": {"code": "private void processInternalUndeploy ( DeployableUnit du ) throws Exception { // Set the DU as not installed du . setInstalled ( false ) ; // Remove if it was present in waiting list waitingForUninstallDUs . remove ( du ) ; // Update the deployed components from SLEE updateDeployedComponents ( ) ; // Go through the remaining DUs waiting for uninstallation Iterator < DeployableUnit > duIt = waitingForUninstallDUs . iterator ( ) ; while ( duIt . hasNext ( ) ) { DeployableUnit waitingDU = duIt . next ( ) ; // If it is ready for being uninstalled, follow the same procedure if ( waitingDU . isReadyToUninstall ( ) ) { // Schedule removal sleeContainerDeployer . getSleeSubDeployer ( ) . stop ( waitingDU . getURL ( ) , waitingDU . getDeploymentInfoShortName ( ) ) ; // Remove the DU from the waiting list. If it fails, will go back. waitingForUninstallDUs . remove ( waitingDU ) ; // Let's start all over.. :) duIt = waitingForUninstallDUs . iterator ( ) ; } } }", "nl": "Sets the DU as not installed and remove it from waiting list if present there . Also tries to undeploy DU s waiting for dependencies to be removed ."}}
{"translation": {"code": "public void uninstallDeployableUnit ( DeployableUnit du ) throws Exception { // Update the deployed components from SLEE updateDeployedComponents ( ) ; // It isn't installed? if ( ! du . isInstalled ( ) ) { // Then it should be in the waiting list... remove and we're done. if ( waitingForInstallDUs . remove ( du ) ) { logger . info ( du . getDeploymentInfoShortName ( ) + \" wasn't deployed. Removing from waiting list.\" ) ; } } // Check if DU components are still present  else if ( ! du . areComponentsStillPresent ( ) ) { logger . info ( du . getDeploymentInfoShortName ( ) + \" components already removed. Removing DU info.\" ) ; // Process internals of undeployment... processInternalUndeploy ( du ) ; } // Check if the DU is ready to be uninstalled else if ( du . isReadyToUninstall ( ) ) { // Get and Run the actions needed for uninstalling this DU sciAction ( du . getUninstallActions ( ) , du ) ; // Process internals of undeployment... processInternalUndeploy ( du ) ; } else { // Have we been her already? If so, don't flood user with log messages... if ( ! waitingForUninstallDUs . contains ( du ) ) { // Add it to the waiting list. waitingForUninstallDUs . add ( du ) ; logger . warn ( \"Unable to UNINSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependents to be removed.\" ) ; } throw new DependencyException ( \"Unable to undeploy \" + du . getDeploymentInfoShortName ( ) ) ; } }", "nl": "Method for uninstalling a Deployable Unit into SLEE ."}}
{"translation": {"code": "public void installDeployableUnit ( DeployableUnit du ) throws Exception { // Update the deployed components from SLEE updateDeployedComponents ( ) ; // Check if the DU is ready to be installed if ( du . isReadyToInstall ( true ) ) { // Get and Run the actions needed for installing this DU sciAction ( du . getInstallActions ( ) , du ) ; // Set the DU as installed du . setInstalled ( true ) ; // Add the DU to the installed list deployedDUs . add ( du ) ; // Update the deployed components from SLEE updateDeployedComponents ( ) ; // Go through the remaining DUs waiting for installation Iterator < DeployableUnit > duIt = waitingForInstallDUs . iterator ( ) ; while ( duIt . hasNext ( ) ) { DeployableUnit waitingDU = duIt . next ( ) ; // If it is ready for installation, follow the same procedure if ( waitingDU . isReadyToInstall ( false ) ) { // Get and Run the actions needed for installing this DU sciAction ( waitingDU . getInstallActions ( ) , waitingDU ) ; // Set the DU as installed waitingDU . setInstalled ( true ) ; // Add the DU to the installed list deployedDUs . add ( waitingDU ) ; // Update the deployed components from SLEE updateDeployedComponents ( ) ; // Remove the DU from the waiting list. waitingForInstallDUs . remove ( waitingDU ) ; // Let's start all over.. :) duIt = waitingForInstallDUs . iterator ( ) ; } } } else { logger . warn ( \"Unable to INSTALL \" + du . getDeploymentInfoShortName ( ) + \" right now. Waiting for dependencies to be resolved.\" ) ; // The DU can't be installed now, let's wait... waitingForInstallDUs . add ( du ) ; } }", "nl": "Method for installing a Deployable Unit into SLEE ."}}
{"translation": {"code": "public void updateDeployedComponents ( ) { try { // Get the SLEE Component Repo ComponentRepository componentRepository = sleeContainerDeployer . getSleeContainer ( ) . getComponentRepository ( ) ; // First we'll put the components in a temp Collection ConcurrentLinkedQueue < String > newDeployedComponents = new ConcurrentLinkedQueue < String > ( ) ; // Get the deployed Profile Specifications for ( ComponentID componentID : componentRepository . getProfileSpecificationIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Event Types for ( ComponentID componentID : componentRepository . getEventComponentIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Resource Adaptor Types for ( ComponentID componentID : componentRepository . getResourceAdaptorTypeIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Resource Adaptors for ( ComponentID componentID : componentRepository . getResourceAdaptorIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Service Building Blocks (SBBs) for ( ComponentID componentID : componentRepository . getSbbIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Services for ( ComponentID componentID : componentRepository . getServiceIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } // Get the deployed Libraries for ( ComponentID componentID : componentRepository . getLibraryIDs ( ) ) { newDeployedComponents . add ( componentID . toString ( ) ) ; } ResourceManagement resourceManagement = sleeContainerDeployer . getSleeContainer ( ) . getResourceManagement ( ) ; // Get the existing Resource Adaptor Entity links String [ ] entityNames = resourceManagement . getResourceAdaptorEntities ( ) ; for ( String entityName : entityNames ) { newDeployedComponents . addAll ( Arrays . asList ( resourceManagement . getLinkNames ( entityName ) ) ) ; } // All good.. Make the temp the good one. deployedComponents = newDeployedComponents ; } catch ( Exception e ) { logger . warn ( \"Failure while updating deployed components.\" , e ) ; } }", "nl": "Updates the list of components already deployed to SLEE ."}}
{"translation": {"code": "public synchronized String [ ] getUsageParameterSets ( SbbID sbbId ) throws NullPointerException , UnrecognizedSbbException , InvalidArgumentException , ManagementException { if ( sbbId == null ) throw new NullPointerException ( \"Sbb ID is null!\" ) ; // get the sbb component\r SbbComponent sbbComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( sbbId ) ; if ( sbbComponent == null ) { throw new UnrecognizedSbbException ( sbbId . toString ( ) ) ; } else { if ( sbbComponent . getUsageParametersInterface ( ) == null ) { throw new InvalidArgumentException ( \"no usage parameter interface for \" + sbbId ) ; } } // get service component and check if the sbb belongs to the service\r ServiceComponent serviceComponent = sleeContainer . getComponentRepository ( ) . getComponentByID ( getService ( ) ) ; if ( ! serviceComponent . getSbbIDs ( sleeContainer . getComponentRepository ( ) ) . contains ( sbbId ) ) { throw new UnrecognizedSbbException ( sbbId . toString ( ) + \" is not part of \" + getService ( ) ) ; } Set < String > resultSet = new HashSet < String > ( ) ; for ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { if ( ( ( SbbNotification ) usageMBeanImpl . getNotificationSource ( ) ) . getSbb ( ) . equals ( sbbId ) ) { String name = usageMBeanImpl . getUsageParameterSet ( ) ; if ( name != null ) { resultSet . add ( name ) ; } } } return resultSet . toArray ( new String [ resultSet . size ( ) ] ) ; }", "nl": "This method returns a list containing the names of the named SBB usage parameter sets that belong to the SBB specified by the sbbID argument and the Service represented by the ServiceUsageMBean object ."}}
{"translation": {"code": "public void sendUsageNotification ( long value , long seqno , String usageParameterSetName , String usageParameterName , boolean isCounter ) { UsageNotificationManagerMBeanImpl notificationManager = parent . getUsageNotificationManagerMBean ( notificationSource ) ; if ( notificationManager == null || notificationManager . getNotificationsEnabled ( usageParameterName ) ) { // if the notification manager is null we consider the notification // can be sent UsageNotification notification = createUsageNotification ( value , seqno , usageParameterSetName , usageParameterName , isCounter ) ; for ( ListenerFilterHandbackTriplet triplet : listeners . values ( ) ) { if ( triplet . notificationFilter == null || triplet . notificationFilter . isNotificationEnabled ( notification ) ) { triplet . notificationListener . handleNotification ( notification , triplet . handbackObject ) ; } } } }", "nl": "Send the notification ."}}
{"translation": {"code": "private static MBeanNotificationInfo [ ] initNotificationInfo ( ) { String [ ] notificationTypes = new String [ ] { ProfileTableNotification . USAGE_NOTIFICATION_TYPE , ResourceAdaptorEntityNotification . USAGE_NOTIFICATION_TYPE , SbbNotification . USAGE_NOTIFICATION_TYPE , SubsystemNotification . USAGE_NOTIFICATION_TYPE } ; return new MBeanNotificationInfo [ ] { new MBeanNotificationInfo ( notificationTypes , UsageNotification . class . getName ( ) , \"JAIN SLEE 1.1 Usage MBean Notification\" ) } ; }", "nl": "Initiates the notification info for usage mbeans"}}
{"translation": {"code": "public Result next ( ActivityContext ac , EventContext sleeEvent , Set < SbbEntityID > sbbEntitiesThatHandledCurrentEvent , SleeContainer sleeContainer ) { SbbEntityID sbbEntityId = null ; SbbEntity sbbEntity = null ; EventEntryDescriptor mEventEntry = null ; // get the highest priority sbb from sbb entities attached to AC for ( Iterator < SbbEntityID > iter = ac . getSortedSbbAttachmentSet ( sbbEntitiesThatHandledCurrentEvent ) . iterator ( ) ; iter . hasNext ( ) ; ) { sbbEntityId = iter . next ( ) ; sbbEntity = sleeContainer . getSbbEntityFactory ( ) . getSbbEntity ( sbbEntityId , true ) ; if ( sbbEntity == null ) { // ignore, sbb entity has been removed continue ; } if ( eventRouterConfiguration . isConfirmSbbEntityAttachement ( ) && ! sbbEntity . isAttached ( ac . getActivityContextHandle ( ) ) ) { // detached by a concurrent tx, see Issue 2313 \t\t\t\t continue ; } if ( sleeEvent . getService ( ) != null && ! sleeEvent . getService ( ) . equals ( sbbEntityId . getServiceID ( ) ) ) { if ( ! sleeEvent . isActivityEndEvent ( ) ) { continue ; } else { return new Result ( sbbEntity , false ) ; } } // check event is allowed to be handled by the sbb mEventEntry = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getEventEntries ( ) . get ( sleeEvent . getEventTypeId ( ) ) ; if ( mEventEntry != null && mEventEntry . isReceived ( ) ) { return new Result ( sbbEntity , true ) ; } else { if ( ! sleeEvent . isActivityEndEvent ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Event is not received by sbb descriptor of entity \" + sbbEntityId + \", will not deliver event to sbb entity ...\" ) ; } continue ; } else { return new Result ( sbbEntity , false ) ; } } } return null ; }", "nl": "Retrieves the next sbb entity to handle the event ."}}
{"translation": {"code": "public Map getNameBindings ( ) { Map result = new HashMap ( ) ; Node childNode = null ; Object name = null ; for ( Object obj : getNode ( ) . getChildren ( ) ) { childNode = ( Node ) obj ; name = childNode . getFqn ( ) . getLastElement ( ) ; result . put ( name , childNode . get ( CACHE_NODE_MAP_KEY ) ) ; } return result ; }", "nl": "Retrieves a map of the bindings . Key is the aci name and Value is the activity context handle"}}
{"translation": {"code": "public Object lookupName ( String name ) { final Node childNode = getNode ( ) . getChild ( name ) ; if ( childNode == null ) { return null ; } else { return childNode . get ( CACHE_NODE_MAP_KEY ) ; } }", "nl": "Lookup of the activity context id bound to the specified aci name"}}
{"translation": {"code": "public synchronized void resetAllUsageParameters ( ) throws ManagementException { try { //FIXME: hmm, how to check here for clustered... ghmp\r for ( UsageMBeanImpl usageMBeanImpl : usageMBeans . values ( ) ) { usageMBeanImpl . resetAllUsageParameters ( ) ; } } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } }", "nl": "Resets the usage parameters of all SBBs within the Service represented by the ServiceUsageMBean object . The SLEE sets counter - type usage parameters to zero and removes all samples from sample - type usage parameters ."}}
{"translation": {"code": "void execute ( final ActivityHandle realHandle , final ActivityHandle refHandle , final FireableEventType eventType , final Object event , final Address address , final ReceivableService receivableService , final int eventFlags ) throws ActivityIsEndingException , FireEventException , SLEEException , UnrecognizedActivityHandleException { final SleeTransaction tx = super . suspendTransaction ( ) ; try { sleeEndpoint . _fireEvent ( realHandle , refHandle , eventType , event , address , receivableService , eventFlags , tx ) ; } finally { if ( tx != null ) { super . resumeTransaction ( tx ) ; } } }", "nl": "Executes a non transacted fire event operation ."}}
{"translation": {"code": "public boolean isRAEntityLinkNameReferenced ( String raLinkName ) { if ( raLinkName == null ) { throw new NullPointerException ( \"null ra link name\" ) ; } boolean b = false ; try { b = transactionManager . requireTransaction ( ) ; for ( ServiceID serviceID : componentRepositoryImpl . getServiceIDs ( ) ) { ServiceComponent serviceComponent = componentRepositoryImpl . getComponentByID ( serviceID ) ; if ( serviceComponent . getServiceState ( ) != ServiceState . INACTIVE && serviceComponent . getResourceAdaptorEntityLinks ( componentRepositoryImpl ) . contains ( raLinkName ) ) { return true ; } } return false ; } finally { try { transactionManager . requireTransactionEnd ( b , false ) ; } catch ( Throwable ex ) { throw new SLEEException ( ex . getMessage ( ) , ex ) ; } } }", "nl": "Verifies if the specified ra entity link name is referenced by a non inactive service ."}}
{"translation": {"code": "public void serviceActive ( ServiceID serviceID ) { try { ReceivableService receivableService = resourceAdaptorContext . getServiceLookupFacility ( ) . getReceivableService ( serviceID ) ; if ( receivableService . getReceivableEvents ( ) . length > 0 ) { object . serviceActive ( receivableService ) ; } } catch ( Throwable e ) { logger . warn ( \"invocation resulted in unchecked exception\" , e ) ; } }", "nl": "Indicates a service was activated the entity will forward this notification to the ra object ."}}
{"translation": {"code": "public Object unbindName ( String name ) throws NameNotBoundException { final Node node = getNode ( ) ; final Node childNode = node . getChild ( name ) ; if ( childNode == null ) { throw new NameNotBoundException ( \"name not bound\" ) ; } else { final Object ach = childNode . get ( CACHE_NODE_MAP_KEY ) ; node . removeChild ( name ) ; return ach ; } }", "nl": "Unbinds the specified aci name with the specified activity context id"}}
{"translation": {"code": "public void activityEnded ( final ActivityHandle handle , int activityFlags ) { logger . trace ( \"activityEnded( handle = \" + handle + \" )\" ) ; ActivityHandle ah = null ; if ( handle instanceof ActivityHandleReference ) { // handle is a ref, derrefer and remove the ref\r ah = resourceManagement . getHandleReferenceFactory ( ) . removeActivityHandleReference ( ( ActivityHandleReference ) handle ) ; } else { // handle is not a reference\r ah = handle ; } if ( ah != null && ActivityFlags . hasRequestEndedCallback ( activityFlags ) ) { object . activityEnded ( ah ) ; } if ( object . getState ( ) == ResourceAdaptorObjectState . STOPPING ) { synchronized ( this ) { // the ra object is stopping, check if the timer task is still\r // needed\r if ( ! hasActivities ( ) ) { if ( timerTask != null ) { timerTask . cancel ( ) ; } allActivitiesEnded ( ) ; } } } }", "nl": "Callback to notify the entity and possibly the ra object informing activity handled ended ."}}
{"translation": {"code": "public String raiseAlarm ( NotificationSourceWrapper notificationSource , String alarmType , String instanceID , AlarmLevel level , String message , Throwable cause ) { synchronized ( notificationSource ) { if ( isAlarmAlive ( notificationSource , alarmType , instanceID ) ) { // Alarm a = this.placeHolderToAlarm.get(new\r // AlarmPlaceHolder(notificationSource, alarmType, instanceID));\r Alarm a = null ; // unconveniant....\r try { AlarmPlaceHolder localAPH = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID ) ; for ( Map . Entry < String , AlarmPlaceHolder > e : this . alarmIdToAlarm . entrySet ( ) ) { if ( e . getValue ( ) . equals ( localAPH ) ) { a = e . getValue ( ) . getAlarm ( ) ; break ; } } } catch ( Exception e ) { // ignore\r } if ( a != null ) { return a . getAlarmID ( ) ; } else { return this . raiseAlarm ( notificationSource , alarmType , instanceID , level , message , cause ) ; } } else { Alarm a = new Alarm ( UUID . randomUUID ( ) . toString ( ) , notificationSource . getNotificationSource ( ) , alarmType , instanceID , level , message , cause , System . currentTimeMillis ( ) ) ; AlarmPlaceHolder aph = new AlarmPlaceHolder ( notificationSource , alarmType , instanceID , a ) ; this . alarmIdToAlarm . put ( a . getAlarmID ( ) , aph ) ; // this.placeHolderToAlarm.put(aph, a);\r this . placeHolderToNotificationSource . put ( aph , aph . getNotificationSource ( ) . getNotificationSource ( ) ) ; generateNotification ( aph , false ) ; return a . getAlarmID ( ) ; } } }", "nl": "THis methods raises alarm . It MUST not receive AlarmLevel . CLEAR it has to be filtered ."}}
{"translation": {"code": "public static Map getInterfaceMethodsFromInterface ( CtClass interfaceClass , Map exceptMethods ) { HashMap interfaceMethods = new HashMap ( ) ; CtMethod [ ] methods = interfaceClass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( exceptMethods . get ( methods [ i ] . getName ( ) ) == null ) { ConcreteClassGeneratorUtils . logger . trace ( methods [ i ] . getName ( ) ) ; interfaceMethods . put ( getMethodKey ( methods [ i ] ) , methods [ i ] ) ; } } Map temp = getSuperClassesAbstractMethodsFromInterface ( interfaceClass ) ; for ( Iterator i = temp . keySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { String key = ( String ) i . next ( ) ; if ( ! exceptMethods . containsKey ( key ) ) { interfaceMethods . put ( key , temp . get ( key ) ) ; } } return interfaceMethods ; }", "nl": "Retrieve all methods from an interface including super interfaces except the ones specified in the provided map"}}
{"translation": {"code": "public static Map getAbstractMethodsFromClass ( CtClass sbbAbstractClass ) { HashMap abstractMethods = new HashMap ( ) ; CtMethod [ ] methods = sbbAbstractClass . getDeclaredMethods ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { if ( Modifier . isAbstract ( methods [ i ] . getModifiers ( ) ) ) { abstractMethods . put ( methods [ i ] . getName ( ) , methods [ i ] ) ; } } return abstractMethods ; }", "nl": "Retrieve all abstract methods from a class"}}
{"translation": {"code": "public static Object getSbbUsageParameterSet ( SbbEntity sbbEntity , String name ) throws UnrecognizedUsageParameterSetNameException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"getSbbUsageParameterSet(): serviceId = \" + sbbEntity . getSbbEntityId ( ) . getServiceID ( ) + \" , sbbID = \" + sbbEntity . getSbbId ( ) + \" , name = \" + name ) ; } return getServiceUsageMBeanImpl ( sbbEntity . getSbbEntityId ( ) . getServiceID ( ) ) . getInstalledUsageParameterSet ( sbbEntity . getSbbId ( ) , name ) ; }", "nl": "SBB USAGE PARAMS"}}
{"translation": {"code": "public static Object getProfileCMPMethod ( SbbEntity sbbEntity , String getProfileCMPMethodName , ProfileID profileID ) throws UnrecognizedProfileTableNameException , UnrecognizedProfileNameException { GetProfileCMPMethodDescriptor mGetProfileCMPMethod = sbbEntity . getSbbComponent ( ) . getDescriptor ( ) . getGetProfileCMPMethods ( ) . get ( getProfileCMPMethodName ) ; if ( mGetProfileCMPMethod == null ) throw new AbstractMethodError ( \"Profile CMP Method not found\" ) ; if ( sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) { throw new IllegalStateException ( \"Could not invoke getProfileCMP Method, Sbb Object is not in the READY state!\" ) ; } ProfileManagement sleeProfileManager = sleeContainer . getSleeProfileTableManager ( ) ; ProfileTable profileTable = sleeProfileManager . getProfileTable ( profileID . getProfileTableName ( ) ) ; if ( ! profileTable . profileExists ( profileID . getProfileName ( ) ) ) { throw new UnrecognizedProfileNameException ( profileID . toString ( ) ) ; } return profileTable . getProfile ( profileID . getProfileName ( ) ) . getProfileCmpSlee10Wrapper ( ) ; }", "nl": "Retrieves a profile given the cmp method name and profile id"}}
{"translation": {"code": "public static void createInheritanceLink ( CtClass concreteClass , CtClass superClass ) { if ( superClass == null ) return ; try { concreteClass . setSuperclass ( superClass ) ; logger . trace ( concreteClass . getName ( ) + \" Inheritance link with \" + superClass . getName ( ) + \" class created\" ) ; } catch ( CannotCompileException cce ) { cce . printStackTrace ( ) ; } }", "nl": "Create the inheritance link with the sbb absract class provided by the sbb developer"}}
{"translation": {"code": "public static void copyMethods ( CtClass source , CtClass destination , CtClass [ ] exceptions ) { copyMethods ( source . getDeclaredMethods ( ) , destination , exceptions ) ; }", "nl": "Copy declared methods from one class to another"}}
{"translation": {"code": "public static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address , ServiceID serviceID ) { if ( sleeContainer . getCongestionControl ( ) . refuseFireEvent ( ) ) { throw new SLEEException ( \"congestion control refused event\" ) ; } // JAIN SLEE (TM) specs - Section 8.4.1 // The SBB object must have an assigned SBB entity when it invokes this // method. // Otherwise, this method throws a java.lang.IllegalStateException. if ( sbbEntity == null || sbbEntity . getSbbObject ( ) == null || sbbEntity . getSbbObject ( ) . getState ( ) != SbbObjectState . READY ) throw new IllegalStateException ( \"SbbObject not assigned!\" ) ; // JAIN SLEE (TM) specs - Section 8.4.1 // The event ... cannot be null. If ... argument is null, the fire // event method throws a java.lang.NullPointerException. if ( eventObject == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The event ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; // JAIN SLEE (TM) specs - Section 8.4.1 // The activity ... cannot be null. If ... argument is null, the fire // event method throws a java.lang.NullPointerException. if ( aci == null ) throw new NullPointerException ( \"JAIN SLEE (TM) specs - Section 8.4.1: The activity ... cannot be null. If ... argument is null, the fire event method throws a java.lang.NullPointerException.\" ) ; // JAIN SLEE (TM) specs - Section 8.4.1 // It is a mandatory transactional method (see Section 9.6.1). final SleeTransactionManager txManager = sleeContainer . getTransactionManager ( ) ; txManager . mandateTransaction ( ) ; // rebuild the ac from the aci in the 2nd argument of the invoked // method, check it's state ActivityContext ac = ( ( org . mobicents . slee . container . activity . ActivityContextInterface ) aci ) . getActivityContext ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"invoke(): firing event on \" + ac ) ; } // exception not in specs by mandated by // tests/activities/activitycontext/Test560Test.xml , it's preferable to // do double check on here than have the aci fire method throwing it and // the ra slee endpoint having to translate it to activity ending // exception, it is not common to have custom event firing in sbbs if ( ac . isEnding ( ) ) { throw new IllegalStateException ( \"activity context \" + ac . getActivityContextHandle ( ) + \" is ending\" ) ; } final EventRoutingTransactionData transactionData = txManager . getTransactionContext ( ) . getEventRoutingTransactionData ( ) ; if ( transactionData != null ) { final EventContext eventBeingDelivered = transactionData . getEventBeingDelivered ( ) ; if ( eventBeingDelivered != null && eventBeingDelivered . getEvent ( ) == eventObject ) { // there is an event being delivered by this tx and it matches the event being fired, lets copy the ref handler // fire the event ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , eventBeingDelivered ) ; return ; } } // seems it is not a refire ac . fireEvent ( eventTypeID , eventObject , ( Address ) address , serviceID , null , null , null ) ; }", "nl": "The logic to fire an event from an SLEE 1 . 1 Sbb"}}
{"translation": {"code": "ActivityHandle derreferActivityHandle ( ActivityHandle handle ) { ActivityHandle ah = null ; if ( resourceManagement . getHandleReferenceFactory ( ) != null && handle . getClass ( ) == ActivityHandleReference . class ) { ActivityHandleReference ahReference = ( ActivityHandleReference ) handle ; ah = resourceManagement . getHandleReferenceFactory ( ) . getActivityHandle ( ahReference ) ; } else { ah = handle ; } return ah ; }", "nl": "if it is a handle reference it gets the referred handle"}}
{"translation": {"code": "public static void fireEvent ( SbbEntity sbbEntity , EventTypeID eventTypeID , Object eventObject , ActivityContextInterface aci , Address address ) { fireEvent ( sbbEntity , eventTypeID , eventObject , aci , address , null ) ; }", "nl": "The logic to fire an event from an SLEE 1 . 0 Sbb"}}
{"translation": {"code": "public ObjectName getUsageMBean ( String paramSetName ) throws NullPointerException , UnrecognizedUsageParameterSetNameException , ManagementException { if ( paramSetName == null ) throw new NullPointerException ( \"Sbb usage param set is null\" ) ; return _getUsageMBean ( paramSetName ) ; }", "nl": "Retrieves the object name for the usage param mbean with the specified name"}}
{"translation": {"code": "static private void validateDirectory ( File aDirectory ) throws FileNotFoundException { if ( aDirectory == null ) { throw new IllegalArgumentException ( \"Directory should not be null.\" ) ; } if ( ! aDirectory . exists ( ) ) { throw new FileNotFoundException ( \"Directory does not exist: \" + aDirectory ) ; } if ( ! aDirectory . isDirectory ( ) ) { throw new IllegalArgumentException ( \"Is not a directory: \" + aDirectory ) ; } if ( ! aDirectory . canRead ( ) ) { throw new IllegalArgumentException ( \"Directory cannot be read: \" + aDirectory ) ; } }", "nl": "Directory is valid if it exists does not represent a file and can be read ."}}
{"translation": {"code": "public boolean isSourceOwnerOfAlarm ( NotificationSourceWrapper notificationSource , String alarmID ) { AlarmPlaceHolder aph = this . alarmIdToAlarm . get ( alarmID ) ; if ( aph == null ) return false ; return aph . getNotificationSource ( ) . getNotificationSource ( ) . equals ( notificationSource . getNotificationSource ( ) ) ; }", "nl": "NON MBEAN - used only internal those methods are not exposed via jmx"}}
{"translation": {"code": "private void resume ( ) { // create runnable to resume the event context Runnable runnable = new Runnable ( ) { public void run ( ) { if ( scheduledFuture == null ) { // already resumed return ; } // cancel timer task scheduledFuture . cancel ( false ) ; scheduledFuture = null ; // send events frozen to event router again, will be processed only after this one ends (this one is already being executed) for ( EventContext ec : barriedEvents ) { ec . getLocalActivityContext ( ) . getExecutorService ( ) . routeEvent ( ec ) ; } barriedEvents = null ; // remove barrier on activity event queue event . getLocalActivityContext ( ) . getEventQueueManager ( ) . removeBarrier ( transaction ) ; // remove suspension suspended = false ; // continue routing the event related with this context event . getLocalActivityContext ( ) . getCurrentEventRoutingTask ( ) . run ( ) ; } } ; // run it using the activity executor service to avoid thread concurrency event . getLocalActivityContext ( ) . getExecutorService ( ) . execute ( runnable ) ; }", "nl": "the real logic to resume the event context"}}
{"translation": {"code": "public void raConfigurationUpdate ( ConfigProperties properties ) throws InvalidConfigurationException { if ( doTraceLogs ) { logger . trace ( \"raConfigurationUpdate( properties = \" + properties + \" )\" ) ; } verifyConfigProperties ( properties ) ; object . raConfigurationUpdate ( configProperties ) ; }", "nl": "Updates the ra configuration ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public void unsetFaultTolerantResourceAdaptorContext ( ) throws IllegalArgumentException { if ( doTraceLogs ) { logger . trace ( \"unsetFaultTolerantResourceAdaptorContext()\" ) ; } if ( isFaultTolerant ( ) ) { ( ( FaultTolerantResourceAdaptor < Serializable , Serializable > ) this . object ) . unsetFaultTolerantResourceAdaptorContext ( ) ; } else { throw new IllegalArgumentException ( \"RA Object is not fault tolerant!\" ) ; } }", "nl": "Unsets the ft context of the ra object ."}}
{"translation": {"code": "public void unsetResourceAdaptorContext ( ) throws InvalidStateException { if ( doTraceLogs ) { logger . trace ( \"unsetResourceAdaptorContext()\" ) ; } if ( state == ResourceAdaptorObjectState . UNCONFIGURED ) { object . unsetResourceAdaptorContext ( ) ; state = null ; } else { throw new InvalidStateException ( \"ra object is in state \" + state ) ; } }", "nl": "Unsets the context of the ra object ."}}
{"translation": {"code": "private void verifyConfigProperties ( ConfigProperties newProperties ) throws InvalidConfigurationException { if ( doTraceLogs ) { logger . trace ( \"verifyConfigProperties( newProperties = \" + newProperties + \" )\" ) ; } // merge properties for ( ConfigProperties . Property configProperty : configProperties . getProperties ( ) ) { if ( newProperties . getProperty ( configProperty . getName ( ) ) == null ) { newProperties . addProperty ( configProperty ) ; } } // validate result for ( ConfigProperties . Property entityProperty : newProperties . getProperties ( ) ) { if ( entityProperty . getValue ( ) == null ) { throw new InvalidConfigurationException ( \"the property \" + entityProperty . getName ( ) + \" has null value\" ) ; } } // validate in ra object object . raVerifyConfiguration ( newProperties ) ; // ok, switch config configProperties = newProperties ; }", "nl": "Merges the current properties values with the new ones and uses the ra to verify the configuration"}}
{"translation": {"code": "public void remove ( ) { Logger logger = getLogger ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Closing \" + toString ( ) ) ; } final MBeanServer mbeanServer = sleeContainer . getMBeanServer ( ) ; try { mbeanServer . unregisterMBean ( getObjectName ( ) ) ; } catch ( Exception e ) { logger . error ( \"failed to remove \" + toString ( ) , e ) ; } // remove all usage param if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Removing all named usage parameters of \" + toString ( ) ) ; } for ( String name : usageMBeans . keySet ( ) ) { try { _removeUsageParameterSet ( name , false ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } // also remove the default try { removeUsageParameterSet ( ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } }", "nl": "Removes the mbean"}}
{"translation": {"code": "public void raUnconfigure ( ) throws InvalidStateException { if ( doTraceLogs ) { logger . trace ( \"raUnconfigure()\" ) ; } if ( state == ResourceAdaptorObjectState . INACTIVE ) { state = ResourceAdaptorObjectState . UNCONFIGURED ; object . raUnconfigure ( ) ; } else { throw new InvalidStateException ( \"ra object is in state \" + state ) ; } }", "nl": "Unconfigures the ra object"}}
{"translation": {"code": "public void raInactive ( ) throws InvalidStateException { if ( doTraceLogs ) { logger . trace ( \"raInactive()\" ) ; } if ( state == ResourceAdaptorObjectState . STOPPING ) { state = ResourceAdaptorObjectState . INACTIVE ; object . raInactive ( ) ; } else { throw new InvalidStateException ( \"ra object is in state \" + state ) ; } }", "nl": "Requests the deactivation of the ra object . If the operation succeeds the ra will transition to INACTIVE state ."}}
{"translation": {"code": "public void raStopping ( ) throws InvalidStateException { if ( doTraceLogs ) { logger . trace ( \"raStopping()\" ) ; } if ( state == ResourceAdaptorObjectState . ACTIVE ) { state = ResourceAdaptorObjectState . STOPPING ; object . raStopping ( ) ; } else { throw new InvalidStateException ( \"ra object is in state \" + state ) ; } }", "nl": "Requests the stopping of the ra object . If the operation succeeds the ra will transition to STOPPING state ."}}
{"translation": {"code": "private File downloadRemoteDU ( URL duURL , File deploymentRoot ) throws Exception { InputStream in = null ; OutputStream out = null ; try { // Get the filename out of the URL\r String filename = new File ( duURL . getPath ( ) ) . getName ( ) ; // Prepare for creating the file at deploy folder\r File tempFile = new File ( deploymentRoot , filename ) ; out = new BufferedOutputStream ( new FileOutputStream ( tempFile ) ) ; URLConnection conn = duURL . openConnection ( ) ; in = conn . getInputStream ( ) ; // Get the data\r byte [ ] buffer = new byte [ 1024 ] ; int numRead ; while ( ( numRead = in . read ( buffer ) ) != - 1 ) { out . write ( buffer , 0 , numRead ) ; } // Done! Successful.\r return tempFile ; } finally { // Do the clean up.\r try { if ( in != null ) { in . close ( ) ; in = null ; } if ( out != null ) { out . close ( ) ; out = null ; } } catch ( IOException ioe ) { // Shouldn't happen, let's ignore.\r } } }", "nl": "Downloads a remote DU to a local folder"}}
{"translation": {"code": "protected URL findResourceLocally ( String name ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + \" findResourceLocally: \" + name ) ; return super . findResource ( name ) ; }", "nl": "Finds a resource locally i . e . in the URLs managed by the extended URLClassLoader ."}}
{"translation": {"code": "void resetCacheFlags ( boolean resetChilds ) { if ( isTraceable ( TraceLevel . FINEST ) ) { finestEnabled = true ; finerEnabled = true ; fineEnabled = true ; configEnabled = true ; infoEnabled = true ; warningEnabled = true ; severeEnabled = true ; } else { finestEnabled = false ; if ( isTraceable ( TraceLevel . FINER ) ) { finerEnabled = true ; fineEnabled = true ; configEnabled = true ; infoEnabled = true ; warningEnabled = true ; severeEnabled = true ; } else { finerEnabled = false ; if ( isTraceable ( TraceLevel . FINE ) ) { fineEnabled = true ; configEnabled = true ; infoEnabled = true ; warningEnabled = true ; severeEnabled = true ; } else { fineEnabled = false ; if ( isTraceable ( TraceLevel . CONFIG ) ) { configEnabled = true ; infoEnabled = true ; warningEnabled = true ; severeEnabled = true ; } else { if ( isTraceable ( TraceLevel . INFO ) ) { infoEnabled = true ; warningEnabled = true ; severeEnabled = true ; } else { infoEnabled = false ; if ( isTraceable ( TraceLevel . WARNING ) ) { warningEnabled = true ; severeEnabled = true ; } else { warningEnabled = false ; if ( isTraceable ( TraceLevel . SEVERE ) ) { severeEnabled = true ; } else { severeEnabled = false ; } } } } } } } if ( resetChilds ) { // implicit change of level demands that we update reset flags on childs without level\r for ( TracerImpl child : childs ) { if ( child . level == null ) { child . resetCacheFlags ( true ) ; } } } }", "nl": "manages the flags which cache if levels are enabled"}}
{"translation": {"code": "private void assignLog4JLevel ( Level log4jLevel ) { if ( log4jLevel == null ) { return ; } if ( log4jLevel == Level . DEBUG ) { level = TraceLevel . FINE ; } else if ( log4jLevel == Level . INFO ) { level = TraceLevel . INFO ; } else if ( log4jLevel == Level . WARN ) { level = TraceLevel . WARNING ; } else if ( log4jLevel == Level . ERROR ) { level = TraceLevel . SEVERE ; } else if ( log4jLevel == Level . TRACE ) { level = TraceLevel . FINEST ; } else if ( log4jLevel == Level . OFF ) { level = TraceLevel . OFF ; } }", "nl": "assigns the equiv log4j level to the tracer"}}
{"translation": {"code": "void syncLevelWithLog4j ( ) { // get the level from log4j, only the root one uses effective level\r Level log4jLevel = parent == null ? logger . getEffectiveLevel ( ) : logger . getLevel ( ) ; if ( level == null ) { // set the level\r assignLog4JLevel ( log4jLevel ) ; } else { // set the level only if differs, otherwise we may loose levels not present in log4j\r if ( tracerToLog4JLevel ( level ) != log4jLevel ) { assignLog4JLevel ( log4jLevel ) ; } } // the root must always have a level\r if ( parent == null && level == null ) { // defaults to INFO\r logger . setLevel ( Level . INFO ) ; level = TraceLevel . INFO ; } // reset the flags\r resetCacheFlags ( false ) ; }", "nl": "syncs the slee tracer level with the one that related logger has in log4j"}}
{"translation": {"code": "public boolean accepts ( URL deployableUnitURL , String deployableUnitName ) { DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; URL url = du . getUrl ( ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Method accepts called for \" + url + \" [DU: \" + deployableUnitName + \"]\" ) ; } try { String fullPath = url . getFile ( ) ; String fileName = fullPath . substring ( fullPath . lastIndexOf ( ' ' ) + 1 , fullPath . length ( ) ) ; // Is it in the toAccept list ? Direct accept. if ( toAccept . containsKey ( fileName ) ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; } return true ; } // If not it the accept list but it's a jar might be a DU jar... else if ( fileName . endsWith ( \".jar\" ) ) { JarFile duJarFile = null ; try { // Try to obtain the DU descriptor, if we got it, we're // accepting it! if ( du . getEntry ( \"META-INF/deployable-unit.xml\" ) != null ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Accepting \" + url . toString ( ) + \".\" ) ; } return true ; } } finally { // Clean up! if ( duJarFile != null ) { try { duJarFile . close ( ) ; } catch ( IOException ignore ) { } finally { duJarFile = null ; } } } } } catch ( Exception ignore ) { // Ignore.. will reject. } // Uh-oh.. looks like it will stay outside. return false ; }", "nl": "Method for deciding whether or not to accept the file ."}}
{"translation": {"code": "public void init ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { URL url = deployableUnitURL ; DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Method init called for \" + deployableUnitURL + \" [DU: \" + deployableUnitName + \"]\" ) ; } // Get the full path and filename for this du String fullPath = du . getFullPath ( ) ; String fileName = du . getFileName ( ) ; try { DeployableUnitWrapper duWrapper = null ; // If we're able to remove it from toAccept was because it was // there! if ( ( duWrapper = toAccept . remove ( fileName ) ) != null ) { // Create a new Deployable Component from this DI. DeployableComponent dc = new DeployableComponent ( du , url , fileName , sleeContainerDeployer ) ; // Also get the deployable unit for this (it exists, we've // checked!) DeployableUnit deployerDU = deployableUnits . get ( duWrapper . getFileName ( ) ) ; for ( DeployableComponent subDC : dc . getSubComponents ( ) ) { // Add the sub-component to the DU object. deployerDU . addComponent ( subDC ) ; } } // If the DU for this component doesn't exists.. it's a new DU! else if ( fileName . endsWith ( \".jar\" ) ) { JarFile duJarFile = null ; try { // Get a reference to the DU jar file duJarFile = new JarFile ( fullPath ) ; // Try to get the Deployable Unit descriptor JarEntry duXmlEntry = duJarFile . getJarEntry ( \"META-INF/deployable-unit.xml\" ) ; // Got descriptor? if ( duXmlEntry != null ) { // Create a new Deployable Unit object. DeployableUnit deployerDU = new DeployableUnit ( du , sleeContainerDeployer ) ; // Let's parse the descriptor to see what we've got... DeployableUnitDescriptorFactory dudf = sleeContainerDeployer . getSleeContainer ( ) . getComponentManagement ( ) . getDeployableUnitManagement ( ) . getDeployableUnitDescriptorFactory ( ) ; DeployableUnitDescriptor duDesc = dudf . parse ( duJarFile . getInputStream ( duXmlEntry ) ) ; // If the filename is present, an undeploy in on the way... let's wait while ( deployableUnits . containsKey ( fileName ) ) { Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; } // Add it to the deployable units map. deployableUnits . put ( fileName , deployerDU ) ; // Go through each jar entry in the DU descriptor for ( String componentJarName : duDesc . getJarEntries ( ) ) { // Might have path... strip it! int beginIndex ; if ( ( beginIndex = componentJarName . lastIndexOf ( ' ' ) ) == - 1 ) beginIndex = componentJarName . lastIndexOf ( ' ' ) ; beginIndex ++ ; // Got a clean jar name, no paths. componentJarName = componentJarName . substring ( beginIndex , componentJarName . length ( ) ) ; // Put it in the accept list. toAccept . put ( componentJarName , du ) ; } // Do the same as above... but for services for ( String serviceXMLName : duDesc . getServiceEntries ( ) ) { // Might have path... strip it! int beginIndex ; if ( ( beginIndex = serviceXMLName . lastIndexOf ( ' ' ) ) == - 1 ) beginIndex = serviceXMLName . lastIndexOf ( ' ' ) ; beginIndex ++ ; // Got a clean XML filename serviceXMLName = serviceXMLName . substring ( beginIndex , serviceXMLName . length ( ) ) ; // Add it to the accept list. toAccept . put ( serviceXMLName , du ) ; } } } finally { // Clean up! if ( duJarFile != null ) { try { duJarFile . close ( ) ; } catch ( IOException ignore ) { } finally { duJarFile = null ; } } } } } catch ( Exception e ) { // Something went wrong... logger . error ( \"Deployment of \" + fileName + \" failed. \" , e ) ; return ; } }", "nl": "Initializer method for accepted files . Will parse descriptors at this point ."}}
{"translation": {"code": "public void start ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Method start called for \" + du . getUrl ( ) + \" [DU: \" + deployableUnitName + \"]\" ) ; } try { // Get the deployable unit object DeployableUnit realDU = deployableUnits . get ( du . getFileName ( ) ) ; // If it exists, install it. if ( realDU != null ) { while ( isInUndeployList ( du . getFileName ( ) ) ) { Thread . sleep ( getWaitTimeBetweenOperations ( ) ) ; } sleeContainerDeployer . getDeploymentManager ( ) . installDeployableUnit ( realDU ) ; } } catch ( Exception e ) { logger . error ( \"\" , e ) ; } }", "nl": "This is where the fun begins . Time to deploy!"}}
{"translation": {"code": "public void stop ( URL deployableUnitURL , String deployableUnitName ) throws DeploymentException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"stop( deployableUnitURL = : \" + deployableUnitURL + \" )\" ) ; } DeployableUnitWrapper du = new DeployableUnitWrapper ( deployableUnitURL , deployableUnitName ) ; DeployableUnit realDU = null ; String fileName = du . getFileName ( ) ; if ( ( realDU = deployableUnits . get ( du . getFileName ( ) ) ) != null ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Got DU: \" + realDU . getDeploymentInfoShortName ( ) ) ; } if ( ! isInUndeployList ( fileName ) ) { addToUndeployList ( fileName ) ; } try { // Uninstall it sleeContainerDeployer . getDeploymentManager ( ) . uninstallDeployableUnit ( realDU ) ; // Remove it from list if successful deployableUnits . remove ( fileName ) ; removeFromUndeployList ( fileName ) ; } catch ( DependencyException e ) { // ignore, will be tried again once there is another undeployment } catch ( Exception e ) { Throwable cause = e . getCause ( ) ; if ( cause instanceof InvalidStateException ) { logger . warn ( cause . getLocalizedMessage ( ) + \"... WAITING ...\" ) ; } else if ( e instanceof DeploymentException ) { throw new IllegalStateException ( e . getLocalizedMessage ( ) , e ) ; } else { logger . error ( e . getMessage ( ) , e ) ; } } } }", "nl": "Fun has ended . Time to undeploy ."}}
{"translation": {"code": "public String showStatus ( ) throws DeploymentException { String output = \"\" ; output += \"<p>Deployable Units List:</p>\" ; for ( String key : deployableUnits . keySet ( ) ) { output += \"&lt;\" + key + \"&gt; [\" + deployableUnits . get ( key ) + \"]<br>\" ; for ( String duComponent : deployableUnits . get ( key ) . getComponents ( ) ) { output += \"+-- \" + duComponent + \"<br>\" ; } } output += \"<p>To Accept List:</p>\" ; for ( String key : toAccept . keySet ( ) ) { output += \"&lt;\" + key + \"&gt; [\" + toAccept . get ( key ) + \"]<br>\" ; } output += \"<p>Undeployments running:</p>\" ; for ( String undeploy : undeploys ) { output += \"+-- \" + undeploy + \"<br>\" ; } output += \"<p>Deployment Manager Status</p>\" ; output += sleeContainerDeployer . getDeploymentManager ( ) . showStatus ( ) ; return output ; }", "nl": "MBean operation for getting Deployer status ."}}
{"translation": {"code": "public void shutdownSlee ( ) throws InvalidStateException { if ( sleeState != SleeState . STOPPED ) { throw new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; } // slee shutdown beforeModulesShutdown ( ) ; for ( Iterator < SleeContainerModule > i = modules . descendingIterator ( ) ; i . hasNext ( ) ; ) { i . next ( ) . sleeShutdown ( ) ; } afterModulesShutdown ( ) ; sleeState = null ; }", "nl": "Shutdown of the SLEE container"}}
{"translation": {"code": "public void initSlee ( ) throws InvalidStateException { if ( sleeState != null ) { throw new InvalidStateException ( \"slee in \" + sleeState + \" state\" ) ; } // slee init beforeModulesInitialization ( ) ; for ( Iterator < SleeContainerModule > i = modules . iterator ( ) ; i . hasNext ( ) ; ) { i . next ( ) . sleeInitialization ( ) ; } afterModulesInitialization ( ) ; sleeState = SleeState . STOPPED ; }", "nl": "Initiates the SLEE container"}}
{"translation": {"code": "protected Class < ? > findClassLocally ( String name ) throws ClassNotFoundException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( toString ( ) + \" findClassLocally: \" + name ) ; } final boolean acquiredLock = acquireGlobalLock ( ) ; try { return findClassLocallyLocked ( name ) ; } finally { if ( acquiredLock ) { releaseGlobalLock ( ) ; } } }", "nl": "Finds a class locally i . e . in the URLs managed by the extended URLClassLoader ."}}
{"translation": {"code": "protected Enumeration < URL > findResourcesLocally ( String name ) throws IOException { if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + \" findResourcesLocally: \" + name ) ; return super . findResources ( name ) ; }", "nl": "Finds resources locally i . e . in the URLs managed by the extended URLClassLoader ."}}
{"translation": {"code": "public void addDirectDependency ( URLClassLoaderDomainImpl domain ) { if ( logger . isTraceEnabled ( ) ) logger . trace ( toString ( ) + \" adding domain \" + domain + \" to direct dependencies\" ) ; directDependencies . add ( domain ) ; }", "nl": "Adds a direct dependency to this domain . Direct dependencies are other domains which the domain depends on ."}}
{"translation": {"code": "public List < URLClassLoaderDomainImpl > getAllDependencies ( ) { List < URLClassLoaderDomainImpl > result = new ArrayList < URLClassLoaderDomainImpl > ( ) ; this . getAllDependencies ( result ) ; return result ; }", "nl": "Retrieves a flat list containing all dependencies for the domain i . e . all direct dependencies and their own dependencies ."}}
{"translation": {"code": "public static synchronized void bind ( String key , Object target ) throws NameAlreadyBoundException { if ( wrapperMap . containsKey ( key ) == true ) throw new NameAlreadyBoundException ( key + \" already exists in the NonSerializableFactory map\" ) ; wrapperMap . put ( key , target ) ; }", "nl": "Place an object into the NonSerializableFactory namespace for subsequent access by getObject . There cannot be an already existing binding for key ."}}
{"translation": {"code": "public static synchronized void rebind ( Name name , Object target ) throws NamingException { rebind ( name , target , false ) ; }", "nl": "A convience method that simplifies the process of rebinding a non - zerializable object into a JNDI context . This version binds the target object into the default IntitialContext using name path ."}}
{"translation": {"code": "protected String unfoldArray ( String prefix , Object [ ] array , PropertyEditor editor ) { //StringBuffer sb = new StringBuffer(\"\\n\");\r StringBuffer sb = new StringBuffer ( \"[\" ) ; for ( int index = 0 ; index < array . length ; index ++ ) { if ( editor != null ) { editor . setValue ( array [ index ] ) ; sb . append ( editor . getAsText ( ) ) ; } else { sb . append ( array [ index ] . toString ( ) ) ; } if ( index < array . length - 1 ) { sb . append ( CID_SEPARATOR ) ; //sb.append(\"\\n\");\r } } sb . append ( \"]\" ) ; return sb . toString ( ) ; }", "nl": "Default implementation ."}}