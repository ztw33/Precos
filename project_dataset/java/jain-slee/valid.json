{"translation": {"code": "public InputSource resolveEntity ( String publicId , String systemId ) throws SAXException , IOException { URL resourceURL = resources . get ( publicId ) ; if ( resourceURL != null ) { InputStream resourceStream = resourceURL . openStream ( ) ; InputSource is = new InputSource ( resourceStream ) ; is . setPublicId ( publicId ) ; is . setSystemId ( resourceURL . toExternalForm ( ) ) ; return is ; } return null ; }", "nl": "Creates an InputSource with a SystemID corresponding to a local dtd file ."}}
{"translation": {"code": "public void removeObjectPool ( final ProfileTableImpl profileTable , final SleeTransactionManager sleeTransactionManager ) { TransactionalAction action = new TransactionalAction ( ) { public void execute ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Removing Pool for \" + profileTable ) ; } removeObjectPool ( profileTable ) ; } } ; if ( sleeTransactionManager != null ) { sleeTransactionManager . getTransactionContext ( ) . getAfterCommitActions ( ) . add ( action ) ; } else { action . execute ( ) ; } }", "nl": "Removes the object pool for the specified profile table . If a transaction manager is used then the removal is only after the tx commit ."}}
{"translation": {"code": "private AbstractProfileMBeanImpl createAndRegisterProfileMBean ( String profileName , ProfileTableImpl profileTable ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"createAndRegisterProfileMBean( profileTable = \" + profileTable + \" , profileName = \" + profileName + \" )\" ) ; } try { ProfileSpecificationComponent component = profileTable . getProfileSpecificationComponent ( ) ; Constructor < ? > constructor = component . getProfileMBeanConcreteImplClass ( ) . getConstructor ( Class . class , String . class , ProfileTableImpl . class ) ; final AbstractProfileMBeanImpl profileMBean = ( AbstractProfileMBeanImpl ) constructor . newInstance ( component . getProfileMBeanConcreteInterfaceClass ( ) , profileName , profileTable ) ; profileMBean . register ( ) ; // add a rollback action to unregister the mbean\r TransactionalAction rollbackAction = new TransactionalAction ( ) { public void execute ( ) { try { profileMBean . unregister ( ) ; } catch ( Throwable e ) { logger . error ( e . getMessage ( ) , e ) ; } } } ; sleeTransactionManagement . getTransactionContext ( ) . getAfterRollbackActions ( ) . add ( rollbackAction ) ; return profileMBean ; } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } }", "nl": "Creates and registers a profile mbean for the specified object ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static void addProfileCall ( ProfileObjectImpl po ) throws SLEEException { SleeTransactionManager sleeTransactionManager = sleeContainer . getTransactionManager ( ) ; try { if ( sleeTransactionManager . getTransaction ( ) == null ) { return ; } } catch ( SystemException se ) { throw new SLEEException ( \"Unable to verify SLEE Transaction.\" , se ) ; } String key = makeKey ( po ) ; if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Recording call to profile. Key[\" + key + \"]\" ) ; } final TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; ProfileCallRecorderTransactionData data = ( ProfileCallRecorderTransactionData ) txContext . getData ( ) . get ( TRANSACTION_CONTEXT_KEY ) ; // If data does not exist, create it\r if ( data == null ) { data = new ProfileCallRecorderTransactionData ( ) ; txContext . getData ( ) . put ( TRANSACTION_CONTEXT_KEY , data ) ; } if ( ! po . isProfileReentrant ( ) ) { // we need to check\r if ( data . invokedProfiles . contains ( key ) && data . invokedProfiles . getLast ( ) . compareTo ( key ) != 0 ) { throw new SLEEException ( \"Detected loopback call. Call sequence: \" + data . invokedProfiles ) ; } data . invokedProfiles . add ( key ) ; data . invokedProfileTablesNames . add ( po . getProfileTable ( ) . getProfileTableName ( ) ) ; } }", "nl": "Adds call to this profile ."}}
{"translation": {"code": "public ProfileObjectImpl getProfile ( String profileName ) throws TransactionRequiredLocalException , SLEEException { Map txData = getTxData ( ) ; ProfileTransactionID key = new ProfileTransactionID ( profileName , profileTable . getProfileTableName ( ) ) ; ProfileObjectImpl value = ( ProfileObjectImpl ) txData . get ( key ) ; if ( value == null ) { ProfileObjectPool pool = profileTable . getProfileManagement ( ) . getObjectPoolManagement ( ) . getObjectPool ( profileTable . getProfileTableName ( ) ) ; value = pool . borrowObject ( ) ; passivateProfileObjectOnTxEnd ( profileTable . getSleeContainer ( ) . getTransactionManager ( ) , value , pool ) ; try { value . profileActivate ( profileName ) ; } catch ( UnrecognizedProfileNameException e ) { value . invalidateObject ( ) ; pool . invalidateObject ( value ) ; return null ; } txData . put ( key , value ) ; } return value ; }", "nl": "Retrieves a profile object for the table and specified profile name there is only one profile object per profile entity per transaction"}}
{"translation": {"code": "protected void checkTransaction ( ) throws IllegalStateException { try { if ( ! sleeContainer . getTransactionManager ( ) . getTransaction ( ) . equals ( this . transaction ) ) { throw new IllegalStateException ( ) ; } } catch ( SystemException e ) { throw new IllegalStateException ( ) ; } }", "nl": "Verifies that the current transaction is still the one used to create the object"}}
{"translation": {"code": "public boolean profileExists ( String profileName ) { boolean result = component . getProfileEntityFramework ( ) . findProfile ( this . getProfileTableName ( ) , profileName ) != null ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Profile named \" + profileName + ( result ? \"\" : \" does not\" ) + \" exists on table named \" + this . getProfileTableName ( ) ) ; } return result ; }", "nl": "Determines if profile is in back end storage == visible to other compoenents than MBean if null is passed as argumetn it must check for any other than defualt?"}}
{"translation": {"code": "public static void addAnnotation ( String annotation , LinkedHashMap < String , Object > memberValues , Object toAnnotate ) { if ( toAnnotate instanceof CtClass ) { CtClass classToAnnotate = ( CtClass ) toAnnotate ; ClassFile cf = classToAnnotate . getClassFile ( ) ; ConstPool cp = cf . getConstPool ( ) ; AnnotationsAttribute attr = ( AnnotationsAttribute ) cf . getAttribute ( AnnotationsAttribute . visibleTag ) ; if ( attr == null ) { attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; } Annotation a = new Annotation ( annotation , cp ) ; if ( memberValues != null ) { addMemberValuesToAnnotation ( a , cp , memberValues ) ; } attr . addAnnotation ( a ) ; cf . addAttribute ( attr ) ; } else if ( toAnnotate instanceof CtMethod ) { CtMethod methodToAnnotate = ( CtMethod ) toAnnotate ; MethodInfo mi = methodToAnnotate . getMethodInfo ( ) ; ConstPool cp = mi . getConstPool ( ) ; AnnotationsAttribute attr = ( AnnotationsAttribute ) mi . getAttribute ( AnnotationsAttribute . visibleTag ) ; if ( attr == null ) { attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; } Annotation a = new Annotation ( annotation , cp ) ; if ( memberValues != null ) { addMemberValuesToAnnotation ( a , cp , memberValues ) ; } attr . addAnnotation ( a ) ; mi . addAttribute ( attr ) ; } else if ( toAnnotate instanceof CtField ) { CtField fieldToAnnotate = ( CtField ) toAnnotate ; FieldInfo fi = fieldToAnnotate . getFieldInfo ( ) ; ConstPool cp = fi . getConstPool ( ) ; AnnotationsAttribute attr = ( AnnotationsAttribute ) fi . getAttribute ( AnnotationsAttribute . visibleTag ) ; if ( attr == null ) { attr = new AnnotationsAttribute ( cp , AnnotationsAttribute . visibleTag ) ; } Annotation a = new Annotation ( annotation , cp ) ; if ( memberValues != null ) { addMemberValuesToAnnotation ( a , cp , memberValues ) ; } attr . addAnnotation ( a ) ; fi . addAttribute ( attr ) ; } else { throw new UnsupportedOperationException ( \"Unknown object type: \" + toAnnotate . getClass ( ) ) ; } }", "nl": "Adds the selected annotation to the Object along with the specified memberValues ."}}
{"translation": {"code": "public void unsetProfileContext ( ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"[unsetProfileContext] \" + this ) ; } if ( state == ProfileObjectState . POOLED && profileConcreteClassInfo . isInvokeUnsetProfileContext ( ) ) { final ClassLoader oldClassLoader = SleeContainerUtils . getCurrentThreadClassLoader ( ) ; try { final ClassLoader cl = profileTable . getProfileSpecificationComponent ( ) . getClassLoader ( ) ; if ( System . getSecurityManager ( ) != null ) { AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Object run ( ) { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; return null ; } } ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; } if ( isSlee11 ) { try { profileConcrete . unsetProfileContext ( ) ; } catch ( RuntimeException e ) { runtimeExceptionOnProfileInvocation ( e ) ; } } profileContext . setProfileObject ( null ) ; state = ProfileObjectState . DOES_NOT_EXIST ; } finally { if ( System . getSecurityManager ( ) != null ) { AccessController . doPrivileged ( new PrivilegedAction < Object > ( ) { public Object run ( ) { Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; return null ; } } ) ; } else { Thread . currentThread ( ) . setContextClassLoader ( oldClassLoader ) ; } } } }", "nl": "Invoked when pool removes object"}}
{"translation": {"code": "public ProfileID getProfileByIndexedAttribute ( java . lang . String profileTableName , java . lang . String attributeName , java . lang . Object attributeValue ) throws NullPointerException , UnrecognizedProfileTableNameException , UnrecognizedAttributeException , AttributeNotIndexedException , AttributeTypeMismatchException , TransactionRolledbackLocalException , FacilityException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"getProfileByIndexedAttribute( profileTableName = \" + profileTableName + \" , attributeName = \" + attributeName + \" , attributeValue = \" + attributeValue + \" )\" ) ; } profileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; try { ProfileTableImpl profileTable = profileManagement . getProfileTable ( profileTableName ) ; if ( profileTable . getProfileSpecificationComponent ( ) . isSlee11 ( ) ) { throw new FacilityException ( \"JAIN SLEE 1.1 Specs forbidden the usage of this method on SLEE 1.1 Profile Tables\" ) ; } Collection < ProfileID > profileIDs = profileTable . getProfilesByAttribute ( attributeName , attributeValue , false ) ; if ( profileIDs . isEmpty ( ) ) { return null ; } else { return profileIDs . iterator ( ) . next ( ) ; } } catch ( NullPointerException e ) { throw e ; } catch ( UnrecognizedProfileTableNameException e ) { throw e ; } catch ( UnrecognizedAttributeException e ) { throw e ; } catch ( AttributeNotIndexedException e ) { throw e ; } catch ( AttributeTypeMismatchException e ) { throw e ; } catch ( Throwable e ) { throw new FacilityException ( e . getMessage ( ) , e ) ; } }", "nl": "Get a ProfileID object that identifies the profile contained in the specified profile table where the specified profile attribute is set to the specified value . In the case of a profile attribute of an array type the type of the specified value must be the base component type of the array not the array type itself and the SLEE will return the profile identifier of any profile that contains the value within the array ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) private EntityManager getEntityManager ( ) { if ( txDataKey == null ) { txDataKey = new StringBuilder ( \"jpapef.em.\" ) . append ( component . getProfileSpecificationID ( ) ) . toString ( ) ; } final TransactionContext txContext = sleeTransactionManager . getTransactionContext ( ) ; // look in tx Map transactionContextData = txContext . getData ( ) ; EntityManager result = ( EntityManager ) transactionContextData . get ( txDataKey ) ; if ( result == null ) { // create using factory result = entityManagerFactory . createEntityManager ( ) ; // store in tx context data transactionContextData . put ( txDataKey , result ) ; // add a tx action to close it before tx commits // FIXME: Do we need this after-rollback action here /*\n\t\t\tfinal EntityManager em = result;\n\t\t\tTransactionalAction action = new TransactionalAction() {\n\t\t\t\tpublic void execute() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tem.close();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tlogger.error(e.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttxContext.getAfterRollbackActions().add(action);\n\t\t\t*/ } return result ; }", "nl": "Retrieves the entity manager for the current tx and the framework profile spec"}}
{"translation": {"code": "private static void addMemberValuesToAnnotation ( Annotation annotation , ConstPool cp , LinkedHashMap < String , Object > memberValues ) { // Get the member value object for ( String mvName : memberValues . keySet ( ) ) { Object mvValue = memberValues . get ( mvName ) ; MemberValue mv = getMemberValue ( mvValue , cp ) ; annotation . addMemberValue ( mvName , mv ) ; } }", "nl": "Private method to add member values to annotation"}}
{"translation": {"code": "public static Collection < ProfileLocalObject > handle ( ProfileTableImpl profileTable , String queryName , Object [ ] arguments ) throws NullPointerException , TransactionRequiredLocalException , SLEEException , UnrecognizedQueryNameException , AttributeTypeMismatchException , InvalidArgumentException { return profileTable . getProfilesByStaticQuery ( queryName , arguments ) ; }", "nl": "Method that does lookup and creates PLOs"}}
{"translation": {"code": "private void profileInitialize ( String profileName ) { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"[profileInitialize] \" + this + \" , profileName = \" + profileName ) ; } if ( this . state != ProfileObjectState . POOLED ) { throw new SLEEException ( this . toString ( ) ) ; } if ( profileName == null ) { // default profile creation // create instance of entity profileEntity = profileEntityFramework . getProfileEntityFactory ( ) . newInstance ( profileTable . getProfileTableName ( ) , null ) ; // change state this . state = ProfileObjectState . PROFILE_INITIALIZATION ; // invoke life cycle method on profile if ( profileConcreteClassInfo . isInvokeProfileInitialize ( ) ) { try { profileConcrete . profileInitialize ( ) ; } catch ( RuntimeException e ) { runtimeExceptionOnProfileInvocation ( e ) ; } } } else { // load the default profile entity if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Copying state from default profile on object \" + this ) ; } profileEntity = cloneEntity ( profileTable . getDefaultProfileEntity ( ) ) ; profileEntity . setProfileName ( profileName ) ; } // mark entity as dirty and for creation profileEntity . create ( ) ; profileEntity . setDirty ( true ) ; }", "nl": "initialize state from default profile"}}
{"translation": {"code": "public static void createInheritanceLink ( CtClass concreteClass , String superClassName ) { if ( superClassName != null && superClassName . length ( ) >= 0 ) { try { concreteClass . setSuperclass ( classPool . get ( superClassName ) ) ; } catch ( CannotCompileException e ) { e . printStackTrace ( ) ; } catch ( NotFoundException e ) { e . printStackTrace ( ) ; } } }", "nl": "Create the inheritance link with the absract class provided by the developer"}}
{"translation": {"code": "public Collection < ProfileID > getProfiles ( String profileTableName ) throws NullPointerException , UnrecognizedProfileTableNameException , TransactionRolledbackLocalException , FacilityException { if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"getProfiles( profileTableName = \" + profileTableName + \" )\" ) ; } profileManagement . getSleeContainer ( ) . getTransactionManager ( ) . mandateTransaction ( ) ; try { return profileManagement . getProfileTable ( profileTableName ) . getProfiles ( ) ; } catch ( NullPointerException e ) { throw e ; } catch ( UnrecognizedProfileTableNameException e ) { throw e ; } catch ( Throwable e ) { throw new FacilityException ( e . getMessage ( ) , e ) ; } }", "nl": "Get a collection of ProfileID objects that identify all the profiles contained in the specified profile table . The collection returned is immutable . Any attempt to modify it either directly or indirectly will result in a java . lang . UnsupportedOperationException being thrown ."}}
{"translation": {"code": "protected Object convert ( String optArg ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException , CommandException { if ( fieldClass . isPrimitive ( ) ) { // TODO: to optimize, to rework new to valueOf\r if ( fieldClass . equals ( int . class ) ) { return new Integer ( optArg ) ; } else if ( fieldClass . equals ( long . class ) ) { return new Long ( optArg ) ; } else if ( fieldClass . equals ( int . class ) ) { return new Integer ( optArg ) ; } else if ( fieldClass . equals ( byte . class ) ) { return new Byte ( optArg ) ; } else if ( fieldClass . equals ( short . class ) ) { return new Short ( optArg ) ; } else if ( fieldClass . equals ( float . class ) ) { return new Float ( optArg ) ; } else if ( fieldClass . equals ( double . class ) ) { return new Double ( optArg ) ; } else if ( fieldClass . equals ( boolean . class ) ) { return new Boolean ( optArg ) ; } else if ( fieldClass . equals ( char . class ) ) { return new Character ( optArg . charAt ( 0 ) ) ; } //?\r throw new CommandException ( \"Unpredicted place. Please report.\" ) ; } else if ( isClassNumber ( ) ) { //Handle Long, Integer, .., Boolean\r Constructor < ? > con = fieldClass . getConstructor ( String . class ) ; return con . newInstance ( optArg ) ; } return optArg ; }", "nl": "This method is called to convert optArg from string form if no conversion is needed it should return passed object ."}}
{"translation": {"code": "private TreeItem doTree ( FQDNNode localRoot ) { TreeItem localLeaf = new TreeItem ( ) ; LogTreeNode logTreeNode = new LogTreeNode ( browseContainer , localRoot . getShortName ( ) , localRoot . getFqdName ( ) , localRoot . isWasLeaf ( ) , this ) ; localLeaf . setWidget ( logTreeNode ) ; if ( localRoot . getChildren ( ) . size ( ) > 0 ) { Tree t = new Tree ( ) ; ArrayList names = new ArrayList ( localRoot . getChildrenNames ( ) ) ; Collections . sort ( names ) ; Iterator it = names . iterator ( ) ; while ( it . hasNext ( ) ) { t . addItem ( doTree ( localRoot . getChild ( ( String ) it . next ( ) ) ) ) ; } localLeaf . addItem ( t ) ; } return localLeaf ; }", "nl": "TMP DEV METHODS"}}
{"translation": {"code": "public List < String > getLoggerNames ( String regex ) throws ManagementConsoleException { try { return ( List < String > ) this . mbeanServer . invoke ( logMgmtMBeanName , \"getLoggerNames\" , new Object [ ] { regex } , new String [ ] { \"java.lang.String\" } ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "SImilar to LoggingMXBean return list of available loggers . Filter is string that has to occur in loggers name ."}}
{"translation": {"code": "public boolean addLogger ( String name , Level level ) throws NullPointerException , ManagementConsoleException { try { return ( ( Boolean ) this . mbeanServer . invoke ( logMgmtMBeanName , \"addLogger\" , new Object [ ] { name , level } , new String [ ] { \"java.lang.String\" , \"java.util.logging.Level\" } ) ) . booleanValue ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new ManagementConsoleException ( SleeManagementMBeanUtils . doMessage ( e ) ) ; } }", "nl": "Tries to add logger if it doesnt exist"}}
{"translation": {"code": "protected void afterManagementMethodInvocation ( boolean activatedTransaction ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"afterManagementMethodInvocation( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } afterNonSetCmpField ( activatedTransaction ) ; jndiManagement . popJndiContext ( ) ; }", "nl": "Logic to execute after invoking a management method on the mbean"}}
{"translation": {"code": "protected void afterSetCmpField ( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"afterSetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } try { sleeContainer . getTransactionManager ( ) . suspend ( ) ; } catch ( Throwable e ) { throw new ManagementException ( e . getMessage ( ) , e ) ; } }", "nl": "Logic to execute after invoking a cmp setter method on the mbean"}}
{"translation": {"code": "protected boolean beforeGetCmpField ( ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"beforeGetCmpField() on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } return beforeNonSetCmpField ( ) ; }", "nl": "Logic to execute before invoking a cmp getter method on the mbean"}}
{"translation": {"code": "protected void afterGetCmpField ( boolean activatedTransaction ) throws ManagementException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"afterGetCmpField( activatedTransaction = \" + activatedTransaction + \" ) on profile with name \" + profileName + \" of table \" + profileTable . getProfileTableName ( ) ) ; } afterNonSetCmpField ( activatedTransaction ) ; }", "nl": "Logic to execute after invoking a cmp getter method on the mbean"}}
{"translation": {"code": "private void writeMode ( ) throws SLEEException , ManagementException { if ( ! isProfileWriteable ( ) ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Changing state to read-write, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; } // get object & make it writable ProfileObjectImpl profileObject = profileTable . getProfile ( profileName ) ; profileObject . getProfileEntity ( ) . setReadOnly ( false ) ; // change state state = State . write ; } else { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Already in write state, for profile mbean with name \" + profileName + \", from table with name \" + this . profileTable . getProfileTableName ( ) ) ; } } }", "nl": "Moves to the write mode using specified object . The current java transaction will be suspended ."}}