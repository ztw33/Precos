{"translation": {"code": "public int cost ( Vertex < T > dest ) { if ( dest == this ) return 0 ; Edge < T > e = findEdge ( dest ) ; int cost = Integer . MAX_VALUE ; if ( e != null ) cost = e . getCost ( ) ; return cost ; }", "nl": "What is the cost from this vertext to the dest vertex ."}}
{"translation": {"code": "public Edge < T > [ ] findCycles ( ) { ArrayList < Edge < T >> cycleEdges = new ArrayList < Edge < T > > ( ) ; // Mark all verticies as white for ( int n = 0 ; n < verticies . size ( ) ; n ++ ) { Vertex < T > v = getVertex ( n ) ; v . setMarkState ( VISIT_COLOR_WHITE ) ; } for ( int n = 0 ; n < verticies . size ( ) ; n ++ ) { Vertex < T > v = getVertex ( n ) ; visit ( v , cycleEdges ) ; } Edge < T > [ ] cycles = new Edge [ cycleEdges . size ( ) ] ; cycleEdges . toArray ( cycles ) ; return cycles ; }", "nl": "Search the graph for cycles . In order to detect cycles we use a modified depth first search called a colored DFS . All nodes are initially marked white . When a node is encountered it is marked grey and when its descendants are completely visited it is marked black . If a grey node is ever encountered then there is a cycle ."}}
{"translation": {"code": "public boolean removeVertex ( Vertex < T > v ) { if ( ! verticies . containsValue ( v ) ) return false ; verticies . remove ( v . getName ( ) ) ; if ( v == rootVertex ) rootVertex = null ; // Remove the edges associated with v for ( int n = 0 ; n < v . getOutgoingEdgeCount ( ) ; n ++ ) { Edge < T > e = v . getOutgoingEdge ( n ) ; v . remove ( e ) ; Vertex < T > to = e . getTo ( ) ; to . remove ( e ) ; edges . remove ( e ) ; } for ( int n = 0 ; n < v . getIncomingEdgeCount ( ) ; n ++ ) { Edge < T > e = v . getIncomingEdge ( n ) ; v . remove ( e ) ; Vertex < T > predecessor = e . getFrom ( ) ; predecessor . remove ( e ) ; } return true ; }", "nl": "Remove a vertex from the graph"}}
{"translation": {"code": "public void addIncomingEdge ( Vertex < T > from , int cost ) { Edge < T > out = new Edge < T > ( this , from , cost ) ; incomingEdges . add ( out ) ; }", "nl": "Add an incoming edge starting at from"}}
{"translation": {"code": "private Map < K , V > createImplementation ( ) { if ( delegate instanceof HashMap == false ) return new HashMap < K , V > ( delegate ) ; return delegate ; }", "nl": "Create the map implementation"}}
{"translation": {"code": "private Set < T > createImplementation ( ) { if ( delegate instanceof HashSet == false ) return new HashSet < T > ( delegate ) ; return delegate ; }", "nl": "Create the set implementation"}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" , \"cast\" } ) public T get ( Type type ) { if ( type == null ) throw new IllegalArgumentException ( \"Null type\" ) ; if ( type instanceof ParameterizedType ) return getParameterizedType ( ( ParameterizedType ) type ) ; else if ( type instanceof Class ) return getClass ( ( Class < ? > ) type ) ; else if ( type instanceof TypeVariable ) // TODO Figure out why we need this cast with the Sun compiler?  return ( T ) getTypeVariable ( ( TypeVariable ) type ) ; else if ( type instanceof GenericArrayType ) return getGenericArrayType ( ( GenericArrayType ) type ) ; else if ( type instanceof WildcardType ) return getWildcardType ( ( WildcardType ) type ) ; else throw new UnsupportedOperationException ( \"Unknown type: \" + type + \" class=\" + type . getClass ( ) ) ; }", "nl": "Get the information for a type"}}
{"translation": {"code": "public static < T > T deref ( final Object obj , Class < T > expected ) { Object result = deref ( obj ) ; if ( result == null ) return null ; return expected . cast ( result ) ; }", "nl": "Dereference an object"}}
{"translation": {"code": "public OutputStream getOutputStream ( ) throws IOException { connect ( ) ; SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { // Check for write access FilePermission p = new FilePermission ( file . getPath ( ) , \"write\" ) ; sm . checkPermission ( p ) ; } return new FileOutputStream ( file ) ; }", "nl": "We should probably disallow this?"}}
{"translation": {"code": "boolean casNext ( Node < K , V > cmp , Node < K , V > val ) { return nextUpdater . compareAndSet ( this , cmp , val ) ; }", "nl": "compareAndSet next field"}}
{"translation": {"code": "final boolean casRight ( Index < K , V > cmp , Index < K , V > val ) { return rightUpdater . compareAndSet ( this , cmp , val ) ; }", "nl": "compareAndSet right field"}}
{"translation": {"code": "SnapshotEntry < K , V > createSnapshot ( ) { V v = getValidValue ( ) ; if ( v == null ) return null ; return new SnapshotEntry ( key , v ) ; }", "nl": "Create and return a new SnapshotEntry holding current mapping if this node holds a valid value else null"}}
{"translation": {"code": "V getValidValue ( ) { Object v = value ; if ( v == this || v == BASE_HEADER ) return null ; return ( V ) v ; }", "nl": "Return value if this node contains a valid key - value pair else null ."}}
{"translation": {"code": "void helpDelete ( Node < K , V > b , Node < K , V > f ) { /*\n             * Rechecking links and then doing only one of the\n             * help-out stages per call tends to minimize CAS\n             * interference among helping threads.\n             */ if ( f == next && this == b . next ) { if ( f == null || f . value != f ) // not already marked appendMarker ( f ) ; else b . casNext ( this , f . next ) ; } }", "nl": "Helps out a deletion by appending marker or unlinking from predecessor . This is called during traversals when value field seen to be null ."}}
{"translation": {"code": "private Logger createLog ( ) { Class < ? > clazz = getClass ( ) ; Logger logger = loggers . get ( clazz ) ; if ( logger == null ) { logger = Logger . getLogger ( clazz ) ; loggers . put ( clazz , logger ) ; } return logger ; }", "nl": "Create logger ."}}
{"translation": {"code": "protected Object replaceObject ( Object obj ) throws IOException { if ( ( obj instanceof Remote ) && ! ( obj instanceof RemoteStub ) ) { Remote remote = ( Remote ) obj ; try { obj = RemoteObject . toStub ( remote ) ; } catch ( IOException ignore ) { // Let the Serialization layer try with the orignal obj } } return obj ; }", "nl": "Override replaceObject to check for Remote objects that are not RemoteStubs ."}}
{"translation": {"code": "protected Class < ? > resolveClass ( ObjectStreamClass v ) throws IOException , ClassNotFoundException { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; String className = v . getName ( ) ; try { // JDK 6, by default, only supports array types (ex. [[B)  using Class.forName() return Class . forName ( className , false , loader ) ; } catch ( ClassNotFoundException cnfe ) { Class cl = primClasses . get ( className ) ; if ( cl == null ) throw cnfe ; else return cl ; } }", "nl": "Use the thread context class loader to resolve the class"}}