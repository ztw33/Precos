{"translation": {"code": "public static Object copy ( final Serializable obj ) throws IOException , ClassNotFoundException { ObjectOutputStream out = null ; ObjectInputStream in = null ; Object copy = null ; try { // write the object ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; out = new ObjectOutputStream ( baos ) ; out . writeObject ( obj ) ; out . flush ( ) ; // read in the copy byte data [ ] = baos . toByteArray ( ) ; ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; in = new ObjectInputStream ( bais ) ; copy = in . readObject ( ) ; } finally { Streams . close ( out ) ; Streams . close ( in ) ; } return copy ; }", "nl": "Copy an serializable object deeply ."}}
{"translation": {"code": "public long stop ( ) { long lap = 0 ; if ( running ) { count ++ ; stop = System . currentTimeMillis ( ) ; lap = stop - start ; total += lap ; running = false ; } return lap ; }", "nl": "Stop the watch ."}}
{"translation": {"code": "public static StopWatch makeSynchronized ( final StopWatch watch ) { return new Wrapper ( watch ) { /** The serialVersionUID */ private static final long serialVersionUID = - 6284244000894114817L ; public synchronized void start ( final boolean reset ) { this . watch . start ( reset ) ; } public synchronized void start ( ) { this . watch . start ( ) ; } public synchronized long stop ( ) { return this . watch . stop ( ) ; } public synchronized void reset ( ) { this . watch . reset ( ) ; } public synchronized long getLapTime ( ) { return this . watch . getLapTime ( ) ; } public synchronized long getAverageLapTime ( ) { return this . watch . getAverageLapTime ( ) ; } public synchronized int getLapCount ( ) { return this . watch . getLapCount ( ) ; } public synchronized long getTime ( ) { return this . watch . getTime ( ) ; } public synchronized boolean isRunning ( ) { return this . watch . isRunning ( ) ; } public synchronized String toString ( ) { return this . watch . toString ( ) ; } } ; }", "nl": "Return a synchronized stop watch ."}}
{"translation": {"code": "public int compareTo ( final Object obj ) throws ClassCastException { HashCode hashCode = ( HashCode ) obj ; return compareTo ( hashCode . value ) ; }", "nl": "Compares this object with the specified object for order ."}}
{"translation": {"code": "public static int generate ( final byte [ ] bytes ) { int hashcode = 0 ; for ( int i = 0 ; i < bytes . length ; i ++ ) { hashcode <<= 1 ; hashcode ^= bytes [ i ] ; } return hashcode ; }", "nl": "Generate a hash code for a byte array ."}}
{"translation": {"code": "public static int generate ( final Object array [ ] , final boolean deep ) { int hashcode = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( deep && ( array [ i ] instanceof Object [ ] ) ) { hashcode ^= generate ( ( Object [ ] ) array [ i ] , true ) ; } else { hashcode ^= array [ i ] . hashCode ( ) ; } } return hashcode ; }", "nl": "Generate a hash code for an object array ."}}
{"translation": {"code": "public void create ( ) { m_map = createMap ( ) ; m_list = createList ( ) ; m_list . m_maxCapacity = m_maxCapacity ; m_list . m_minCapacity = m_minCapacity ; m_list . m_capacity = m_maxCapacity ; }", "nl": "Initializes the cache creating all required objects and initializing their values ."}}
{"translation": {"code": "protected void setFieldValue ( String value ) { try { // filter property value value = filterValue ( value ) ; // coerce value to field type Class < ? > type = fieldInstance . getField ( ) . getType ( ) ; PropertyEditor editor = PropertyEditors . findEditor ( type ) ; editor . setAsText ( value ) ; Object coerced = editor . getValue ( ) ; // bind value to field fieldInstance . set ( coerced ) ; } catch ( IllegalAccessException e ) { throw new PropertyException ( e ) ; } }", "nl": "Coerce and set specified value to field ."}}
{"translation": {"code": "protected String nextToken ( ) throws IOException { String token = \"\" ; int ch , nextch ; if ( ! tokenStack . empty ( ) ) { return ( String ) tokenStack . pop ( ) ; } // Skip over leading whitespace and comments while ( true ) { // skip leading whitespace ch = catfile . read ( ) ; while ( ch <= ' ' ) { // all ctrls are whitespace ch = catfile . read ( ) ; if ( ch < 0 ) { return null ; } } // now 'ch' is the current char from the file nextch = catfile . read ( ) ; if ( nextch < 0 ) { return null ; } if ( ch == ' ' && nextch == ' ' ) { // we've found a comment, skip it... ch = ' ' ; nextch = nextChar ( ) ; while ( ch != ' ' || nextch != ' ' ) { ch = nextch ; nextch = nextChar ( ) ; } // Ok, we've found the end of the comment, // loop back to the top and start again... } else { stack [ ++ top ] = nextch ; stack [ ++ top ] = ch ; break ; } } ch = nextChar ( ) ; if ( ch == ' ' || ch == ' ' ) { int quote = ch ; while ( ( ch = nextChar ( ) ) != quote ) { char [ ] chararr = new char [ 1 ] ; chararr [ 0 ] = ( char ) ch ; String s = new String ( chararr ) ; token = token . concat ( s ) ; } return token ; } else { // return the next whitespace or comment delimited // string while ( ch > ' ' ) { nextch = nextChar ( ) ; if ( ch == ' ' && nextch == ' ' ) { stack [ ++ top ] = ch ; stack [ ++ top ] = nextch ; return token ; } else { char [ ] chararr = new char [ 1 ] ; chararr [ 0 ] = ( char ) ch ; String s = new String ( chararr ) ; token = token . concat ( s ) ; ch = nextch ; } } return token ; } }", "nl": "Return the next token in the catalog file ."}}
{"translation": {"code": "public static void initialize ( ) { PrivilegedAction action = new PrivilegedAction ( ) { public Object run ( ) { String defaultFormat = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.format\" , \"MMM d, yyyy\" ) ; String defaultLocale = System . getProperty ( \"org.jboss.util.propertyeditor.DateEditor.locale\" ) ; DateFormat defaultDateFormat ; if ( defaultLocale == null || defaultLocale . length ( ) == 0 ) { defaultDateFormat = new SimpleDateFormat ( defaultFormat ) ; } else { defaultDateFormat = new SimpleDateFormat ( defaultFormat , Strings . parseLocaleString ( defaultLocale ) ) ; } formats = new DateFormat [ ] { defaultDateFormat , // Tue Jan 04 00:00:00 PST 2005 new SimpleDateFormat ( \"EEE MMM d HH:mm:ss z yyyy\" ) , // Wed, 4 Jul 2001 12:08:56 -0700 new SimpleDateFormat ( \"EEE, d MMM yyyy HH:mm:ss Z\" ) } ; return null ; } } ; AccessController . doPrivileged ( action ) ; }", "nl": "Setup the parsing formats . Offered as a separate static method to allow testing of locale changes since SimpleDateFormat will use the default locale upon construction . Should not be normally used!"}}
{"translation": {"code": "public static String normalize ( String s , boolean canonical ) { StringBuffer str = new StringBuffer ( ) ; int len = ( s != null ) ? s . length ( ) : 0 ; for ( int i = 0 ; i < len ; i ++ ) { char ch = s . charAt ( i ) ; switch ( ch ) { case ' ' : { str . append ( \"&lt;\" ) ; break ; } case ' ' : { str . append ( \"&gt;\" ) ; break ; } case ' ' : { str . append ( \"&amp;\" ) ; break ; } case ' ' : { str . append ( \"&quot;\" ) ; break ; } case ' ' : { str . append ( \"&apos;\" ) ; break ; } case ' ' : case ' ' : { if ( canonical ) { str . append ( \"&#\" ) ; str . append ( Integer . toString ( ch ) ) ; str . append ( ' ' ) ; break ; } // else, default append char } default : { str . append ( ch ) ; } } } return ( str . toString ( ) ) ; }", "nl": "Normalizes the given string ."}}
{"translation": {"code": "public static Element parse ( String xmlString ) throws IOException { try { return parse ( new ByteArrayInputStream ( xmlString . getBytes ( \"UTF-8\" ) ) ) ; } catch ( IOException e ) { log . error ( \"Cannot parse: \" + xmlString ) ; throw e ; } }", "nl": "Parse the given XML string and return the root Element"}}
{"translation": {"code": "public static Element parse ( InputStream xmlStream ) throws IOException { try { Document doc = getDocumentBuilder ( ) . parse ( xmlStream ) ; Element root = doc . getDocumentElement ( ) ; return root ; } catch ( SAXException e ) { throw new IOException ( e . toString ( ) ) ; } }", "nl": "Parse the given XML stream and return the root Element"}}
{"translation": {"code": "public static Element parse ( InputSource source ) throws IOException { try { Document doc = getDocumentBuilder ( ) . parse ( source ) ; Element root = doc . getDocumentElement ( ) ; return root ; } catch ( SAXException e ) { throw new IOException ( e . toString ( ) ) ; } }", "nl": "Parse the given input source and return the root Element"}}
{"translation": {"code": "public static Element createElement ( String localPart ) { Document doc = getOwnerDocument ( ) ; log . trace ( \"createElement {}\" + localPart ) ; return doc . createElement ( localPart ) ; }", "nl": "Create an Element for a given name"}}
{"translation": {"code": "public static QName resolveQName ( Element el , String qualifiedName ) { QName qname ; String prefix = \"\" ; String namespaceURI = \"\" ; String localPart = qualifiedName ; int colIndex = qualifiedName . indexOf ( \":\" ) ; if ( colIndex > 0 ) { prefix = qualifiedName . substring ( 0 , colIndex ) ; localPart = qualifiedName . substring ( colIndex + 1 ) ; if ( \"xmlns\" . equals ( prefix ) ) { namespaceURI = \"URI:XML_PREDEFINED_NAMESPACE\" ; } else { Element nsElement = el ; while ( namespaceURI . equals ( \"\" ) && nsElement != null ) { namespaceURI = nsElement . getAttribute ( \"xmlns:\" + prefix ) ; if ( namespaceURI . equals ( \"\" ) ) nsElement = getParentElement ( nsElement ) ; } } if ( namespaceURI . equals ( \"\" ) ) throw new IllegalArgumentException ( \"Cannot find namespace uri for: \" + qualifiedName ) ; } qname = new QName ( namespaceURI , localPart , prefix ) ; return qname ; }", "nl": "Transform the giveen qualified name into a QName"}}
{"translation": {"code": "public static void copyAttributes ( Element destElement , Element srcElement ) { NamedNodeMap attribs = srcElement . getAttributes ( ) ; for ( int i = 0 ; i < attribs . getLength ( ) ; i ++ ) { Attr attr = ( Attr ) attribs . item ( i ) ; String uri = attr . getNamespaceURI ( ) ; String qname = attr . getName ( ) ; String value = attr . getNodeValue ( ) ; // Prevent DOMException: NAMESPACE_ERR: An attempt is made to create or  // change an object in a way which is incorrect with regard to namespaces. if ( uri == null && qname . startsWith ( \"xmlns\" ) ) { log . trace ( \"Ignore attribute: [uri=\" + uri + \",qname=\" + qname + \",value=\" + value + \"]\" ) ; } else { destElement . setAttributeNS ( uri , qname , value ) ; } } }", "nl": "Copy attributes between elements"}}
{"translation": {"code": "public static boolean hasChildElements ( Node node ) { NodeList nlist = node . getChildNodes ( ) ; for ( int i = 0 ; i < nlist . getLength ( ) ; i ++ ) { Node child = nlist . item ( i ) ; if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) return true ; } return false ; }", "nl": "True if the node has child elements"}}
{"translation": {"code": "public static Iterator getChildElements ( Node node ) { ArrayList list = new ArrayList ( ) ; NodeList nlist = node . getChildNodes ( ) ; for ( int i = 0 ; i < nlist . getLength ( ) ; i ++ ) { Node child = nlist . item ( i ) ; if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) list . add ( child ) ; } return list . iterator ( ) ; }", "nl": "Gets child elements"}}
{"translation": {"code": "public static String getTextContent ( Node node , boolean replaceProps ) { boolean hasTextContent = false ; StringBuffer buffer = new StringBuffer ( ) ; NodeList nlist = node . getChildNodes ( ) ; for ( int i = 0 ; i < nlist . getLength ( ) ; i ++ ) { Node child = nlist . item ( i ) ; if ( child . getNodeType ( ) == Node . TEXT_NODE ) { buffer . append ( child . getNodeValue ( ) ) ; hasTextContent = true ; } } String text = ( hasTextContent ? buffer . toString ( ) : null ) ; if ( text != null && replaceProps ) text = StringPropertyReplacer . replaceProperties ( text ) ; return text ; }", "nl": "Get the concatenated text content or null ."}}
{"translation": {"code": "public static Iterator getChildElements ( Node node , String nodeName ) { return getChildElementsIntern ( node , new QName ( nodeName ) ) ; }", "nl": "Gets the child elements for a given local name without namespace"}}
{"translation": {"code": "public static Element getParentElement ( Node node ) { Node parent = node . getParentNode ( ) ; return ( parent instanceof Element ? ( Element ) parent : null ) ; }", "nl": "Gets parent element or null if there is none"}}
{"translation": {"code": "public void addWaiting ( Object holder , Resource resource ) { synchronized ( waiting ) { waiting . put ( holder , resource ) ; } }", "nl": "Add a transaction waiting for a lock"}}
{"translation": {"code": "public void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { DocumentBuilderFactory factory = null ; DocumentBuilder builder = null ; factory = DocumentBuilderFactory . newInstance ( ) ; factory . setNamespaceAware ( false ) ; factory . setValidating ( false ) ; try { builder = factory . newDocumentBuilder ( ) ; } catch ( ParserConfigurationException pce ) { throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } Document doc = null ; try { doc = builder . parse ( is ) ; } catch ( SAXException se ) { throw new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; } Element root = doc . getDocumentElement ( ) ; String namespaceURI = Namespaces . getNamespaceURI ( root ) ; String localName = Namespaces . getLocalName ( root ) ; String domParserClass = getCatalogParser ( namespaceURI , localName ) ; if ( domParserClass == null ) { if ( namespaceURI == null ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + localName ) ; } else { catalog . getCatalogManager ( ) . debug . message ( 1 , \"No Catalog parser for \" + \"{\" + namespaceURI + \"}\" + localName ) ; } return ; } DOMCatalogParser domParser = null ; try { domParser = ( DOMCatalogParser ) Class . forName ( domParserClass ) . newInstance ( ) ; } catch ( ClassNotFoundException cnfe ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot load XML Catalog Parser class\" , domParserClass ) ; throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( InstantiationException ie ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot instantiate XML Catalog Parser class\" , domParserClass ) ; throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( IllegalAccessException iae ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot access XML Catalog Parser class\" , domParserClass ) ; throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( ClassCastException cce ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"Cannot cast XML Catalog Parser class\" , domParserClass ) ; throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } Node node = root . getFirstChild ( ) ; while ( node != null ) { domParser . parseCatalogEntry ( catalog , node ) ; node = node . getNextSibling ( ) ; } }", "nl": "Read a catalog from an input stream ."}}
{"translation": {"code": "public void start ( final boolean reset ) { if ( ! running ) { if ( reset ) reset ( ) ; start = System . currentTimeMillis ( ) ; running = true ; } }", "nl": "Start the watch ."}}
{"translation": {"code": "private static String stringReplace ( String str , String oldStr , String newStr ) { String result = \"\" ; int pos = str . indexOf ( oldStr ) ; //    System.out.println(str + \": \" + oldStr + \" => \" + newStr); while ( pos >= 0 ) { //      System.out.println(str + \" (\" + pos + \")\"); result += str . substring ( 0 , pos ) ; result += newStr ; str = str . substring ( pos + 1 ) ; pos = str . indexOf ( oldStr ) ; } return result + str ; }", "nl": "Replace one string with another ."}}
{"translation": {"code": "public static String decodeURN ( String urn ) { String publicId = \"\" ; if ( urn . startsWith ( \"urn:publicid:\" ) ) { publicId = urn . substring ( 13 ) ; } else { return urn ; } publicId = PublicId . stringReplace ( publicId , \"%2F\" , \"/\" ) ; publicId = PublicId . stringReplace ( publicId , \":\" , \"//\" ) ; publicId = PublicId . stringReplace ( publicId , \"%3A\" , \":\" ) ; publicId = PublicId . stringReplace ( publicId , \";\" , \"::\" ) ; publicId = PublicId . stringReplace ( publicId , \"+\" , \" \" ) ; publicId = PublicId . stringReplace ( publicId , \"%2B\" , \"+\" ) ; publicId = PublicId . stringReplace ( publicId , \"%23\" , \"#\" ) ; publicId = PublicId . stringReplace ( publicId , \"%3F\" , \"?\" ) ; publicId = PublicId . stringReplace ( publicId , \"%27\" , \"'\" ) ; publicId = PublicId . stringReplace ( publicId , \"%3B\" , \";\" ) ; publicId = PublicId . stringReplace ( publicId , \"%25\" , \"%\" ) ; return publicId ; }", "nl": "Decode a publicid URN into a public identifier ."}}
{"translation": {"code": "public static String encodeURN ( String publicId ) { String urn = PublicId . normalize ( publicId ) ; urn = PublicId . stringReplace ( urn , \"%\" , \"%25\" ) ; urn = PublicId . stringReplace ( urn , \";\" , \"%3B\" ) ; urn = PublicId . stringReplace ( urn , \"'\" , \"%27\" ) ; urn = PublicId . stringReplace ( urn , \"?\" , \"%3F\" ) ; urn = PublicId . stringReplace ( urn , \"#\" , \"%23\" ) ; urn = PublicId . stringReplace ( urn , \"+\" , \"%2B\" ) ; urn = PublicId . stringReplace ( urn , \" \" , \"+\" ) ; urn = PublicId . stringReplace ( urn , \"::\" , \";\" ) ; urn = PublicId . stringReplace ( urn , \":\" , \"%3A\" ) ; urn = PublicId . stringReplace ( urn , \"//\" , \":\" ) ; urn = PublicId . stringReplace ( urn , \"/\" , \"%2F\" ) ; return \"urn:publicid:\" + urn ; }", "nl": "Encode a public identifier as a publicid URN ."}}
{"translation": {"code": "protected String toStringImplementation ( ) { JBossStringBuilder buffer = new JBossStringBuilder ( ) ; buffer . append ( getClassShortName ( ) ) . append ( ' ' ) ; buffer . append ( Integer . toHexString ( System . identityHashCode ( this ) ) ) ; buffer . append ( ' ' ) ; toString ( buffer ) ; buffer . append ( ' ' ) ; return buffer . toString ( ) ; }", "nl": "Implementation of String"}}
{"translation": {"code": "public static Iterator names ( ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) sm . checkPropertiesAccess ( ) ; return props . names ( ) ; }", "nl": "Return an iterator over all contained property names ."}}
{"translation": {"code": "public static PropertyGroup getPropertyGroup ( final String basename ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) sm . checkPropertiesAccess ( ) ; return props . getPropertyGroup ( basename ) ; }", "nl": "Get a property group for the given property base ."}}
{"translation": {"code": "public static Constructor getCompatibleConstructor ( final Class type , final Class valueType ) { // first try and find a constructor with the exact argument type try { return type . getConstructor ( new Class [ ] { valueType } ) ; } catch ( Exception ignore ) { // if the above failed, then try and find a constructor with // an compatible argument type // get an array of compatible types Class [ ] types = type . getClasses ( ) ; for ( int i = 0 ; i < types . length ; i ++ ) { try { return type . getConstructor ( new Class [ ] { types [ i ] } ) ; } catch ( Exception ignore2 ) { } } } // if we get this far, then we can't find a compatible constructor return null ; }", "nl": "Get a compatible constructor for the given value type"}}
{"translation": {"code": "private static void jar ( File src , String prefix , JarInfo info ) throws IOException { JarOutputStream jout = info . out ; if ( src . isDirectory ( ) ) { // create / init the zip entry prefix = prefix + src . getName ( ) + \"/\" ; ZipEntry entry = new ZipEntry ( prefix ) ; entry . setTime ( src . lastModified ( ) ) ; entry . setMethod ( JarOutputStream . STORED ) ; entry . setSize ( 0L ) ; entry . setCrc ( 0L ) ; jout . putNextEntry ( entry ) ; jout . closeEntry ( ) ; // process the sub-directories File [ ] files = src . listFiles ( info . filter ) ; for ( int i = 0 ; i < files . length ; i ++ ) { jar ( files [ i ] , prefix , info ) ; } } else if ( src . isFile ( ) ) { // get the required info objects byte [ ] buffer = info . buffer ; // create / init the zip entry ZipEntry entry = new ZipEntry ( prefix + src . getName ( ) ) ; entry . setTime ( src . lastModified ( ) ) ; jout . putNextEntry ( entry ) ; // dump the file FileInputStream in = new FileInputStream ( src ) ; int len ; while ( ( len = in . read ( buffer , 0 , buffer . length ) ) != - 1 ) { jout . write ( buffer , 0 , len ) ; } in . close ( ) ; jout . closeEntry ( ) ; } }", "nl": "This recursive method writes all matching files and directories to the jar output stream ."}}
{"translation": {"code": "private void init ( ) { unboundListeners = Collections . synchronizedList ( new ArrayList ( ) ) ; boundListeners = Collections . synchronizedMap ( new HashMap ( ) ) ; jndiMap = new HashMap ( ) ; PrivilegedAction action = new PrivilegedAction ( ) { public Object run ( ) { Object value = System . getProperty ( Context . PROVIDER_URL ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . PROVIDER_URL , value ) ; value = System . getProperty ( Context . INITIAL_CONTEXT_FACTORY ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . INITIAL_CONTEXT_FACTORY , value ) ; value = System . getProperty ( Context . OBJECT_FACTORIES ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . OBJECT_FACTORIES , value ) ; value = System . getProperty ( Context . URL_PKG_PREFIXES ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . URL_PKG_PREFIXES , value ) ; value = System . getProperty ( Context . STATE_FACTORIES ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . STATE_FACTORIES , value ) ; value = System . getProperty ( Context . DNS_URL ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( Context . DNS_URL , value ) ; value = System . getProperty ( LdapContext . CONTROL_FACTORIES ) ; if ( value == null ) value = NULL_VALUE ; jndiMap . put ( LdapContext . CONTROL_FACTORIES , value ) ; return null ; } } ; AccessController . doPrivileged ( action ) ; }", "nl": "Initialized listener lists and the JNDI properties cache map"}}
{"translation": {"code": "private void updateJndiCache ( String name , String value ) { if ( name == null ) return ; boolean isJndiProperty = name . equals ( Context . PROVIDER_URL ) || name . equals ( Context . INITIAL_CONTEXT_FACTORY ) || name . equals ( Context . OBJECT_FACTORIES ) || name . equals ( Context . URL_PKG_PREFIXES ) || name . equals ( Context . STATE_FACTORIES ) || name . equals ( Context . DNS_URL ) || name . equals ( LdapContext . CONTROL_FACTORIES ) ; if ( isJndiProperty == true ) jndiMap . put ( name , value ) ; }", "nl": "Called by setProperty to update the jndiMap cache values ."}}
{"translation": {"code": "public Set keySet ( final boolean includeDefaults ) { if ( includeDefaults ) { Set set = new HashSet ( ) ; set . addAll ( defaults . keySet ( ) ) ; set . addAll ( super . keySet ( ) ) ; return Collections . synchronizedSet ( set ) ; } return super . keySet ( ) ; }", "nl": "Returns a set of keys for all entries in this group and optionally all of the keys in the defaults map ."}}
{"translation": {"code": "public Set entrySet ( final boolean includeDefaults ) { if ( includeDefaults ) { Set set = new HashSet ( ) ; set . addAll ( defaults . entrySet ( ) ) ; set . addAll ( super . entrySet ( ) ) ; return Collections . synchronizedSet ( set ) ; } return super . entrySet ( ) ; }", "nl": "Returns a set of entrys for all entries in this group and optionally all of the entrys in the defaults map ."}}
{"translation": {"code": "public boolean removePropertyListener ( PropertyListener listener ) { if ( listener == null ) throw new NullArgumentException ( \"listener\" ) ; boolean removed = false ; if ( listener instanceof BoundPropertyListener ) { removed = removePropertyListener ( ( BoundPropertyListener ) listener ) ; } else { removed = unboundListeners . remove ( listener ) ; } return removed ; }", "nl": "Remove a property listener ."}}
{"translation": {"code": "private void firePropertyAdded ( List list , PropertyEvent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyAdded ( event ) ; } }", "nl": "Fire a property added event to the given list of listeners ."}}
{"translation": {"code": "public void readCatalog ( Catalog catalog , String fileUrl ) throws MalformedURLException , IOException , CatalogException { URL url = new URL ( fileUrl ) ; URLConnection urlCon = url . openConnection ( ) ; readCatalog ( catalog , urlCon . getInputStream ( ) ) ; }", "nl": "Read the catalog behind the specified URL ."}}
{"translation": {"code": "private void firePropertyRemoved ( List list , PropertyEvent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyRemoved ( event ) ; } }", "nl": "Fire a property removed event to the given list of listeners ."}}
{"translation": {"code": "protected void firePropertyChanged ( PropertyEvent event ) { // fire all bound listeners (if any) first if ( boundListeners != null ) { List list = ( List ) boundListeners . get ( event . getPropertyName ( ) ) ; if ( list != null ) { firePropertyChanged ( list , event ) ; } } // next fire all unbound listeners firePropertyChanged ( unboundListeners , event ) ; }", "nl": "Fire a property changed event to all listeners ."}}
{"translation": {"code": "protected String makePrefixedPropertyName ( String base , String prefix ) { String name = base ; if ( prefix != null ) { StringBuffer buff = new StringBuffer ( base ) ; if ( prefix != null ) { buff . insert ( 0 , PROPERTY_NAME_SEPARATOR ) ; buff . insert ( 0 , prefix ) ; } return buff . toString ( ) ; } return name ; }", "nl": "Make a optionaly prefixed property name ."}}
{"translation": {"code": "public void load ( PropertyReader reader ) throws PropertyException , IOException { if ( reader == null ) throw new NullArgumentException ( \"reader\" ) ; load ( reader . readProperties ( ) ) ; }", "nl": "Load properties from a PropertyReader ."}}
{"translation": {"code": "public void load ( String className ) throws PropertyException , IOException { if ( className == null ) throw new NullArgumentException ( \"className\" ) ; PropertyReader reader = null ; try { Class type = Class . forName ( className ) ; reader = ( PropertyReader ) type . newInstance ( ) ; } catch ( Exception e ) { throw new PropertyException ( e ) ; } // load the properties from the source load ( reader ) ; }", "nl": "Load properties from a PropertyReader specifed by the given class name ."}}
{"translation": {"code": "public PropertyGroup getPropertyGroup ( String basename , int index ) { String name = makeIndexPropertyName ( basename , index ) ; return getPropertyGroup ( name ) ; }", "nl": "Get a property group for the given property base at the given index ."}}
{"translation": {"code": "public boolean isEntityResolved ( ) { Boolean value = entityResolved . get ( ) ; return value != null ? value . booleanValue ( ) : false ; }", "nl": "Returns the boolean value to inform id DTD was found in the XML file or not"}}
{"translation": {"code": "protected InputSource resolveSystemID ( String systemId , boolean trace ) { if ( systemId == null ) return null ; if ( trace ) log . trace ( \"resolveSystemID, systemId=\" + systemId ) ; InputSource inputSource = null ; // Try to resolve the systemId as an entity key String filename = null ; if ( localEntities != null ) filename = ( String ) localEntities . get ( systemId ) ; if ( filename == null ) filename = ( String ) entities . get ( systemId ) ; if ( filename != null ) { if ( trace ) log . trace ( \"Found entity systemId=\" + systemId + \" fileName=\" + filename ) ; InputStream ins = loadClasspathResource ( filename , trace ) ; if ( ins != null ) { inputSource = new InputSource ( ins ) ; inputSource . setSystemId ( systemId ) ; } else { log . warn ( \"Cannot load systemId from resource: \" + filename ) ; } } return inputSource ; }", "nl": "Attempt to use the systemId as a URL from which the schema can be read . This checks to see whether the systemId is a key to an entry in the class entity map ."}}
{"translation": {"code": "protected InputSource resolveSystemIDasURL ( String systemId , boolean trace ) { if ( systemId == null ) return null ; if ( trace ) log . trace ( \"resolveSystemIDasURL, systemId=\" + systemId ) ; InputSource inputSource = null ; // Try to use the systemId as a URL to the schema try { if ( trace ) log . trace ( \"Trying to resolve systemId as a URL\" ) ; // Replace any system property refs if isReplaceSystemProperties is true if ( isReplaceSystemProperties ( ) ) systemId = StringPropertyReplacer . replaceProperties ( systemId ) ; URL url = new URL ( systemId ) ; if ( warnOnNonFileURLs && url . getProtocol ( ) . equalsIgnoreCase ( \"file\" ) == false && url . getProtocol ( ) . equalsIgnoreCase ( \"vfszip\" ) == false ) { log . warn ( \"Trying to resolve systemId as a non-file URL: \" + systemId ) ; } InputStream ins = url . openStream ( ) ; if ( ins != null ) { inputSource = new InputSource ( ins ) ; inputSource . setSystemId ( systemId ) ; } else { log . warn ( \"Cannot load systemId as URL: \" + systemId ) ; } if ( trace ) log . trace ( \"Resolved systemId as a URL\" ) ; } catch ( MalformedURLException ignored ) { if ( trace ) log . trace ( \"SystemId is not a url: \" + systemId , ignored ) ; } catch ( IOException e ) { if ( trace ) log . trace ( \"Failed to obtain URL.InputStream from systemId: \" + systemId , e ) ; } return inputSource ; }", "nl": "Attempt to use the systemId as a URL from which the schema can be read . This uses the systemID as a URL ."}}
{"translation": {"code": "protected InputSource resolveClasspathName ( String systemId , boolean trace ) { if ( systemId == null ) return null ; if ( trace ) log . trace ( \"resolveClasspathName, systemId=\" + systemId ) ; String filename = systemId ; // Parse the systemId as a uri to get the final path component try { URI url = new URI ( systemId ) ; String path = url . getPath ( ) ; if ( path == null ) path = url . getSchemeSpecificPart ( ) ; int slash = path . lastIndexOf ( ' ' ) ; if ( slash >= 0 ) filename = path . substring ( slash + 1 ) ; else filename = path ; if ( filename . length ( ) == 0 ) return null ; if ( trace ) log . trace ( \"Mapped systemId to filename: \" + filename ) ; } catch ( URISyntaxException e ) { if ( trace ) log . trace ( \"systemId: is not a URI, using systemId as resource\" , e ) ; } // Resolve the filename as a classpath resource InputStream is = loadClasspathResource ( filename , trace ) ; InputSource inputSource = null ; if ( is != null ) { inputSource = new InputSource ( is ) ; inputSource . setSystemId ( systemId ) ; } return inputSource ; }", "nl": "Resolve the systemId as a classpath resource . If not found the systemId is simply used as a classpath resource name ."}}
{"translation": {"code": "public void setAsText ( String text ) { Document d = getAsDocument ( text ) ; setValue ( d . getDocumentElement ( ) ) ; }", "nl": "Sets as an Element created by a String ."}}
{"translation": {"code": "public static String normalize ( String publicId ) { String normal = publicId . replace ( ' ' , ' ' ) ; normal = normal . replace ( ' ' , ' ' ) ; normal = normal . replace ( ' ' , ' ' ) ; normal = normal . trim ( ) ; int pos ; while ( ( pos = normal . indexOf ( \"  \" ) ) >= 0 ) { normal = normal . substring ( 0 , pos ) + normal . substring ( pos + 1 ) ; } return normal ; }", "nl": "Normalize a public identifier ."}}
{"translation": {"code": "private void firePropertyChanged ( List list , PropertyEvent event ) { if ( list == null ) return ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { PropertyListener listener = ( PropertyListener ) list . get ( i ) ; listener . propertyChanged ( event ) ; } }", "nl": "Fire a property changed event to the given list of listeners ."}}
{"translation": {"code": "public String getClassShortName ( ) { String longName = getClass ( ) . getName ( ) ; int dot = longName . lastIndexOf ( ' ' ) ; if ( dot != - 1 ) return longName . substring ( dot + 1 ) ; return longName ; }", "nl": "Get the class short name"}}
{"translation": {"code": "private static byte [ ] getHostAddress ( ) { return ( byte [ ] ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { try { return InetAddress . getLocalHost ( ) . getAddress ( ) ; } catch ( Exception e ) { return UNKNOWN_HOST ; } } } ) ; }", "nl": "Return the current host internet address ."}}
{"translation": {"code": "public static Throwable setSystemPropertyClassValue ( String property , String className ) { // Validation if ( property == null || property . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( \"Null or empty property\" ) ; if ( className == null || className . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( \"Null or empty class name\" ) ; // Is the class available? try { Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; } catch ( Throwable problem ) { return problem ; } // The class is there, set the property. System . setProperty ( property , className ) ; return null ; }", "nl": "Sets the system property to a class when the class is available ."}}
{"translation": {"code": "public static Context createSubcontext ( Context ctx , String name ) throws NamingException { Name n = ctx . getNameParser ( \"\" ) . parse ( name ) ; return createSubcontext ( ctx , n ) ; }", "nl": "Create a subcontext including any intermediate contexts ."}}
{"translation": {"code": "public static Object lookup ( String name , Class < ? > clazz ) throws Exception { InitialContext ctx = new InitialContext ( ) ; try { return lookup ( ctx , name , clazz ) ; } finally { ctx . close ( ) ; } }", "nl": "Lookup an object in the default initial context"}}
{"translation": {"code": "protected static void checkObject ( Context context , String name , Object object , Class clazz ) throws Exception { Class objectClass = object . getClass ( ) ; if ( clazz . isAssignableFrom ( objectClass ) == false ) { StringBuffer buffer = new StringBuffer ( 100 ) ; buffer . append ( \"Object at '\" ) . append ( name ) ; buffer . append ( \"' in context \" ) . append ( context . getEnvironment ( ) ) ; buffer . append ( \" is not an instance of \" ) ; appendClassInfo ( buffer , clazz ) ; buffer . append ( \" object class is \" ) ; appendClassInfo ( buffer , object . getClass ( ) ) ; throw new ClassCastException ( buffer . toString ( ) ) ; } }", "nl": "Checks an object implements the given class"}}
{"translation": {"code": "protected static void appendClassInfo ( StringBuffer buffer , Class clazz ) { buffer . append ( \"[class=\" ) . append ( clazz . getName ( ) ) ; buffer . append ( \" classloader=\" ) . append ( clazz . getClassLoader ( ) ) ; buffer . append ( \" interfaces={\" ) ; Class [ ] interfaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { if ( i > 0 ) buffer . append ( \", \" ) ; buffer . append ( \"interface=\" ) . append ( interfaces [ i ] . getName ( ) ) ; buffer . append ( \" classloader=\" ) . append ( interfaces [ i ] . getClassLoader ( ) ) ; } buffer . append ( \"}]\" ) ; }", "nl": "Append Class Info"}}
{"translation": {"code": "public Transition getTransition ( String name ) { Transition t = ( Transition ) allowedTransitions . get ( name ) ; return t ; }", "nl": "Lookup an allowed transition given its name ."}}
{"translation": {"code": "private synchronized void readProperties ( ) { try { propertyFileURI = CatalogManager . class . getResource ( \"/\" + propertyFile ) ; InputStream in = CatalogManager . class . getResourceAsStream ( \"/\" + propertyFile ) ; if ( in == null ) { if ( ! ignoreMissingProperties ) { System . err . println ( \"Cannot find \" + propertyFile ) ; // there's no reason to give this warning more than once ignoreMissingProperties = true ; } return ; } resources = new PropertyResourceBundle ( in ) ; } catch ( MissingResourceException mre ) { if ( ! ignoreMissingProperties ) { System . err . println ( \"Cannot read \" + propertyFile ) ; } } catch ( java . io . IOException e ) { if ( ! ignoreMissingProperties ) { System . err . println ( \"Failure trying to read \" + propertyFile ) ; } } // This is a bit of a hack. After we've successfully read the properties, // use them to set the default debug level, if the user hasn't already set // the default debug level. if ( verbosity == null ) { try { String verbStr = resources . getString ( \"verbosity\" ) ; int verb = Integer . parseInt ( verbStr . trim ( ) ) ; debug . setDebug ( verb ) ; verbosity = new Integer ( verb ) ; } catch ( Exception e ) { // nop } } }", "nl": "Load the properties from the propertyFile and build the resources from it ."}}
{"translation": {"code": "private int queryVerbosity ( ) { String verbStr = System . getProperty ( pVerbosity ) ; if ( verbStr == null ) { if ( resources == null ) readProperties ( ) ; if ( resources == null ) return defaultVerbosity ; try { verbStr = resources . getString ( \"verbosity\" ) ; } catch ( MissingResourceException e ) { return defaultVerbosity ; } } try { int verb = Integer . parseInt ( verbStr . trim ( ) ) ; return verb ; } catch ( Exception e ) { System . err . println ( \"Cannot parse verbosity: \\\"\" + verbStr + \"\\\"\" ) ; return defaultVerbosity ; } }", "nl": "Obtain the verbosity setting from the properties ."}}
{"translation": {"code": "private boolean queryRelativeCatalogs ( ) { if ( resources == null ) readProperties ( ) ; if ( resources == null ) return defaultRelativeCatalogs ; try { String allow = resources . getString ( \"relative-catalogs\" ) ; return ( allow . equalsIgnoreCase ( \"true\" ) || allow . equalsIgnoreCase ( \"yes\" ) || allow . equalsIgnoreCase ( \"1\" ) ) ; } catch ( MissingResourceException e ) { return defaultRelativeCatalogs ; } }", "nl": "Obtain the relativeCatalogs setting from the properties ."}}
{"translation": {"code": "private String queryCatalogFiles ( ) { String catalogList = System . getProperty ( pFiles ) ; fromPropertiesFile = false ; if ( catalogList == null ) { if ( resources == null ) readProperties ( ) ; if ( resources != null ) { try { catalogList = resources . getString ( \"catalogs\" ) ; fromPropertiesFile = true ; } catch ( MissingResourceException e ) { System . err . println ( propertyFile + \": catalogs not found.\" ) ; catalogList = null ; } } } if ( catalogList == null ) { catalogList = defaultCatalogFiles ; } return catalogList ; }", "nl": "Obtain the list of catalog files from the properties ."}}
{"translation": {"code": "public Vector getCatalogFiles ( ) { if ( catalogFiles == null ) { catalogFiles = queryCatalogFiles ( ) ; } StringTokenizer files = new StringTokenizer ( catalogFiles , \";\" ) ; Vector catalogs = new Vector ( ) ; while ( files . hasMoreTokens ( ) ) { String catalogFile = files . nextToken ( ) ; URL absURI = null ; if ( fromPropertiesFile && ! relativeCatalogs ( ) ) { try { absURI = new URL ( propertyFileURI , catalogFile ) ; catalogFile = absURI . toString ( ) ; } catch ( MalformedURLException mue ) { absURI = null ; } } catalogs . add ( catalogFile ) ; } return catalogs ; }", "nl": "Return the current list of catalog files ."}}
{"translation": {"code": "private boolean queryPreferPublic ( ) { String prefer = System . getProperty ( pPrefer ) ; if ( prefer == null ) { if ( resources == null ) readProperties ( ) ; if ( resources == null ) return defaultPreferPublic ; try { prefer = resources . getString ( \"prefer\" ) ; } catch ( MissingResourceException e ) { return defaultPreferPublic ; } } if ( prefer == null ) { return defaultPreferPublic ; } return ( prefer . equalsIgnoreCase ( \"public\" ) ) ; }", "nl": "Obtain the preferPublic setting from the properties ."}}
{"translation": {"code": "private boolean queryUseStaticCatalog ( ) { String staticCatalog = System . getProperty ( pStatic ) ; if ( useStaticCatalog == null ) { if ( resources == null ) readProperties ( ) ; if ( resources == null ) return defaultUseStaticCatalog ; try { staticCatalog = resources . getString ( \"static-catalog\" ) ; } catch ( MissingResourceException e ) { return defaultUseStaticCatalog ; } } if ( staticCatalog == null ) { return defaultUseStaticCatalog ; } return ( staticCatalog . equalsIgnoreCase ( \"true\" ) || staticCatalog . equalsIgnoreCase ( \"yes\" ) || staticCatalog . equalsIgnoreCase ( \"1\" ) ) ; }", "nl": "Obtain the static - catalog setting from the properties ."}}
{"translation": {"code": "public InputSource resolveEntity ( String publicId , String systemId ) { String resolved = null ; if ( systemId != null && systemMap . containsKey ( systemId ) ) { resolved = ( String ) systemMap . get ( systemId ) ; } else if ( publicId != null && publicMap . containsKey ( publicId ) ) { resolved = ( String ) publicMap . get ( publicId ) ; } if ( resolved != null ) { try { InputSource iSource = new InputSource ( resolved ) ; iSource . setPublicId ( publicId ) ; // Ideally this method would not attempt to open the // InputStream, but there is a bug (in Xerces, at least) // that causes the parser to mistakenly open the wrong // system identifier if the returned InputSource does // not have a byteStream. // // It could be argued that we still shouldn't do this here, // but since the purpose of calling the entityResolver is // almost certainly to open the input stream, it seems to // do little harm. // URL url = new URL ( resolved ) ; InputStream iStream = url . openStream ( ) ; iSource . setByteStream ( iStream ) ; return iSource ; } catch ( Exception e ) { // FIXME: silently fail? return null ; } } return null ; }", "nl": "SAX resolveEntity API ."}}
{"translation": {"code": "public Source resolve ( String href , String base ) throws TransformerException { String uri = href ; int hashPos = href . indexOf ( \"#\" ) ; if ( hashPos >= 0 ) { uri = href . substring ( 0 , hashPos ) ; } String result = null ; if ( href != null && uriMap . containsKey ( href ) ) { result = ( String ) uriMap . get ( href ) ; } if ( result == null ) { try { URL url = null ; if ( base == null ) { url = new URL ( uri ) ; result = url . toString ( ) ; } else { URL baseURL = new URL ( base ) ; url = ( href . length ( ) == 0 ? baseURL : new URL ( baseURL , uri ) ) ; result = url . toString ( ) ; } } catch ( java . net . MalformedURLException mue ) { // try to make an absolute URI from the current base String absBase = makeAbsolute ( base ) ; if ( ! absBase . equals ( base ) ) { // don't bother if the absBase isn't different! return resolve ( href , absBase ) ; } else { throw new TransformerException ( \"Malformed URL \" + href + \"(base \" + base + \")\" , mue ) ; } } } SAXSource source = new SAXSource ( ) ; source . setInputSource ( new InputSource ( result ) ) ; return source ; }", "nl": "Transformer resolve API ."}}
{"translation": {"code": "private String makeAbsolute ( String uri ) { if ( uri == null ) { uri = \"\" ; } try { URL url = new URL ( uri ) ; return url . toString ( ) ; } catch ( MalformedURLException mue ) { String dir = System . getProperty ( \"user.dir\" ) ; String file = \"\" ; if ( dir . endsWith ( \"/\" ) ) { file = \"file://\" + dir + uri ; } else { file = \"file://\" + dir + \"/\" + uri ; } try { URL fileURL = new URL ( file ) ; return fileURL . toString ( ) ; } catch ( MalformedURLException mue2 ) { // bail return uri ; } } }", "nl": "Attempt to construct an absolute URI"}}
{"translation": {"code": "protected void invokeSetter ( String value ) { try { // coerce value to field type Class < ? > type = descriptor . getPropertyType ( ) ; PropertyEditor editor = PropertyEditors . findEditor ( type ) ; editor . setAsText ( value ) ; Object coerced = editor . getValue ( ) ; // System.out.println(\"type: \" + type); // System.out.println(\"coerced: \" + coerced); // invoke the setter method setter . invoke ( instance , new Object [ ] { coerced } ) ; } catch ( InvocationTargetException e ) { Throwable target = e . getTargetException ( ) ; if ( target instanceof PropertyException ) { throw ( PropertyException ) target ; } else { throw new PropertyException ( target ) ; } } catch ( Exception e ) { throw new PropertyException ( e ) ; } }", "nl": "Coerce and invoke the property setter method on the instance ."}}
{"translation": {"code": "public static String getLocalName ( Element element ) { String name = element . getTagName ( ) ; if ( name . indexOf ( ' ' ) > 0 ) { name = name . substring ( name . indexOf ( ' ' ) + 1 ) ; } return name ; }", "nl": "Returns the localname part of a QName which is the whole name if it has no prefix ."}}
{"translation": {"code": "public static String getNamespaceURI ( Node node , String prefix ) { if ( node == null || node . getNodeType ( ) != Node . ELEMENT_NODE ) { return null ; } if ( prefix . equals ( \"\" ) ) { if ( ( ( Element ) node ) . hasAttribute ( \"xmlns\" ) ) { return ( ( Element ) node ) . getAttribute ( \"xmlns\" ) ; } } else { String nsattr = \"xmlns:\" + prefix ; if ( ( ( Element ) node ) . hasAttribute ( nsattr ) ) { return ( ( Element ) node ) . getAttribute ( nsattr ) ; } } return getNamespaceURI ( node . getParentNode ( ) , prefix ) ; }", "nl": "Returns the namespace URI for the specified prefix at the specified context node ."}}
{"translation": {"code": "public static String getNamespaceURI ( Element element ) { String prefix = getPrefix ( element ) ; return getNamespaceURI ( element , prefix ) ; }", "nl": "Returns the namespace URI for the namespace to which the element belongs ."}}
{"translation": {"code": "public static List list ( Enumeration e ) { ArrayList result = new ArrayList ( ) ; while ( e . hasMoreElements ( ) ) result . add ( e . nextElement ( ) ) ; return result ; }", "nl": "Create a list from an enumeration"}}
{"translation": {"code": "protected InputStream getInputStream ( String filename ) throws IOException { File file = new File ( filename ) ; return new FileInputStream ( file ) ; }", "nl": "Get an input stream for the given filename ."}}
{"translation": {"code": "protected void loadProperties ( Properties props , String filename ) throws IOException { if ( filename == null ) throw new NullArgumentException ( \"filename\" ) ; if ( filename . equals ( \"\" ) ) throw new IllegalArgumentException ( \"filename\" ) ; InputStream in = new BufferedInputStream ( getInputStream ( filename ) ) ; props . load ( in ) ; in . close ( ) ; }", "nl": "Load properties from a file into a properties map ."}}
{"translation": {"code": "public Map readProperties ( ) throws PropertyException , IOException { Properties props = new Properties ( ) ; // load each specified property file for ( int i = 0 ; i < filenames . length ; i ++ ) { loadProperties ( props , filenames [ i ] ) ; } return props ; }", "nl": "Read properties from each specified filename"}}
{"translation": {"code": "private void doWork ( ) { while ( cancelled . get ( ) == false ) { TimeoutExt work = queue . take ( ) ; // Do work, if any if ( work != null ) { // Wrap the TimeoutExt with a runnable that invokes the target callback TimeoutWorker worker = new TimeoutWorker ( work ) ; try { threadPool . run ( worker ) ; } catch ( Throwable t ) { // protect the worker thread from pool enqueue errors ThrowableHandler . add ( ThrowableHandler . Type . ERROR , t ) ; } synchronized ( work ) { work . done ( ) ; } } } // TimeoutFactory was cancelled queue . cancel ( ) ; }", "nl": "Timeout worker method ."}}
{"translation": {"code": "public Timeout schedule ( long time , TimeoutTarget target ) { if ( cancelled . get ( ) ) throw new IllegalStateException ( \"TimeoutFactory has been cancelled\" ) ; if ( time < 0 ) throw new IllegalArgumentException ( \"Negative time\" ) ; if ( target == null ) throw new IllegalArgumentException ( \"Null timeout target\" ) ; return queue . offer ( time , target ) ; }", "nl": "Schedules a new timeout ."}}
{"translation": {"code": "public static ApplicationDeadlockException isADE ( Throwable t ) { while ( t != null ) { if ( t instanceof ApplicationDeadlockException ) { return ( ApplicationDeadlockException ) t ; } else { t = t . getCause ( ) ; } } return null ; }", "nl": "Detects exception contains is or a ApplicationDeadlockException ."}}
{"translation": {"code": "public ClassLoader getContextClassLoader ( final Thread thread ) { return ( ClassLoader ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return thread . getContextClassLoader ( ) ; } } ) ; }", "nl": "Retrieve the context classloader for the given thread"}}
{"translation": {"code": "public static void displayClassInfo ( Class clazz , StringBuffer results ) { // Print out some codebase info for the clazz ClassLoader cl = clazz . getClassLoader ( ) ; results . append ( \"\\n\" ) ; results . append ( clazz . getName ( ) ) ; results . append ( \"(\" ) ; results . append ( Integer . toHexString ( clazz . hashCode ( ) ) ) ; results . append ( \").ClassLoader=\" ) ; results . append ( cl ) ; ClassLoader parent = cl ; while ( parent != null ) { results . append ( \"\\n..\" ) ; results . append ( parent ) ; URL [ ] urls = getClassLoaderURLs ( parent ) ; int length = urls != null ? urls . length : 0 ; for ( int u = 0 ; u < length ; u ++ ) { results . append ( \"\\n....\" ) ; results . append ( urls [ u ] ) ; } if ( parent != null ) parent = parent . getParent ( ) ; } CodeSource clazzCS = clazz . getProtectionDomain ( ) . getCodeSource ( ) ; if ( clazzCS != null ) { results . append ( \"\\n++++CodeSource: \" ) ; results . append ( clazzCS ) ; } else results . append ( \"\\n++++Null CodeSource\" ) ; results . append ( \"\\nImplemented Interfaces:\" ) ; Class [ ] ifaces = clazz . getInterfaces ( ) ; for ( int i = 0 ; i < ifaces . length ; i ++ ) { Class iface = ifaces [ i ] ; results . append ( \"\\n++\" ) ; results . append ( iface ) ; results . append ( \"(\" ) ; results . append ( Integer . toHexString ( iface . hashCode ( ) ) ) ; results . append ( \")\" ) ; ClassLoader loader = ifaces [ i ] . getClassLoader ( ) ; results . append ( \"\\n++++ClassLoader: \" ) ; results . append ( loader ) ; ProtectionDomain pd = ifaces [ i ] . getProtectionDomain ( ) ; CodeSource cs = pd . getCodeSource ( ) ; if ( cs != null ) { results . append ( \"\\n++++CodeSource: \" ) ; results . append ( cs ) ; } else results . append ( \"\\n++++Null CodeSource\" ) ; } }", "nl": "Format a string buffer containing the Class Interfaces CodeSource and ClassLoader information for the given object clazz ."}}
{"translation": {"code": "public static void describe ( StringBuffer buffer , Class clazz ) { if ( clazz == null ) buffer . append ( \"**null**\" ) ; else { buffer . append ( \"{class=\" ) . append ( clazz . getName ( ) ) ; Class [ ] intfs = clazz . getInterfaces ( ) ; if ( intfs . length > 0 ) { buffer . append ( \" intfs=\" ) ; for ( int i = 0 ; i < intfs . length ; ++ i ) { buffer . append ( intfs [ i ] . getName ( ) ) ; if ( i < intfs . length - 1 ) buffer . append ( \", \" ) ; } } buffer . append ( \"}\" ) ; } }", "nl": "Describe the class"}}
{"translation": {"code": "public static String stripPackageName ( final String classname ) { int idx = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; if ( idx != - 1 ) return classname . substring ( idx + 1 , classname . length ( ) ) ; return classname ; }", "nl": "Get the short name of the specified class by striping off the package name ."}}
{"translation": {"code": "public static String getPackageName ( final String classname ) { if ( classname . length ( ) == 0 ) throw new EmptyStringException ( ) ; int index = classname . lastIndexOf ( PACKAGE_SEPARATOR ) ; if ( index != - 1 ) return classname . substring ( 0 , index ) ; return \"\" ; }", "nl": "Get the package name of the specified class ."}}
{"translation": {"code": "public static void forceLoad ( final Class type ) { if ( type == null ) throw new NullArgumentException ( \"type\" ) ; // don't attempt to force primitives to load if ( type . isPrimitive ( ) ) return ; // don't attempt to force java.* classes to load String packageName = Classes . getPackageName ( type ) ; // System.out.println(\"package name: \" + packageName); if ( packageName . startsWith ( \"java.\" ) || packageName . startsWith ( \"javax.\" ) ) { return ; } // System.out.println(\"forcing class to load: \" + type); try { Method methods [ ] = type . getDeclaredMethods ( ) ; Method method = null ; for ( int i = 0 ; i < methods . length ; i ++ ) { int modifiers = methods [ i ] . getModifiers ( ) ; if ( Modifier . isStatic ( modifiers ) ) { method = methods [ i ] ; break ; } } if ( method != null ) { method . invoke ( null , ( Object [ ] ) null ) ; } else { type . newInstance ( ) ; } } catch ( Exception ignore ) { ThrowableHandler . add ( ignore ) ; } }", "nl": "Force the given class to be loaded fully ."}}
{"translation": {"code": "public static Class getPrimitiveWrapper ( final Class type ) { if ( ! type . isPrimitive ( ) ) { throw new IllegalArgumentException ( \"type is not a primitive class\" ) ; } for ( int i = 0 ; i < PRIMITIVE_WRAPPER_MAP . length ; i += 2 ) { if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i ] ) ) return PRIMITIVE_WRAPPER_MAP [ i + 1 ] ; } // should never get here, if we do then PRIMITIVE_WRAPPER_MAP // needs to be updated to include the missing mapping throw new UnreachableStatementException ( ) ; }", "nl": "Get the wrapper class for the given primitive type ."}}
{"translation": {"code": "public static void getAllInterfaces ( List allIfaces , Class c ) { while ( c != null ) { Class [ ] ifaces = c . getInterfaces ( ) ; for ( int n = 0 ; n < ifaces . length ; n ++ ) { allIfaces . add ( ifaces [ n ] ) ; } c = c . getSuperclass ( ) ; } }", "nl": "Populates a list with all the interfaces implemented by the argument class c and all its superclasses ."}}
{"translation": {"code": "public static boolean isPrimitiveWrapper ( final Class type ) { for ( int i = 0 ; i < PRIMITIVE_WRAPPER_MAP . length ; i += 2 ) { if ( type . equals ( PRIMITIVE_WRAPPER_MAP [ i + 1 ] ) ) { return true ; } } return false ; }", "nl": "Check if the given class is a primitive wrapper class ."}}
{"translation": {"code": "public static Object instantiate ( Class expected , String property , String defaultClassName ) { String className = getProperty ( property , defaultClassName ) ; Class clazz = null ; try { clazz = loadClass ( className ) ; } catch ( ClassNotFoundException e ) { throw new NestedRuntimeException ( \"Cannot load class \" + className , e ) ; } Object result = null ; try { result = clazz . newInstance ( ) ; } catch ( InstantiationException e ) { throw new NestedRuntimeException ( \"Error instantiating \" + className , e ) ; } catch ( IllegalAccessException e ) { throw new NestedRuntimeException ( \"Error instantiating \" + className , e ) ; } if ( expected . isAssignableFrom ( clazz ) == false ) throw new NestedRuntimeException ( \"Class \" + className + \" from classloader \" + clazz . getClassLoader ( ) + \" is not of the expected class \" + expected + \" loaded from \" + expected . getClassLoader ( ) ) ; return result ; }", "nl": "Instantiate a java class object"}}
{"translation": {"code": "public final static Method getAttributeGetter ( Class cls , String attr ) throws NoSuchMethodException { StringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; buf . append ( \"get\" ) ; if ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) { buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; } else { buf . append ( attr ) ; } try { return cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; } catch ( NoSuchMethodException e ) { buf . replace ( 0 , 3 , \"is\" ) ; return cls . getMethod ( buf . toString ( ) , ( Class [ ] ) null ) ; } }", "nl": "Returns attribute s getter method . If the method not found then NoSuchMethodException will be thrown ."}}
{"translation": {"code": "public final static Method getAttributeSetter ( Class cls , String attr , Class type ) throws NoSuchMethodException { StringBuffer buf = new StringBuffer ( attr . length ( ) + 3 ) ; buf . append ( \"set\" ) ; if ( Character . isLowerCase ( attr . charAt ( 0 ) ) ) { buf . append ( Character . toUpperCase ( attr . charAt ( 0 ) ) ) . append ( attr . substring ( 1 ) ) ; } else { buf . append ( attr ) ; } return cls . getMethod ( buf . toString ( ) , new Class [ ] { type } ) ; }", "nl": "Returns attribute s setter method . If the method not found then NoSuchMethodException will be thrown ."}}
{"translation": {"code": "public InputSource resolveEntity ( String publicId , String systemId ) throws MalformedURLException , IOException { String resolvedURI = catologResolver . resolveSystem ( systemId ) ; if ( resolvedURI == null ) { resolvedURI = catologResolver . resolvePublic ( publicId , systemId ) ; } if ( resolvedURI != null ) { final InputSource is = new InputSource ( ) ; is . setPublicId ( publicId ) ; is . setSystemId ( systemId ) ; is . setByteStream ( this . loadResource ( resolvedURI ) ) ; this . isLastEntityResolved = true ; return is ; } else { //resource could\ufffdt be resloved this . isLastEntityResolved = false ; return null ; } }", "nl": "Tries to resolve the entity using the thread specific catolog resolvers"}}
{"translation": {"code": "private final static Class convertToJavaClass ( String name , ClassLoader cl ) throws ClassNotFoundException { int arraySize = 0 ; while ( name . endsWith ( \"[]\" ) ) { name = name . substring ( 0 , name . length ( ) - 2 ) ; arraySize ++ ; } // Check for a primitive type Class c = ( Class ) PRIMITIVE_NAME_TYPE_MAP . get ( name ) ; if ( c == null ) { // No primitive, try to load it from the given ClassLoader try { c = cl . loadClass ( name ) ; } catch ( ClassNotFoundException cnfe ) { throw new ClassNotFoundException ( \"Parameter class not found: \" + name ) ; } } // if we have an array get the array class if ( arraySize > 0 ) { int [ ] dims = new int [ arraySize ] ; for ( int i = 0 ; i < arraySize ; i ++ ) { dims [ i ] = 1 ; } c = Array . newInstance ( c , dims ) . getClass ( ) ; } return c ; }", "nl": "Convert a given String into the appropriate Class ."}}
{"translation": {"code": "public static String [ ] getFilenames ( final String propertyName ) throws PropertyException { String filenames [ ] ; // check for singleton property first Object filename = PropertyManager . getProperty ( propertyName ) ; if ( filename != null ) { filenames = new String [ ] { String . valueOf ( filename ) } ; } else { // if no singleton property exists then look for array props filenames = PropertyManager . getArrayProperty ( propertyName ) ; } return filenames ; }", "nl": "Get an array of filenames to load ."}}
{"translation": {"code": "protected final void maintain ( ) { WeakObject weak ; while ( ( weak = ( WeakObject ) queue . poll ( ) ) != null ) { set . remove ( weak ) ; } }", "nl": "Maintain the elements in the set . Removes objects from the set that have been reclaimed due to GC ."}}
{"translation": {"code": "public Iterator iterator ( ) { return new Iterator ( ) { /** The set's iterator */ Iterator iter = set . iterator ( ) ; /** JBCOMMON-24, handle null values and multiple invocations of hasNext() */ Object UNKNOWN = new Object ( ) ; /** The next available object. */ Object next = UNKNOWN ; public boolean hasNext ( ) { if ( next != UNKNOWN ) { return true ; } while ( iter . hasNext ( ) ) { WeakObject weak = ( WeakObject ) iter . next ( ) ; Object obj = null ; if ( weak != null && ( obj = weak . get ( ) ) == null ) { // object has been reclaimed by the GC continue ; } next = obj ; return true ; } return false ; } public Object next ( ) { if ( ( next == UNKNOWN ) && ! hasNext ( ) ) { throw new NoSuchElementException ( ) ; } Object obj = next ; next = UNKNOWN ; return obj ; } public void remove ( ) { iter . remove ( ) ; } } ; }", "nl": "Return an iteration over the elements in the set ."}}
{"translation": {"code": "public URLLister createURLLister ( String protocol ) throws MalformedURLException { try { String className = ( String ) classes . get ( protocol ) ; if ( className == null ) { throw new MalformedURLException ( \"No lister class defined for protocol \" + protocol ) ; } Class < ? > clazz = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( className ) ; return ( URLLister ) clazz . newInstance ( ) ; } catch ( ClassNotFoundException e ) { throw new MalformedURLException ( e . getMessage ( ) ) ; } catch ( InstantiationException e ) { throw new MalformedURLException ( e . getMessage ( ) ) ; } catch ( IllegalAccessException e ) { throw new MalformedURLException ( e . getMessage ( ) ) ; } }", "nl": "Create a URL lister for the supplied protocol"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Set entrySet ( ) { final Set superSet = super . entrySet ( true ) ; return new java . util . AbstractSet ( ) { private boolean isInGroup ( Map . Entry entry ) { String key = ( String ) entry . getKey ( ) ; return key . startsWith ( basename ) ; } public int size ( ) { Iterator iter = superSet . iterator ( ) ; int count = 0 ; while ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( isInGroup ( entry ) ) { count ++ ; } } return count ; } public Iterator iterator ( ) { return new Iterator ( ) { private Iterator iter = superSet . iterator ( ) ; private Object next ; public boolean hasNext ( ) { if ( next != null ) return true ; while ( next == null ) { if ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; if ( isInGroup ( entry ) ) { next = entry ; return true ; } } else { break ; } } return false ; } public Object next ( ) { if ( next == null ) throw new java . util . NoSuchElementException ( ) ; Object obj = next ; next = null ; return obj ; } public void remove ( ) { iter . remove ( ) ; } } ; } } ; }", "nl": "Returns an entry set for all properties in this group ."}}
{"translation": {"code": "protected void addPropertyListener ( final BoundPropertyListener listener ) { // get the bound property name String name = makePropertyName ( listener . getPropertyName ( ) ) ; // get the bound listener list for the property List list = ( List ) boundListeners . get ( name ) ; // if list is null, then add a new list if ( list == null ) { list = new ArrayList ( ) ; boundListeners . put ( name , list ) ; } // if listener is not in the list already, then add it if ( ! list . contains ( listener ) ) { list . add ( listener ) ; // notify listener that is is bound listener . propertyBound ( this ) ; } }", "nl": "Add a bound property listener ."}}
{"translation": {"code": "protected boolean removePropertyListener ( final BoundPropertyListener listener ) { // get the bound property name String name = makePropertyName ( listener . getPropertyName ( ) ) ; // get the bound listener list for the property List list = ( List ) boundListeners . get ( name ) ; boolean removed = false ; if ( list != null ) { removed = list . remove ( listener ) ; // notify listener that is was unbound if ( removed ) listener . propertyUnbound ( this ) ; } return removed ; }", "nl": "Remove a bound property listener ."}}
{"translation": {"code": "public static final boolean isNull ( final String value , final boolean trim , final boolean empty ) { // For backwards compatibility if ( disableIsNull ) return false ; // No value? if ( value == null ) return true ; // Trim the text when requested String trimmed = trim ? value . trim ( ) : value ; // Is the empty string null? if ( empty && trimmed . length ( ) == 0 ) return true ; // Just check it. return NULL . equalsIgnoreCase ( trimmed ) ; }", "nl": "Whether a string is interpreted as the null value"}}
{"translation": {"code": "public static PropertyEditor findEditor ( final String typeName ) throws ClassNotFoundException { // see if it is a primitive type first Class < ? > type = Classes . getPrimitiveTypeForName ( typeName ) ; if ( type == null ) { // nope try look up ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; type = loader . loadClass ( typeName ) ; } return PropertyEditorManager . findEditor ( type ) ; }", "nl": "Locate a value editor for a given target type ."}}
{"translation": {"code": "public static void registerEditor ( final String typeName , final String editorTypeName ) throws ClassNotFoundException { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Class < ? > type = loader . loadClass ( typeName ) ; Class < ? > editorType = loader . loadClass ( editorTypeName ) ; PropertyEditorManager . registerEditor ( type , editorType ) ; }", "nl": "Register an editor class to be used to editor values of a given target class ."}}
{"translation": {"code": "public static Object convertValue ( String text , String typeName ) throws ClassNotFoundException , IntrospectionException { // see if it is a primitive type first Class < ? > typeClass = Classes . getPrimitiveTypeForName ( typeName ) ; if ( typeClass == null ) { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; typeClass = loader . loadClass ( typeName ) ; } PropertyEditor editor = PropertyEditorManager . findEditor ( typeClass ) ; if ( editor == null ) { throw new IntrospectionException ( \"No property editor for type=\" + typeClass ) ; } editor . setAsText ( text ) ; return editor . getValue ( ) ; }", "nl": "Convert a string value into the true value for typeName using the PropertyEditor associated with typeName ."}}
{"translation": {"code": "private static String getProperty ( final String name , final String defaultValue ) { return ( String ) AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { return System . getProperty ( name , defaultValue ) ; } } ) ; }", "nl": "Get a system property"}}
{"translation": {"code": "public static void list ( JBossStringBuilder buffer , Collection objects ) { if ( objects == null ) return ; buffer . append ( ' ' ) ; if ( objects . isEmpty ( ) == false ) { for ( Iterator i = objects . iterator ( ) ; i . hasNext ( ) ; ) { Object object = i . next ( ) ; if ( object instanceof JBossObject ) ( ( JBossObject ) object ) . toShortString ( buffer ) ; else buffer . append ( object . toString ( ) ) ; if ( i . hasNext ( ) ) buffer . append ( \", \" ) ; } } buffer . append ( ' ' ) ; }", "nl": "List the set of JBossObjects"}}
{"translation": {"code": "public boolean hasNext ( ) { for ( ; index < iters . length ; index ++ ) { if ( iters [ index ] != null && iters [ index ] . hasNext ( ) ) { return true ; } } return false ; }", "nl": "Check if there are more elements ."}}
{"translation": {"code": "public void setContextClassLoader ( final Thread thread , final ClassLoader cl ) { AccessController . doPrivileged ( new PrivilegedAction ( ) { public Object run ( ) { thread . setContextClassLoader ( cl ) ; return null ; } } ) ; }", "nl": "Set the context classloader for the given thread"}}
{"translation": {"code": "protected String encodedByte ( int b ) { String hex = Integer . toHexString ( b ) . toUpperCase ( ) ; if ( hex . length ( ) < 2 ) { return \"%0\" + hex ; } else { return \"%\" + hex ; } }", "nl": "Perform % - encoding on a single byte ."}}
{"translation": {"code": "protected void addDelegate ( CatalogEntry entry ) { int pos = 0 ; String partial = entry . getEntryArg ( 0 ) ; Enumeration local = localDelegate . elements ( ) ; while ( local . hasMoreElements ( ) ) { CatalogEntry dpe = ( CatalogEntry ) local . nextElement ( ) ; String dp = dpe . getEntryArg ( 0 ) ; if ( dp . equals ( partial ) ) { // we already have this prefix return ; } if ( dp . length ( ) > partial . length ( ) ) { pos ++ ; } if ( dp . length ( ) < partial . length ( ) ) { break ; } } // now insert partial into the vector at [pos] if ( localDelegate . size ( ) == 0 ) { localDelegate . addElement ( entry ) ; } else { localDelegate . insertElementAt ( entry , pos ) ; } }", "nl": "Add to the current list of delegated catalogs ."}}
{"translation": {"code": "public State nextState ( String actionName ) throws IllegalTransitionException { Transition t = currentState . getTransition ( actionName ) ; if ( t == null ) { String msg = \"No transition for action: '\" + actionName + \"' from state: '\" + currentState . getName ( ) + \"'\" ; throw new IllegalTransitionException ( msg ) ; } State nextState = t . getTarget ( ) ; log . trace ( \"nextState(\" + actionName + \") = \" + nextState ) ; currentState = nextState ; return currentState ; }", "nl": "Transition to the next state given the name of a valid transition ."}}
{"translation": {"code": "protected static void fireOnThrowable ( int type , Throwable t ) { Object [ ] list = listeners . toArray ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { ( ( ThrowableListener ) list [ i ] ) . onThrowable ( type , t ) ; } }", "nl": "Fire onThrowable to all registered listeners ."}}
{"translation": {"code": "public static void add ( int type , Throwable t ) { // don't add null throwables if ( t == null ) return ; try { fireOnThrowable ( type , t ) ; } catch ( Throwable bad ) { // don't let these propagate, that could introduce unwanted side-effects System . err . println ( \"Unable to handle throwable: \" + t + \" because of:\" ) ; bad . printStackTrace ( ) ; } }", "nl": "Add a throwable that is to be handled ."}}
{"translation": {"code": "public static String [ ] getArray ( String base , String [ ] defaultValues ) { return PropertyManager . getArrayProperty ( base , defaultValues ) ; }", "nl": "Get an array style property"}}
{"translation": {"code": "private List < T > createImplementation ( ) { if ( delegate instanceof ArrayList == false ) return new ArrayList < T > ( delegate ) ; return delegate ; }", "nl": "Create the list implementation"}}
{"translation": {"code": "public int compareTo ( Object other ) { if ( other == this ) return 0 ; TimerTask t = ( TimerTask ) other ; long diff = getNextExecutionTime ( ) - t . getNextExecutionTime ( ) ; return ( int ) diff ; }", "nl": "A TimerTask is less than another if it will be scheduled before ."}}
{"translation": {"code": "public Object getValue ( ) { try { String text = getAsText ( ) ; if ( text == null ) { return null ; } if ( text . startsWith ( \"/\" ) ) { // seems like localhost sometimes will look like: // /127.0.0.1 and the getByNames barfs on the slash - JGH text = text . substring ( 1 ) ; } return InetAddress . getByName ( StringPropertyReplacer . replaceProperties ( text ) ) ; } catch ( UnknownHostException e ) { throw new NestedRuntimeException ( e ) ; } }", "nl": "Returns a InetAddress for the input object converted to a string ."}}
{"translation": {"code": "private Object getObject ( final int index ) { Object obj = list . get ( index ) ; return Objects . deref ( obj ) ; }", "nl": "Dereference the object at the given index ."}}
{"translation": {"code": "public Object set ( final int index , final Object obj ) { maintain ( ) ; SoftObject soft = SoftObject . create ( obj , queue ) ; soft = ( SoftObject ) list . set ( index , soft ) ; return Objects . deref ( soft ) ; }", "nl": "Replaces the element at the specified position in this list with the specified element ."}}
{"translation": {"code": "protected String normalizeURI ( String uriref ) { String newRef = \"\" ; byte [ ] bytes ; if ( uriref == null ) { return null ; } try { bytes = uriref . getBytes ( \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { // this can't happen catalogManager . debug . message ( 1 , \"UTF-8 is an unsupported encoding!?\" ) ; return uriref ; } for ( int count = 0 ; count < bytes . length ; count ++ ) { int ch = bytes [ count ] & 0xFF ; if ( ( ch <= 0x20 ) // ctrl || ( ch > 0x7F ) // high ascii || ( ch == 0x22 ) // \" || ( ch == 0x3C ) // < || ( ch == 0x3E ) // > || ( ch == 0x5C ) // \\ || ( ch == 0x5E ) // ^ || ( ch == 0x60 ) // ` || ( ch == 0x7B ) // { || ( ch == 0x7C ) // | || ( ch == 0x7D ) // } || ( ch == 0x7F ) ) { newRef += encodedByte ( ch ) ; } else { newRef += ( char ) bytes [ count ] ; } } return newRef ; }", "nl": "Perform character normalization on a URI reference ."}}
{"translation": {"code": "private void maintain ( ) { SoftObject obj ; int count = 0 ; while ( ( obj = ( SoftObject ) queue . poll ( ) ) != null ) { count ++ ; list . remove ( obj ) ; } if ( count != 0 ) { // some temporary debugging fluff System . err . println ( \"vm reclaimed \" + count + \" objects\" ) ; } }", "nl": "Maintains the collection by removing garbage collected objects ."}}
{"translation": {"code": "public static int getEntryType ( String name ) throws CatalogException { if ( ! entryTypes . containsKey ( name ) ) { throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; } Integer iType = ( Integer ) entryTypes . get ( name ) ; if ( iType == null ) { throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; } return iType . intValue ( ) ; }", "nl": "Lookup an entry type"}}
{"translation": {"code": "public static int getEntryArgCount ( int type ) throws CatalogException { try { Integer iArgs = ( Integer ) entryArgs . get ( type ) ; return iArgs . intValue ( ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new CatalogException ( CatalogException . INVALID_ENTRY_TYPE ) ; } }", "nl": "Find out how many arguments an entry is required to have ."}}
{"translation": {"code": "public String getEntryArg ( int argNum ) { try { String arg = ( String ) args . get ( argNum ) ; return arg ; } catch ( ArrayIndexOutOfBoundsException e ) { return null ; } }", "nl": "Get an entry argument ."}}
{"translation": {"code": "public static String set ( String name , String value ) { return PropertyManager . setProperty ( name , value ) ; }", "nl": "Set a property"}}
{"translation": {"code": "private void swap ( int a , int b ) { // INV: assertExpr(a > 0); // INV: assertExpr(a <= size); // INV: assertExpr(b > 0); // INV: assertExpr(b <= size); // INV: assertExpr(queue[a] != null); // INV: assertExpr(queue[b] != null); // INV: assertExpr(queue[a].index == a); // INV: assertExpr(queue[b].index == b); TimeoutExtImpl temp = queue [ a ] ; queue [ a ] = queue [ b ] ; queue [ a ] . index = a ; queue [ b ] = temp ; queue [ b ] . index = b ; }", "nl": "Swap two nodes in the tree ."}}
{"translation": {"code": "private TimeoutExtImpl removeNode ( int index ) { // INV: assertExpr(index > 0); // INV: assertExpr(index <= size); TimeoutExtImpl res = queue [ index ] ; // INV: assertExpr(res != null); // INV: assertExpr(res.index == index); if ( index == size ) { -- size ; queue [ index ] = null ; return res ; } swap ( index , size ) ; // Exchange removed node with last leaf node -- size ; // INV: assertExpr(res.index == size + 1); queue [ res . index ] = null ; if ( normalizeUp ( index ) ) return res ; // Node moved up, so it shouldn't move down long t = queue [ index ] . time ; int c = index << 1 ; while ( c <= size ) { // INV: assertExpr(q[index].time == t); TimeoutExtImpl l = queue [ c ] ; // INV: assertExpr(l != null); // INV: assertExpr(l.index == c); if ( c + 1 <= size ) { // two children, swap with smallest TimeoutExtImpl r = queue [ c + 1 ] ; // INV: assertExpr(r != null); // INV: assertExpr(r.index == c+1); if ( l . time <= r . time ) { if ( t <= l . time ) break ; // done swap ( index , c ) ; index = c ; } else { if ( t <= r . time ) break ; // done swap ( index , c + 1 ) ; index = c + 1 ; } } else { // one child if ( t <= l . time ) break ; // done swap ( index , c ) ; index = c ; } c = index << 1 ; } return res ; }", "nl": "Remove a node from the tree and normalize ."}}
{"translation": {"code": "private TimeoutExtImpl cleanupTimeoutExtImpl ( TimeoutExtImpl timeout ) { if ( timeout != null ) timeout . target = null ; return null ; }", "nl": "Recursive cleanup of a TimeoutImpl"}}
{"translation": {"code": "protected Class < ? > loadClass ( String className , boolean resolve ) throws ClassNotFoundException { // Revert to standard rules if ( standard ) return super . loadClass ( className , resolve ) ; // Ask the parent Class < ? > clazz = null ; try { clazz = parent . loadClass ( className ) ; } catch ( ClassNotFoundException e ) { // Not found in parent, // maybe it is a proxy registered against this classloader? clazz = findLoadedClass ( className ) ; if ( clazz == null ) throw e ; } // Link the class if ( resolve ) resolveClass ( clazz ) ; return clazz ; }", "nl": "Load a class by asking the parent"}}
{"translation": {"code": "@ SuppressWarnings ( \"unused\" ) public static void preload ( ) { for ( int i = 0 ; i < PROTOCOLS . length ; i ++ ) { try { URL url = new URL ( PROTOCOLS [ i ] , \"\" , - 1 , \"\" ) ; log . trace ( \"Loaded protocol: \" + PROTOCOLS [ i ] ) ; } catch ( Exception e ) { log . warn ( \"Failed to load protocol: \" + PROTOCOLS [ i ] , e ) ; } } }", "nl": "Preload the JBoss specific protocol handlers so that URL knows about them even if the handler factory is changed ."}}
{"translation": {"code": "public URLStreamHandler createURLStreamHandler ( final String protocol ) { // Check the handler map URLStreamHandler handler = ( URLStreamHandler ) handlerMap . get ( protocol ) ; if ( handler != null ) return handler ; // Validate that createURLStreamHandler is not recursing String prevProtocol = ( String ) createURLStreamHandlerProtocol . get ( ) ; if ( prevProtocol != null && prevProtocol . equals ( protocol ) ) return null ; createURLStreamHandlerProtocol . set ( protocol ) ; // See if the handler pkgs definition has changed checkHandlerPkgs ( ) ; // Search the handlerPkgs for a matching protocol handler ClassLoader ctxLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; for ( int p = 0 ; p < handlerPkgs . length ; p ++ ) { try { // Form the standard protocol handler class name String classname = handlerPkgs [ p ] + \".\" + protocol + \".Handler\" ; Class < ? > type = null ; try { type = ctxLoader . loadClass ( classname ) ; } catch ( ClassNotFoundException e ) { // Try our class loader type = Class . forName ( classname ) ; } if ( type != null ) { handler = ( URLStreamHandler ) type . newInstance ( ) ; handlerMap . put ( protocol , handler ) ; log . trace ( \"Found protocol:\" + protocol + \" handler:\" + handler ) ; } } catch ( Throwable ignore ) { } } createURLStreamHandlerProtocol . set ( null ) ; return handler ; }", "nl": "Search the handlerPkgs for URLStreamHandler classes matching the pkg + protocol + . Handler naming convention ."}}
{"translation": {"code": "private synchronized void checkHandlerPkgs ( ) { String handlerPkgsProp = System . getProperty ( \"java.protocol.handler.pkgs\" ) ; if ( handlerPkgsProp != null && handlerPkgsProp . equals ( lastHandlerPkgs ) == false ) { // Update the handlerPkgs[] from the handlerPkgsProp StringTokenizer tokeninzer = new StringTokenizer ( handlerPkgsProp , \"|\" ) ; ArrayList < String > tmp = new ArrayList < String > ( ) ; while ( tokeninzer . hasMoreTokens ( ) ) { String pkg = tokeninzer . nextToken ( ) . intern ( ) ; if ( tmp . contains ( pkg ) == false ) tmp . add ( pkg ) ; } // Include the JBoss default protocol handler pkg if ( tmp . contains ( PACKAGE_PREFIX ) == false ) tmp . add ( PACKAGE_PREFIX ) ; handlerPkgs = new String [ tmp . size ( ) ] ; tmp . toArray ( handlerPkgs ) ; lastHandlerPkgs = handlerPkgsProp ; } }", "nl": "See if the java . protocol . handler . pkgs system property has changed and if it has parse it to update the handlerPkgs array ."}}
{"translation": {"code": "public static int addEntryType ( String name , int numArgs ) { entryTypes . put ( name , new Integer ( nextEntry ) ) ; entryArgs . add ( nextEntry , new Integer ( numArgs ) ) ; nextEntry ++ ; return nextEntry - 1 ; }", "nl": "Adds a new catalog entry type ."}}
{"translation": {"code": "protected String makeAbsolute ( String sysid ) { URL local = null ; sysid = fixSlashes ( sysid ) ; try { local = new URL ( base , sysid ) ; } catch ( MalformedURLException e ) { catalogManager . debug . message ( 1 , \"Malformed URL on system identifier\" , sysid ) ; } if ( local != null ) { return local . toString ( ) ; } else { return sysid ; } }", "nl": "Construct an absolute URI from a relative one using the current base URI ."}}
{"translation": {"code": "protected synchronized String resolveSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { for ( int catPos = 0 ; catPos < catalogs . size ( ) ; catPos ++ ) { Catalog c = null ; try { c = ( Catalog ) catalogs . elementAt ( catPos ) ; } catch ( ClassCastException e ) { String catfile = ( String ) catalogs . elementAt ( catPos ) ; c = newCatalog ( ) ; try { c . parseCatalog ( catfile ) ; } catch ( MalformedURLException mue ) { catalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; } catch ( FileNotFoundException fnfe ) { catalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; } catch ( IOException ioe ) { catalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; } catalogs . setElementAt ( c , catPos ) ; } String resolved = null ; // Ok, now what are we supposed to call here? if ( entityType == DOCTYPE ) { resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; } else if ( entityType == DOCUMENT ) { resolved = c . resolveDocument ( ) ; } else if ( entityType == ENTITY ) { resolved = c . resolveEntity ( entityName , publicId , systemId ) ; } else if ( entityType == NOTATION ) { resolved = c . resolveNotation ( entityName , publicId , systemId ) ; } else if ( entityType == PUBLIC ) { resolved = c . resolvePublic ( publicId , systemId ) ; } else if ( entityType == SYSTEM ) { resolved = c . resolveSystem ( systemId ) ; } else if ( entityType == URI ) { resolved = c . resolveURI ( systemId ) ; } if ( resolved != null ) { return resolved ; } } return null ; }", "nl": "Search the subordinate catalogs in order looking for a match ."}}
{"translation": {"code": "protected String resolveLocalURI ( String uri ) throws MalformedURLException , IOException { Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == URI && ( e . getEntryArg ( 0 ) . equals ( uri ) ) ) { return e . getEntryArg ( 1 ) ; } } // If there's a REWRITE_URI entry in this catalog, use it enumt = catalogEntries . elements ( ) ; String startString = null ; String prefix = null ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == REWRITE_URI ) { String p = e . getEntryArg ( 0 ) ; if ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { // Is this the longest prefix? if ( startString == null || p . length ( ) > startString . length ( ) ) { startString = p ; prefix = e . getEntryArg ( 1 ) ; } } } if ( prefix != null ) { // return the systemId with the new prefix return prefix + uri . substring ( startString . length ( ) ) ; } } // If there's a DELEGATE_URI entry in this catalog, use it enumt = catalogEntries . elements ( ) ; Vector delCats = new Vector ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == DELEGATE_URI ) { String p = e . getEntryArg ( 0 ) ; if ( p . length ( ) <= uri . length ( ) && p . equals ( uri . substring ( 0 , p . length ( ) ) ) ) { // delegate this match to the other catalog delCats . addElement ( e . getEntryArg ( 1 ) ) ; } } } if ( delCats . size ( ) > 0 ) { Enumeration enumCats = delCats . elements ( ) ; if ( catalogManager . debug . getDebug ( ) > 1 ) { catalogManager . debug . message ( 2 , \"Switching to delegated catalog(s):\" ) ; while ( enumCats . hasMoreElements ( ) ) { String delegatedCatalog = ( String ) enumCats . nextElement ( ) ; catalogManager . debug . message ( 2 , \"\\t\" + delegatedCatalog ) ; } } Catalog dcat = newCatalog ( ) ; enumCats = delCats . elements ( ) ; while ( enumCats . hasMoreElements ( ) ) { String delegatedCatalog = ( String ) enumCats . nextElement ( ) ; dcat . parseCatalog ( delegatedCatalog ) ; } return dcat . resolveURI ( uri ) ; } return null ; }", "nl": "Return the applicable URI in this catalog ."}}
{"translation": {"code": "private void processQueue ( ) { ComparableSoftReference cr ; while ( ( cr = ( ComparableSoftReference ) gcqueue . poll ( ) ) != null ) { map . remove ( cr . getKey ( ) ) ; } }", "nl": "Iterate through the gcqueue for for any cleared reference remove the associated value from the underlying set ."}}
{"translation": {"code": "public void run ( ) { // Get the execution thread this . runThread = Thread . currentThread ( ) ; // Check for a start timeout long runTime = getElapsedTime ( ) ; if ( startTimeout > 0l && runTime >= startTimeout ) { taskRejected ( new StartTimeoutException ( \"Start Timeout exceeded for task \" + taskString ) ) ; return ; } // We are about to start, check for a stop boolean stopped = false ; synchronized ( stateLock ) { if ( state == TASK_STOPPED ) { stopped = true ; } else { state = TASK_STARTED ; taskStarted ( ) ; if ( waitType == Task . WAIT_FOR_START ) stateLock . notifyAll ( ) ; } } if ( stopped ) { taskRejected ( new TaskStoppedException ( \"Task stopped for task \" + taskString ) ) ; return ; } // Run the task Throwable throwable = null ; try { task . execute ( ) ; } catch ( Throwable t ) { throwable = t ; } // It is complete taskCompleted ( throwable ) ; // We are completed synchronized ( stateLock ) { state = TASK_COMPLETED ; if ( waitType == Task . WAIT_FOR_COMPLETE ) stateLock . notifyAll ( ) ; } }", "nl": "Called by the thread pool executor"}}
{"translation": {"code": "protected void setTask ( Task task ) { if ( task == null ) throw new IllegalArgumentException ( \"Null task\" ) ; this . task = task ; this . taskString = task . toString ( ) ; this . startTime = System . currentTimeMillis ( ) ; this . waitType = task . getWaitType ( ) ; this . priority = task . getPriority ( ) ; this . startTimeout = task . getStartTimeout ( ) ; this . completionTimeout = task . getCompletionTimeout ( ) ; }", "nl": "Set thetask for this wrapper"}}
{"translation": {"code": "protected boolean taskAccepted ( ) { try { task . accepted ( getElapsedTime ( ) ) ; return true ; } catch ( Throwable t ) { log . warn ( \"Unexpected error during 'accepted' for task: \" + taskString , t ) ; return false ; } }", "nl": "Notify the task it has been accepted"}}
{"translation": {"code": "protected boolean taskRejected ( RuntimeException e ) { try { task . rejected ( getElapsedTime ( ) , e ) ; return true ; } catch ( Throwable t ) { log . warn ( \"Unexpected error during 'rejected' for task: \" + taskString , t ) ; if ( e != null ) log . warn ( \"Original reason for rejection of task: \" + taskString , e ) ; return false ; } }", "nl": "Notify the task it has been rejected"}}
{"translation": {"code": "protected boolean taskStarted ( ) { try { task . started ( getElapsedTime ( ) ) ; return true ; } catch ( Throwable t ) { log . warn ( \"Unexpected error during 'started' for task: \" + taskString , t ) ; return false ; } }", "nl": "Notify the task it has started"}}
{"translation": {"code": "protected boolean taskCompleted ( Throwable throwable ) { try { task . completed ( getElapsedTime ( ) , throwable ) ; return true ; } catch ( Throwable t ) { log . warn ( \"Unexpected error during 'completed' for task: \" + taskString , t ) ; if ( throwable != null ) log . warn ( \"Original error during 'run' for task: \" + taskString , throwable ) ; return false ; } }", "nl": "Notify the task it has completed"}}
{"translation": {"code": "protected boolean taskStop ( ) { try { task . stop ( ) ; return true ; } catch ( Throwable t ) { log . warn ( \"Unexpected error during 'stop' for task: \" + taskString , t ) ; return false ; } }", "nl": "Stop the task"}}
{"translation": {"code": "protected Executable getJobImpl ( ) throws InterruptedException { // While the queue is empty, wait(); // when notified take an event from the queue and return it. while ( m_currentJob == null ) { wait ( ) ; } // This one is the job to return JobItem item = m_currentJob ; // Go on to the next object for the next call.  m_currentJob = m_currentJob . m_next ; return item . m_job ; }", "nl": "Never call this method only override in subclasses to perform job getting in a specific way normally tied to the data structure holding the jobs ."}}
{"translation": {"code": "protected void putJobImpl ( Executable job ) { JobItem posted = new JobItem ( job ) ; if ( m_currentJob == null ) { // The queue is empty, set the current job to process and // wake up the thread waiting in method getJob m_currentJob = posted ; notifyAll ( ) ; } else { JobItem item = m_currentJob ; // The queue is not empty, find the end of the queue ad add the // posted job at the end while ( item . m_next != null ) { item = item . m_next ; } item . m_next = posted ; } }", "nl": "Never call this method only override in subclasses to perform job adding in a specific way normally tied to the data structure holding the jobs ."}}
{"translation": {"code": "public static final BlockingMode toBlockingMode ( String name ) { BlockingMode mode = null ; if ( name == null ) { mode = null ; } else if ( name . equalsIgnoreCase ( \"run\" ) ) { mode = RUN ; } else if ( name . equalsIgnoreCase ( \"wait\" ) ) { mode = WAIT ; } else if ( name . equalsIgnoreCase ( \"discard\" ) ) { mode = DISCARD ; } else if ( name . equalsIgnoreCase ( \"discardOldest\" ) ) { mode = DISCARD_OLDEST ; } else if ( name . equalsIgnoreCase ( \"abort\" ) ) { mode = ABORT ; } return mode ; }", "nl": "A utility method to convert a string name to a BlockingMode"}}
{"translation": {"code": "Object readResolve ( ) throws ObjectStreamException { // Replace the marshalled instance type with the local instance BlockingMode mode = ABORT ; switch ( type ) { case RUN_TYPE : mode = RUN ; break ; case WAIT_TYPE : mode = RUN ; break ; case DISCARD_TYPE : mode = RUN ; break ; case DISCARD_OLDEST_TYPE : mode = RUN ; break ; case ABORT_TYPE : mode = RUN ; break ; } return mode ; }", "nl": "Overriden to return the indentity instance of BlockingMode based on the stream type int value . This ensures that BlockingMode enums can be compared using == ."}}
{"translation": {"code": "public void setupReaders ( ) { SAXParserFactory spf = SAXParserFactory . newInstance ( ) ; spf . setNamespaceAware ( true ) ; spf . setValidating ( false ) ; SAXCatalogReader saxReader = new SAXCatalogReader ( spf ) ; saxReader . setCatalogParser ( null , \"XMLCatalog\" , \"org.apache.xml.resolver.readers.XCatalogReader\" ) ; saxReader . setCatalogParser ( OASISXMLCatalogReader . namespaceName , \"catalog\" , \"org.apache.xml.resolver.readers.OASISXMLCatalogReader\" ) ; addReader ( \"application/xml\" , saxReader ) ; TR9401CatalogReader textReader = new TR9401CatalogReader ( ) ; addReader ( \"text/plain\" , textReader ) ; }", "nl": "Setup readers ."}}
{"translation": {"code": "public void addReader ( String mimeType , CatalogReader reader ) { if ( readerMap . containsKey ( mimeType ) ) { Integer pos = ( Integer ) readerMap . get ( mimeType ) ; readerArr . set ( pos . intValue ( ) , reader ) ; } else { readerArr . add ( reader ) ; Integer pos = new Integer ( readerArr . size ( ) - 1 ) ; readerMap . put ( mimeType , pos ) ; } }", "nl": "Add a new CatalogReader to the Catalog ."}}
{"translation": {"code": "protected void copyReaders ( Catalog newCatalog ) { // Have to copy the readers in the right order...convert hash to arr Vector mapArr = new Vector ( readerMap . size ( ) ) ; // Pad the mapArr out to the right length for ( int count = 0 ; count < readerMap . size ( ) ; count ++ ) { mapArr . add ( null ) ; } Enumeration enumt = readerMap . keys ( ) ; while ( enumt . hasMoreElements ( ) ) { String mimeType = ( String ) enumt . nextElement ( ) ; Integer pos = ( Integer ) readerMap . get ( mimeType ) ; mapArr . set ( pos . intValue ( ) , mimeType ) ; } for ( int count = 0 ; count < mapArr . size ( ) ; count ++ ) { String mimeType = ( String ) mapArr . get ( count ) ; Integer pos = ( Integer ) readerMap . get ( mimeType ) ; newCatalog . addReader ( mimeType , ( CatalogReader ) readerArr . get ( pos . intValue ( ) ) ) ; } }", "nl": "Copies the reader list from the current Catalog to a new Catalog ."}}
{"translation": {"code": "protected Catalog newCatalog ( ) { String catalogClass = this . getClass ( ) . getName ( ) ; try { Catalog c = ( Catalog ) ( Class . forName ( catalogClass ) . newInstance ( ) ) ; c . setCatalogManager ( catalogManager ) ; copyReaders ( c ) ; return c ; } catch ( ClassNotFoundException cnfe ) { catalogManager . debug . message ( 1 , \"Class Not Found Exception: \" + catalogClass ) ; } catch ( IllegalAccessException iae ) { catalogManager . debug . message ( 1 , \"Illegal Access Exception: \" + catalogClass ) ; } catch ( InstantiationException ie ) { catalogManager . debug . message ( 1 , \"Instantiation Exception: \" + catalogClass ) ; } catch ( ClassCastException cce ) { catalogManager . debug . message ( 1 , \"Class Cast Exception: \" + catalogClass ) ; } catch ( Exception e ) { catalogManager . debug . message ( 1 , \"Other Exception: \" + catalogClass ) ; } Catalog c = new Catalog ( ) ; c . setCatalogManager ( catalogManager ) ; copyReaders ( c ) ; return c ; }", "nl": "Create a new Catalog object ."}}
{"translation": {"code": "public void loadSystemCatalogs ( ) throws MalformedURLException , IOException { Vector catalogs = catalogManager . getCatalogFiles ( ) ; if ( catalogs != null ) { for ( int count = 0 ; count < catalogs . size ( ) ; count ++ ) { catalogFiles . addElement ( catalogs . elementAt ( count ) ) ; } } if ( catalogFiles . size ( ) > 0 ) { // This is a little odd. The parseCatalog() method expects // a filename, but it adds that name to the end of the // catalogFiles vector, and then processes that vector. // This allows the system to handle CATALOG entries // correctly. // // In this init case, we take the last element off the // catalogFiles vector and pass it to parseCatalog. This // will \"do the right thing\" in the init case, and allow // parseCatalog() to do the right thing in the non-init // case. Honest. // String catfile = ( String ) catalogFiles . lastElement ( ) ; catalogFiles . removeElement ( catfile ) ; parseCatalog ( catfile ) ; } }", "nl": "Load the system catalog files ."}}
{"translation": {"code": "public synchronized void parseCatalog ( URL aUrl ) throws IOException { catalogCwd = aUrl ; base = aUrl ; default_override = catalogManager . getPreferPublic ( ) ; catalogManager . debug . message ( 4 , \"Parse catalog: \" + aUrl . toString ( ) ) ; DataInputStream inStream = null ; boolean parsed = false ; for ( int count = 0 ; ! parsed && count < readerArr . size ( ) ; count ++ ) { CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; try { inStream = new DataInputStream ( aUrl . openStream ( ) ) ; } catch ( FileNotFoundException fnfe ) { // No catalog; give up! break ; } try { reader . readCatalog ( this , inStream ) ; parsed = true ; } catch ( CatalogException ce ) { if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { // give up! break ; } else { // try again! } } try { inStream . close ( ) ; } catch ( IOException e ) { //nop } } if ( parsed ) parsePendingCatalogs ( ) ; }", "nl": "Parse a catalog document augmenting internal data structures ."}}
{"translation": {"code": "protected synchronized void parsePendingCatalogs ( ) throws MalformedURLException , IOException { if ( ! localCatalogFiles . isEmpty ( ) ) { // Move all the localCatalogFiles into the front of // the catalogFiles queue Vector newQueue = new Vector ( ) ; Enumeration q = localCatalogFiles . elements ( ) ; while ( q . hasMoreElements ( ) ) { newQueue . addElement ( q . nextElement ( ) ) ; } // Put the rest of the catalogs on the end of the new list for ( int curCat = 0 ; curCat < catalogFiles . size ( ) ; curCat ++ ) { String catfile = ( String ) catalogFiles . elementAt ( curCat ) ; newQueue . addElement ( catfile ) ; } catalogFiles = newQueue ; localCatalogFiles . clear ( ) ; } // Suppose there are no catalog files to process, but the // single catalog already parsed included some delegate // entries? Make sure they don't get lost. if ( catalogFiles . isEmpty ( ) && ! localDelegate . isEmpty ( ) ) { Enumeration e = localDelegate . elements ( ) ; while ( e . hasMoreElements ( ) ) { catalogEntries . addElement ( e . nextElement ( ) ) ; } localDelegate . clear ( ) ; } // Now process all the files on the catalogFiles vector. This // vector can grow during processing if CATALOG entries are // encountered in the catalog while ( ! catalogFiles . isEmpty ( ) ) { String catfile = ( String ) catalogFiles . elementAt ( 0 ) ; try { catalogFiles . remove ( 0 ) ; } catch ( ArrayIndexOutOfBoundsException e ) { // can't happen } if ( catalogEntries . size ( ) == 0 && catalogs . size ( ) == 0 ) { // We haven't parsed any catalogs yet, let this // catalog be the first... try { parseCatalogFile ( catfile ) ; } catch ( CatalogException ce ) { System . out . println ( \"FIXME: \" + ce . toString ( ) ) ; } } else { // This is a subordinate catalog. We save its name, // but don't bother to load it unless it's necessary. catalogs . addElement ( catfile ) ; } if ( ! localCatalogFiles . isEmpty ( ) ) { // Move all the localCatalogFiles into the front of // the catalogFiles queue Vector newQueue = new Vector ( ) ; Enumeration q = localCatalogFiles . elements ( ) ; while ( q . hasMoreElements ( ) ) { newQueue . addElement ( q . nextElement ( ) ) ; } // Put the rest of the catalogs on the end of the new list for ( int curCat = 0 ; curCat < catalogFiles . size ( ) ; curCat ++ ) { catfile = ( String ) catalogFiles . elementAt ( curCat ) ; newQueue . addElement ( catfile ) ; } catalogFiles = newQueue ; localCatalogFiles . clear ( ) ; } if ( ! localDelegate . isEmpty ( ) ) { Enumeration e = localDelegate . elements ( ) ; while ( e . hasMoreElements ( ) ) { catalogEntries . addElement ( e . nextElement ( ) ) ; } localDelegate . clear ( ) ; } } // We've parsed them all, reinit the vector... catalogFiles . clear ( ) ; }", "nl": "Parse all of the pending catalogs ."}}
{"translation": {"code": "protected synchronized void parseCatalogFile ( String fileName ) throws MalformedURLException , IOException , CatalogException { // The base-base is the cwd. If the catalog file is specified // with a relative path, this assures that it gets resolved // properly... try { // tack on a basename because URLs point to files not dirs String userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; catalogCwd = new URL ( \"file:\" + userdir + \"/basename\" ) ; } catch ( MalformedURLException e ) { String userdir = fixSlashes ( System . getProperty ( \"user.dir\" ) ) ; catalogManager . debug . message ( 1 , \"Malformed URL on cwd\" , userdir ) ; catalogCwd = null ; } // The initial base URI is the location of the catalog file try { base = new URL ( catalogCwd , fixSlashes ( fileName ) ) ; } catch ( MalformedURLException e ) { try { base = new URL ( \"file:\" + fixSlashes ( fileName ) ) ; } catch ( MalformedURLException e2 ) { catalogManager . debug . message ( 1 , \"Malformed URL on catalog filename\" , fixSlashes ( fileName ) ) ; base = null ; } } catalogManager . debug . message ( 2 , \"Loading catalog\" , fileName ) ; catalogManager . debug . message ( 4 , \"Default BASE\" , base . toString ( ) ) ; fileName = base . toString ( ) ; DataInputStream inStream = null ; boolean parsed = false ; boolean notFound = false ; for ( int count = 0 ; ! parsed && count < readerArr . size ( ) ; count ++ ) { CatalogReader reader = ( CatalogReader ) readerArr . get ( count ) ; try { notFound = false ; inStream = new DataInputStream ( base . openStream ( ) ) ; } catch ( FileNotFoundException fnfe ) { // No catalog; give up! notFound = true ; break ; } try { reader . readCatalog ( this , inStream ) ; parsed = true ; } catch ( CatalogException ce ) { if ( ce . getExceptionType ( ) == CatalogException . PARSE_FAILED ) { // give up! break ; } else { // try again! } } try { inStream . close ( ) ; } catch ( IOException e ) { //nop } } if ( ! parsed ) { if ( notFound ) { catalogManager . debug . message ( 3 , \"Catalog does not exist\" , fileName ) ; } else { catalogManager . debug . message ( 1 , \"Failed to parse catalog\" , fileName ) ; } } }", "nl": "Parse a single catalog file augmenting internal data structures ."}}
{"translation": {"code": "public void unknownEntry ( Vector strings ) { if ( strings != null && strings . size ( ) > 0 ) { String keyword = ( String ) strings . elementAt ( 0 ) ; catalogManager . debug . message ( 2 , \"Unrecognized token parsing catalog\" , keyword ) ; } }", "nl": "Handle unknown CatalogEntry types ."}}
{"translation": {"code": "public void parseAllCatalogs ( ) throws MalformedURLException , IOException { // Parse all the subordinate catalogs for ( int catPos = 0 ; catPos < catalogs . size ( ) ; catPos ++ ) { Catalog c = null ; try { c = ( Catalog ) catalogs . elementAt ( catPos ) ; } catch ( ClassCastException e ) { String catfile = ( String ) catalogs . elementAt ( catPos ) ; c = newCatalog ( ) ; c . parseCatalog ( catfile ) ; catalogs . setElementAt ( c , catPos ) ; c . parseAllCatalogs ( ) ; } } // Parse all the DELEGATE catalogs Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == DELEGATE_PUBLIC || e . getEntryType ( ) == DELEGATE_SYSTEM || e . getEntryType ( ) == DELEGATE_URI ) { Catalog dcat = newCatalog ( ) ; dcat . parseCatalog ( e . getEntryArg ( 1 ) ) ; } } }", "nl": "Parse all subordinate catalogs ."}}
{"translation": {"code": "public String resolveDoctype ( String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { String resolved = null ; catalogManager . debug . message ( 3 , \"resolveDoctype(\" + entityName + \",\" + publicId + \",\" + systemId + \")\" ) ; systemId = normalizeURI ( systemId ) ; if ( publicId != null && publicId . startsWith ( \"urn:publicid:\" ) ) { publicId = PublicId . decodeURN ( publicId ) ; } if ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { systemId = PublicId . decodeURN ( systemId ) ; if ( publicId != null && ! publicId . equals ( systemId ) ) { catalogManager . debug . message ( 1 , \"urn:publicid: system identifier differs from public identifier; using public identifier\" ) ; systemId = null ; } else { publicId = systemId ; systemId = null ; } } if ( systemId != null ) { // If there's a SYSTEM entry in this catalog, use it resolved = resolveLocalSystem ( systemId ) ; if ( resolved != null ) { return resolved ; } } if ( publicId != null ) { // If there's a PUBLIC entry in this catalog, use it resolved = resolveLocalPublic ( DOCTYPE , entityName , publicId , systemId ) ; if ( resolved != null ) { return resolved ; } } // If there's a DOCTYPE entry in this catalog, use it boolean over = default_override ; Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == OVERRIDE ) { over = e . getEntryArg ( 0 ) . equalsIgnoreCase ( \"YES\" ) ; continue ; } if ( e . getEntryType ( ) == DOCTYPE && e . getEntryArg ( 0 ) . equals ( entityName ) ) { if ( over || systemId == null ) { return e . getEntryArg ( 1 ) ; } } } // Otherwise, look in the subordinate catalogs return resolveSubordinateCatalogs ( DOCTYPE , entityName , publicId , systemId ) ; }", "nl": "Return the applicable DOCTYPE system identifier ."}}
{"translation": {"code": "public String resolveDocument ( ) throws MalformedURLException , IOException { // If there's a DOCUMENT entry, return it catalogManager . debug . message ( 3 , \"resolveDocument\" ) ; Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == DOCUMENT ) { return e . getEntryArg ( 1 ) ; //FIXME check this } } return resolveSubordinateCatalogs ( DOCUMENT , null , null , null ) ; }", "nl": "Return the applicable DOCUMENT entry ."}}
{"translation": {"code": "public String resolveSystem ( String systemId ) throws MalformedURLException , IOException { catalogManager . debug . message ( 3 , \"resolveSystem(\" + systemId + \")\" ) ; systemId = normalizeURI ( systemId ) ; if ( systemId != null && systemId . startsWith ( \"urn:publicid:\" ) ) { systemId = PublicId . decodeURN ( systemId ) ; return resolvePublic ( systemId , null ) ; } // If there's a SYSTEM entry in this catalog, use it if ( systemId != null ) { String resolved = resolveLocalSystem ( systemId ) ; if ( resolved != null ) { return resolved ; } } // Otherwise, look in the subordinate catalogs return resolveSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; }", "nl": "Return the applicable SYSTEM system identifier ."}}
{"translation": {"code": "public Object getValue ( ) { try { ClassLoader loader = Thread . currentThread ( ) . getContextClassLoader ( ) ; String classname = getAsText ( ) ; Class < ? > type = loader . loadClass ( classname ) ; return type ; } catch ( Exception e ) { throw new NestedRuntimeException ( e ) ; } }", "nl": "Returns a Class for the input object converted to a string ."}}
{"translation": {"code": "public boolean add ( final Object obj ) { maintain ( ) ; SoftObject soft = SoftObject . create ( obj , queue ) ; return collection . add ( soft ) ; }", "nl": "Add an object to the collection ."}}
{"translation": {"code": "public static LongCounter makeSynchronized ( final LongCounter counter ) { return new Wrapper ( counter ) { /** The serialVersionUID */ private static final long serialVersionUID = 8903330696503363758L ; public synchronized long increment ( ) { return this . counter . increment ( ) ; } public synchronized long decrement ( ) { return this . counter . decrement ( ) ; } public synchronized long getCount ( ) { return this . counter . getCount ( ) ; } public synchronized void reset ( ) { this . counter . reset ( ) ; } public synchronized int hashCode ( ) { return this . counter . hashCode ( ) ; } public synchronized boolean equals ( final Object obj ) { return this . counter . equals ( obj ) ; } public synchronized String toString ( ) { return this . counter . toString ( ) ; } public synchronized Object clone ( ) { return this . counter . clone ( ) ; } } ; }", "nl": "Return a synchronized counter ."}}
{"translation": {"code": "public static LongCounter makeDirectional ( final LongCounter counter , final boolean increasing ) { LongCounter temp ; if ( increasing ) { temp = new Wrapper ( counter ) { /** The serialVersionUID */ private static final long serialVersionUID = - 8902748795144754375L ; public long decrement ( ) { throw new UnsupportedOperationException ( ) ; } public void reset ( ) { throw new UnsupportedOperationException ( ) ; } } ; } else { temp = new Wrapper ( counter ) { /** The serialVersionUID */ private static final long serialVersionUID = 2584758778978644599L ; public long increment ( ) { throw new UnsupportedOperationException ( ) ; } } ; } return temp ; }", "nl": "Returns a directional counter ."}}
{"translation": {"code": "public static Element getOptionalChild ( Element element , String tagName ) throws Exception { return getOptionalChild ( element , tagName , null ) ; }", "nl": "Gets the child of the specified element having the specified name . If the child with this name doesn t exist then null is returned instead ."}}
{"translation": {"code": "public void printStackTrace ( final PrintWriter writer ) { if ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) { super . printStackTrace ( writer ) ; } NestedThrowable . Util . print ( nested , writer ) ; }", "nl": "Prints the composite message and the embedded stack trace to the specified print writer ."}}
{"translation": {"code": "public static String getUniqueChildContent ( Element element , String tagName ) throws Exception { return getElementContent ( getUniqueChild ( element , tagName ) ) ; }", "nl": "Macro to get the content of a unique child element ."}}
{"translation": {"code": "public static String getOptionalChildContent ( Element element , String tagName ) throws Exception { return getElementContent ( getOptionalChild ( element , tagName ) ) ; }", "nl": "Macro to get the content of an optional child element ."}}
{"translation": {"code": "public void setMaximumQueueSize ( int size ) { // Reset the executor work queue ArrayList tmp = new ArrayList ( ) ; queue . drainTo ( tmp ) ; queue = new LinkedBlockingQueue ( size ) ; queue . addAll ( tmp ) ; ThreadFactory tf = executor . getThreadFactory ( ) ; RejectedExecutionHandler handler = executor . getRejectedExecutionHandler ( ) ; long keepAlive = executor . getKeepAliveTime ( TimeUnit . SECONDS ) ; int cs = executor . getCorePoolSize ( ) ; int mcs = executor . getMaximumPoolSize ( ) ; executor = new ThreadPoolExecutor ( cs , mcs , keepAlive , TimeUnit . SECONDS , queue ) ; executor . setThreadFactory ( tf ) ; executor . setRejectedExecutionHandler ( handler ) ; }", "nl": "This resets the work queue capacity . This requires recreating the work queue and ThreadPoolExecutor so this needs to be called before doing any work with the pool ."}}
{"translation": {"code": "public void setBlockingMode ( String name ) { blockingMode = BlockingMode . toBlockingMode ( name ) ; if ( blockingMode == null ) blockingMode = BlockingMode . ABORT ; }", "nl": "For backward compatibility with the previous string based mode"}}
{"translation": {"code": "public void setBlockingModeString ( String name ) { blockingMode = BlockingMode . toBlockingMode ( name ) ; if ( blockingMode == null ) blockingMode = BlockingMode . ABORT ; }", "nl": "For backward compatibility with the previous string based mode This is needed for microcontainer as it gets confused with overloaded setters ."}}
{"translation": {"code": "protected void execute ( TaskWrapper wrapper ) { if ( trace ) log . trace ( \"execute, wrapper=\" + wrapper ) ; try { executor . execute ( wrapper ) ; } catch ( Throwable t ) { wrapper . rejectTask ( new ThreadPoolFullException ( \"Error scheduling work: \" + wrapper , t ) ) ; } }", "nl": "Execute a task"}}
{"translation": {"code": "public String resolveSystem ( String systemId ) throws MalformedURLException , IOException { String resolved = super . resolveSystem ( systemId ) ; if ( resolved != null ) { return resolved ; } Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == RESOLVER ) { resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } else if ( e . getEntryType ( ) == SYSTEMSUFFIX ) { String suffix = e . getEntryArg ( 0 ) ; String result = e . getEntryArg ( 1 ) ; if ( suffix . length ( ) <= systemId . length ( ) && systemId . substring ( systemId . length ( ) - suffix . length ( ) ) . equals ( suffix ) ) { return result ; } } } return resolveSubordinateCatalogs ( Catalog . SYSTEM , null , null , systemId ) ; }", "nl": "Return the applicable SYSTEM system identifier resorting to external RESOLVERs if necessary ."}}
{"translation": {"code": "public String resolvePublic ( String publicId , String systemId ) throws MalformedURLException , IOException { String resolved = super . resolvePublic ( publicId , systemId ) ; if ( resolved != null ) { return resolved ; } Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == RESOLVER ) { if ( systemId != null ) { resolved = resolveExternalSystem ( systemId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } resolved = resolveExternalPublic ( publicId , e . getEntryArg ( 0 ) ) ; if ( resolved != null ) { return resolved ; } } } return resolveSubordinateCatalogs ( Catalog . PUBLIC , null , publicId , systemId ) ; }", "nl": "Return the applicable PUBLIC or SYSTEM identifier resorting to external resolvers if necessary ."}}
{"translation": {"code": "protected String resolveExternalSystem ( String systemId , String resolver ) throws MalformedURLException , IOException { Resolver r = queryResolver ( resolver , \"i2l\" , systemId , null ) ; if ( r != null ) { return r . resolveSystem ( systemId ) ; } else { return null ; } }", "nl": "Query an external RFC2483 resolver for a system identifier ."}}
{"translation": {"code": "protected String resolveExternalPublic ( String publicId , String resolver ) throws MalformedURLException , IOException { Resolver r = queryResolver ( resolver , \"fpi2l\" , publicId , null ) ; if ( r != null ) { return r . resolvePublic ( publicId , null ) ; } else { return null ; } }", "nl": "Query an external RFC2483 resolver for a public identifier ."}}
{"translation": {"code": "protected Resolver queryResolver ( String resolver , String command , String arg1 , String arg2 ) { String RFC2483 = resolver + \"?command=\" + command + \"&format=tr9401&uri=\" + arg1 + \"&uri2=\" + arg2 ; try { URL url = new URL ( RFC2483 ) ; URLConnection urlCon = url . openConnection ( ) ; urlCon . setUseCaches ( false ) ; Resolver r = ( Resolver ) newCatalog ( ) ; String cType = urlCon . getContentType ( ) ; // I don't care about the character set or subtype if ( cType . indexOf ( \";\" ) > 0 ) { cType = cType . substring ( 0 , cType . indexOf ( \";\" ) ) ; } r . parseCatalog ( cType , urlCon . getInputStream ( ) ) ; return r ; } catch ( CatalogException cex ) { if ( cex . getExceptionType ( ) == CatalogException . UNPARSEABLE ) { catalogManager . debug . message ( 1 , \"Unparseable catalog: \" + RFC2483 ) ; } else if ( cex . getExceptionType ( ) == CatalogException . UNKNOWN_FORMAT ) { catalogManager . debug . message ( 1 , \"Unknown catalog format: \" + RFC2483 ) ; } return null ; } catch ( MalformedURLException mue ) { catalogManager . debug . message ( 1 , \"Malformed resolver URL: \" + RFC2483 ) ; return null ; } catch ( IOException ie ) { catalogManager . debug . message ( 1 , \"I/O Exception opening resolver: \" + RFC2483 ) ; return null ; } }", "nl": "Query an external RFC2483 resolver ."}}
{"translation": {"code": "private Vector appendVector ( Vector vec , Vector appvec ) { if ( appvec != null ) { for ( int count = 0 ; count < appvec . size ( ) ; count ++ ) { vec . addElement ( appvec . elementAt ( count ) ) ; } } return vec ; }", "nl": "Append two vectors returning the result ."}}
{"translation": {"code": "public Vector resolveAllSystemReverse ( String systemId ) throws MalformedURLException , IOException { Vector resolved = new Vector ( ) ; // If there's a SYSTEM entry in this catalog, use it if ( systemId != null ) { Vector localResolved = resolveLocalSystemReverse ( systemId ) ; resolved = appendVector ( resolved , localResolved ) ; } // Otherwise, look in the subordinate catalogs Vector subResolved = resolveAllSubordinateCatalogs ( SYSTEMREVERSE , null , null , systemId ) ; return appendVector ( resolved , subResolved ) ; }", "nl": "Find the URNs for a given system identifier in all catalogs ."}}
{"translation": {"code": "public String resolveSystemReverse ( String systemId ) throws MalformedURLException , IOException { Vector resolved = resolveAllSystemReverse ( systemId ) ; if ( resolved != null && resolved . size ( ) > 0 ) { return ( String ) resolved . elementAt ( 0 ) ; } else { return null ; } }", "nl": "Find the URN for a given system identifier ."}}
{"translation": {"code": "public Vector resolveAllSystem ( String systemId ) throws MalformedURLException , IOException { Vector resolutions = new Vector ( ) ; // If there are SYSTEM entries in this catalog, start with them if ( systemId != null ) { Vector localResolutions = resolveAllLocalSystem ( systemId ) ; resolutions = appendVector ( resolutions , localResolutions ) ; } // Then look in the subordinate catalogs Vector subResolutions = resolveAllSubordinateCatalogs ( SYSTEM , null , null , systemId ) ; resolutions = appendVector ( resolutions , subResolutions ) ; if ( resolutions . size ( ) > 0 ) { return resolutions ; } else { return null ; } }", "nl": "Return the applicable SYSTEM system identifiers ."}}
{"translation": {"code": "private Vector resolveAllLocalSystem ( String systemId ) { Vector map = new Vector ( ) ; String osname = System . getProperty ( \"os.name\" ) ; boolean windows = ( osname . indexOf ( \"Windows\" ) >= 0 ) ; Enumeration enumt = catalogEntries . elements ( ) ; while ( enumt . hasMoreElements ( ) ) { CatalogEntry e = ( CatalogEntry ) enumt . nextElement ( ) ; if ( e . getEntryType ( ) == SYSTEM && ( e . getEntryArg ( 0 ) . equals ( systemId ) || ( windows && e . getEntryArg ( 0 ) . equalsIgnoreCase ( systemId ) ) ) ) { map . addElement ( e . getEntryArg ( 1 ) ) ; } } if ( map . size ( ) == 0 ) { return null ; } else { return map ; } }", "nl": "Return all applicable SYSTEM system identifiers in this catalog ."}}
{"translation": {"code": "private synchronized Vector resolveAllSubordinateCatalogs ( int entityType , String entityName , String publicId , String systemId ) throws MalformedURLException , IOException { Vector resolutions = new Vector ( ) ; for ( int catPos = 0 ; catPos < catalogs . size ( ) ; catPos ++ ) { Resolver c = null ; try { c = ( Resolver ) catalogs . elementAt ( catPos ) ; } catch ( ClassCastException e ) { String catfile = ( String ) catalogs . elementAt ( catPos ) ; c = ( Resolver ) newCatalog ( ) ; try { c . parseCatalog ( catfile ) ; } catch ( MalformedURLException mue ) { catalogManager . debug . message ( 1 , \"Malformed Catalog URL\" , catfile ) ; } catch ( FileNotFoundException fnfe ) { catalogManager . debug . message ( 1 , \"Failed to load catalog, file not found\" , catfile ) ; } catch ( IOException ioe ) { catalogManager . debug . message ( 1 , \"Failed to load catalog, I/O error\" , catfile ) ; } catalogs . setElementAt ( c , catPos ) ; } String resolved = null ; // Ok, now what are we supposed to call here? if ( entityType == DOCTYPE ) { resolved = c . resolveDoctype ( entityName , publicId , systemId ) ; if ( resolved != null ) { // Only find one DOCTYPE resolution resolutions . addElement ( resolved ) ; return resolutions ; } } else if ( entityType == DOCUMENT ) { resolved = c . resolveDocument ( ) ; if ( resolved != null ) { // Only find one DOCUMENT resolution resolutions . addElement ( resolved ) ; return resolutions ; } } else if ( entityType == ENTITY ) { resolved = c . resolveEntity ( entityName , publicId , systemId ) ; if ( resolved != null ) { // Only find one ENTITY resolution resolutions . addElement ( resolved ) ; return resolutions ; } } else if ( entityType == NOTATION ) { resolved = c . resolveNotation ( entityName , publicId , systemId ) ; if ( resolved != null ) { // Only find one NOTATION resolution resolutions . addElement ( resolved ) ; return resolutions ; } } else if ( entityType == PUBLIC ) { resolved = c . resolvePublic ( publicId , systemId ) ; if ( resolved != null ) { // Only find one PUBLIC resolution resolutions . addElement ( resolved ) ; return resolutions ; } } else if ( entityType == SYSTEM ) { Vector localResolutions = c . resolveAllSystem ( systemId ) ; resolutions = appendVector ( resolutions , localResolutions ) ; break ; } else if ( entityType == SYSTEMREVERSE ) { Vector localResolutions = c . resolveAllSystemReverse ( systemId ) ; resolutions = appendVector ( resolutions , localResolutions ) ; } } if ( resolutions != null ) { return resolutions ; } else { return null ; } }", "nl": "Search the subordinate catalogs in order looking for all match ."}}
{"translation": {"code": "public void readCatalog ( Catalog catalog , String fileUrl ) throws MalformedURLException , IOException , CatalogException { URL url = null ; try { url = new URL ( fileUrl ) ; } catch ( MalformedURLException e ) { url = new URL ( \"file:///\" + fileUrl ) ; } debug = catalog . getCatalogManager ( ) . debug ; try { URLConnection urlCon = url . openConnection ( ) ; readCatalog ( catalog , urlCon . getInputStream ( ) ) ; } catch ( FileNotFoundException e ) { catalog . getCatalogManager ( ) . debug . message ( 1 , \"Failed to load catalog, file not found\" , url . toString ( ) ) ; } }", "nl": "Parse an XML Catalog file ."}}
{"translation": {"code": "public void readCatalog ( Catalog catalog , InputStream is ) throws IOException , CatalogException { // Create an instance of the parser if ( parserFactory == null && parserClass == null ) { debug . message ( 1 , \"Cannot read SAX catalog without a parser\" ) ; throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } debug = catalog . getCatalogManager ( ) . debug ; EntityResolver bResolver = catalog . getCatalogManager ( ) . getBootstrapResolver ( ) ; this . catalog = catalog ; try { if ( parserFactory != null ) { SAXParser parser = parserFactory . newSAXParser ( ) ; SAXParserHandler spHandler = new SAXParserHandler ( ) ; spHandler . setContentHandler ( this ) ; if ( bResolver != null ) { spHandler . setEntityResolver ( bResolver ) ; } parser . parse ( new InputSource ( is ) , spHandler ) ; } else { Parser parser = ( Parser ) Class . forName ( parserClass ) . newInstance ( ) ; parser . setDocumentHandler ( this ) ; if ( bResolver != null ) { parser . setEntityResolver ( bResolver ) ; } parser . parse ( new InputSource ( is ) ) ; } } catch ( ClassNotFoundException cnfe ) { throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( IllegalAccessException iae ) { throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( InstantiationException ie ) { throw new CatalogException ( CatalogException . UNPARSEABLE ) ; } catch ( ParserConfigurationException pce ) { throw new CatalogException ( CatalogException . UNKNOWN_FORMAT ) ; } catch ( SAXException se ) { Exception e = se . getException ( ) ; // FIXME: there must be a better way UnknownHostException uhe = new UnknownHostException ( ) ; FileNotFoundException fnfe = new FileNotFoundException ( ) ; if ( e != null ) { if ( e . getClass ( ) == uhe . getClass ( ) ) { throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; } else if ( e . getClass ( ) == fnfe . getClass ( ) ) { throw new CatalogException ( CatalogException . PARSE_FAILED , e . toString ( ) ) ; } } throw new CatalogException ( se ) ; } }", "nl": "Parse an XML Catalog stream ."}}
{"translation": {"code": "public static Element getUniqueChild ( Element element , String tagName ) throws Exception { Iterator goodChildren = getChildrenByTagName ( element , tagName ) ; if ( goodChildren != null && goodChildren . hasNext ( ) ) { Element child = ( Element ) goodChildren . next ( ) ; if ( goodChildren . hasNext ( ) ) { throw new Exception ( \"expected only one \" + tagName + \" tag\" ) ; } return child ; } else { throw new Exception ( \"expected one \" + tagName + \" tag\" ) ; } }", "nl": "Gets the child of the specified element having the specified unique name . If there are more than one children elements with the same name and exception is thrown ."}}
{"translation": {"code": "public static Iterator getChildrenByTagName ( Element element , String tagName ) { if ( element == null ) return null ; // getElementsByTagName gives the corresponding elements in the whole  // descendance. We want only children NodeList children = element . getChildNodes ( ) ; ArrayList goodChildren = new ArrayList ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node currentChild = children . item ( i ) ; if ( currentChild . getNodeType ( ) == Node . ELEMENT_NODE && ( ( Element ) currentChild ) . getTagName ( ) . equals ( tagName ) ) { goodChildren . add ( currentChild ) ; } } return goodChildren . iterator ( ) ; }", "nl": "Returns an iterator over the children of the given element with the given tag name ."}}
{"translation": {"code": "public static String getElementContent ( Element element , String defaultStr ) throws Exception { if ( element == null ) return defaultStr ; NodeList children = element . getChildNodes ( ) ; String result = \"\" ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { if ( children . item ( i ) . getNodeType ( ) == Node . TEXT_NODE || children . item ( i ) . getNodeType ( ) == Node . CDATA_SECTION_NODE ) { result += children . item ( i ) . getNodeValue ( ) ; } else if ( children . item ( i ) . getNodeType ( ) == Node . COMMENT_NODE ) { // Ignore comment nodes } } return result . trim ( ) ; }", "nl": "Get the content of the given element ."}}
{"translation": {"code": "public synchronized void setResolution ( int resolution ) { if ( resolution <= 0 ) resolution = 60 ; if ( resolution != this . resolution ) { this . resolution = resolution ; theTimer . cancel ( ) ; theTimer = new ResolutionTimer ( ) ; resolutionTimer . scheduleAtFixedRate ( theTimer , 0 , 1000 * resolution ) ; } }", "nl": "Set the cache timer resolution"}}
{"translation": {"code": "protected boolean inExtensionNamespace ( ) { boolean inExtension = false ; Enumeration elements = namespaceStack . elements ( ) ; while ( ! inExtension && elements . hasMoreElements ( ) ) { String ns = ( String ) elements . nextElement ( ) ; if ( ns == null ) { inExtension = true ; } else { inExtension = ( ! ns . equals ( tr9401NamespaceName ) && ! ns . equals ( namespaceName ) ) ; } } return inExtension ; }", "nl": "Are we in an extension namespace?"}}
{"translation": {"code": "public void checkNotification ( int result ) { // Is a notification required? chunk += result ; if ( chunk >= chunkSize ) { if ( listener != null ) listener . onStreamNotification ( this , chunk ) ; // Start a new chunk chunk = 0 ; } }", "nl": "Checks whether a notification is required and notifies as appropriate"}}
{"translation": {"code": "public TimedEntry peekEntry ( Object key ) { TimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; return entry ; }", "nl": "Get the raw TimedEntry for key without performing any expiration check ."}}
{"translation": {"code": "public Object getObjectInstance ( Object obj , Name name , Context nameCtx , Hashtable env ) throws Exception { // Get the nns value from the Reference obj and use it as the map key Reference ref = ( Reference ) obj ; RefAddr addr = ref . get ( \"nns\" ) ; String key = ( String ) addr . getContent ( ) ; Object target = wrapperMap . get ( key ) ; return target ; }", "nl": "Transform the obj Reference bound into the JNDI namespace into the actual non - Serializable object ."}}
{"translation": {"code": "public static String subst ( final StringBuffer buff , final String string , final Map map , final String beginToken , final String endToken ) { int begin = 0 , rangeEnd = 0 ; Range range ; while ( ( range = rangeOf ( beginToken , endToken , string , rangeEnd ) ) != null ) { // append the first part of the string buff . append ( string . substring ( begin , range . begin ) ) ; // Get the string to replace from the map String key = string . substring ( range . begin + beginToken . length ( ) , range . end ) ; Object value = map . get ( key ) ; // if mapping does not exist then use empty; if ( value == null ) value = EMPTY ; // append the replaced string buff . append ( value ) ; // update positions begin = range . end + endToken . length ( ) ; rangeEnd = begin ; } // append the rest of the string buff . append ( string . substring ( begin , string . length ( ) ) ) ; return buff . toString ( ) ; }", "nl": "Substitute sub - strings in side of a string ."}}
{"translation": {"code": "public static String [ ] split ( final String string , final String delim , final int limit ) { // get the count of delim in string, if count is > limit  // then use limit for count.  The number of delimiters is less by one // than the number of elements, so add one to count. int count = count ( string , delim ) + 1 ; if ( limit > 0 && count > limit ) { count = limit ; } String strings [ ] = new String [ count ] ; int begin = 0 ; for ( int i = 0 ; i < count ; i ++ ) { // get the next index of delim int end = string . indexOf ( delim , begin ) ; // if the end index is -1 or if this is the last element // then use the string's length for the end index if ( end == - 1 || i + 1 == count ) end = string . length ( ) ; // if end is 0, then the first element is empty if ( end == 0 ) strings [ i ] = EMPTY ; else strings [ i ] = string . substring ( begin , end ) ; // update the begining index begin = end + 1 ; } return strings ; }", "nl": "Split up a string into multiple strings based on a delimiter ."}}
{"translation": {"code": "public static String join ( final byte array [ ] ) { Byte bytes [ ] = new Byte [ array . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { bytes [ i ] = new Byte ( array [ i ] ) ; } return join ( bytes , null ) ; }", "nl": "Convert and join an array of bytes into one string ."}}
{"translation": {"code": "public void printStackTrace ( final PrintStream stream ) { if ( nested == null || NestedThrowable . PARENT_TRACE_ENABLED ) { super . printStackTrace ( stream ) ; } NestedThrowable . Util . print ( nested , stream ) ; }", "nl": "Prints the composite message and the embedded stack trace to the specified print stream ."}}
{"translation": {"code": "public Object getValue ( ) { String text = getAsText ( ) ; BlockingMode mode = BlockingMode . toBlockingMode ( text ) ; return mode ; }", "nl": "Returns a BlockingMode for the input object converted to a string ."}}
{"translation": {"code": "public void create ( ) { if ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; else entryMap = new HashMap ( ) ; now = System . currentTimeMillis ( ) ; }", "nl": "Initializes the cache for use . Prior to this the cache has no store ."}}
{"translation": {"code": "public Object get ( Object key ) { TimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; if ( entry == null ) return null ; if ( entry . isCurrent ( now ) == false ) { // Try to refresh the entry if ( entry . refresh ( ) == false ) { // Failed, remove the entry and return null entry . destroy ( ) ; entryMap . remove ( key ) ; return null ; } } Object value = entry . getValue ( ) ; return value ; }", "nl": "Get the cache value for key if it has not expired . If the TimedEntry is expired its destroy method is called and then removed from the cache ."}}
{"translation": {"code": "public Object peek ( Object key ) { TimedEntry entry = ( TimedEntry ) entryMap . get ( key ) ; Object value = null ; if ( entry != null ) value = entry . getValue ( ) ; return value ; }", "nl": "Get the cache value for key . This method does not check to see if the entry has expired ."}}
{"translation": {"code": "public void remove ( Object key ) { TimedEntry entry = ( TimedEntry ) entryMap . remove ( key ) ; if ( entry != null ) entry . destroy ( ) ; }", "nl": "Remove the entry associated with key and call destroy on the entry if found ."}}
{"translation": {"code": "public List getValidKeys ( ) { ArrayList validKeys = new ArrayList ( ) ; synchronized ( entryMap ) { Iterator iter = entryMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; TimedEntry value = ( TimedEntry ) entry . getValue ( ) ; if ( value . isCurrent ( now ) == true ) validKeys . add ( entry . getKey ( ) ) ; } } return validKeys ; }", "nl": "Get the list of keys for entries that are not expired ."}}
{"translation": {"code": "public static final void defaultToString ( JBossStringBuilder buffer , Object object ) { if ( object == null ) buffer . append ( \"null\" ) ; else { buffer . append ( object . getClass ( ) . getName ( ) ) ; buffer . append ( ' ' ) ; buffer . append ( Integer . toHexString ( System . identityHashCode ( object ) ) ) ; } }", "nl": "The default toString implementation of an object"}}
{"translation": {"code": "public void flush ( ) { Map tmpMap = null ; synchronized ( this ) { tmpMap = entryMap ; if ( threadSafe ) entryMap = Collections . synchronizedMap ( new HashMap ( ) ) ; else entryMap = new HashMap ( ) ; } // Notify the entries of their removal Iterator iter = tmpMap . values ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { TimedEntry entry = ( TimedEntry ) iter . next ( ) ; entry . destroy ( ) ; } tmpMap . clear ( ) ; }", "nl": "Remove all entries from the cache ."}}