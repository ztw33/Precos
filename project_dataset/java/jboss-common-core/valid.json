{"translation": {"code": "public Edge < T > findEdge ( Edge < T > e ) { if ( outgoingEdges . contains ( e ) ) return e ; else return null ; }", "nl": "Search the outgoing edges for a match to e ."}}
{"translation": {"code": "public Edge < T > findEdge ( Vertex < T > dest ) { for ( Edge < T > e : outgoingEdges ) { if ( e . getTo ( ) == dest ) return e ; } return null ; }", "nl": "Search the outgoing edges looking for an edge whose s edge . to == dest ."}}
{"translation": {"code": "public boolean remove ( Edge < T > e ) { if ( e . getFrom ( ) == this ) outgoingEdges . remove ( e ) ; else if ( e . getTo ( ) == this ) incomingEdges . remove ( e ) ; else return false ; return true ; }", "nl": "Remove an edge from this vertex"}}
{"translation": {"code": "public boolean hasEdge ( Edge < T > e ) { if ( e . getFrom ( ) == this ) return outgoingEdges . contains ( e ) ; else if ( e . getTo ( ) == this ) return incomingEdges . contains ( e ) ; else return false ; }", "nl": "Check the vertex for either an incoming or outgoing edge mathcing e ."}}
{"translation": {"code": "public void dfsSpanningTree ( Vertex < T > v , DFSVisitor < T > visitor ) { v . visit ( ) ; if ( visitor != null ) visitor . visit ( this , v ) ; for ( int i = 0 ; i < v . getOutgoingEdgeCount ( ) ; i ++ ) { Edge < T > e = v . getOutgoingEdge ( i ) ; if ( ! e . getTo ( ) . visited ( ) ) { if ( visitor != null ) visitor . visit ( this , v , e ) ; e . mark ( ) ; dfsSpanningTree ( e . getTo ( ) , visitor ) ; } } }", "nl": "Find the spanning tree using a DFS starting from v ."}}
{"translation": {"code": "public void depthFirstSearch ( Vertex < T > v , final Visitor < T > visitor ) { VisitorEX < T , RuntimeException > wrapper = new VisitorEX < T , RuntimeException > ( ) { public void visit ( Graph < T > g , Vertex < T > v ) throws RuntimeException { if ( visitor != null ) visitor . visit ( g , v ) ; } } ; this . depthFirstSearch ( v , wrapper ) ; }", "nl": "Perform a depth first serach using recursion ."}}
{"translation": {"code": "public boolean addVertex ( Vertex < T > v ) { if ( verticies . containsValue ( v ) == false ) { verticies . put ( v . getName ( ) , v ) ; return true ; } return false ; }", "nl": "Add a vertex to the graph"}}
{"translation": {"code": "public boolean addEdge ( Edge < T > e ) { if ( e . getFrom ( ) == this ) outgoingEdges . add ( e ) ; else if ( e . getTo ( ) == this ) incomingEdges . add ( e ) ; else return false ; return true ; }", "nl": "Add an edge to the vertex . If edge . from is this vertex its an outgoing edge . If edge . to is this vertex its an incoming edge . If neither from or to is this vertex the edge is not added ."}}
{"translation": {"code": "public Vertex < T > findVertexByData ( T data , Comparator < T > compare ) { Vertex < T > match = null ; for ( Vertex < T > v : verticies . values ( ) ) { if ( compare . compare ( data , v . getData ( ) ) == 0 ) { match = v ; break ; } } return match ; }", "nl": "Search the verticies for one with data ."}}
{"translation": {"code": "public void addOutgoingEdge ( Vertex < T > to , int cost ) { Edge < T > out = new Edge < T > ( this , to , cost ) ; outgoingEdges . add ( out ) ; }", "nl": "Add an outgoing edge ending at to ."}}
{"translation": {"code": "public void setRootVertex ( Vertex < T > root ) { this . rootVertex = root ; if ( verticies . containsValue ( root ) == false ) addVertex ( root ) ; }", "nl": "Set a root vertex . If root does no exist in the graph it is added ."}}
{"translation": {"code": "protected < D extends GenericDeclaration > T getTypeVariable ( TypeVariable < D > type ) { // TODO JBMICROCONT-131 improve this return get ( type . getBounds ( ) [ 0 ] ) ; }", "nl": "Get the information for a type variable"}}
{"translation": {"code": "protected T getParameterizedType ( ParameterizedType type ) { // First check if we already have it T result = peek ( type ) ; if ( result != null ) return result ; // Instantiate result = instantiate ( type ) ; // Put the perlimanary result into the cache put ( type , result ) ; // Generate the details generate ( type , result ) ; return result ; }", "nl": "Get the information for a parameterized type"}}
{"translation": {"code": "public static Class [ ] getAllUniqueInterfaces ( Class c ) { Set uniqueIfaces = new HashSet ( ) ; while ( c != null ) { Class [ ] ifaces = c . getInterfaces ( ) ; for ( int n = 0 ; n < ifaces . length ; n ++ ) { uniqueIfaces . add ( ifaces [ n ] ) ; } c = c . getSuperclass ( ) ; } return ( Class [ ] ) uniqueIfaces . toArray ( new Class [ uniqueIfaces . size ( ) ] ) ; }", "nl": "Returns an array containing all the unique interfaces implemented by the argument class c and all its superclasses . Interfaces that appear multiple times through inheritence are only accounted for once ."}}
{"translation": {"code": "public void connect ( ) throws IOException { if ( connected ) return ; if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getPath ( ) ) ; } connected = true ; }", "nl": "Checks if the underlying file for this connection exists ."}}
{"translation": {"code": "static < K , V > SoftValueRef < K , V > create ( K key , V val , ReferenceQueue < V > q ) { if ( val == null ) return null ; else return new SoftValueRef < K , V > ( key , val , q ) ; }", "nl": "Safely create a new SoftValueRef"}}
{"translation": {"code": "public static synchronized void rebind ( Name name , Object target , boolean createSubcontexts ) throws NamingException { String key = name . toString ( ) ; InitialContext ctx = new InitialContext ( ) ; if ( createSubcontexts == true && name . size ( ) > 1 ) { int size = name . size ( ) - 1 ; Util . createSubcontext ( ctx , name . getPrefix ( size ) ) ; } rebind ( ctx , key , target ) ; }", "nl": "A convenience method that simplifies the process of rebinding a non - serializable object into a JNDI context . This version binds the target object into the default IntitialContext using name path ."}}