{"translation": {"code": "public static CharArraySequence from ( final char [ ] value , final int offset , final int len ) { final char [ ] buffer = new char [ value . length ] ; System . arraycopy ( value , offset , buffer , 0 , len ) ; return new CharArraySequence ( buffer ) ; }", "nl": "Static constructor that creates a char sequence by making a copy of provided char array ."}}
{"translation": {"code": "public static int findFirstEqual ( final CharSequence source , final int index , final CharSequence match ) { for ( int i = index ; i < source . length ( ) ; i ++ ) { if ( equalsOne ( source . charAt ( i ) , match ) ) { return i ; } } return - 1 ; }", "nl": "Finds index of the first character in given charsequence the matches any from the given set of characters ."}}
{"translation": {"code": "public static boolean equalsOne ( final char c , final CharSequence match ) { for ( int i = 0 ; i < match . length ( ) ; i ++ ) { char aMatch = match . charAt ( i ) ; if ( c == aMatch ) { return true ; } } return false ; }", "nl": "Match if one character equals to any of the given character ."}}
{"translation": {"code": "public static int findFirstEqual ( final char [ ] source , final int index , final char match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( source [ i ] == match ) { return i ; } } return - 1 ; }", "nl": "Finds index of the first character in given array the matches any from the given set of characters ."}}
{"translation": {"code": "protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , true ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , false ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }", "nl": "Scans single classpath directory ."}}
{"translation": {"code": "protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( \"Invalid zip: \" + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , true ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , false ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }", "nl": "Scans classes inside single JAR archive . Archive is scanned as a zip file ."}}
{"translation": {"code": "public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }", "nl": "Specify excluded jars ."}}
{"translation": {"code": "public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }", "nl": "Returns type signature bytes used for searching in class file ."}}
{"translation": {"code": "public static void invoke ( final Object listener , final Class listenerType ) { if ( listenerType == Init . class ) { ( ( Init ) listener ) . init ( ) ; return ; } if ( listenerType == Start . class ) { ( ( Start ) listener ) . start ( ) ; return ; } if ( listenerType == Ready . class ) { ( ( Ready ) listener ) . ready ( ) ; return ; } if ( listenerType == Stop . class ) { ( ( Stop ) listener ) . stop ( ) ; return ; } throw new MadvocException ( \"Invalid listener\" ) ; }", "nl": "Invoke the listener based on type . Not very OOP but works ."}}
{"translation": {"code": "public RawData downloadableAs ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }", "nl": "Defines download file name and mime type from the name extension ."}}
{"translation": {"code": "public static JsonResult of ( final Object object ) { final String json = JsonSerializer . create ( ) . deep ( true ) . serialize ( object ) ; return new JsonResult ( json ) ; }", "nl": "Creates JSON result from given object . The object will be serialized to JSON ."}}
{"translation": {"code": "public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }", "nl": "Extracts encoding from a given content type ."}}
{"translation": {"code": "public RouteChunk findOrCreateChild ( final String value ) { if ( children != null ) { for ( RouteChunk child : children ) { if ( child . get ( ) . equals ( value ) ) { return child ; } } } return add ( value ) ; }", "nl": "Finds existing chunk or creates a new one if does not exist ."}}
{"translation": {"code": "public void invoke ( final ActionRequest actionRequest ) { if ( executorService == null ) { throw new MadvocException ( \"No action is marked as async!\" ) ; } final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; log . debug ( ( ) -> \"Async call to: \" + actionRequest ) ; final AsyncContext asyncContext = servletRequest . startAsync ( ) ; executorService . submit ( ( ) -> { try { actionRequest . invoke ( ) ; } catch ( Exception ex ) { log . error ( \"Invoking async action path failed: \" , ExceptionUtil . unwrapThrowable ( ex ) ) ; } finally { asyncContext . complete ( ) ; } } ) ; }", "nl": "Invokes an action asynchronously by submitting it to the thread pool ."}}
{"translation": {"code": "public static File toContainerFile ( final URL url ) { String protocol = url . getProtocol ( ) ; if ( protocol . equals ( FILE_PROTOCOL ) ) { return toFile ( url ) ; } String path = url . getPath ( ) ; return new File ( URI . create ( path . substring ( ZERO , path . lastIndexOf ( \"!/\" ) ) ) ) ; }", "nl": "Returns a file of either a folder or a containing archive ."}}
{"translation": {"code": "public static File mkdirs ( final File dirs ) throws IOException { if ( dirs . exists ( ) ) { checkIsDirectory ( dirs ) ; return dirs ; } return checkCreateDirectory ( dirs ) ; }", "nl": "Creates all directories at once ."}}
{"translation": {"code": "public static File createTempDirectory ( final String prefix , final String suffix , final File tempDir ) throws IOException { File file = createTempFile ( prefix , suffix , tempDir ) ; file . delete ( ) ; file . mkdir ( ) ; return file ; }", "nl": "Creates temporary directory ."}}
{"translation": {"code": "public static File mkdir ( final File dir ) throws IOException { if ( dir . exists ( ) ) { checkIsDirectory ( dir ) ; return dir ; } return checkCreateDirectory ( dir ) ; }", "nl": "Creates single directory ."}}
{"translation": {"code": "private static void checkFileCopy ( final File srcFile , final File destFile ) throws IOException { checkExists ( srcFile ) ; checkIsFile ( srcFile ) ; if ( equals ( srcFile , destFile ) ) { throw new IOException ( \"Files '\" + srcFile + \"' and '\" + destFile + \"' are equal\" ) ; } File destParent = destFile . getParentFile ( ) ; if ( destParent != null && ! destParent . exists ( ) ) { checkCreateDirectory ( destParent ) ; } }", "nl": "Checks that file copy can occur ."}}
{"translation": {"code": "public static void writeBytes ( final File dest , final byte [ ] data , final int off , final int len ) throws IOException { outBytes ( dest , data , off , len , false ) ; }", "nl": "Write bytes . append = false"}}
{"translation": {"code": "private static void _copyFile ( final File srcFile , final File destFile ) throws IOException { if ( destFile . exists ( ) ) { if ( destFile . isDirectory ( ) ) { throw new IOException ( \"Destination '\" + destFile + \"' is a directory\" ) ; } } // do copy file FileInputStream input = null ; FileOutputStream output = null ; try { input = new FileInputStream ( srcFile ) ; output = new FileOutputStream ( destFile , false ) ; StreamUtil . copy ( input , output ) ; } finally { StreamUtil . close ( output ) ; StreamUtil . close ( input ) ; } // done if ( srcFile . length ( ) != destFile . length ( ) ) { throw new IOException ( \"Copy file failed of '\" + srcFile + \"' to '\" + destFile + \"' due to different sizes\" ) ; } destFile . setLastModified ( srcFile . lastModified ( ) ) ; }", "nl": "Internal file copy when most of the pre - checking has passed ."}}
{"translation": {"code": "public static char [ ] readUTFChars ( final File file ) throws IOException { checkExists ( file ) ; checkIsFile ( file ) ; UnicodeInputStream in = unicodeInputStreamOf ( file ) ; try { return StreamUtil . readChars ( in , detectEncoding ( in ) ) ; } finally { StreamUtil . close ( in ) ; } }", "nl": "Reads UTF file content as char array ."}}
{"translation": {"code": "public static void cleanDir ( final File destDir ) throws IOException { checkExists ( destDir ) ; checkIsDirectory ( destDir ) ; File [ ] files = destDir . listFiles ( ) ; if ( files == null ) { throw new IOException ( \"Failed to list contents of: \" + destDir ) ; } IOException exception = null ; for ( File file : files ) { try { if ( file . isDirectory ( ) ) { deleteDir ( file ) ; } else { file . delete ( ) ; } } catch ( IOException ioex ) { exception = ioex ; continue ; } } if ( exception != null ) { throw exception ; } }", "nl": "Cleans a directory without deleting it ."}}
{"translation": {"code": "public static void copy ( final File src , final File dest ) throws IOException { if ( src . isDirectory ( ) ) { copyDir ( src , dest ) ; return ; } if ( dest . isDirectory ( ) ) { copyFileToDir ( src , dest ) ; return ; } copyFile ( src , dest ) ; }", "nl": "Smart copy . If source is a directory copy it to destination . Otherwise if destination is directory copy source file to it . Otherwise try to copy source file to destination file ."}}
{"translation": {"code": "public static void copyDir ( final File srcDir , final File destDir ) throws IOException { checkDirCopy ( srcDir , destDir ) ; _copyDirectory ( srcDir , destDir ) ; }", "nl": "Copies directory with specified copy params ."}}
{"translation": {"code": "public static char [ ] readChars ( final File file , final String encoding ) throws IOException { checkExists ( file ) ; checkIsFile ( file ) ; InputStream in = streamOf ( file , encoding ) ; try { return StreamUtil . readChars ( in , encoding ) ; } finally { StreamUtil . close ( in ) ; } }", "nl": "Reads file content as char array ."}}
{"translation": {"code": "private void setSubject ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { if ( emailWithData . subjectEncoding ( ) != null ) { msgToSet . setSubject ( emailWithData . subject ( ) , emailWithData . subjectEncoding ( ) ) ; } else { msgToSet . setSubject ( emailWithData . subject ( ) ) ; } }", "nl": "Sets subject in msgToSet from subject in emailWithData ."}}
{"translation": {"code": "private static String removeAnyBounding ( final char s , final char e , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }", "nl": "If the string starts and ends with start and end char remove them otherwise return the string as it was passed in ."}}
{"translation": {"code": "protected String resolveContentType ( final String contentType ) { if ( contentType != null ) { return contentType ; } if ( name == null ) { return MimeTypes . MIME_APPLICATION_OCTET_STREAM ; } final String extension = FileNameUtil . getExtension ( name ) ; return MimeTypes . getMimeType ( extension ) ; }", "nl": "Resolves content type from all data ."}}
{"translation": {"code": "protected void concat ( SearchTerm searchTerm ) { if ( nextIsNot ) { searchTerm = new NotTerm ( searchTerm ) ; nextIsNot = false ; } if ( operatorAnd ) { and ( searchTerm ) ; } else { or ( searchTerm ) ; } }", "nl": "Concatenates last search term with new one ."}}
{"translation": {"code": "public EmailFilter or ( final EmailFilter ... emailFilters ) { final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; for ( int i = 0 ; i < emailFilters . length ; i ++ ) { searchTerms [ i ] = emailFilters [ i ] . searchTerm ; } concat ( new OrTerm ( searchTerms ) ) ; return this ; }", "nl": "Defines OR group of filters ."}}
{"translation": {"code": "public EmailFilter sentDate ( final Operator operator , final long milliseconds ) { final SearchTerm term = new SentDateTerm ( operator . value , new Date ( milliseconds ) ) ; concat ( term ) ; return this ; }", "nl": "Defines filter for sent date ."}}
{"translation": {"code": "public EmailFilter receivedDate ( final Operator operator , final long milliseconds ) { final SearchTerm term = new ReceivedDateTerm ( operator . value , new Date ( milliseconds ) ) ; concat ( term ) ; return this ; }", "nl": "Defines filter for received date ."}}
{"translation": {"code": "public EmailFilter flags ( final Flags flags , final boolean value ) { final SearchTerm flagTerm = new FlagTerm ( flags , value ) ; concat ( flagTerm ) ; return this ; }", "nl": "Defines filter for many flags at once ."}}
{"translation": {"code": "public T cc ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }", "nl": "Appends CC addresses ."}}
{"translation": {"code": "public String getEncodedName ( ) { if ( name == null ) { return null ; } try { return MimeUtility . encodeText ( name ) ; } catch ( final UnsupportedEncodingException ueex ) { throw new MailException ( ueex ) ; } }", "nl": "Returns encoded attachment name ."}}
{"translation": {"code": "protected void closeFolderIfOpened ( final Folder folder ) { if ( folder != null ) { try { folder . close ( true ) ; } catch ( final MessagingException ignore ) { } } }", "nl": "Closes folder if opened and expunge deleted messages ."}}
{"translation": {"code": "public Email bcc ( final EmailAddress ... bccs ) { this . bcc = ArraysUtil . join ( this . bcc , valueOrEmptyArray ( bccs ) ) ; return _this ( ) ; }", "nl": "Appends one or more BCC addresses ."}}
{"translation": {"code": "ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; } // process messages final ReceivedEmail [ ] emails = new ReceivedEmail [ messages . length ] ; for ( int i = 0 ; i < messages . length ; i ++ ) { final Message msg = messages [ i ] ; // we need to parse message BEFORE flags are set! emails [ i ] = new ReceivedEmail ( msg , envelope , attachmentStorage ) ; if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { emails [ i ] . flags ( flagsToSet ) ; msg . setFlags ( flagsToSet , true ) ; } if ( ! EmailUtil . isEmptyFlags ( flagsToUnset ) ) { emails [ i ] . flags ( ) . remove ( flagsToUnset ) ; msg . setFlags ( flagsToUnset , false ) ; } if ( EmailUtil . isEmptyFlags ( flagsToSet ) && ! emails [ i ] . isSeen ( ) ) { msg . setFlag ( Flags . Flag . SEEN , false ) ; } } if ( processedMessageConsumer != null ) { processedMessageConsumer . accept ( messages ) ; } // if messages were marked to be deleted, we need to expunge the folder if ( ! EmailUtil . isEmptyFlags ( flagsToSet ) ) { if ( flagsToSet . contains ( Flags . Flag . DELETED ) ) { folder . expunge ( ) ; } } return emails ; } catch ( final MessagingException msgexc ) { throw new MailException ( \"Failed to fetch messages\" , msgexc ) ; } }", "nl": "The main email receiving method ."}}
{"translation": {"code": "protected EmailAttachmentBuilder setContentIdFromNameIfMissing ( ) { if ( contentId == null ) { if ( name != null ) { contentId ( FileNameUtil . getName ( name ) ) ; } else { contentId ( NO_NAME ) ; } } return this ; }", "nl": "Set content ID if it is missing ."}}
{"translation": {"code": "public T textMessage ( final String text , final String encoding ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }", "nl": "Adds plain message text ."}}
{"translation": {"code": "@ Override protected IMAPSSLStore getStore ( final Session session ) { SimpleAuthenticator simpleAuthenticator = ( SimpleAuthenticator ) authenticator ; final URLName url ; if ( simpleAuthenticator == null ) { url = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , null , null ) ; } else { final PasswordAuthentication pa = simpleAuthenticator . getPasswordAuthentication ( ) ; url = new URLName ( PROTOCOL_IMAP , host , port , StringPool . EMPTY , pa . getUserName ( ) , pa . getPassword ( ) ) ; } return new IMAPSSLStore ( session , url ) ; }", "nl": "Returns email store ."}}
{"translation": {"code": "public T header ( final String name , final String value ) { headers . put ( name , value ) ; return _this ( ) ; }", "nl": "Sets header value ."}}
{"translation": {"code": "@ Override public JoyProps addPropsFile ( final String namePattern ) { requireNotStarted ( props ) ; this . propsNamePatterns . add ( namePattern ) ; return this ; }", "nl": "Adds props files or patterns ."}}
{"translation": {"code": "public String getValueOrDefault ( final String key , final String defaultValue ) { initialize ( ) ; final String value = data . lookupValue ( key , activeProfiles ) ; if ( value == null ) { return defaultValue ; } return value ; }", "nl": "Returns value of property using active profiles or default value if not found ."}}
{"translation": {"code": "private void skipObject ( ) { int bracketCount = 1 ; boolean insideString = false ; while ( ndx < total ) { final char c = input [ ndx ] ; if ( insideString ) { if ( c == ' ' && notPrecededByEvenNumberOfBackslashes ( ) ) { insideString = false ; } } else if ( c == ' ' ) { insideString = true ; } else if ( c == ' ' ) { bracketCount ++ ; } else if ( c == ' ' ) { bracketCount -- ; if ( bracketCount == 0 ) { ndx ++ ; return ; } } ndx ++ ; } }", "nl": "Skips over complete object . It is not parsed just skipped . It will be parsed later but only if required ."}}
{"translation": {"code": "public long toMilliseconds ( ) { double then = ( fraction - JD_1970 . fraction ) * MILLIS_IN_DAY ; then += ( integer - JD_1970 . integer ) * MILLIS_IN_DAY ; then += then > 0 ? 1.0e-6 : - 1.0e-6 ; return ( long ) then ; }", "nl": "Converts to milliseconds ."}}
{"translation": {"code": "protected void initBeanDefinition ( final BeanDefinition def ) { // init methods if ( def . initMethods == null ) { def . initMethods = petiteResolvers . resolveInitMethodPoint ( def . type ) ; } // destroy methods if ( def . destroyMethods == null ) { def . destroyMethods = petiteResolvers . resolveDestroyMethodPoint ( def . type ) ; } // properties if ( def . properties == null ) { def . properties = petiteResolvers . resolvePropertyInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; } // methods if ( def . methods == null ) { def . methods = petiteResolvers . resolveMethodInjectionPoint ( def . type ) ; } // ctors if ( def . ctor == null ) { def . ctor = petiteResolvers . resolveCtorInjectionPoint ( def . type ) ; } // values if ( def . values == null ) { def . values = paramManager . resolveParamInjectionPoints ( def . type ) ; } // sets if ( def . sets == null ) { def . sets = petiteResolvers . resolveSetInjectionPoint ( def . type , def . wiringMode == WiringMode . AUTOWIRE ) ; } // params if ( def . params == null ) { def . params = paramManager . filterParametersForBeanName ( def . name , petiteConfig . getResolveReferenceParameters ( ) ) ; } }", "nl": "Resolves and initializes bean definition . May be called multiple times ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }", "nl": "Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned ."}}
{"translation": {"code": "public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }", "nl": "Finds a given scope and consumes it ."}}
{"translation": {"code": "public void forEachTargetAndOut ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { for ( final Target target : targets ) { final ScopeData scopeData = target . scopeData ( ) ; if ( scopeData . out ( ) == null ) { continue ; } for ( final InjectionPoint out : scopeData . out ( ) ) { if ( out . scope ( ) != scope ) { continue ; } biConsumer . accept ( target , out ) ; } } }", "nl": "Iterates all targets and for each target iterates all OUT injection points of given scope ."}}
{"translation": {"code": "public Object [ ] extractParametersValues ( ) { final Object [ ] values = new Object [ targets . length - 1 ] ; for ( int i = 1 ; i < targets . length ; i ++ ) { values [ i - 1 ] = targets [ i ] . value ( ) ; } return values ; }", "nl": "Collects all parameters from target into an array ."}}
{"translation": {"code": "protected Target [ ] makeTargets ( final Target actionTarget , final MethodParam [ ] methodParams ) { if ( methodParams == null ) { // action does not have method parameters, so there is just one target return new Target [ ] { actionTarget } ; } // action has method arguments, so there is more then one target final Target [ ] target = new Target [ methodParams . length + 1 ] ; target [ 0 ] = actionTarget ; final Object action = actionTarget . value ( ) ; for ( int i = 0 ; i < methodParams . length ; i ++ ) { final MethodParam methodParam = methodParams [ i ] ; final Class paramType = methodParam . type ( ) ; final Target paramTarget ; if ( methodParam . annotationType ( ) == null ) { // parameter is NOT annotated, create new value for the target // the class itself will be a base class, and should be scanned final ScopeData newScopeData = methodParam . scopeData ( ) . inspector ( ) . inspectClassScopesWithCache ( paramType ) ; paramTarget = Target . ofValue ( createActionMethodArgument ( paramType , action ) , newScopeData ) ; } else if ( methodParam . annotationType ( ) == Out . class ) { // parameter is annotated with *only* OUT annotation // create the output value now AND to save the type paramTarget = Target . ofMethodParam ( methodParam , createActionMethodArgument ( paramType , action ) ) ; } else { // parameter is annotated with any IN annotation // create target with NO value, as the value will be created later paramTarget = Target . ofMethodParam ( methodParam , type -> createActionMethodArgument ( type , action ) ) ; } target [ i + 1 ] = paramTarget ; } return target ; }", "nl": "Joins action and parameters into one single array of Targets ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" , \"NullArgumentToVariableArgMethod\" } ) protected Object createActionMethodArgument ( final Class type , final Object action ) { try { if ( type . getEnclosingClass ( ) == null || Modifier . isStatic ( type . getModifiers ( ) ) ) { // regular or static class return ClassUtil . newInstance ( type ) ; } else { // member class Constructor ctor = type . getDeclaredConstructor ( type . getDeclaringClass ( ) ) ; ctor . setAccessible ( true ) ; return ctor . newInstance ( action ) ; } } catch ( Exception ex ) { throw new MadvocException ( ex ) ; } }", "nl": "Creates action method arguments ."}}
{"translation": {"code": "public void forEachTarget ( final Consumer < Target > targetConsumer ) { for ( final Target target : targets ) { targetConsumer . accept ( target ) ; } }", "nl": "Iterates all targets ."}}
{"translation": {"code": "private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }", "nl": "Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "public void visitInvokeDynamicInsn ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { mv . visitInvokeDynamicInsn ( name , descriptor , bootstrapMethodHandle , bootstrapMethodArguments ) ; } }", "nl": "Visits an invokedynamic instruction ."}}
{"translation": {"code": "public void visitMethodInsn ( final int opcode , final String owner , final String name , final String descriptor , final boolean isInterface ) { if ( api < Opcodes . ASM5 ) { if ( isInterface != ( opcode == Opcodes . INVOKEINTERFACE ) ) { throw new IllegalArgumentException ( \"INVOKESPECIAL/STATIC on interfaces requires ASM5\" ) ; } visitMethodInsn ( opcode , owner , name , descriptor ) ; return ; } if ( mv != null ) { mv . visitMethodInsn ( opcode , owner , name , descriptor , isInterface ) ; } }", "nl": "Visits a method instruction . A method instruction is an instruction that invokes a method ."}}
{"translation": {"code": "public void visitFieldInsn ( final int opcode , final String owner , final String name , final String descriptor ) { if ( mv != null ) { mv . visitFieldInsn ( opcode , owner , name , descriptor ) ; } }", "nl": "Visits a field instruction . A field instruction is an instruction that loads or stores the value of a field of an object ."}}
{"translation": {"code": "Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }", "nl": "Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "public AnnotationVisitor visitTypeAnnotation ( final int typeRef , final TypePath typePath , final String descriptor , final boolean visible ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { return mv . visitTypeAnnotation ( typeRef , typePath , descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation on a type in the method signature ."}}
{"translation": {"code": "public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( \")V\" ) . toString ( ) ; }", "nl": "Returns the descriptor corresponding to the given constructor ."}}
{"translation": {"code": "public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }", "nl": "Returns the descriptor corresponding to the given method ."}}
{"translation": {"code": "private Attribute [ ] getAttributePrototypes ( ) { Attribute . Set attributePrototypes = new Attribute . Set ( ) ; attributePrototypes . addAttributes ( firstAttribute ) ; FieldWriter fieldWriter = firstField ; while ( fieldWriter != null ) { fieldWriter . collectAttributePrototypes ( attributePrototypes ) ; fieldWriter = ( FieldWriter ) fieldWriter . fv ; } MethodWriter methodWriter = firstMethod ; while ( methodWriter != null ) { methodWriter . collectAttributePrototypes ( attributePrototypes ) ; methodWriter = ( MethodWriter ) methodWriter . mv ; } return attributePrototypes . toArray ( ) ; }", "nl": "Returns the prototypes of the attributes used by this class its fields and its methods ."}}
{"translation": {"code": "final void collectAttributePrototypes ( final Attribute . Set attributePrototypes ) { attributePrototypes . addAttributes ( firstAttribute ) ; attributePrototypes . addAttributes ( firstCodeAttribute ) ; }", "nl": "Collects the attributes of this method into the given set of attribute prototypes ."}}
{"translation": {"code": "static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { return firstHandler ; } if ( rangeStart <= handlerStart ) { if ( rangeEnd >= handlerEnd ) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler . nextHandler ; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler ( firstHandler , end , firstHandler . endPc ) ; } } else if ( rangeEnd >= handlerEnd ) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler ( firstHandler , firstHandler . startPc , start ) ; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; return new Handler ( firstHandler , firstHandler . startPc , start ) ; } }", "nl": "Removes the range between start and end from the Handler list that begins with the given element ."}}
{"translation": {"code": "protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }", "nl": "Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created ."}}
{"translation": {"code": "private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ; // Read the num_element_value_pairs field (or num_values field for an array_value). int numElementValuePairs = readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; if ( named ) { // Parse the element_value_pairs array. while ( numElementValuePairs -- > 0 ) { String elementName = readUTF8 ( currentOffset , charBuffer ) ; currentOffset = readElementValue ( annotationVisitor , currentOffset + 2 , elementName , charBuffer ) ; } } else { // Parse the array_value array. while ( numElementValuePairs -- > 0 ) { currentOffset = readElementValue ( annotationVisitor , currentOffset , /* named = */ null , charBuffer ) ; } } if ( annotationVisitor != null ) { annotationVisitor . visitEnd ( ) ; } return currentOffset ; }", "nl": "Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value ."}}
{"translation": {"code": "private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }", "nl": "Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table ."}}
{"translation": {"code": "int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }", "nl": "Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "void putBootstrapMethods ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }", "nl": "Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value ."}}
{"translation": {"code": "private void addConstantUtf8 ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }", "nl": "Adds a new CONSTANT_String_info to the constant pool of this symbol table ."}}
{"translation": {"code": "private Symbol addConstantUtf8Reference ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }", "nl": "Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }", "nl": "Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }", "nl": "Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table ."}}
{"translation": {"code": "Symbol addConstantInvokeDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }", "nl": "Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "public void writeValue ( final InjectionPoint injectionPoint , final Object propertyValue , final boolean silent ) { writeValue ( injectionPoint . targetName ( ) , propertyValue , silent ) ; }", "nl": "Writes value to this target . Depending on a flag writing the value can be completely silent when no exception is thrown and with top performances . Otherwise an exception is thrown on a failure ."}}
{"translation": {"code": "public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid init method: \" + initMethod , ex ) ; } } }", "nl": "Invokes init methods ."}}
{"translation": {"code": "public void callDestroyMethods ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid destroy method: \" + destroyMethodPoint . method , ex ) ; } } }", "nl": "Calls destroy methods on given BeanData . Destroy methods are called without any order ."}}
{"translation": {"code": "public String resolveJsonName ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }", "nl": "Resolves JSON name from real name ."}}
{"translation": {"code": "public DbOom connect ( ) { connectionProvider . init ( ) ; final DbDetector dbDetector = new DbDetector ( ) ; dbDetector . detectDatabaseAndConfigureDbOom ( connectionProvider , dbOomConfig ) ; return this ; }", "nl": "Initializes the DbOom by connecting to the database . Database will be detected and DbOom will be configured to match it ."}}
{"translation": {"code": "public void populateGeneratedKeys ( final Object entity ) { final String [ ] generatedColumns = getGeneratedColumnNames ( ) ; if ( generatedColumns == null ) { return ; } DbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( entity . getClass ( ) ) ; // prepare key types Class [ ] keyTypes = new Class [ generatedColumns . length ] ; String [ ] properties = new String [ generatedColumns . length ] ; for ( int i = 0 ; i < generatedColumns . length ; i ++ ) { String column = generatedColumns [ i ] ; DbEntityColumnDescriptor decd = ded . findByColumnName ( column ) ; if ( decd != null ) { keyTypes [ i ] = decd . getPropertyType ( ) ; properties [ i ] = decd . getPropertyName ( ) ; } } final Object keyValues = findGeneratedColumns ( keyTypes ) ; if ( ! keyValues . getClass ( ) . isArray ( ) ) { BeanUtil . declared . setProperty ( entity , properties [ 0 ] , keyValues ) ; } else { for ( int i = 0 ; i < properties . length ; i ++ ) { BeanUtil . declared . setProperty ( entity , properties [ i ] , ( ( Object [ ] ) keyValues ) [ i ] ) ; } } }", "nl": "Populates entity with generated column values from executed query ."}}
{"translation": {"code": "protected String preprocessSql ( String sqlString ) { // detects callable statement if ( sqlString . charAt ( 0 ) == ' ' ) { return sqlString ; } // quickly detect if SQL string is a key if ( ! CharUtil . isAlpha ( sqlString . charAt ( 0 ) ) ) { sqlString = sqlString . substring ( 1 ) ; } else if ( sqlString . indexOf ( ' ' ) != - 1 ) { return sqlString ; } final String sqlFromMap = dbOom . queryMap ( ) . getQuery ( sqlString ) ; if ( sqlFromMap != null ) { sqlString = sqlFromMap . trim ( ) ; } return sqlString ; }", "nl": "Pre - process SQL before using it . If string starts with a non - ascii char or it has no spaces it will be loaded from the query map ."}}
{"translation": {"code": "public T put ( final Class < ? > type , final T value ) { return map . put ( type , value ) ; }", "nl": "Add values to the map ."}}
{"translation": {"code": "public static < T > Stream < T > streamOf ( final Iterator < T > iterator ) { return StreamSupport . stream ( ( ( Iterable < T > ) ( ) -> iterator ) . spliterator ( ) , false ) ; }", "nl": "Converts iterator to a stream ."}}
{"translation": {"code": "private void printLogo ( ) { System . out . println ( Chalk256 . chalk ( ) . yellow ( ) . on ( Jodd . JODD ) ) ; }", "nl": "Prints a logo ."}}
{"translation": {"code": "public static JsonResult of ( final Exception exception ) { final HashMap < String , Object > errorMap = new HashMap <> ( ) ; errorMap . put ( \"message\" , ExceptionUtil . message ( exception ) ) ; errorMap . put ( \"error\" , exception . getClass ( ) . getName ( ) ) ; errorMap . put ( \"cause\" , exception . getCause ( ) != null ? exception . getCause ( ) . getClass ( ) . getName ( ) : null ) ; final ArrayList < String > details = new ArrayList <> ( ) ; final StackTraceElement [ ] ste = ExceptionUtil . getStackTrace ( exception , null , null ) ; for ( StackTraceElement stackTraceElement : ste ) { details . add ( stackTraceElement . toString ( ) ) ; } errorMap . put ( \"details\" , details ) ; final String json = JsonSerializer . create ( ) . deep ( true ) . serialize ( errorMap ) ; return new JsonResult ( json ) . status ( HttpStatus . error500 ( ) . internalError ( ) ) ; }", "nl": "Creates a JSON response from an exception . Response body will have information about the exception and response status will be set to 500 ."}}
{"translation": {"code": "public void bindAnnotationConfig ( final Class < ? extends Annotation > annotationType , final Class < ? extends ActionConfig > actionConfigClass ) { final ActionConfig actionConfig = registerNewActionConfiguration ( actionConfigClass ) ; actionConfigs . put ( annotationType , actionConfig ) ; for ( final AnnotationParser annotationParser : annotationParsers ) { if ( annotationType . equals ( annotationParser . getAnnotationType ( ) ) ) { // parser already exists return ; } } annotationParsers = ArraysUtil . append ( annotationParsers , new AnnotationParser ( annotationType , Action . class ) ) ; }", "nl": "Binds action annotation and the action config . This can overwrite the default annotation configuration of an annotation ."}}
{"translation": {"code": "protected ActionConfig registerNewActionConfiguration ( final Class < ? extends ActionConfig > actionConfigClass ) { final ActionConfig newActionConfig = createActionConfig ( actionConfigClass ) ; actionConfigs . put ( actionConfigClass , newActionConfig ) ; return newActionConfig ; }", "nl": "Registers action configuration for given type ."}}
{"translation": {"code": "public ActionConfig lookup ( final Class actionTypeOrAnnotationType ) { final ActionConfig actionConfig = actionConfigs . get ( actionTypeOrAnnotationType ) ; if ( actionConfig == null ) { throw new MadvocException ( \"ActionConfiguration not registered:\" + actionTypeOrAnnotationType . getName ( ) ) ; } return actionConfig ; }", "nl": "Lookup for the action configuration . Typically the input argument is either the action type or annotation type ."}}
{"translation": {"code": "public < T extends ActionConfig > void with ( final Class < T > actionConfigType , final Consumer < T > actionConfigConsumer ) { final T actionConfig = ( T ) lookup ( actionConfigType ) ; actionConfigConsumer . accept ( actionConfig ) ; }", "nl": "Fetch some action config and consumes it ."}}
{"translation": {"code": "public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }", "nl": "Configures the action configurations ."}}
{"translation": {"code": "protected T authenticateUserViaHttpSession ( final ActionRequest actionRequest ) { final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; final UserSession < T > userSession = UserSession . get ( servletRequest ) ; if ( userSession == null ) { return null ; } final T authToken = userSession . getAuthToken ( ) ; if ( authToken == null ) { return null ; } // granted final T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; if ( newAuthToken != authToken ) { final UserSession < T > newUserSesion = new UserSession <> ( newAuthToken , userAuth ( ) . tokenValue ( newAuthToken ) ) ; newUserSesion . start ( servletRequest , actionRequest . getHttpServletResponse ( ) ) ; } return newAuthToken ; }", "nl": "Tries to authenticate user via HTTP session . Returns the token if user is authenticated . Returned token may be rotated ."}}
{"translation": {"code": "protected JsonResult tokenAsJson ( final T authToken ) { final JsonObject jsonObject = new JsonObject ( ) ; jsonObject . put ( \"token\" , userAuth . tokenValue ( authToken ) ) ; return JsonResult . of ( jsonObject ) ; }", "nl": "Prepares the JSON payload that carries on the token value ."}}
{"translation": {"code": "public void start ( final HttpServletRequest httpServletRequest , final HttpServletResponse httpServletResponse ) { final HttpSession httpSession = httpServletRequest . getSession ( true ) ; httpSession . setAttribute ( AUTH_SESSION_NAME , this ) ; final Cookie cookie = new Cookie ( AUTH_COOKIE_NAME , authTokenValue ) ; //cookie.setDomain(SSORealm.SSO_DOMAIN); cookie . setMaxAge ( cookieMaxAge ) ; cookie . setPath ( \"/\" ) ; httpServletResponse . addCookie ( cookie ) ; }", "nl": "Starts new user session ."}}
{"translation": {"code": "public static void stop ( final HttpServletRequest servletRequest , final HttpServletResponse servletResponse ) { final HttpSession httpSession = servletRequest . getSession ( false ) ; if ( httpSession != null ) { httpSession . removeAttribute ( AUTH_SESSION_NAME ) ; } final Cookie cookie = ServletUtil . getCookie ( servletRequest , AUTH_COOKIE_NAME ) ; if ( cookie == null ) { return ; } cookie . setMaxAge ( 0 ) ; cookie . setPath ( \"/\" ) ; servletResponse . addCookie ( cookie ) ; }", "nl": "Stops the user session by removing it from the http session and invalidating the cookie ."}}
{"translation": {"code": "public Node findChildNodeWithName ( final String name ) { if ( childNodes == null ) { return null ; } for ( final Node childNode : childNodes ) { if ( childNode . getNodeName ( ) . equals ( name ) ) { return childNode ; } } return null ; }", "nl": "Finds the first child node with given node name ."}}
{"translation": {"code": "public static boolean getBoolean ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case \"true\" : case \"yes\" : case \"1\" : case \"on\" : return true ; case \"false\" : case \"no\" : case \"0\" : case \"off\" : return false ; default : return defaultValue ; } }", "nl": "Returns system property as boolean ."}}
{"translation": {"code": "public static String get ( final String name , final String defaultValue ) { Objects . requireNonNull ( name ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( name ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }", "nl": "Returns system property . If key is not available returns the default value ."}}
{"translation": {"code": "public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }", "nl": "Returns system property as a long ."}}
{"translation": {"code": "public static String toPrettyString ( final Object value ) { if ( value == null ) { return StringPool . NULL ; } final Class < ? > type = value . getClass ( ) ; if ( type . isArray ( ) ) { final Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' ' ) ; if ( componentType == int . class ) { sb . append ( ArraysUtil . toString ( ( int [ ] ) value ) ) ; } else if ( componentType == long . class ) { sb . append ( ArraysUtil . toString ( ( long [ ] ) value ) ) ; } else if ( componentType == double . class ) { sb . append ( ArraysUtil . toString ( ( double [ ] ) value ) ) ; } else if ( componentType == float . class ) { sb . append ( ArraysUtil . toString ( ( float [ ] ) value ) ) ; } else if ( componentType == boolean . class ) { sb . append ( ArraysUtil . toString ( ( boolean [ ] ) value ) ) ; } else if ( componentType == short . class ) { sb . append ( ArraysUtil . toString ( ( short [ ] ) value ) ) ; } else if ( componentType == byte . class ) { sb . append ( ArraysUtil . toString ( ( byte [ ] ) value ) ) ; } else { throw new IllegalArgumentException ( ) ; } sb . append ( ' ' ) ; return sb . toString ( ) ; } else { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' ' ) ; final Object [ ] array = ( Object [ ] ) value ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( i > 0 ) { sb . append ( ' ' ) ; } sb . append ( toPrettyString ( array [ i ] ) ) ; } sb . append ( ' ' ) ; return sb . toString ( ) ; } } else if ( value instanceof Iterable ) { final Iterable iterable = ( Iterable ) value ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' ' ) ; int i = 0 ; for ( final Object o : iterable ) { if ( i > 0 ) { sb . append ( ' ' ) ; } sb . append ( toPrettyString ( o ) ) ; i ++ ; } sb . append ( ' ' ) ; return sb . toString ( ) ; } return value . toString ( ) ; }", "nl": "Converts object into pretty string . All arrays are iterated ."}}
{"translation": {"code": "public static String toCamelCase ( final String input , final boolean firstCharUppercase , final char separator ) { final int length = input . length ( ) ; final StringBuilder sb = new StringBuilder ( length ) ; boolean upperCase = firstCharUppercase ; for ( int i = 0 ; i < length ; i ++ ) { final char ch = input . charAt ( i ) ; if ( ch == separator ) { upperCase = true ; } else if ( upperCase ) { sb . append ( Character . toUpperCase ( ch ) ) ; upperCase = false ; } else { sb . append ( ch ) ; } } return sb . toString ( ) ; }", "nl": "Converts separated string value to CamelCase ."}}
{"translation": {"code": "public static String unescapeJava ( final String str ) { char [ ] chars = str . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( str . length ( ) ) ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( c != ' ' ) { sb . append ( c ) ; continue ; } i ++ ; c = chars [ i ] ; switch ( c ) { case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : sb . append ( ' ' ) ; break ; case ' ' : char hex = ( char ) Integer . parseInt ( new String ( chars , i + 1 , 4 ) , 16 ) ; sb . append ( hex ) ; i += 4 ; break ; default : throw new IllegalArgumentException ( \"Invalid escaping character: \" + c ) ; } } return sb . toString ( ) ; }", "nl": "Unescapes a string using java rules ."}}
{"translation": {"code": "public static String escapeJava ( final String string ) { int strLen = string . length ( ) ; StringBuilder sb = new StringBuilder ( strLen ) ; for ( int i = 0 ; i < strLen ; i ++ ) { char c = string . charAt ( i ) ; switch ( c ) { case ' ' : sb . append ( \"\\\\b\" ) ; break ; case ' ' : sb . append ( \"\\\\t\" ) ; break ; case ' ' : sb . append ( \"\\\\n\" ) ; break ; case ' ' : sb . append ( \"\\\\f\" ) ; break ; case ' ' : sb . append ( \"\\\\r\" ) ; break ; case ' ' : sb . append ( \"\\\\\\\"\" ) ; break ; case ' ' : sb . append ( \"\\\\\\\\\" ) ; break ; default : if ( ( c < 32 ) || ( c > 127 ) ) { String hex = Integer . toHexString ( c ) ; sb . append ( \"\\\\u\" ) ; for ( int k = hex . length ( ) ; k < 4 ; k ++ ) { sb . append ( ' ' ) ; } sb . append ( hex ) ; } else { sb . append ( c ) ; } } } return sb . toString ( ) ; }", "nl": "Escapes a string using java rules ."}}
{"translation": {"code": "public static String formatParagraph ( final String src , final int len , final boolean breakOnWhitespace ) { StringBuilder str = new StringBuilder ( ) ; int total = src . length ( ) ; int from = 0 ; while ( from < total ) { int to = from + len ; if ( to >= total ) { to = total ; } else if ( breakOnWhitespace ) { int ndx = StringUtil . lastIndexOfWhitespace ( src , to - 1 , from ) ; if ( ndx != - 1 ) { to = ndx + 1 ; } } int cutFrom = StringUtil . indexOfNonWhitespace ( src , from , to ) ; if ( cutFrom != - 1 ) { int cutTo = StringUtil . lastIndexOfNonWhitespace ( src , to - 1 , from ) + 1 ; str . append ( src , cutFrom , cutTo ) ; } str . append ( ' ' ) ; from = to ; } return str . toString ( ) ; }", "nl": "Formats provided string as paragraph ."}}
{"translation": {"code": "private byte [ ] replaceAsmInstructions ( final byte [ ] classFile , final boolean hasFrames ) { final Attribute [ ] attributes = getAttributePrototypes ( ) ; firstField = null ; lastField = null ; firstMethod = null ; lastMethod = null ; lastRuntimeVisibleAnnotation = null ; lastRuntimeInvisibleAnnotation = null ; lastRuntimeVisibleTypeAnnotation = null ; lastRuntimeInvisibleTypeAnnotation = null ; moduleWriter = null ; nestHostClassIndex = 0 ; numberOfNestMemberClasses = 0 ; nestMemberClasses = null ; firstAttribute = null ; compute = hasFrames ? MethodWriter . COMPUTE_INSERTED_FRAMES : MethodWriter . COMPUTE_NOTHING ; new ClassReader ( classFile , 0 , /* checkClassVersion = */ false ) . accept ( this , attributes , ( hasFrames ? ClassReader . EXPAND_FRAMES : 0 ) | ClassReader . EXPAND_ASM_INSNS ) ; return toByteArray ( ) ; }", "nl": "Returns the equivalent of the given class file with the ASM specific instructions replaced with standard ones . This is done with a ClassReader - &gt ; ClassWriter round trip ."}}
{"translation": {"code": "public ReceivedEmail [ ] get ( ) { if ( fromFolder != null ) { session . useFolder ( fromFolder ) ; } return session . receiveMessages ( filter , flagsToSet , flagsToUnset , envelopeOnly , messages -> { if ( targetFolder != null ) { try { session . folder . copyMessages ( messages , session . getFolder ( targetFolder ) ) ; } catch ( MessagingException e ) { throw new MailException ( \"Copying messages failed\" ) ; } } } ) ; }", "nl": "Receives the emails as specified by the builder ."}}
{"translation": {"code": "public void printUsage ( final String commandName ) { final StringBuilder usage = new StringBuilder ( commandName ) ; for ( final Option option : options ) { if ( option . shortName != null ) { usage . append ( \" [-\" ) . append ( option . shortName ) . append ( \"]\" ) ; } else if ( option . longName != null ) { usage . append ( \" [--\" ) . append ( option . longName ) . append ( \"]\" ) ; } } for ( final Param param : params ) { usage . append ( \" \" ) . append ( param . label ) ; } System . out . println ( usage ) ; }", "nl": "Prints the usage line ."}}
{"translation": {"code": "public static char detectQuoteChar ( final String str ) { if ( str . length ( ) < 2 ) { return 0 ; } final char c = str . charAt ( 0 ) ; if ( c != str . charAt ( str . length ( ) - 1 ) ) { return 0 ; } if ( c == ' ' || c == ' ' || c == ' ' ) { return c ; } return 0 ; }", "nl": "Detects quote character or return 0 ."}}
{"translation": {"code": "public void updateBean ( final Object bean ) { this . setBean ( bean ) ; if ( this . cd != null && this . cd . isSupplier ( ) ) { final Object newBean = ( ( Supplier ) this . bean ) . get ( ) ; setBean ( newBean ) ; } }", "nl": "Updates the bean . Detects special case of suppliers ."}}
{"translation": {"code": "public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }", "nl": "Returns the descriptor corresponding to the given argument and return types ."}}
{"translation": {"code": "public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { int argumentsSize = 1 ; // Skip the first character, which is always a '('. int currentOffset = 1 ; int currentChar = methodDescriptor . charAt ( currentOffset ) ; // Parse the argument types and compute their size, one at a each loop iteration. while ( currentChar != ' ' ) { if ( currentChar == ' ' || currentChar == ' ' ) { currentOffset ++ ; argumentsSize += 2 ; } else { while ( methodDescriptor . charAt ( currentOffset ) == ' ' ) { currentOffset ++ ; } if ( methodDescriptor . charAt ( currentOffset ++ ) == ' ' ) { // Skip the argument descriptor content. currentOffset = methodDescriptor . indexOf ( ' ' , currentOffset ) + 1 ; } argumentsSize += 1 ; } currentChar = methodDescriptor . charAt ( currentOffset ) ; } currentChar = methodDescriptor . charAt ( currentOffset + 1 ) ; if ( currentChar == ' ' ) { return argumentsSize << 2 ; } else { int returnSize = ( currentChar == ' ' || currentChar == ' ' ) ? 2 : 1 ; return argumentsSize << 2 | returnSize ; } }", "nl": "Computes the size of the arguments and of the return value of a method ."}}
{"translation": {"code": "final void copyFrom ( final Frame frame ) { inputLocals = frame . inputLocals ; inputStack = frame . inputStack ; outputStackStart = 0 ; outputLocals = frame . outputLocals ; outputStack = frame . outputStack ; outputStackTop = frame . outputStackTop ; initializationCount = frame . initializationCount ; initializations = frame . initializations ; }", "nl": "Sets this frame to the value of the given frame ."}}
{"translation": {"code": "public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return true ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return false ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return false ; } return true ; }", "nl": "Check whether flags is a empty flags"}}