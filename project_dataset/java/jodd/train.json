{"translation": {"code": "public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }", "nl": "Finds constructor description that matches given argument types ."}}
{"translation": {"code": "public static Class [ ] getSuperclasses ( final Class type ) { int i = 0 ; for ( Class x = type . getSuperclass ( ) ; x != null ; x = x . getSuperclass ( ) ) { i ++ ; } Class [ ] result = new Class [ i ] ; i = 0 ; for ( Class x = type . getSuperclass ( ) ; x != null ; x = x . getSuperclass ( ) ) { result [ i ] = x ; i ++ ; } return result ; }", "nl": "Returns all superclasses ."}}
{"translation": {"code": "public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( \"TX is already completed, resource are not available after commit or rollback\" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( \"TX is marked as rollback only, resource are not available\" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( \"Resources are not available since TX is not active\" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( \"TX already has attached max. number of resources\" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }", "nl": "Requests a resource . If resource is not found it will be created and new transaction will be started on it ."}}
{"translation": {"code": "protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( \"Rollback failed: one or more TX resources couldn't rollback a TX\" , lastException ) ; } if ( wasForced ) { throw new JtxException ( \"TX rolled back because it has been marked as rollback-only\" , rollbackCause ) ; } }", "nl": "Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end ."}}
{"translation": {"code": "protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( \"Commit JTX\" ) ; } else { log . debug ( \"Rollback JTX\" ) ; } } boolean forcedRollback = false ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = false ; forcedRollback = true ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( \"TX is already completed, commit or rollback should be called once per TX\" ) ; } throw new JtxException ( \"No active TX to \" + ( doCommit ? \"commit\" : \"rollback\" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }", "nl": "Performs either commit or rollback on all transaction resources ."}}
{"translation": {"code": "public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( \"TNo active TX that can be marked as rollback only\" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }", "nl": "Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction ."}}
{"translation": {"code": "public static String toCsvString ( final Object ... elements ) { StringBuilder line = new StringBuilder ( ) ; int last = elements . length - 1 ; for ( int i = 0 ; i < elements . length ; i ++ ) { if ( elements [ i ] == null ) { if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } continue ; } String field = elements [ i ] . toString ( ) ; // check for special cases int ndx = field . indexOf ( FIELD_SEPARATOR ) ; if ( ndx == - 1 ) { ndx = field . indexOf ( FIELD_QUOTE ) ; } if ( ndx == - 1 ) { if ( field . startsWith ( StringPool . SPACE ) || field . endsWith ( StringPool . SPACE ) ) { ndx = 1 ; } } if ( ndx == - 1 ) { ndx = StringUtil . indexOfChars ( field , SPECIAL_CHARS ) ; } // add field if ( ndx != - 1 ) { line . append ( FIELD_QUOTE ) ; } field = StringUtil . replace ( field , StringPool . QUOTE , DOUBLE_QUOTE ) ; line . append ( field ) ; if ( ndx != - 1 ) { line . append ( FIELD_QUOTE ) ; } // last if ( i != last ) { line . append ( FIELD_SEPARATOR ) ; } } return line . toString ( ) ; }", "nl": "Parse fields as csv string"}}
{"translation": {"code": "public static void sleep ( final long ms ) { try { Thread . sleep ( ms ) ; } catch ( InterruptedException iex ) { Thread . currentThread ( ) . interrupt ( ) ; } }", "nl": "Puts a thread to sleep without throwing an InterruptedException ."}}
{"translation": {"code": "public static String [ ] toStringArray ( final String line ) { List < String > row = new ArrayList <> ( ) ; boolean inQuotedField = false ; int fieldStart = 0 ; final int len = line . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = line . charAt ( i ) ; if ( c == FIELD_SEPARATOR ) { if ( ! inQuotedField ) { // ignore we are quoting addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + 1 ; } } else if ( c == FIELD_QUOTE ) { if ( inQuotedField ) { if ( i + 1 == len || line . charAt ( i + 1 ) == FIELD_SEPARATOR ) { // we are already quoting - peek to see if this is the end of the field addField ( row , line , fieldStart , i , inQuotedField ) ; fieldStart = i + 2 ; i ++ ; // and skip the comma inQuotedField = false ; } } else if ( fieldStart == i ) { inQuotedField = true ; // this is a beginning of a quote fieldStart ++ ; // move field start } } } // add last field - but only if string was not empty if ( len > 0 && fieldStart <= len ) { addField ( row , line , fieldStart , len , inQuotedField ) ; } return row . toArray ( new String [ 0 ] ) ; }", "nl": "Converts CSV line to string array ."}}
{"translation": {"code": "public static void sleep ( ) { try { Thread . sleep ( Long . MAX_VALUE ) ; } catch ( InterruptedException iex ) { Thread . currentThread ( ) . interrupt ( ) ; } }", "nl": "Puts a thread to sleep forever ."}}
{"translation": {"code": "public CtorInjectionPoint resolve ( final Class type , final boolean useAnnotation ) { // lookup methods ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; CtorDescriptor [ ] allCtors = cd . getAllCtorDescriptors ( ) ; Constructor foundedCtor = null ; Constructor defaultCtor = null ; BeanReferences [ ] references = null ; for ( CtorDescriptor ctorDescriptor : allCtors ) { Constructor < ? > ctor = ctorDescriptor . getConstructor ( ) ; Class < ? > [ ] paramTypes = ctor . getParameterTypes ( ) ; if ( paramTypes . length == 0 ) { defaultCtor = ctor ; // detects default ctors } if ( ! useAnnotation ) { continue ; } BeanReferences [ ] ctorReferences = referencesResolver . readAllReferencesFromAnnotation ( ctor ) ; if ( ctorReferences == null ) { continue ; } if ( foundedCtor != null ) { throw new PetiteException ( \"Two or more constructors are annotated as injection points in the bean: \" + type . getName ( ) ) ; } foundedCtor = ctor ; references = ctorReferences ; } if ( foundedCtor == null ) { // there is no annotated constructor if ( allCtors . length == 1 ) { foundedCtor = allCtors [ 0 ] . getConstructor ( ) ; } else { foundedCtor = defaultCtor ; } if ( foundedCtor == null ) { // no matching ctor found // still this is not an error if bean is already instantiated. return CtorInjectionPoint . EMPTY ; } references = referencesResolver . readAllReferencesFromAnnotation ( foundedCtor ) ; if ( references == null ) { references = new BeanReferences [ 0 ] ; } } return new CtorInjectionPoint ( foundedCtor , references ) ; }", "nl": "Resolves constructor injection point from type . Looks for single annotated constructor . If no annotated constructors found the total number of constructors will be checked . If there is only one constructor that one will be used as injection point . If more constructors exist the default one will be used as injection point . Otherwise exception is thrown ."}}
{"translation": {"code": "public static void wait ( final Object obj ) { synchronized ( obj ) { try { obj . wait ( ) ; } catch ( InterruptedException inex ) { Thread . currentThread ( ) . interrupt ( ) ; } } }", "nl": "Waits for a object for synchronization purposes ."}}
{"translation": {"code": "@ Override public void processStream ( ) throws IOException { FastByteArrayOutputStream out = new FastByteArrayOutputStream ( ) ; size = 0 ; if ( maxFileSize == - 1 ) { size += input . copyAll ( out ) ; } else { size += input . copyMax ( out , maxFileSize + 1 ) ; // one more byte to detect larger files if ( size > maxFileSize ) { fileTooBig = true ; valid = false ; input . skipToBoundary ( ) ; return ; } } data = out . toByteArray ( ) ; size = data . length ; valid = true ; }", "nl": "Reads data from input stream into byte array and stores file size ."}}
{"translation": {"code": "private boolean moveToNext ( ) { if ( last ) { // last has been set to true, so no more rows to iterate - close everything if ( closeOnEnd ) { query . close ( ) ; } else { query . closeResultSet ( resultSetMapper . getResultSet ( ) ) ; } return false ; } while ( true ) { if ( ! resultSetMapper . next ( ) ) { // no more rows, no more parsing, previousElement is the last one to iterate last = true ; return entityAwareMode ; } // parse row Object [ ] objects = resultSetMapper . parseObjects ( types ) ; Object row = query . resolveRowResults ( objects ) ; newElement = ( T ) row ; if ( entityAwareMode ) { if ( count == 0 && previousElement == null ) { previousElement = newElement ; continue ; } if ( previousElement != null && newElement != null ) { boolean equals ; if ( newElement . getClass ( ) . isArray ( ) ) { equals = Arrays . equals ( ( Object [ ] ) previousElement , ( Object [ ] ) newElement ) ; } else { equals = previousElement . equals ( newElement ) ; } if ( equals ) { continue ; } } } break ; } return true ; }", "nl": "Moves to next element ."}}
{"translation": {"code": "public FindFile searchPath ( final URL searchPath ) { File file = FileUtil . toContainerFile ( searchPath ) ; if ( file == null ) { throw new FindFileException ( \"URL error: \" + searchPath ) ; } addPath ( file ) ; return this ; }", "nl": "Specifies the search path . Throws an exception if URL is invalid ."}}
{"translation": {"code": "public FindFile searchPath ( final URI searchPath ) { File file ; try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( \"URI error: \" + searchPath , ex ) ; } addPath ( file ) ; return this ; }", "nl": "Specifies the search path . Throws an exception if URI is invalid ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public static < T > T [ ] join ( Class < T > componentType , T [ ] [ ] arrays ) { if ( arrays . length == 1 ) { return arrays [ 0 ] ; } int length = 0 ; for ( T [ ] array : arrays ) { length += array . length ; } T [ ] result = ( T [ ] ) Array . newInstance ( componentType , length ) ; length = 0 ; for ( T [ ] array : arrays ) { System . arraycopy ( array , 0 , result , length , array . length ) ; length += array . length ; } return result ; }", "nl": "Joins arrays using provided component type ."}}
{"translation": {"code": "protected long [ ] convertArrayToArray ( final Object value ) { final Class valueComponentType = value . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( value , valueComponentType ) ; } else { // convert object array to target array final Object [ ] array = ( Object [ ] ) value ; result = new long [ array . length ] ; for ( int i = 0 ; i < array . length ; i ++ ) { result [ i ] = convertType ( array [ i ] ) ; } } return result ; }", "nl": "Converts array value to array ."}}
{"translation": {"code": "public static void forceAccess ( final AccessibleObject accObject ) { try { if ( System . getSecurityManager ( ) == null ) accObject . setAccessible ( true ) ; else { AccessController . doPrivileged ( ( PrivilegedAction ) ( ) -> { accObject . setAccessible ( true ) ; return null ; } ) ; } } catch ( SecurityException sex ) { // ignore } }", "nl": "Suppress access check against a reflection object . SecurityException is silently ignored . Checks first if the object is already accessible ."}}
{"translation": {"code": "public static String exceptionStackTraceToString ( final Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; t . printStackTrace ( pw ) ; StreamUtil . close ( pw ) ; StreamUtil . close ( sw ) ; return sw . toString ( ) ; }", "nl": "Prints stack trace into a String ."}}
{"translation": {"code": "public static boolean compareParameters ( final Class [ ] first , final Class [ ] second ) { if ( first . length != second . length ) { return false ; } for ( int i = 0 ; i < first . length ; i ++ ) { if ( first [ i ] != second [ i ] ) { return false ; } } return true ; }", "nl": "Compares classes usually method or ctor parameters ."}}
{"translation": {"code": "public void registerDefaults ( ) { register ( Integer . class , IntegerSqlType . class ) ; register ( int . class , IntegerSqlType . class ) ; register ( MutableInteger . class , IntegerSqlType . class ) ; register ( Float . class , FloatSqlType . class ) ; register ( float . class , FloatSqlType . class ) ; register ( MutableFloat . class , FloatSqlType . class ) ; register ( Double . class , DoubleSqlType . class ) ; register ( double . class , DoubleSqlType . class ) ; register ( MutableDouble . class , DoubleSqlType . class ) ; register ( Byte . class , ByteSqlType . class ) ; register ( byte . class , ByteSqlType . class ) ; register ( MutableByte . class , ByteSqlType . class ) ; register ( Boolean . class , BooleanSqlType . class ) ; register ( boolean . class , BooleanSqlType . class ) ; register ( MutableBoolean . class , BooleanSqlType . class ) ; register ( Long . class , LongSqlType . class ) ; register ( long . class , LongSqlType . class ) ; register ( MutableLong . class , LongSqlType . class ) ; register ( Short . class , ShortSqlType . class ) ; register ( short . class , ShortSqlType . class ) ; register ( MutableShort . class , ShortSqlType . class ) ; register ( Character . class , CharacterSqlType . class ) ; register ( char . class , CharacterSqlType . class ) ; register ( BigDecimal . class , BigDecimalSqlType . class ) ; register ( BigInteger . class , BigIntegerSqlType . class ) ; register ( String . class , StringSqlType . class ) ; register ( LocalDateTime . class , LocalDateTimeSqlType . class ) ; register ( LocalDate . class , LocalDateSqlType . class ) ; register ( LocalTime . class , LocalTimeSqlType . class ) ; register ( Date . class , SqlDateSqlType . class ) ; register ( Timestamp . class , TimestampSqlType . class ) ; register ( Time . class , TimeSqlType . class ) ; register ( java . util . Date . class , DateSqlType . class ) ; register ( JulianDate . class , JulianDateSqlType . class ) ; register ( byte [ ] . class , ByteArraySqlType . class ) ; register ( URL . class , URLSqlType . class ) ; register ( Blob . class , BlobSqlType . class ) ; register ( Clob . class , ClobSqlType . class ) ; register ( Array . class , SqlArraySqlType . class ) ; register ( Ref . class , SqlRefSqlType . class ) ; }", "nl": "Registers default set of SQL types ."}}
{"translation": {"code": "public static String replaceChar ( final String s , final char sub , final char with ) { int startIndex = s . indexOf ( sub ) ; if ( startIndex == - 1 ) { return s ; } char [ ] str = s . toCharArray ( ) ; for ( int i = startIndex ; i < str . length ; i ++ ) { if ( str [ i ] == sub ) { str [ i ] = with ; } } return new String ( str ) ; }", "nl": "Replaces all occurrences of a character in a string ."}}
{"translation": {"code": "public static String replace ( final String s , final String sub , final String with ) { if ( sub . isEmpty ( ) ) { return s ; } int c = 0 ; int i = s . indexOf ( sub , c ) ; if ( i == - 1 ) { return s ; } int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length + with . length ( ) ) ; do { sb . append ( s , c , i ) ; sb . append ( with ) ; c = i + sub . length ( ) ; } while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; if ( c < length ) { sb . append ( s , c , length ) ; } return sb . toString ( ) ; }", "nl": "Replaces all occurrences of a certain pattern in a string with a replacement string . This is the fastest replace function known to author ."}}
{"translation": {"code": "protected void iterateArray ( final Object [ ] array , final int from , final int count , final PageContext pageContext ) throws JspException { JspFragment body = getJspBody ( ) ; int len = array . length ; int to = calculateTo ( from , count , len ) ; int last = to - 1 ; for ( int i = from ; i < to ; i ++ ) { Object item = array [ i ] ; if ( status != null ) { iteratorStatus . next ( i == last ) ; } TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; TagUtil . invokeBody ( body ) ; } }", "nl": "Iterates arrays ."}}
{"translation": {"code": "protected void iterateCollection ( final Collection collection , final int from , final int count , final PageContext pageContext ) throws JspException { JspFragment body = getJspBody ( ) ; Iterator iter = collection . iterator ( ) ; int i = 0 ; int to = calculateTo ( from , count , collection . size ( ) ) ; while ( i < to ) { Object item = iter . next ( ) ; if ( i >= from ) { if ( status != null ) { iteratorStatus . next ( ! iter . hasNext ( ) ) ; } TagUtil . setScopeAttribute ( var , item , scope , pageContext ) ; TagUtil . invokeBody ( body ) ; } i ++ ; } }", "nl": "Iterates collection ."}}
{"translation": {"code": "public void parse ( final DbSqlBuilder sqlBuilder , final String template ) { int length = template . length ( ) ; int last = 0 ; while ( true ) { int mark = template . indexOf ( ' ' , last ) ; if ( mark == - 1 ) { if ( last < length ) { sqlBuilder . appendRaw ( template . substring ( last ) ) ; } break ; } int escapesCount = countEscapes ( template , mark ) ; // check if escaped if ( escapesCount > 0 ) { boolean isEscaped = escapesCount % 2 != 0 ; int escapesToAdd = escapesCount >> 1 ; sqlBuilder . appendRaw ( template . substring ( last , mark - escapesCount + escapesToAdd ) + ' ' ) ; if ( isEscaped ) { last = mark + 1 ; continue ; } } else { sqlBuilder . appendRaw ( template . substring ( last , mark ) ) ; } int end ; if ( template . startsWith ( MACRO_TABLE , mark ) ) { mark += MACRO_TABLE . length ( ) ; end = findMacroEnd ( template , mark ) ; onTable ( sqlBuilder , template . substring ( mark , end ) ) ; } else if ( template . startsWith ( MACRO_COLUMN , mark ) ) { mark += MACRO_COLUMN . length ( ) ; end = findMacroEnd ( template , mark ) ; onColumn ( sqlBuilder , template . substring ( mark , end ) ) ; } else if ( template . startsWith ( MACRO_MATCH , mark ) ) { mark += MACRO_MATCH . length ( ) ; end = findMacroEnd ( template , mark ) ; onMatch ( sqlBuilder , template . substring ( mark , end ) ) ; } else if ( template . startsWith ( MACRO_VALUE , mark ) ) { mark += MACRO_VALUE . length ( ) ; end = findMacroEnd ( template , mark ) ; onValue ( sqlBuilder , template . substring ( mark , end ) ) ; } else { mark ++ ; // reference found end = mark ; // find macro end while ( end < length ) { if ( ! isReferenceChar ( template , end ) ) { break ; } end ++ ; } onReference ( sqlBuilder , template . substring ( mark , end ) ) ; end -- ; } end ++ ; last = end ; } }", "nl": "Parses template and returns generated sql builder ."}}
{"translation": {"code": "protected int findMacroEnd ( final String template , final int fromIndex ) { int endIndex = template . indexOf ( ' ' , fromIndex ) ; if ( endIndex == - 1 ) { throw new DbSqlBuilderException ( \"Template syntax error, some macros are not closed. Error at: '...\" + template . substring ( fromIndex ) ) ; } return endIndex ; }", "nl": "Finds macros end ."}}
{"translation": {"code": "protected int countEscapes ( final String template , int macroIndex ) { macroIndex -- ; int escapeCount = 0 ; while ( macroIndex >= 0 ) { if ( template . charAt ( macroIndex ) != ESCAPE_CHARACTER ) { break ; } escapeCount ++ ; macroIndex -- ; } return escapeCount ; }", "nl": "Count escapes to the left ."}}
{"translation": {"code": "public Object getBeanProperty ( final String name ) { int ndx = name . indexOf ( ' ' ) ; if ( ndx == - 1 ) { throw new PetiteException ( \"Only bean name is specified, missing property name: \" + name ) ; } String beanName = name . substring ( 0 , ndx ) ; Object bean = getBean ( beanName ) ; if ( bean == null ) { throw new PetiteException ( \"Bean doesn't exist: \" + name ) ; } try { return BeanUtil . declared . getProperty ( bean , name . substring ( ndx + 1 ) ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid bean property: \" + name , ex ) ; } }", "nl": "Returns petite bean property value ."}}
{"translation": {"code": "public void setBeanProperty ( final String name , final Object value ) { Object bean = null ; int ndx = name . length ( ) ; while ( true ) { ndx = name . lastIndexOf ( ' ' , ndx ) ; if ( ndx == - 1 ) { break ; } String beanName = name . substring ( 0 , ndx ) ; bean = getBean ( beanName ) ; if ( bean != null ) { break ; } ndx -- ; } if ( bean == null ) { throw new PetiteException ( \"Invalid bean property: \" + name ) ; } try { BeanUtil . declared . setProperty ( bean , name . substring ( ndx + 1 ) , value ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid bean property: \" + name , ex ) ; } }", "nl": "Sets petite bean property ."}}
{"translation": {"code": "public void addBean ( final String name , final Object bean , WiringMode wiringMode ) { wiringMode = petiteConfig . resolveWiringMode ( wiringMode ) ; registerPetiteBean ( bean . getClass ( ) , name , SingletonScope . class , wiringMode , false , null ) ; BeanDefinition def = lookupExistingBeanDefinition ( name ) ; registerBeanAndWireAndInjectParamsAndInvokeInitMethods ( new BeanData ( this , def , bean ) ) ; }", "nl": "Adds object instance to the container as singleton bean ."}}
{"translation": {"code": "public < T > T getBean ( final String name ) { // Lookup for registered bean definition. BeanDefinition def = lookupBeanDefinition ( name ) ; if ( def == null ) { // try provider ProviderDefinition providerDefinition = providers . get ( name ) ; if ( providerDefinition != null ) { return ( T ) invokeProvider ( providerDefinition ) ; } return null ; } // Find the bean in its scope Object bean = def . scopeLookup ( ) ; if ( bean == null ) { // Create new bean in the scope initBeanDefinition ( def ) ; final BeanData beanData = new BeanData ( this , def ) ; registerBeanAndWireAndInjectParamsAndInvokeInitMethods ( beanData ) ; bean = beanData . bean ( ) ; } return ( T ) bean ; }", "nl": "Returns Petite bean instance . Petite container will find the bean in corresponding scope and all its dependencies either by constructor or property injection . When using constructor injection cyclic dependencies can not be prevented but at least they are detected ."}}
{"translation": {"code": "protected < E > JtxResourceManager < E > lookupResourceManager ( final Class < E > resourceType ) { //noinspection unchecked JtxResourceManager < E > resourceManager = this . resourceManagers . get ( resourceType ) ; if ( resourceManager == null ) { throw new JtxException ( \"No registered resource manager for resource type: \" + resourceType . getSimpleName ( ) ) ; } return resourceManager ; }", "nl": "Lookups resource manager for provided type . Throws an exception if provider doesn t exists ."}}
{"translation": {"code": "protected void continueTx ( final JtxTransaction sourceTx , final JtxTransactionMode destMode ) { if ( ! validateExistingTransaction ) { return ; } JtxTransactionMode sourceMode = sourceTx . getTransactionMode ( ) ; JtxIsolationLevel destIsolationLevel = destMode . getIsolationLevel ( ) ; if ( destIsolationLevel != ISOLATION_DEFAULT ) { JtxIsolationLevel currentIsolationLevel = sourceMode . getIsolationLevel ( ) ; if ( currentIsolationLevel != destIsolationLevel ) { throw new JtxException ( \"Participating TX specifies isolation level: \" + destIsolationLevel + \" which is incompatible with existing TX: \" + currentIsolationLevel ) ; } } if ( ( ! destMode . isReadOnly ( ) ) && ( sourceMode . isReadOnly ( ) ) ) { throw new JtxException ( \"Participating TX is not marked as read-only, but existing TX is\" ) ; } }", "nl": "Check if propagation of a transaction is possible due to source and destination transaction modes ."}}
{"translation": {"code": "protected void associateTransaction ( final JtxTransaction tx ) { totalTransactions ++ ; ArrayList < JtxTransaction > txList = txStack . get ( ) ; if ( txList == null ) { txList = new ArrayList <> ( ) ; txStack . set ( txList ) ; } txList . add ( tx ) ; // add last }", "nl": "Associate transaction to current thread ."}}
{"translation": {"code": "public int totalThreadTransactionsWithStatus ( final JtxStatus status ) { ArrayList < JtxTransaction > txlist = txStack . get ( ) ; if ( txlist == null ) { return 0 ; } int count = 0 ; for ( JtxTransaction tx : txlist ) { if ( tx . getStatus ( ) == status ) { count ++ ; } } return count ; }", "nl": "Returns total number of transactions of the specified status associated with current thread ."}}
{"translation": {"code": "public int totalThreadTransactions ( ) { ArrayList < JtxTransaction > txList = txStack . get ( ) ; if ( txList == null ) { return 0 ; } return txList . size ( ) ; }", "nl": "Returns total number of transactions associated with current thread ."}}
{"translation": {"code": "public SqlType lookupSqlType ( final Class < ? extends SqlType > sqlTypeClass ) { SqlType sqlType = sqlTypes . get ( sqlTypeClass ) ; if ( sqlType == null ) { try { sqlType = ClassUtil . newInstance ( sqlTypeClass ) ; } catch ( Exception ex ) { throw new DbSqlException ( \"SQL type not found: \" + sqlTypeClass . getSimpleName ( ) , ex ) ; } sqlTypes . put ( sqlTypeClass , sqlType ) ; } return sqlType ; }", "nl": "Returns sql type instance . Instances are stored for better performances ."}}
{"translation": {"code": "public static Method findMethod ( final Class c , final String methodName ) { return findDeclaredMethod ( c , methodName , true ) ; }", "nl": "Returns method from an object matched by name . This may be considered as a slow operation since methods are matched one by one . Returns only accessible methods . Only first method is matched ."}}
{"translation": {"code": "protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor ctor = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }", "nl": "Inspects all declared constructors of a target type ."}}
{"translation": {"code": "private ClassReader createAdviceClassReader ( final Class < ? extends ProxyAdvice > advice ) { InputStream inputStream = null ; try { inputStream = ClassLoaderUtil . getClassAsStream ( advice ) ; return new ClassReader ( inputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( ioex ) ; } finally { StreamUtil . close ( inputStream ) ; } }", "nl": "Creates advice s class reader ."}}
{"translation": {"code": "public static < T > T [ ] resize ( T [ ] buffer , int newSize ) { Class < T > componentType = ( Class < T > ) buffer . getClass ( ) . getComponentType ( ) ; T [ ] temp = ( T [ ] ) Array . newInstance ( componentType , newSize ) ; System . arraycopy ( buffer , 0 , temp , 0 , buffer . length >= newSize ? newSize : buffer . length ) ; return temp ; }", "nl": "Resizes an array ."}}
{"translation": {"code": "DbQueryNamedParameter lookupNamedParameter ( final String name ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( name ) ) { return p ; } p = p . next ; } return null ; }", "nl": "Lookup for named parameter ."}}
{"translation": {"code": "@ Override public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }", "nl": "Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map ."}}
{"translation": {"code": "public PropertyInjectionPoint [ ] resolve ( Class type , final boolean autowire ) { final List < PropertyInjectionPoint > list = new ArrayList <> ( ) ; final Set < String > usedPropertyNames = new HashSet <> ( ) ; // lookup fields while ( type != Object . class ) { final ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; final PropertyDescriptor [ ] allPropertyDescriptors = cd . getAllPropertyDescriptors ( ) ; for ( PropertyDescriptor propertyDescriptor : allPropertyDescriptors ) { if ( propertyDescriptor . isGetterOnly ( ) ) { continue ; } if ( usedPropertyNames . contains ( propertyDescriptor . getName ( ) ) ) { continue ; } Class propertyType = propertyDescriptor . getType ( ) ; if ( ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { continue ; } BeanReferences reference = referencesResolver . readReferenceFromAnnotation ( propertyDescriptor ) ; if ( reference == null ) { if ( ! autowire ) { continue ; } else { reference = referencesResolver . buildDefaultReference ( propertyDescriptor ) ; } } list . add ( new PropertyInjectionPoint ( propertyDescriptor , reference ) ) ; usedPropertyNames . add ( propertyDescriptor . getName ( ) ) ; } // go to the supertype type = type . getSuperclass ( ) ; } final PropertyInjectionPoint [ ] fields ; if ( list . isEmpty ( ) ) { fields = PropertyInjectionPoint . EMPTY ; } else { fields = list . toArray ( new PropertyInjectionPoint [ 0 ] ) ; } return fields ; }", "nl": "Resolves all properties for given type ."}}
{"translation": {"code": "public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }", "nl": "Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy ."}}
{"translation": {"code": "public Set < ActionResult > getAllActionResults ( ) { final Set < ActionResult > set = new HashSet <> ( allResults . size ( ) ) ; allResults . forEachValue ( set :: add ) ; return set ; }", "nl": "Returns all action results as new set ."}}
{"translation": {"code": "@ Override protected int pruneCache ( ) { int count = 0 ; Iterator < CacheObject < K , V > > values = cacheMap . values ( ) . iterator ( ) ; while ( values . hasNext ( ) ) { CacheObject co = values . next ( ) ; if ( co . isExpired ( ) ) { values . remove ( ) ; count ++ ; } } return count ; }", "nl": "Prunes expired elements from the cache . Returns the number of removed objects ."}}
{"translation": {"code": "public void schedulePrune ( final long delay ) { if ( pruneTimer != null ) { pruneTimer . cancel ( ) ; } pruneTimer = new Timer ( ) ; pruneTimer . schedule ( new TimerTask ( ) { @ Override public void run ( ) { prune ( ) ; } } , delay , delay ) ; }", "nl": "Schedules prune ."}}
{"translation": {"code": "private void set ( final int i , double f ) { integer = i ; int fi = ( int ) f ; f -= fi ; integer += fi ; if ( f < 0 ) { f += 1 ; integer -- ; } this . fraction = f ; }", "nl": "Sets integer and fractional part with normalization . Normalization means that if double is out of range values will be correctly fixed ."}}
{"translation": {"code": "public JulianDate sub ( final JulianDate jds ) { int i = this . integer - jds . integer ; double f = this . fraction - jds . fraction ; return new JulianDate ( i , f ) ; }", "nl": "Subtracts a JD from current instance ."}}
{"translation": {"code": "public static DbThreadSession getThreadSession ( ) { DbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; if ( session == null ) { session = new DbThreadSession ( ) ; } return session ; }", "nl": "Returns existing thread session or new one if already not exist . If session doesn t exist it will be created using default connection provider ."}}
{"translation": {"code": "public static void closeThreadSession ( ) { DbThreadSession session = ( DbThreadSession ) ThreadDbSessionHolder . get ( ) ; if ( session != null ) { session . closeSession ( ) ; } }", "nl": "Closes thread session ."}}
{"translation": {"code": "protected ActionWrapper [ ] createExecutionArray ( ) { int totalInterceptors = ( this . actionRuntime . getInterceptors ( ) != null ? this . actionRuntime . getInterceptors ( ) . length : 0 ) ; int totalFilters = ( this . actionRuntime . getFilters ( ) != null ? this . actionRuntime . getFilters ( ) . length : 0 ) ; ActionWrapper [ ] executionArray = new ActionWrapper [ totalFilters + 1 + totalInterceptors + 1 ] ; // filters int index = 0 ; if ( totalFilters > 0 ) { System . arraycopy ( actionRuntime . getFilters ( ) , 0 , executionArray , index , totalFilters ) ; index += totalFilters ; } // result is executed AFTER the action AND interceptors executionArray [ index ++ ] = actionRequest -> { Object actionResult = actionRequest . invoke ( ) ; ActionRequest . this . madvocController . render ( ActionRequest . this , actionResult ) ; return actionResult ; } ; // interceptors if ( totalInterceptors > 0 ) { System . arraycopy ( actionRuntime . getInterceptors ( ) , 0 , executionArray , index , totalInterceptors ) ; index += totalInterceptors ; } // action executionArray [ index ] = actionRequest -> { actionResult = invokeActionMethod ( ) ; return actionResult ; } ; return executionArray ; }", "nl": "Creates execution array that will invoke all filters actions and results in correct order ."}}
{"translation": {"code": "protected Object invokeActionMethod ( ) throws Exception { if ( actionRuntime . isActionHandlerDefined ( ) ) { actionRuntime . getActionHandler ( ) . handle ( this ) ; return null ; } final Object [ ] params = targets . extractParametersValues ( ) ; try { return actionRuntime . getActionClassMethod ( ) . invoke ( action , params ) ; } catch ( InvocationTargetException itex ) { throw wrapToException ( unwrapThrowable ( itex ) ) ; } }", "nl": "Invokes action method after starting all interceptors . After method invocation all interceptors will finish in opposite order ."}}
{"translation": {"code": "public static byte [ ] toRawByteArray ( final char [ ] carr ) { byte [ ] barr = new byte [ carr . length << 1 ] ; for ( int i = 0 , bpos = 0 ; i < carr . length ; i ++ ) { char c = carr [ i ] ; barr [ bpos ++ ] = ( byte ) ( ( c & 0xFF00 ) >> 8 ) ; barr [ bpos ++ ] = ( byte ) ( c & 0x00FF ) ; } return barr ; }", "nl": "Converts char array into byte array by replacing each character with two bytes ."}}
{"translation": {"code": "public static int findFirstDiff ( final char [ ] source , final int index , final char [ ] match ) { for ( int i = index ; i < source . length ; i ++ ) { if ( ! equalsOne ( source [ i ] , match ) ) { return i ; } } return - 1 ; }", "nl": "Finds index of the first character in given array the differs from the given set of characters ."}}
{"translation": {"code": "protected void addPropertyInjectionPoint ( final PropertyInjectionPoint pip ) { if ( properties == null ) { properties = new PropertyInjectionPoint [ 1 ] ; properties [ 0 ] = pip ; } else { properties = ArraysUtil . append ( properties , pip ) ; } }", "nl": "Adds property injection point ."}}
{"translation": {"code": "protected void addMethodInjectionPoint ( final MethodInjectionPoint mip ) { if ( methods == null ) { methods = new MethodInjectionPoint [ 1 ] ; methods [ 0 ] = mip ; } else { methods = ArraysUtil . append ( methods , mip ) ; } }", "nl": "Adds method injection point ."}}
{"translation": {"code": "public static Properties subset ( final Properties p , String prefix , final boolean stripPrefix ) { if ( StringUtil . isBlank ( prefix ) ) { return p ; } if ( ! prefix . endsWith ( StringPool . DOT ) ) { prefix += ' ' ; } Properties result = new Properties ( ) ; int baseLen = prefix . length ( ) ; for ( Object o : p . keySet ( ) ) { String key = ( String ) o ; if ( key . startsWith ( prefix ) ) { result . setProperty ( stripPrefix ? key . substring ( baseLen ) : key , p . getProperty ( key ) ) ; } } return result ; }", "nl": "Creates new Properties object from the original one by copying those properties that have specified first part of the key name . Prefix may be optionally stripped during this process ."}}
{"translation": {"code": "public static Properties createFromFile ( final File file ) throws IOException { Properties prop = new Properties ( ) ; loadFromFile ( prop , file ) ; return prop ; }", "nl": "Create properties from the file ."}}
{"translation": {"code": "public void rollbackTransaction ( ) { log . debug ( \"Rolling-back transaction\" ) ; assertTxIsActive ( ) ; try { connection . rollback ( ) ; } catch ( SQLException sex ) { throw new DbSqlException ( \"Rollback TX failed\" , sex ) ; } finally { closeTx ( ) ; } }", "nl": "Roll back the current transaction . Transaction mode is closed ."}}
{"translation": {"code": "public void commitTransaction ( ) { log . debug ( \"Committing transaction\" ) ; assertTxIsActive ( ) ; try { connection . commit ( ) ; } catch ( SQLException sex ) { throw new DbSqlException ( \"Commit TX failed\" , sex ) ; } finally { closeTx ( ) ; } }", "nl": "Commit the current transaction writing any unflushed changes to the database . Transaction mode is closed ."}}
{"translation": {"code": "public static < T > T [ ] append ( T [ ] buffer , T newElement ) { T [ ] t = resize ( buffer , buffer . length + 1 ) ; t [ buffer . length ] = newElement ; return t ; }", "nl": "Appends an element to array ."}}
{"translation": {"code": "public static int indexOf ( char [ ] array , char value ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { return i ; } } return - 1 ; }", "nl": "Finds the first occurrence of an element in an array ."}}
{"translation": {"code": "public static int indexOf ( byte [ ] array , byte [ ] sub , int startIndex ) { return indexOf ( array , sub , startIndex , array . length ) ; }", "nl": "Finds the first occurrence in an array from specified given position ."}}
{"translation": {"code": "public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }", "nl": "Returns property descriptor . Declared flag is matched on both read and write methods ."}}
{"translation": {"code": "public FieldDescriptor getFieldDescriptor ( final String name , final boolean declared ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( declared ) ) { return null ; } } return fieldDescriptor ; }", "nl": "Returns field descriptor ."}}
{"translation": {"code": "public MethodInjectionPoint [ ] resolve ( final Class type ) { // lookup methods ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; List < MethodInjectionPoint > list = new ArrayList <> ( ) ; MethodDescriptor [ ] allMethods = cd . getAllMethodDescriptors ( ) ; for ( MethodDescriptor methodDescriptor : allMethods ) { Method method = methodDescriptor . getMethod ( ) ; if ( ClassUtil . isBeanPropertySetter ( method ) ) { // ignore setters continue ; } if ( method . getParameterTypes ( ) . length == 0 ) { // ignore methods with no argument continue ; } BeanReferences [ ] references = referencesResolver . readAllReferencesFromAnnotation ( method ) ; if ( references != null ) { MethodInjectionPoint methodInjectionPoint = new MethodInjectionPoint ( method , references ) ; list . add ( methodInjectionPoint ) ; } } final MethodInjectionPoint [ ] methodInjectionPoints ; if ( list . isEmpty ( ) ) { methodInjectionPoints = MethodInjectionPoint . EMPTY ; } else { methodInjectionPoints = list . toArray ( new MethodInjectionPoint [ 0 ] ) ; } return methodInjectionPoints ; }", "nl": "Resolve method injection points in given class ."}}
{"translation": {"code": "public static String stripLastCamelWord ( String name ) { int ndx = name . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( name . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { name = name . substring ( 0 , ndx ) ; } return name ; }", "nl": "Removes last CamelWord"}}
{"translation": {"code": "public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }", "nl": "Locates first dot after the last slash ."}}
{"translation": {"code": "public static String replaceChars ( final String s , final char [ ] sub , final char [ ] with ) { char [ ] str = s . toCharArray ( ) ; for ( int i = 0 ; i < str . length ; i ++ ) { char c = str [ i ] ; for ( int j = 0 ; j < sub . length ; j ++ ) { if ( c == sub [ j ] ) { str [ i ] = with [ j ] ; break ; } } } return new String ( str ) ; }", "nl": "Replaces all occurrences of a characters in a string ."}}
{"translation": {"code": "public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }", "nl": "Locates last index of dot after the optional last slash ."}}
{"translation": {"code": "public String resolveResultPathString ( final String path , final String value ) { final ResultPath resultPath = resolveResultPath ( path , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }", "nl": "Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done ."}}
{"translation": {"code": "public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = false ; if ( value != null ) { // [*] resolve alias in value value = resolveAlias ( value ) ; // [*] absolute paths if ( StringUtil . startsWithChar ( value , ' ' ) ) { absolutePath = true ; int dotNdx = value . indexOf ( \"..\" ) ; if ( dotNdx != - 1 ) { path = value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { path = value ; value = null ; } } else { // [*] resolve # in value and path int i = 0 ; while ( i < value . length ( ) ) { if ( value . charAt ( i ) != ' ' ) { break ; } int dotNdx = MadvocUtil . lastIndexOfSlashDot ( path ) ; if ( dotNdx != - 1 ) { // dot found path = path . substring ( 0 , dotNdx ) ; } i ++ ; } if ( i > 0 ) { // remove # from value value = value . substring ( i ) ; // [*] update path and value if ( StringUtil . startsWithChar ( value , ' ' ) ) { value = value . substring ( 1 ) ; } else { int dotNdx = value . indexOf ( \"..\" ) ; if ( dotNdx != - 1 ) { path += ' ' + value . substring ( 0 , dotNdx ) ; value = value . substring ( dotNdx + 2 ) ; } else { if ( value . length ( ) > 0 ) { if ( StringUtil . endsWithChar ( path , ' ' ) ) { path += value ; } else { path += ' ' + value ; } } value = null ; } } } } } if ( ! absolutePath ) { if ( resultPathPrefix != null ) { path = resultPathPrefix + path ; } } return new ResultPath ( path , value ) ; }", "nl": "Resolves result path ."}}
{"translation": {"code": "protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) { // alias markers not found if ( i == 0 ) { // try whole string as an alias String alias = lookupAlias ( value ) ; return ( alias != null ? alias : value ) ; } else { result . append ( value . substring ( i ) ) ; } break ; } // alias marked found result . append ( value . substring ( i , ndx ) ) ; ndx ++ ; int ndx2 = value . indexOf ( ' ' , ndx ) ; String aliasName = ( ndx2 == - 1 ? value . substring ( ndx ) : value . substring ( ndx , ndx2 ) ) ; // process alias String alias = lookupAlias ( aliasName ) ; if ( alias != null ) { result . append ( alias ) ; } else { // alias not found if ( log . isWarnEnabled ( ) ) { log . warn ( \"Alias not found: \" + aliasName ) ; } } i = ndx2 + 1 ; } // fix prefix '//' - may happened when aliases are used i = 0 ; len = result . length ( ) ; while ( i < len ) { if ( result . charAt ( i ) != ' ' ) { break ; } i ++ ; } if ( i > 1 ) { return result . substring ( i - 1 , len ) ; } return result . toString ( ) ; }", "nl": "Returns resolved alias result value or passed on if alias doesn t exist ."}}
{"translation": {"code": "private ClassReader getCachedAdviceClassReader ( final Class < ? extends ProxyAdvice > advice ) { if ( adviceClassReaderCache == null ) { adviceClassReaderCache = TypeCache . createDefault ( ) ; } ClassReader adviceReader = adviceClassReaderCache . get ( advice ) ; if ( adviceReader == null ) { adviceReader = createAdviceClassReader ( advice ) ; adviceClassReaderCache . put ( advice , adviceReader ) ; } return adviceReader ; }", "nl": "Returns class reader for advice ."}}
{"translation": {"code": "protected static String createTableRefName ( final Object entity ) { Class type = entity . getClass ( ) ; type = ( type == Class . class ? ( Class ) entity : type ) ; return ( type . getSimpleName ( ) + ' ' ) ; }", "nl": "Creates table reference name from entity type . Always appends an underscore to reference name in order to circumvent SQL compatibility issues when entity class name equals to a reserved word ."}}
{"translation": {"code": "protected void openConnectionForQuery ( ) { if ( connection == null ) { connection = connectionProvider . getConnection ( ) ; txActive = false ; // txAction should already be false try { connection . setAutoCommit ( true ) ; } catch ( SQLException sex ) { throw new DbSqlException ( \"Failed to open non-TX connection\" , sex ) ; } } }", "nl": "Opens connection in auto - commit mode if already not opened ."}}
{"translation": {"code": "protected void openTx ( ) { if ( connection == null ) { connection = connectionProvider . getConnection ( ) ; } txActive = true ; try { connection . setAutoCommit ( false ) ; if ( txMode . getIsolation ( ) != DbTransactionMode . ISOLATION_DEFAULT ) { connection . setTransactionIsolation ( txMode . getIsolation ( ) ) ; } connection . setReadOnly ( txMode . isReadOnly ( ) ) ; } catch ( SQLException sex ) { throw new DbSqlException ( \"Open TX failed\" , sex ) ; } }", "nl": "Opens a transaction ."}}
{"translation": {"code": "protected void closeTx ( ) { txActive = false ; try { connection . setAutoCommit ( true ) ; } catch ( SQLException sex ) { throw new DbSqlException ( \"Close TX failed\" , sex ) ; } }", "nl": "Closes current transaction ."}}
{"translation": {"code": "public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }", "nl": "Locates last dot after the last slash or just slash ."}}
{"translation": {"code": "public static String replaceFirst ( final String s , final String sub , final String with ) { int i = s . indexOf ( sub ) ; if ( i == - 1 ) { return s ; } return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; }", "nl": "Replaces the very first occurrence of a substring with supplied string ."}}
{"translation": {"code": "public static String replaceFirst ( final String s , final char sub , final char with ) { int index = s . indexOf ( sub ) ; if ( index == - 1 ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; }", "nl": "Replaces the very first occurrence of a character in a string ."}}
{"translation": {"code": "public static String replaceLast ( final String s , final String sub , final String with ) { int i = s . lastIndexOf ( sub ) ; if ( i == - 1 ) { return s ; } return s . substring ( 0 , i ) + with + s . substring ( i + sub . length ( ) ) ; }", "nl": "Replaces the very last occurrence of a substring with supplied string ."}}
{"translation": {"code": "private String getContentType ( final String dataHeader ) { String token = \"Content-Type:\" ; int start = dataHeader . indexOf ( token ) ; if ( start == - 1 ) { return StringPool . EMPTY ; } start += token . length ( ) ; return dataHeader . substring ( start ) . trim ( ) ; }", "nl": "Strips content type information from requests data header ."}}
{"translation": {"code": "protected void appendColumnName ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { query . append ( resolveTable ( tableRef , ded ) ) . append ( ' ' ) . append ( dec . getColumnName ( ) ) ; if ( templateData . getColumnAliasType ( ) != null ) { // create column aliases query . append ( AS ) ; switch ( templateData . getColumnAliasType ( ) ) { case TABLE_NAME : { final String tableName = ded . getTableNameForQuery ( ) ; query . append ( tableName ) . append ( columnAliasSeparator ) . append ( dec . getColumnNameForQuery ( ) ) ; break ; } case TABLE_REFERENCE : { final String tableName = ded . getTableName ( ) ; templateData . registerColumnDataForTableRef ( tableRef , tableName ) ; query . append ( tableRef ) . append ( columnAliasSeparator ) . append ( dec . getColumnNameForQuery ( ) ) ; break ; } case COLUMN_CODE : { final String tableName = ded . getTableName ( ) ; final String code = templateData . registerColumnDataForColumnCode ( tableName , dec . getColumnName ( ) ) ; query . append ( code ) ; break ; } } } }", "nl": "Simply appends column name with optional table reference and alias ."}}
{"translation": {"code": "protected void appendAlias ( final StringBuilder query , final DbEntityDescriptor ded , final DbEntityColumnDescriptor dec ) { final ColumnAliasType columnAliasType = templateData . getColumnAliasType ( ) ; if ( columnAliasType == null || columnAliasType == ColumnAliasType . TABLE_REFERENCE ) { final String tableName = ded . getTableName ( ) ; final String columnName = dec . getColumnNameForQuery ( ) ; templateData . registerColumnDataForTableRef ( tableRef , tableName ) ; query . append ( tableRef ) . append ( columnAliasSeparator ) . append ( columnName ) ; } else if ( columnAliasType == ColumnAliasType . COLUMN_CODE ) { final String tableName = ded . getTableName ( ) ; final String columnName = dec . getColumnName ( ) ; final String code = templateData . registerColumnDataForColumnCode ( tableName , columnName ) ; query . append ( code ) ; } else if ( columnAliasType == ColumnAliasType . TABLE_NAME ) { final String tableName = ded . getTableNameForQuery ( ) ; final String columnName = dec . getColumnNameForQuery ( ) ; query . append ( tableName ) . append ( columnAliasSeparator ) . append ( columnName ) ; } }", "nl": "Appends alias ."}}
{"translation": {"code": "@ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( hint != null ) { templateData . incrementHintsCount ( ) ; } }", "nl": "Counts actual real hints ."}}
{"translation": {"code": "public ServletOutputStream createOutputStream ( ) throws IOException { GzipResponseStream gzstream = new GzipResponseStream ( origResponse ) ; gzstream . setBuffer ( threshold ) ; return gzstream ; }", "nl": "Creates and returns a ServletOutputStream to write the content associated with this Response ."}}
{"translation": {"code": "protected void saveResultSet ( final ResultSet rs ) { if ( resultSets == null ) { resultSets = new HashSet <> ( ) ; } resultSets . add ( rs ) ; }", "nl": "Stores result set ."}}
{"translation": {"code": "public Q closeAllResultSets ( ) { final SQLException sex = closeQueryResultSets ( ) ; if ( sex != null ) { throw new DbSqlException ( \"Close associated ResultSets error\" , sex ) ; } return _this ( ) ; }", "nl": "Closes all result sets created by this query . Query remains active ."}}
{"translation": {"code": "protected SQLException closeQuery ( ) { SQLException sqlException = closeQueryResultSets ( ) ; if ( statement != null ) { try { statement . close ( ) ; } catch ( SQLException sex ) { if ( sqlException == null ) { sqlException = sex ; } else { sqlException . setNextException ( sex ) ; } } statement = null ; } query = null ; queryState = CLOSED ; return sqlException ; }", "nl": "Closes all assigned result sets and then closes the query . Query becomes closed ."}}
{"translation": {"code": "@ Override @ SuppressWarnings ( { \"ClassReferencesSubclass\" } ) public void close ( ) { final SQLException sqlException = closeQuery ( ) ; connection = null ; if ( this . session != null ) { this . session . detachQuery ( this ) ; } if ( sqlException != null ) { throw new DbSqlException ( \"Close query error\" , sqlException ) ; } }", "nl": "Closes the query and all created results sets and detaches itself from the session ."}}
{"translation": {"code": "public Q setFetchSize ( final int rows ) { checkNotClosed ( ) ; this . fetchSize = rows ; if ( statement != null ) { try { statement . setFetchSize ( fetchSize ) ; } catch ( SQLException sex ) { throw new DbSqlException ( this , \"Unable to set fetch size: \" + fetchSize , sex ) ; } } return _this ( ) ; }", "nl": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are needed . The number of rows specified affects only result sets created using this statement . If the value specified is zero then the hint is ignored . The default value is zero ."}}
{"translation": {"code": "protected void loopBody ( ) throws JspException { JspFragment body = getJspBody ( ) ; if ( body == null ) { return ; } LoopIterator loopIterator = new LoopIterator ( start , end , step , modulus ) ; if ( status != null ) { getJspContext ( ) . setAttribute ( status , loopIterator ) ; } while ( loopIterator . next ( ) ) { TagUtil . invokeBody ( body ) ; } if ( status != null ) { getJspContext ( ) . removeAttribute ( status ) ; } }", "nl": "Loops body ."}}
{"translation": {"code": "public Q setMaxRows ( final int maxRows ) { checkNotClosed ( ) ; this . maxRows = maxRows ; if ( statement != null ) { try { statement . setMaxRows ( maxRows ) ; } catch ( SQLException sex ) { throw new DbSqlException ( this , \"Unable to set max rows: \" + maxRows , sex ) ; } } return _this ( ) ; }", "nl": "Sets the limit for the maximum number of rows that any ResultSet object can contain to the given number . If the limit is exceeded the excess rows are silently dropped . Zero means there is no limit ."}}
{"translation": {"code": "protected int executeUpdate ( final boolean closeQuery ) { start = System . currentTimeMillis ( ) ; init ( ) ; final int result ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Executing update: \" + getQueryString ( ) ) ; } try { if ( preparedStatement == null ) { if ( generatedColumns != null ) { if ( generatedColumns . length == 0 ) { result = statement . executeUpdate ( query . sql , Statement . RETURN_GENERATED_KEYS ) ; } else { result = statement . executeUpdate ( query . sql , generatedColumns ) ; } } else { result = statement . executeUpdate ( query . sql ) ; } } else { result = preparedStatement . executeUpdate ( ) ; } } catch ( SQLException sex ) { throw new DbSqlException ( this , \"Query execution failed\" , sex ) ; } if ( closeQuery ) { close ( ) ; } elapsed = System . currentTimeMillis ( ) - start ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"execution time: \" + elapsed + \"ms\" ) ; } return result ; }", "nl": "Executes UPDATE INSERT or DELETE queries and optionally closes the query ."}}
{"translation": {"code": "protected long executeCount ( final boolean close ) { start = System . currentTimeMillis ( ) ; init ( ) ; ResultSet rs = null ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Executing prepared count: \" + getQueryString ( ) ) ; } try { if ( preparedStatement == null ) { rs = statement . executeQuery ( query . sql ) ; } else { rs = preparedStatement . executeQuery ( ) ; } final long firstLong = DbUtil . getFirstLong ( rs ) ; elapsed = System . currentTimeMillis ( ) - start ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"execution time: \" + elapsed + \"ms\" ) ; } return firstLong ; } catch ( SQLException sex ) { throw new DbSqlException ( this , \"Count query failed\" , sex ) ; } finally { DbUtil . close ( rs ) ; if ( close ) { close ( ) ; } } }", "nl": "Executes count queries and optionally closes query afterwards ."}}
{"translation": {"code": "public ResultSet getGeneratedColumns ( ) { checkInitialized ( ) ; if ( generatedColumns == null ) { throw new DbSqlException ( this , \"No column is specified as auto-generated\" ) ; } final ResultSet rs ; try { rs = statement . getGeneratedKeys ( ) ; } catch ( SQLException sex ) { throw new DbSqlException ( this , \"No generated keys\" , sex ) ; } saveResultSet ( rs ) ; totalOpenResultSetCount ++ ; return rs ; }", "nl": "Returns generated columns ."}}
{"translation": {"code": "public String getColumnName ( final String propertyName ) { DbEntityColumnDescriptor dec = findByPropertyName ( propertyName ) ; return dec == null ? null : dec . columnName ; }", "nl": "Returns column name for specified property name .."}}
{"translation": {"code": "public String getPropertyName ( final String columnName ) { DbEntityColumnDescriptor dec = findByColumnName ( columnName ) ; return dec == null ? null : dec . propertyName ; }", "nl": "Returns property name for specified column name ."}}
{"translation": {"code": "@ Override public int compareTo ( final Object o ) { DbEntityColumnDescriptor that = ( DbEntityColumnDescriptor ) o ; if ( this . isId != that . isId ) { return this . isId ? - 1 : 1 ; // IDs should be the first in the array } return this . columnName . compareTo ( that . columnName ) ; }", "nl": "Compares two column descriptors . Identity columns should be the first on the list . Each group then will be sorted by column name ."}}
{"translation": {"code": "void addAdviceInitMethod ( final String name ) { if ( adviceInits == null ) { adviceInits = new ArrayList <> ( ) ; } adviceInits . add ( name ) ; }", "nl": "Saves used constructors of advices ."}}
{"translation": {"code": "public PropertyDescriptor [ ] getAllPropertyDescriptors ( ) { if ( allProperties == null ) { PropertyDescriptor [ ] allProperties = new PropertyDescriptor [ propertyDescriptors . size ( ) ] ; int index = 0 ; for ( PropertyDescriptor propertyDescriptor : propertyDescriptors . values ( ) ) { allProperties [ index ] = propertyDescriptor ; index ++ ; } Arrays . sort ( allProperties , new Comparator < PropertyDescriptor > ( ) { @ Override public int compare ( final PropertyDescriptor pd1 , final PropertyDescriptor pd2 ) { return pd1 . getName ( ) . compareTo ( pd2 . getName ( ) ) ; } } ) ; this . allProperties = allProperties ; } return allProperties ; }", "nl": "Returns all property descriptors . Properties are sorted by name ."}}
{"translation": {"code": "protected Class extractType ( final BeanProperty bp ) { Getter getter = bp . getGetter ( isDeclared ) ; if ( getter != null ) { if ( bp . index != null ) { Class type = getter . getGetterRawComponentType ( ) ; return type == null ? Object . class : type ; } return getter . getGetterRawType ( ) ; } return null ; // this should not happens }", "nl": "Extracts type of current property ."}}
{"translation": {"code": "public static Throwable [ ] getExceptionChain ( Throwable throwable ) { ArrayList < Throwable > list = new ArrayList <> ( ) ; list . add ( throwable ) ; while ( ( throwable = throwable . getCause ( ) ) != null ) { list . add ( throwable ) ; } Throwable [ ] result = new Throwable [ list . size ( ) ] ; return list . toArray ( result ) ; }", "nl": "Returns exception chain starting from top up to root cause ."}}
{"translation": {"code": "public static StackTraceElement [ ] [ ] getStackTraceChain ( Throwable t , final String [ ] allow , final String [ ] deny ) { ArrayList < StackTraceElement [ ] > result = new ArrayList <> ( ) ; while ( t != null ) { StackTraceElement [ ] stack = getStackTrace ( t , allow , deny ) ; result . add ( stack ) ; t = t . getCause ( ) ; } StackTraceElement [ ] [ ] allStacks = new StackTraceElement [ result . size ( ) ] [  ] ; for ( int i = 0 ; i < allStacks . length ; i ++ ) { allStacks [ i ] = result . get ( i ) ; } return allStacks ; }", "nl": "Returns stack trace chain filtered by class names ."}}
{"translation": {"code": "public static StackTraceElement [ ] getStackTrace ( final Throwable t , final String [ ] allow , final String [ ] deny ) { StackTraceElement [ ] st = t . getStackTrace ( ) ; ArrayList < StackTraceElement > result = new ArrayList <> ( st . length ) ; elementLoop : for ( StackTraceElement element : st ) { String className = element . getClassName ( ) ; if ( allow != null ) { boolean validElemenet = false ; for ( String filter : allow ) { if ( className . contains ( filter ) ) { validElemenet = true ; break ; } } if ( ! validElemenet ) { continue ; } } if ( deny != null ) { for ( String filter : deny ) { if ( className . contains ( filter ) ) { continue elementLoop ; } } } result . add ( element ) ; } st = new StackTraceElement [ result . size ( ) ] ; return result . toArray ( st ) ; }", "nl": "Returns stack trace filtered by class names ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"ThrowCaughtLocally\" } ) public static StackTraceElement [ ] getCurrentStackTrace ( ) { StackTraceElement [ ] ste = new Exception ( ) . getStackTrace ( ) ; if ( ste . length > 1 ) { StackTraceElement [ ] result = new StackTraceElement [ ste . length - 1 ] ; System . arraycopy ( ste , 1 , result , 0 , ste . length - 1 ) ; return result ; } else { return ste ; } }", "nl": "Returns current stack trace in form of array of stack trace elements . First stack trace element is removed . Since an exception is thrown internally this method is slow ."}}
{"translation": {"code": "@ Override public Object remove ( final Object key ) { entries = null ; Object value = get ( key ) ; removeAttribute ( key . toString ( ) ) ; return value ; }", "nl": "Removes the specified request attribute ."}}
{"translation": {"code": "@ Override public Object put ( final String key , final Object value ) { entries = null ; Object previous = get ( key ) ; setAttribute ( key , value ) ; return previous ; }", "nl": "Saves an attribute in the request ."}}
{"translation": {"code": "@ Override public Set < Entry < String , Object > > entrySet ( ) { if ( entries == null ) { entries = new HashSet <> ( ) ; Iterator < String > iterator = getAttributeNames ( ) ; while ( iterator . hasNext ( ) ) { final String key = iterator . next ( ) ; final Object value = getAttribute ( key ) ; entries . add ( new Entry < String , Object > ( ) { @ Override public boolean equals ( final Object obj ) { if ( obj == null ) { return false ; } if ( this . getClass ( ) != obj . getClass ( ) ) { return false ; } Entry entry = ( Entry ) obj ; return ( ( key == null ) ? ( entry . getKey ( ) == null ) : key . equals ( entry . getKey ( ) ) ) && ( ( value == null ) ? ( entry . getValue ( ) == null ) : value . equals ( entry . getValue ( ) ) ) ; } @ Override public int hashCode ( ) { return ( ( key == null ) ? 0 : key . hashCode ( ) ) ^ ( ( value == null ) ? 0 : value . hashCode ( ) ) ; } @ Override public String getKey ( ) { return key ; } @ Override public Object getValue ( ) { return value ; } @ Override public Object setValue ( final Object obj ) { setAttribute ( key , obj ) ; return value ; } } ) ; } } return entries ; }", "nl": "Returns a Set of attributes from the http request ."}}
{"translation": {"code": "@ Override public void clear ( ) { entries = null ; Iterator < String > keys = getAttributeNames ( ) ; while ( keys . hasNext ( ) ) { removeAttribute ( keys . next ( ) ) ; } }", "nl": "Removes all attributes from the request as well as clears entries in this map ."}}
{"translation": {"code": "public DbEntityColumnDescriptor findByPropertyName ( final String propertyName ) { if ( propertyName == null ) { return null ; } init ( ) ; for ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { if ( columnDescriptor . propertyName . equals ( propertyName ) ) { return columnDescriptor ; } } return null ; }", "nl": "Finds column descriptor by property name ."}}
{"translation": {"code": "protected ResourceBundle getBundle ( final String bundleName , final Locale locale , final ClassLoader classLoader ) { return ResourceBundle . getBundle ( bundleName , locale , classLoader ) ; }", "nl": "Returns specified bundle . Invoked every time if cache is disabled . Input arguments are always valid ."}}
{"translation": {"code": "public static String buildMessage ( final String message , Throwable cause ) { if ( cause != null ) { cause = getRootCause ( cause ) ; StringBuilder buf = new StringBuilder ( ) ; if ( message != null ) { buf . append ( message ) . append ( \"; \" ) ; } buf . append ( \"<--- \" ) . append ( cause ) ; return buf . toString ( ) ; } else { return message ; } }", "nl": "Build a message for the given base message and its cause ."}}
{"translation": {"code": "public static ClassLoader getSystemClassLoader ( ) { if ( System . getSecurityManager ( ) == null ) { return ClassLoader . getSystemClassLoader ( ) ; } else { return AccessController . doPrivileged ( ( PrivilegedAction < ClassLoader > ) ClassLoader :: getSystemClassLoader ) ; } }", "nl": "Returns system class loader ."}}
{"translation": {"code": "public static InputStream getResourceAsStream ( final String resourceName , final ClassLoader callingClass ) throws IOException { URL url = getResourceUrl ( resourceName , callingClass ) ; if ( url != null ) { return url . openStream ( ) ; } return null ; }", "nl": "Opens a resource of the specified name for reading ."}}
{"translation": {"code": "public static InputStream getClassAsStream ( final Class clazz ) throws IOException { return getResourceAsStream ( ClassUtil . convertClassNameToFileName ( clazz ) , clazz . getClassLoader ( ) ) ; }", "nl": "Opens a class of the specified name for reading using class classloader ."}}
{"translation": {"code": "public void parseRequest ( ) throws IOException { if ( ServletUtil . isMultipartRequest ( request ) ) { parseRequestStream ( request . getInputStream ( ) , characterEncoding ) ; } else { Enumeration names = request . getParameterNames ( ) ; while ( names . hasMoreElements ( ) ) { String paramName = ( String ) names . nextElement ( ) ; String [ ] values = request . getParameterValues ( paramName ) ; putParameters ( paramName , values ) ; } } }", "nl": "Checks if request if multi - part and parse it . If request is not multi - part it copies all parameters to make usage the same in both cases ."}}
{"translation": {"code": "protected Object invokeSetter ( final Setter setter , final BeanProperty bp , Object value ) { try { final MapperFunction setterMapperFunction = setter . getMapperFunction ( ) ; if ( setterMapperFunction != null ) { value = setterMapperFunction . apply ( value ) ; } final Class type = setter . getSetterRawType ( ) ; if ( ClassUtil . isTypeOf ( type , Collection . class ) ) { Class componentType = setter . getSetterRawComponentType ( ) ; value = convertToCollection ( value , type , componentType ) ; } else { // no collections value = convertType ( value , type ) ; } setter . invokeSetter ( bp . bean , value ) ; } catch ( Exception ex ) { if ( isSilent ) { return null ; } throw new BeanException ( \"Setter failed: \" + setter , ex ) ; } return value ; }", "nl": "Invokes setter but first converts type to match the setter type ."}}
{"translation": {"code": "protected void arrayForcedSet ( final BeanProperty bp , Object array , final int index , Object value ) { Class componentType = array . getClass ( ) . getComponentType ( ) ; array = ensureArraySize ( bp , array , componentType , index ) ; value = convertType ( value , componentType ) ; Array . set ( array , index , value ) ; }", "nl": "Sets the array element forced . If index is greater then arrays length array will be expanded to the index . If speed is critical it is better to allocate an array with proper size before using this method ."}}
{"translation": {"code": "protected Object createBeanProperty ( final BeanProperty bp ) { Setter setter = bp . getSetter ( true ) ; if ( setter == null ) { return null ; } Class type = setter . getSetterRawType ( ) ; Object newInstance ; try { newInstance = ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { if ( isSilent ) { return null ; } throw new BeanException ( \"Invalid property: \" + bp . name , bp , ex ) ; } newInstance = invokeSetter ( setter , bp , newInstance ) ; return newInstance ; }", "nl": "Creates new instance for current property name through its setter . It uses default constructor!"}}
{"translation": {"code": "public String findDefaultMessage ( final Locale locale , final String key ) { String indexedKey = calcIndexKey ( key ) ; String msg = getMessage ( fallbackBundlename , locale , key , indexedKey ) ; if ( msg != null ) { return msg ; } for ( String bname : defaultBundles ) { msg = getMessage ( bname , locale , key , indexedKey ) ; if ( msg != null ) { return msg ; } } return null ; }", "nl": "Finds message in default bundles only starting from fallback bundlename ."}}
{"translation": {"code": "protected void addInitMethodPoints ( final InitMethodPoint [ ] methods ) { if ( initMethods == null ) { initMethods = methods ; } else { initMethods = ArraysUtil . join ( initMethods , methods ) ; } }", "nl": "Adds init methods ."}}
{"translation": {"code": "public DbEntityColumnDescriptor findByColumnName ( final String columnName ) { if ( columnName == null ) { return null ; } init ( ) ; for ( DbEntityColumnDescriptor columnDescriptor : columnDescriptors ) { if ( columnDescriptor . columnName . equalsIgnoreCase ( columnName ) ) { return columnDescriptor ; } } return null ; }", "nl": "Finds column descriptor by column name . Case is ignored ."}}
{"translation": {"code": "public String getQueryString ( ) { if ( debug ) { if ( ( callableStatement != null ) ) { if ( preparedStatement instanceof LoggableCallableStatement ) { return ( ( LoggableCallableStatement ) callableStatement ) . getQueryString ( ) ; } } if ( preparedStatement != null ) { if ( preparedStatement instanceof LoggablePreparedStatement ) { return ( ( LoggablePreparedStatement ) preparedStatement ) . getQueryString ( ) ; } } } if ( query != null ) { return query . sql ; } return sqlString ; }", "nl": "Returns query SQL string . For prepared statements returned sql string with quick - and - dirty replaced values ."}}
{"translation": {"code": "public static String suffix ( String string , final String suffix ) { if ( ! string . endsWith ( suffix ) ) { string += suffix ; } return string ; }", "nl": "Appends suffix if doesn t exist ."}}
{"translation": {"code": "public static String prefix ( String string , final String prefix ) { if ( ! string . startsWith ( prefix ) ) { string = prefix + string ; } return string ; }", "nl": "Inserts prefix if doesn t exist ."}}
{"translation": {"code": "public static String surround ( String string , final String prefix , final String suffix ) { if ( ! string . startsWith ( prefix ) ) { string = prefix + string ; } if ( ! string . endsWith ( suffix ) ) { string += suffix ; } return string ; }", "nl": "Surrounds the string with provided prefix and suffix if such missing from string ."}}
{"translation": {"code": "public static boolean isCharAtEqual ( final String string , final int index , final char charToCompare ) { if ( ( index < 0 ) || ( index >= string . length ( ) ) ) { return false ; } return string . charAt ( index ) == charToCompare ; }", "nl": "Safely compares provided char with char on given location ."}}
{"translation": {"code": "public static String convertCharset ( final String source , final String srcCharsetName , final String newCharsetName ) { if ( srcCharsetName . equals ( newCharsetName ) ) { return source ; } return StringUtil . newString ( StringUtil . getBytes ( source , srcCharsetName ) , newCharsetName ) ; }", "nl": "Converts string charset . If charset names are the same the same string is returned ."}}
{"translation": {"code": "@ Override public void init ( final FilterConfig filterConfig ) { this . filterConfig = filterConfig ; this . encoding = filterConfig . getInitParameter ( \"encoding\" ) ; if ( this . encoding == null ) { this . encoding = JoddCore . encoding ; } this . ignore = Converter . get ( ) . toBooleanValue ( filterConfig . getInitParameter ( \"ignore\" ) , true ) ; }", "nl": "Place this filter into service ."}}
{"translation": {"code": "public static int [ ] indexOfRegion ( final String string , final String leftBoundary , final String rightBoundary , final int offset ) { int ndx = offset ; int [ ] res = new int [ 4 ] ; ndx = string . indexOf ( leftBoundary , ndx ) ; if ( ndx == - 1 ) { return null ; } res [ 0 ] = ndx ; ndx += leftBoundary . length ( ) ; res [ 1 ] = ndx ; ndx = string . indexOf ( rightBoundary , ndx ) ; if ( ndx == - 1 ) { return null ; } res [ 2 ] = ndx ; res [ 3 ] = ndx + rightBoundary . length ( ) ; return res ; }", "nl": "Returns indexes of the first region without escaping character ."}}
{"translation": {"code": "public static String stripTrailingChar ( final String string , final char c ) { if ( string . length ( ) > 0 ) { if ( string . charAt ( string . length ( ) - 1 ) == c ) { return string . substring ( 0 , string . length ( ) - 1 ) ; } } return string ; }", "nl": "Strips trailing char if string ends with one ."}}
{"translation": {"code": "public static String stripLeadingChar ( final String string , final char c ) { if ( string . length ( ) > 0 ) { if ( string . charAt ( 0 ) == c ) { return string . substring ( 1 ) ; } } return string ; }", "nl": "Strips leading char if string starts with one ."}}
{"translation": {"code": "public static boolean equalsIgnoreCase ( final String [ ] as , final String [ ] as1 ) { if ( as . length != as1 . length ) { return false ; } for ( int i = 0 ; i < as . length ; i ++ ) { if ( ! as [ i ] . equalsIgnoreCase ( as1 [ i ] ) ) { return false ; } } return true ; }", "nl": "Compares two string arrays ."}}
{"translation": {"code": "public static int countIgnoreCase ( final String source , final String sub ) { int count = 0 ; int j = 0 ; int sublen = sub . length ( ) ; if ( sublen == 0 ) { return 0 ; } while ( true ) { int i = indexOfIgnoreCase ( source , sub , j ) ; if ( i == - 1 ) { break ; } count ++ ; j = i + sublen ; } return count ; }", "nl": "Count substring occurrences in a source string ignoring case ."}}
{"translation": {"code": "public static boolean startsWithIgnoreCase ( final String src , final String subS , final int startIndex ) { String sub = subS . toLowerCase ( ) ; int sublen = sub . length ( ) ; if ( startIndex + sublen > src . length ( ) ) { return false ; } int j = 0 ; int i = startIndex ; while ( j < sublen ) { char source = Character . toLowerCase ( src . charAt ( i ) ) ; if ( sub . charAt ( j ) != source ) { return false ; } j ++ ; i ++ ; } return true ; }", "nl": "Tests if this string starts with the specified prefix with ignored case and with the specified prefix beginning a specified index ."}}
{"translation": {"code": "private static String changeFirstCharacterCase ( final boolean capitalize , final String string ) { int strLen = string . length ( ) ; if ( strLen == 0 ) { return string ; } char ch = string . charAt ( 0 ) ; char modifiedCh ; if ( capitalize ) { modifiedCh = Character . toUpperCase ( ch ) ; } else { modifiedCh = Character . toLowerCase ( ch ) ; } if ( modifiedCh == ch ) { // no change, return unchanged string return string ; } char [ ] chars = string . toCharArray ( ) ; chars [ 0 ] = modifiedCh ; return new String ( chars ) ; }", "nl": "Internal method for changing the first character case ."}}
{"translation": {"code": "public static String [ ] toStringArray ( final Object value ) { if ( value == null ) { return new String [ 0 ] ; } Class < ? > type = value . getClass ( ) ; if ( ! type . isArray ( ) ) { return new String [ ] { value . toString ( ) } ; } Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { if ( componentType == int . class ) { return ArraysUtil . toStringArray ( ( int [ ] ) value ) ; } else if ( componentType == long . class ) { return ArraysUtil . toStringArray ( ( long [ ] ) value ) ; } else if ( componentType == double . class ) { return ArraysUtil . toStringArray ( ( double [ ] ) value ) ; } else if ( componentType == float . class ) { return ArraysUtil . toStringArray ( ( float [ ] ) value ) ; } else if ( componentType == boolean . class ) { return ArraysUtil . toStringArray ( ( boolean [ ] ) value ) ; } else if ( componentType == short . class ) { return ArraysUtil . toStringArray ( ( short [ ] ) value ) ; } else if ( componentType == byte . class ) { return ArraysUtil . toStringArray ( ( byte [ ] ) value ) ; } else { throw new IllegalArgumentException ( ) ; } } else { return ArraysUtil . toStringArray ( ( Object [ ] ) value ) ; } }", "nl": "Converts an array object to array of strings where every element of input array is converted to a string . If input is not an array the result will still be an array with one element ."}}
{"translation": {"code": "public static String remove ( final String string , final char ch ) { int stringLen = string . length ( ) ; char [ ] result = new char [ stringLen ] ; int offset = 0 ; for ( int i = 0 ; i < stringLen ; i ++ ) { char c = string . charAt ( i ) ; if ( c == ch ) { continue ; } result [ offset ] = c ; offset ++ ; } if ( offset == stringLen ) { return string ; // no changes } return new String ( result , 0 , offset ) ; }", "nl": "Removes a single character from string ."}}
{"translation": {"code": "public static String remove ( final String s , final String sub ) { int c = 0 ; int sublen = sub . length ( ) ; if ( sublen == 0 ) { return s ; } int i = s . indexOf ( sub , c ) ; if ( i == - 1 ) { return s ; } StringBuilder sb = new StringBuilder ( s . length ( ) ) ; do { sb . append ( s , c , i ) ; c = i + sublen ; } while ( ( i = s . indexOf ( sub , c ) ) != - 1 ) ; if ( c < s . length ( ) ) { sb . append ( s , c , s . length ( ) ) ; } return sb . toString ( ) ; }", "nl": "Removes all substring occurrences from the string ."}}
{"translation": {"code": "public static String replaceLast ( final String s , final char sub , final char with ) { int index = s . lastIndexOf ( sub ) ; if ( index == - 1 ) { return s ; } char [ ] str = s . toCharArray ( ) ; str [ index ] = with ; return new String ( str ) ; }", "nl": "Replaces the very last occurrence of a character in a string ."}}
{"translation": {"code": "public static String cutToIndexOf ( String string , final String substring ) { int i = string . indexOf ( substring ) ; if ( i != - 1 ) { string = string . substring ( 0 , i ) ; } return string ; }", "nl": "Cuts the string from beginning to the first index of provided substring ."}}
{"translation": {"code": "public static String cutFromIndexOf ( String string , final String substring ) { int i = string . indexOf ( substring ) ; if ( i != - 1 ) { string = string . substring ( i ) ; } return string ; }", "nl": "Cuts the string from the first index of provided substring to the end ."}}
{"translation": {"code": "public static String cutPrefix ( String string , final String prefix ) { if ( string . startsWith ( prefix ) ) { string = string . substring ( prefix . length ( ) ) ; } return string ; }", "nl": "Cuts prefix if exists ."}}
{"translation": {"code": "public static String cutSuffix ( String string , final String suffix ) { if ( string . endsWith ( suffix ) ) { string = string . substring ( 0 , string . length ( ) - suffix . length ( ) ) ; } return string ; }", "nl": "Cuts sufix if exists ."}}
{"translation": {"code": "@ Override public int compare ( final T o1 , final T o2 ) { for ( Comparator < T > comparator : comparators ) { int result = comparator . compare ( o1 , o2 ) ; if ( result != 0 ) { return result ; } } return 0 ; }", "nl": "Compares two objects starting with first comparator ; if they are equals proceeds to the next comparator and so on ."}}
{"translation": {"code": "public PetiteConfig setDefaultWiringMode ( final WiringMode defaultWiringMode ) { if ( ( defaultWiringMode == null ) || ( defaultWiringMode == WiringMode . DEFAULT ) ) { throw new PetiteException ( \"Invalid default wiring mode: \" + defaultWiringMode ) ; } this . defaultWiringMode = defaultWiringMode ; return this ; }", "nl": "Specifies default wiring mode ."}}
{"translation": {"code": "public static < T extends Serializable > T cloneViaSerialization ( final T obj ) throws IOException , ClassNotFoundException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream ( ) ; ObjectOutputStream out = null ; ObjectInputStream in = null ; Object objCopy = null ; try { out = new ObjectOutputStream ( bos ) ; out . writeObject ( obj ) ; out . flush ( ) ; byte [ ] bytes = bos . toByteArray ( ) ; in = new ObjectInputStream ( new ByteArrayInputStream ( bytes ) ) ; objCopy = in . readObject ( ) ; } finally { StreamUtil . close ( out ) ; StreamUtil . close ( in ) ; } return ( T ) objCopy ; }", "nl": "Create object copy using serialization mechanism ."}}
{"translation": {"code": "public static void writeObject ( final File dest , final Object object ) throws IOException { FileOutputStream fos = null ; BufferedOutputStream bos = null ; ObjectOutputStream oos = null ; try { fos = new FileOutputStream ( dest ) ; bos = new BufferedOutputStream ( fos ) ; oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( object ) ; } finally { StreamUtil . close ( oos ) ; StreamUtil . close ( bos ) ; StreamUtil . close ( fos ) ; } }", "nl": "Writes serializable object to a file . Existing file will be overwritten ."}}
{"translation": {"code": "public static Object readObject ( final File source ) throws IOException , ClassNotFoundException { Object result = null ; FileInputStream fis = null ; BufferedInputStream bis = null ; ObjectInputStream ois = null ; try { fis = new FileInputStream ( source ) ; bis = new BufferedInputStream ( fis ) ; ois = new ObjectInputStream ( bis ) ; result = ois . readObject ( ) ; } finally { StreamUtil . close ( ois ) ; StreamUtil . close ( bis ) ; StreamUtil . close ( fis ) ; } return result ; }", "nl": "Reads serialized object from the file ."}}
{"translation": {"code": "public static byte [ ] objectToByteArray ( final Object obj ) throws IOException { FastByteArrayOutputStream bos = new FastByteArrayOutputStream ( ) ; ObjectOutputStream oos = null ; try { oos = new ObjectOutputStream ( bos ) ; oos . writeObject ( obj ) ; } finally { StreamUtil . close ( oos ) ; } return bos . toByteArray ( ) ; }", "nl": "Serialize an object to byte array ."}}
{"translation": {"code": "public static Object byteArrayToObject ( final byte [ ] data ) throws IOException , ClassNotFoundException { Object retObj = null ; ByteArrayInputStream bais = new ByteArrayInputStream ( data ) ; ObjectInputStream ois = null ; try { ois = new ObjectInputStream ( bais ) ; retObj = ois . readObject ( ) ; } finally { StreamUtil . close ( ois ) ; } return retObj ; }", "nl": "De - serialize an object from byte array ."}}
{"translation": {"code": "protected String [ ] [ ] resolveMappedTypesTableNames ( final Class [ ] types ) { if ( cachedMappedNames == null ) { String [ ] [ ] names = new String [ types . length ] [  ] ; for ( int i = 0 ; i < types . length ; i ++ ) { Class type = types [ i ] ; if ( type != null ) { DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; if ( ded != null ) { Class [ ] mappedTypes = ded . getMappedTypes ( ) ; if ( mappedTypes != null ) { names [ i ] = createTypesTableNames ( mappedTypes ) ; } } } } cachedMappedNames = names ; } return cachedMappedNames ; }", "nl": "Resolved mapped type names for each type ."}}
{"translation": {"code": "private void resolveColumnsAndProperties ( final Class type ) { PropertyDescriptor [ ] allProperties = ClassIntrospector . get ( ) . lookup ( type ) . getAllPropertyDescriptors ( ) ; List < DbEntityColumnDescriptor > decList = new ArrayList <> ( allProperties . length ) ; int idcount = 0 ; HashSet < String > names = new HashSet <> ( allProperties . length ) ; for ( PropertyDescriptor propertyDescriptor : allProperties ) { DbEntityColumnDescriptor dec = DbMetaUtil . resolveColumnDescriptors ( this , propertyDescriptor , isAnnotated , columnNamingStrategy ) ; if ( dec != null ) { if ( ! names . add ( dec . getColumnName ( ) ) ) { throw new DbOomException ( \"Duplicate column name: \" + dec . getColumnName ( ) ) ; } decList . add ( dec ) ; if ( dec . isId ) { idcount ++ ; } } } if ( decList . isEmpty ( ) ) { throw new DbOomException ( \"No column mappings in entity: \" + type ) ; } columnDescriptors = decList . toArray ( new DbEntityColumnDescriptor [ 0 ] ) ; Arrays . sort ( columnDescriptors ) ; // extract ids from sorted list if ( idcount > 0 ) { idColumnDescriptors = new DbEntityColumnDescriptor [ idcount ] ; idcount = 0 ; for ( DbEntityColumnDescriptor dec : columnDescriptors ) { if ( dec . isId ) { idColumnDescriptors [ idcount ++ ] = dec ; } } } }", "nl": "Resolves list of all columns and properties ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) protected Object readColumnValue ( final int colNdx , final Class destinationType , final Class < ? extends SqlType > sqlTypeClass , final int columnDbSqlType ) { if ( colNdx != cachedColumnNdx ) { try { SqlType sqlType ; if ( sqlTypeClass != null ) { sqlType = SqlTypeManager . get ( ) . lookupSqlType ( sqlTypeClass ) ; } else { sqlType = SqlTypeManager . get ( ) . lookup ( destinationType ) ; } if ( sqlType != null ) { cachedColumnValue = sqlType . readValue ( resultSet , colNdx + 1 , destinationType , columnDbSqlType ) ; } else { cachedColumnValue = resultSet . getObject ( colNdx + 1 ) ; cachedColumnValue = TypeConverterManager . get ( ) . convertType ( cachedColumnValue , destinationType ) ; } } catch ( SQLException sex ) { throw new DbOomException ( dbOomQuery , \"Invalid value for column #\" + ( colNdx + 1 ) , sex ) ; } cachedColumnNdx = colNdx ; } return cachedColumnValue ; }", "nl": "Reads column value from result set . Since this method may be called more then once for the same column it caches column values ."}}
{"translation": {"code": "@ Override protected void renderView ( final ActionRequest actionRequest , final String target ) throws Exception { HttpServletRequest request = actionRequest . getHttpServletRequest ( ) ; HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; RequestDispatcher dispatcher = request . getRequestDispatcher ( target ) ; if ( dispatcher == null ) { response . sendError ( SC_NOT_FOUND , \"Result not found: \" + target ) ; // should never happened return ; } // If we're included, then include the view, otherwise do forward. // This allow the page to, for example, set content type. if ( DispatcherUtil . isPageIncluded ( request , response ) ) { dispatcher . include ( request , response ) ; } else { dispatcher . forward ( request , response ) ; } }", "nl": "Renders the view by dispatching to the target JSP ."}}
{"translation": {"code": "public ActionRuntime registerAction ( final Class actionClass , final String actionMethodName , final ActionDefinition actionDefinition ) { Method actionMethod = resolveActionMethod ( actionClass , actionMethodName ) ; return registerAction ( actionClass , actionMethod , actionDefinition ) ; }", "nl": "Registers action with provided action class and method name ."}}
{"translation": {"code": "@ Override public void write ( final int b ) throws IOException { if ( closed ) { throw new IOException ( \"Cannot write to a closed output stream\" ) ; } if ( bufferCount >= buffer . length ) { flushToGZip ( ) ; } buffer [ bufferCount ++ ] = ( byte ) b ; }", "nl": "Writes the specified byte to our output stream ."}}
{"translation": {"code": "@ Override public void close ( ) throws IOException { if ( closed ) { return ; } if ( gzipstream != null ) { flushToGZip ( ) ; gzipstream . close ( ) ; gzipstream = null ; } else { if ( bufferCount > 0 ) { output . write ( buffer , 0 , bufferCount ) ; bufferCount = 0 ; } } output . close ( ) ; closed = true ; }", "nl": "Closes this output stream causing any buffered data to be flushed and any further output data to throw an IOException ."}}
{"translation": {"code": "public < E > DbEntityDescriptor < E > removeEntity ( final Class < E > type ) { DbEntityDescriptor < E > ded = descriptorsMap . remove ( type ) ; if ( ded == null ) { ded = createDbEntityDescriptor ( type ) ; } entityNamesMap . remove ( ded . getEntityName ( ) ) ; tableNamesMap . remove ( ded . getTableName ( ) ) ; return ded ; }", "nl": "Removes entity and returns removed descriptor ."}}
{"translation": {"code": "public < E > DbEntityDescriptor < E > registerEntity ( final Class < E > type , final boolean force ) { if ( force ) { removeEntity ( type ) ; } return registerEntity ( type ) ; }", "nl": "Registers entity . Existing entity will be removed if exist so no exception will be thrown ."}}
{"translation": {"code": "public < E > DbEntityDescriptor < E > registerType ( final Class < E > type ) { DbEntityDescriptor < E > ded = createDbEntityDescriptor ( type ) ; DbEntityDescriptor < E > existing = descriptorsMap . put ( type , ded ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Register \" + type . getName ( ) + \" as \" + ded . getTableName ( ) ) ; } if ( existing != null ) { if ( ded . getType ( ) == type ) { return ded ; } throw new DbOomException ( \"Type already registered: \" + existing . getType ( ) ) ; } existing = entityNamesMap . put ( ded . getEntityName ( ) , ded ) ; if ( existing != null ) { throw new DbOomException ( \"Name '\" + ded . getEntityName ( ) + \"' already mapped to an entity: \" + existing . getType ( ) ) ; } return ded ; }", "nl": "Registers just type and entity names . Enough for most usages ."}}
{"translation": {"code": "public static String cutSurrounding ( final String string , final String prefix , final String suffix ) { int start = 0 ; int end = string . length ( ) ; if ( string . startsWith ( prefix ) ) { start = prefix . length ( ) ; } if ( string . endsWith ( suffix ) ) { end -= suffix . length ( ) ; } if ( end <= start ) { return StringPool . EMPTY ; } return string . substring ( start , end ) ; }", "nl": "Removes surrounding prefix and suffixes ."}}
{"translation": {"code": "private boolean isConnectionValid ( final ConnectionData connectionData , final long now ) { if ( ! validateConnection ) { return true ; } if ( now < connectionData . lastUsed + validationTimeout ) { return true ; } Connection conn = connectionData . connection ; if ( validationQuery == null ) { try { return ! conn . isClosed ( ) ; } catch ( SQLException sex ) { return false ; } } boolean valid = true ; Statement st = null ; try { st = conn . createStatement ( ) ; st . execute ( validationQuery ) ; } catch ( SQLException sex ) { valid = false ; } finally { if ( st != null ) { try { st . close ( ) ; } catch ( SQLException ignore ) { } } } return valid ; }", "nl": "Checks if existing connection is valid and available . It may happens that if connection is not used for a while it becomes inactive although not technically closed ."}}
{"translation": {"code": "private static boolean match ( final CharSequence string , final CharSequence pattern , int sNdx , int pNdx ) { int pLen = pattern . length ( ) ; if ( pLen == 1 ) { if ( pattern . charAt ( 0 ) == ' ' ) { // speed-up return true ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = false ; while ( true ) { // check if end of string and/or pattern occurred if ( ( sNdx >= sLen ) ) { // end of string still may have pending '*' in pattern while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == ' ' ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { // end of pattern, but not end of the string return false ; } char p = pattern . charAt ( pNdx ) ; // pattern char // perform logic if ( ! nextIsNotWildcard ) { if ( p == ' ' ) { pNdx ++ ; nextIsNotWildcard = true ; continue ; } if ( p == ' ' ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == ' ' ) { char pNext = 0 ; // next pattern char if ( pNdx + 1 < pLen ) { pNext = pattern . charAt ( pNdx + 1 ) ; } if ( pNext == ' ' ) { // double '*' have the same effect as one '*' pNdx ++ ; continue ; } int i ; pNdx ++ ; // find recursively if there is any substring from the end of the // line that matches the rest of the pattern !!! for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) ) { return true ; } } return false ; } } else { nextIsNotWildcard = false ; } // check if pattern char and string char are equals if ( p != string . charAt ( sNdx ) ) { return false ; } // everything matches for now, continue sNdx ++ ; pNdx ++ ; } }", "nl": "Internal matching recursive function ."}}
{"translation": {"code": "public static String exceptionChainToString ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; while ( t != null ) { t . printStackTrace ( pw ) ; t = t . getCause ( ) ; } StreamUtil . close ( pw ) ; StreamUtil . close ( sw ) ; return sw . toString ( ) ; }", "nl": "Prints full exception stack trace from top to root cause into a String ."}}
{"translation": {"code": "@ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }", "nl": "Resolves and registers table references ."}}
{"translation": {"code": "protected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }", "nl": "Detects if alias is defined in annotation and registers it if so ."}}
{"translation": {"code": "public void registerHint ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }", "nl": "Registers a hint ."}}
{"translation": {"code": "protected boolean isGzipEligible ( final HttpServletRequest request ) { // request parameter name if ( requestParameterName . length ( ) != 0 ) { String forceGzipString = request . getParameter ( requestParameterName ) ; if ( forceGzipString != null ) { return Converter . get ( ) . toBooleanValue ( forceGzipString , false ) ; } } // extract uri String uri = request . getRequestURI ( ) ; if ( uri == null ) { return false ; } uri = uri . toLowerCase ( ) ; boolean result = false ; // check uri if ( matches == null ) { // match == * if ( extensions == null ) { // extensions == * return true ; } // extension String extension = FileNameUtil . getExtension ( uri ) ; if ( extension . length ( ) > 0 ) { extension = extension . toLowerCase ( ) ; if ( StringUtil . equalsOne ( extension , extensions ) != - 1 ) { result = true ; } } } else { if ( wildcards ) { result = Wildcard . matchPathOne ( uri , matches ) != - 1 ; } else { for ( String match : matches ) { if ( uri . contains ( match ) ) { result = true ; break ; } } } } if ( ( result ) && ( excludes != null ) ) { if ( wildcards ) { if ( Wildcard . matchPathOne ( uri , excludes ) != - 1 ) { result = false ; } } else { for ( String exclude : excludes ) { if ( uri . contains ( exclude ) ) { result = false ; // excludes founded break ; } } } } return result ; }", "nl": "Determine if request is eligible for GZipping ."}}
{"translation": {"code": "public static String createMethodSignaturesKey ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }", "nl": "Creates unique key for method signatures map ."}}
{"translation": {"code": "public static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }", "nl": "Prepares return value ."}}
{"translation": {"code": "protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( \"GET\" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , true ) ; } } } ) ; } }", "nl": "Inject request parameters ."}}
{"translation": {"code": "public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }", "nl": "Stores one argument . Index is 1 - based . No conversion occurs ."}}
{"translation": {"code": "public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , \"Basic realm=\\\"\" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }", "nl": "Sends correct headers to require basic authentication for the given realm ."}}
{"translation": {"code": "public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }", "nl": "Loads one argument . Index is 1 - based . No conversion occurs ."}}
{"translation": {"code": "public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }", "nl": "Decodes a BASE64 encoded char array ."}}
{"translation": {"code": "protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }", "nl": "Collects all action results ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"UnusedDeclaration\" } ) public String rewrite ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod ) { return actionPath ; }", "nl": "Rewrites action path ."}}
{"translation": {"code": "public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }", "nl": "Loads all method arguments before INVOKEVIRTUAL call ."}}
{"translation": {"code": "public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }", "nl": "Loads all method arguments before INVOKESPECIAL call ."}}
{"translation": {"code": "protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }", "nl": "Reads class or method annotation for action interceptors ."}}
{"translation": {"code": "public static String getRequestUri ( final HttpServletRequest request ) { String result = getIncludeRequestUri ( request ) ; if ( result == null ) { result = request . getRequestURI ( ) ; } return result ; }", "nl": "Get current request uri ."}}
{"translation": {"code": "protected byte [ ] convertValueToArray ( final Object value ) { if ( value instanceof Blob ) { final Blob blob = ( Blob ) value ; try { final long length = blob . length ( ) ; if ( length > Integer . MAX_VALUE ) { throw new TypeConversionException ( \"Blob is too big.\" ) ; } return blob . getBytes ( 1 , ( int ) length ) ; } catch ( SQLException sex ) { throw new TypeConversionException ( value , sex ) ; } } if ( value instanceof File ) { try { return FileUtil . readBytes ( ( File ) value ) ; } catch ( IOException ioex ) { throw new TypeConversionException ( value , ioex ) ; } } if ( value instanceof Collection ) { final Collection collection = ( Collection ) value ; final byte [ ] target = new byte [ collection . size ( ) ] ; int i = 0 ; for ( final Object element : collection ) { target [ i ] = convertType ( element ) ; i ++ ; } return target ; } if ( value instanceof Iterable ) { final Iterable iterable = ( Iterable ) value ; final ArrayList < Byte > byteArrayList = new ArrayList <> ( ) ; for ( final Object element : iterable ) { final byte convertedValue = convertType ( element ) ; byteArrayList . add ( Byte . valueOf ( convertedValue ) ) ; } final byte [ ] array = new byte [ byteArrayList . size ( ) ] ; for ( int i = 0 ; i < byteArrayList . size ( ) ; i ++ ) { final Byte b = byteArrayList . get ( i ) ; array [ i ] = b . byteValue ( ) ; } return array ; } if ( value instanceof CharSequence ) { final String [ ] strings = StringUtil . splitc ( value . toString ( ) , ArrayConverter . NUMBER_DELIMITERS ) ; return convertArrayToArray ( strings ) ; } // everything else: return convertToSingleElementArray ( value ) ; }", "nl": "Converts non - array value to array . Detects various types and collections iterates them to make conversion and to create target array ."}}
{"translation": {"code": "public static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( \"File not found: \" + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( \"File too big: \" + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }", "nl": "Prepares response for file download with provided mime type ."}}
{"translation": {"code": "public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String extension = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( extension ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; } // support internationalization // See https://tools.ietf.org/html/rfc6266#section-5 for more information. if ( fileName != null ) { String name = FileNameUtil . getName ( fileName ) ; String encodedFileName = URLCoder . encode ( name ) ; response . setHeader ( CONTENT_DISPOSITION , \"attachment;filename=\\\"\" + name + \"\\\";filename*=utf8''\" + encodedFileName ) ; } }", "nl": "Prepares response for various provided data ."}}
{"translation": {"code": "public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }", "nl": "Stores context path in page context and request scope ."}}
{"translation": {"code": "public Q setObjects ( final Object ... objects ) { int index = 1 ; for ( final Object object : objects ) { setObject ( index ++ , object ) ; } return _this ( ) ; }", "nl": "Sets an array of objects parameters in given order ."}}
{"translation": {"code": "public void add ( final Iterator < T > iterator ) { if ( allIterators . contains ( iterator ) ) { throw new IllegalArgumentException ( \"Duplicate iterator\" ) ; } allIterators . add ( iterator ) ; }", "nl": "Adds an iterator to this composite ."}}
{"translation": {"code": "public void insertChunkAfter ( final SqlChunk previous ) { SqlChunk next = previous . nextChunk ; previous . nextChunk = this ; this . previousChunk = previous ; if ( next != null ) { next . previousChunk = this ; this . nextChunk = next ; } }", "nl": "Appends chunk to previous one and maintains the double - linked list of the previous chunk . Current surrounding connections of this chunk will be cut - off ."}}
{"translation": {"code": "protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( \"Madvoc WebApp not initialized.\" ) ; } log . debug ( \"Registering Madvoc WebApp components\" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }", "nl": "Registers default Madvoc components ."}}
{"translation": {"code": "protected DbEntityDescriptor lookupType ( final Class entity ) { final DbEntityDescriptor ded = dbEntityManager . lookupType ( entity ) ; if ( ded == null ) { throw new DbSqlBuilderException ( \"Invalid or not-persistent entity: \" + entity . getName ( ) ) ; } return ded ; }", "nl": "Lookups for entity name and throws an exception if entity type is invalid ."}}
{"translation": {"code": "public Q setBean ( final String beanName , final Object bean ) { if ( bean == null ) { return _this ( ) ; } init ( ) ; final String beanNamePrefix = beanName + ' ' ; query . forEachNamedParameter ( p -> { final String paramName = p . name ; if ( paramName . startsWith ( beanNamePrefix ) ) { final String propertyName = paramName . substring ( beanNamePrefix . length ( ) ) ; if ( BeanUtil . declared . hasRootProperty ( bean , propertyName ) ) { final Object value = BeanUtil . declared . getProperty ( bean , propertyName ) ; setObject ( paramName , value ) ; } } } ) ; return _this ( ) ; }", "nl": "Sets bean parameters from bean . Non - existing bean properties are ignored ."}}
{"translation": {"code": "@ Override protected < R extends ActionInterceptor > R createWrapper ( final Class < R > wrapperClass ) { return petiteContainer . createBean ( wrapperClass ) ; }", "nl": "Acquires interceptor from Petite container ."}}
{"translation": {"code": "public < T > T findGeneratedKey ( final Class < T > type ) { return find ( new Class [ ] { type } , false , getGeneratedColumns ( ) ) ; }", "nl": "Finds generated key column of given type ."}}
{"translation": {"code": "public JulianDate add ( final JulianDate jds ) { int i = this . integer + jds . integer ; double f = this . fraction + jds . fraction ; return new JulianDate ( i , f ) ; }", "nl": "Adds a JD to current instance ."}}
{"translation": {"code": "protected ResultSetMapper createResultSetMapper ( final ResultSet resultSet ) { final Map < String , ColumnData > columnAliases = sqlgen != null ? sqlgen . getColumnData ( ) : null ; return new DefaultResultSetMapper ( dbOom , resultSet , columnAliases , cacheEntities , this ) ; }", "nl": "Factory for result sets mapper ."}}
{"translation": {"code": "protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , true ) ; } } ) ; } }", "nl": "Injects request attributes ."}}
{"translation": {"code": "private void setBean ( final Object bean ) { this . bean = bean ; this . cd = ( bean == null ? null : introspector . lookup ( bean . getClass ( ) ) ) ; this . first = false ; this . updateProperty = true ; }", "nl": "Sets new bean instance ."}}
{"translation": {"code": "public static void invokeBody ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( \"Tag body failed\" , ioex ) ; } }", "nl": "Invokes tag body ."}}
{"translation": {"code": "public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; } // multipart if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; } }", "nl": "Copies all request parameters to attributes ."}}
{"translation": {"code": "public int copyAll ( final OutputStream out ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; } return count ; }", "nl": "Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour ."}}
{"translation": {"code": "public int copyMax ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( true ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }", "nl": "Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected ."}}
{"translation": {"code": "public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ; // interceptors ActionInterceptor [ ] actionInterceptors = parseActionInterceptors ( actionClass , actionMethod , actionConfig ) ; // filters ActionFilter [ ] actionFilters = parseActionFilters ( actionClass , actionMethod , actionConfig ) ; // build action definition when not provided if ( actionDefinition == null ) { actionDefinition = parseActionDefinition ( actionClass , actionMethod ) ; } detectAndRegisterAlias ( annotationValues , actionDefinition ) ; final boolean async = parseMethodAsyncFlag ( actionMethod ) ; final boolean auth = parseMethodAuthFlag ( actionMethod ) ; final Class < ? extends ActionResult > actionResult = parseActionResult ( actionMethod ) ; final Class < ? extends ActionResult > defaultActionResult = actionConfig . getActionResult ( ) ; return createActionRuntime ( null , actionClass , actionMethod , actionResult , defaultActionResult , actionFilters , actionInterceptors , actionDefinition , async , auth ) ; }", "nl": "Parses java action method annotation and returns its action runtime ."}}
{"translation": {"code": "public static String adviceMethodName ( final String name , final int index ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + index ; }", "nl": "Builds advice method name ."}}
{"translation": {"code": "protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ; // 1 - read annotations first String packageActionPathFromAnnotation ; mainloop : while ( true ) { MadvocAction madvocActionAnnotation = actionPackage . getAnnotation ( MadvocAction . class ) ; packageActionPathFromAnnotation = madvocActionAnnotation != null ? madvocActionAnnotation . value ( ) . trim ( ) : null ; if ( StringUtil . isEmpty ( packageActionPathFromAnnotation ) ) { packageActionPathFromAnnotation = null ; } if ( packageActionPathFromAnnotation == null ) { // next package String newPackage = actionPackage . getName ( ) ; actionPackage = null ; while ( actionPackage == null ) { final int ndx = newPackage . lastIndexOf ( ' ' ) ; if ( ndx == - 1 ) { // end of hierarchy, nothing found break mainloop ; } newPackage = newPackage . substring ( 0 , ndx ) ; actionPackage = Packages . of ( actionClass . getClassLoader ( ) , newPackage ) ; } } else { // annotation found, register root rootPackages . addRootPackage ( actionPackage . getName ( ) , packageActionPathFromAnnotation ) ; break ; } } // 2 - read root package String packagePath = rootPackages . findPackagePathForActionPackage ( actionPackageName ) ; if ( packagePath == null ) { return ArraysUtil . array ( null , null ) ; } return ArraysUtil . array ( StringUtil . stripChar ( packagePath , ' ' ) , StringUtil . surround ( packagePath , StringPool . SLASH ) ) ; }", "nl": "Reads action path for package . If annotation is not set on package - level class package will be used for package action path part ."}}
{"translation": {"code": "protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }", "nl": "Collects all action runtime configurations ."}}
{"translation": {"code": "@ Override public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }", "nl": "Returns buffered writer . Buffer will be created if not already used ."}}
{"translation": {"code": "public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( \"Invalid object reference: \" + ref ) ; } return value ; }", "nl": "Lookups for object reference and throws an exception if reference doesn t exist ."}}
{"translation": {"code": "public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . desc ; }", "nl": "Returns entity descriptor for provided table reference ."}}
{"translation": {"code": "public static String getUrl ( final HttpServletRequest request ) { String servletPath = request . getServletPath ( ) ; String query = request . getQueryString ( ) ; if ( ( query != null ) && ( query . length ( ) != 0 ) ) { servletPath += ' ' + query ; } return servletPath ; }", "nl": "Returns url without context path convenient for request dispatcher ."}}
{"translation": {"code": "public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }", "nl": "Converts all separators to the system separator ."}}
{"translation": {"code": "protected void appendMissingSpace ( final StringBuilder out ) { int len = out . length ( ) ; if ( len == 0 ) { return ; } len -- ; if ( ! CharUtil . isWhitespace ( out . charAt ( len ) ) ) { out . append ( ' ' ) ; } }", "nl": "Appends missing space if the output doesn t end with whitespace ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return true ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return false ; } boolean found = false ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = true ; } } return found ; }", "nl": "Checks token value . C"}}
{"translation": {"code": "public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }", "nl": "Returns table alias for provided table reference ."}}
{"translation": {"code": "@ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = \"<exception>\" ; throw ex ; } catch ( Throwable th ) { result = \"<throwable>\" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , result ) ; } return result ; }", "nl": "Measure action invocation time ."}}
{"translation": {"code": "public static String resolveIpAddress ( final String hostname ) { try { InetAddress netAddress ; if ( hostname == null || hostname . equalsIgnoreCase ( LOCAL_HOST ) ) { netAddress = InetAddress . getLocalHost ( ) ; } else { netAddress = Inet4Address . getByName ( hostname ) ; } return netAddress . getHostAddress ( ) ; } catch ( UnknownHostException ignore ) { return null ; } }", "nl": "Resolves IP address from a hostname ."}}
{"translation": {"code": "protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( \"Table reference not used in this query: \" + tableRef ) ; } return ded ; }", "nl": "Lookups for table reference and throws an exception if table reference not found ."}}
{"translation": {"code": "public static byte [ ] downloadBytes ( final String url ) throws IOException { try ( InputStream inputStream = new URL ( url ) . openStream ( ) ) { return StreamUtil . readBytes ( inputStream ) ; } }", "nl": "Downloads resource as byte array ."}}
{"translation": {"code": "public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( \"Duplicated table reference: \" + tableReference ) ; } }", "nl": "Registers table reference for provided entity ."}}
{"translation": {"code": "@ Override public byte [ ] getFileContent ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }", "nl": "Returns the content of file upload item ."}}
{"translation": {"code": "protected void inject ( final ActionRequest actionRequest ) { final Targets targets = actionRequest . getTargets ( ) ; final ServletContext servletContext = actionRequest . getHttpServletRequest ( ) . getServletContext ( ) ; scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( actionRequest , targets ) ) ; }", "nl": "Performs injection ."}}
{"translation": {"code": "protected void outject ( final ActionRequest actionRequest ) { final Targets targets = actionRequest . getTargets ( ) ; scopeResolver . forEachScope ( madvocScope -> madvocScope . outject ( actionRequest , targets ) ) ; }", "nl": "Performs outjection ."}}
{"translation": {"code": "protected Object parseRequestBody ( final String body , final Class targetType ) { return JsonParser . create ( ) . parse ( body , targetType ) ; }", "nl": "Parses request body into the target type ."}}
{"translation": {"code": "public static String resolveHostName ( final byte [ ] ip ) { try { InetAddress address = InetAddress . getByAddress ( ip ) ; return address . getHostName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } }", "nl": "Resolves host name from IP address bytes ."}}
{"translation": {"code": "public static void pushInt ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }", "nl": "Pushes int value in an optimal way ."}}
{"translation": {"code": "public Q setMap ( final Map parameters ) { if ( parameters == null ) { return _this ( ) ; } init ( ) ; query . forEachNamedParameter ( p -> { final String paramName = p . name ; setObject ( paramName , parameters . get ( paramName ) ) ; } ) ; return _this ( ) ; }", "nl": "Sets properties from the map ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }", "nl": "Generates new CSRF token and puts it in the session . Returns generated token value ."}}
{"translation": {"code": "public void setObjectReference ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }", "nl": "Saves object reference ."}}
{"translation": {"code": "protected static Class resolveClass ( final Object object ) { Class type = object . getClass ( ) ; return type == Class . class ? ( Class ) object : type ; }", "nl": "Resolves object to a class ."}}
{"translation": {"code": "private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }", "nl": "Does the work of getting the path ."}}
{"translation": {"code": "public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }", "nl": "Returns object reference ."}}
{"translation": {"code": "protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) { // read annotation String methodActionPath = annotationValues != null ? annotationValues . value ( ) : null ; if ( methodActionPath == null ) { methodActionPath = methodName ; } else { if ( methodActionPath . equals ( Action . NONE ) ) { return ArraysUtil . array ( null , null ) ; } } // check for defaults for ( String path : actionConfig . getActionMethodNames ( ) ) { if ( methodActionPath . equals ( path ) ) { methodActionPath = null ; break ; } } return ArraysUtil . array ( methodName , methodActionPath ) ; }", "nl": "Reads action path from the action method ."}}
{"translation": {"code": "public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ; // find ins and outs final Class [ ] paramTypes = actionClassMethod . getParameterTypes ( ) ; final MethodParam [ ] params = new MethodParam [ paramTypes . length ] ; final Annotation [ ] [ ] paramAnns = actionClassMethod . getParameterAnnotations ( ) ; String [ ] methodParamNames = null ; // for all elements: action and method arguments... for ( int ndx = 0 ; ndx < paramTypes . length ; ndx ++ ) { Class paramType = paramTypes [ ndx ] ; // lazy init to postpone bytecode usage, when method has no arguments if ( methodParamNames == null ) { methodParamNames = actionMethodParamNameResolver . resolveParamNames ( actionClassMethod ) ; } final String paramName = methodParamNames [ ndx ] ; final Annotation [ ] parameterAnnotations = paramAnns [ ndx ] ; final ScopeData paramsScopeData = scopeDataInspector . inspectMethodParameterScopes ( paramName , paramType , parameterAnnotations ) ; MapperFunction mapperFunction = null ; for ( final Annotation annotation : parameterAnnotations ) { if ( annotation instanceof Mapper ) { mapperFunction = MapperFunctionInstances . get ( ) . lookup ( ( ( Mapper ) annotation ) . value ( ) ) ; break ; } } params [ ndx ] = new MethodParam ( paramTypes [ ndx ] , paramName , scopeDataInspector . detectAnnotationType ( parameterAnnotations ) , paramsScopeData , mapperFunction ) ; } return new ActionRuntime ( null , actionClass , actionClassMethod , filters , interceptors , actionDefinition , actionResult , defaultActionResult , async , auth , scopeData , params ) ; }", "nl": "Creates new instance of action runtime configuration . Initialize caches ."}}
{"translation": {"code": "public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }", "nl": "Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator ."}}
{"translation": {"code": "protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }", "nl": "Reads method s alias value ."}}
{"translation": {"code": "public static String adviceFieldName ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }", "nl": "Builds advice field name ."}}
{"translation": {"code": "public Enumeration < String > getFileParameterNames ( ) { if ( mreq == null ) { return null ; } return Collections . enumeration ( mreq . getFileParameterNames ( ) ) ; }", "nl": "Get an enumeration of the parameter names for uploaded files"}}
{"translation": {"code": "public static boolean include ( final ServletRequest request , final ServletResponse response , final String page ) throws IOException , ServletException { RequestDispatcher dispatcher = request . getRequestDispatcher ( page ) ; if ( dispatcher != null ) { dispatcher . include ( request , response ) ; return true ; } return false ; }", "nl": "Include page which path is relative to the current HTTP request ."}}
{"translation": {"code": "protected String resolveTable ( final String tableRef , final DbEntityDescriptor ded ) { String tableAlias = templateData . getTableAlias ( tableRef ) ; if ( tableAlias != null ) { return tableAlias ; } return ded . getTableNameForQuery ( ) ; }", "nl": "Resolves table name or alias that will be used in the query ."}}
{"translation": {"code": "protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , true ) ; } } ) ; } }", "nl": "Inject uploaded files from multipart request parameters ."}}
{"translation": {"code": "public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( \"Invalid argument index: \" + argIndex ) ; } }", "nl": "Validates argument index ."}}
{"translation": {"code": "public static String downloadString ( final String url , final String encoding ) throws IOException { try ( InputStream inputStream = new URL ( url ) . openStream ( ) ) { return new String ( StreamUtil . readChars ( inputStream , encoding ) ) ; } }", "nl": "Downloads resource as String ."}}
{"translation": {"code": "public static void downloadFile ( final String url , final File file ) throws IOException { try ( InputStream inputStream = new URL ( url ) . openStream ( ) ; ReadableByteChannel rbc = Channels . newChannel ( inputStream ) ; FileChannel fileChannel = FileChannel . open ( file . toPath ( ) , StandardOpenOption . CREATE , StandardOpenOption . TRUNCATE_EXISTING , StandardOpenOption . WRITE ) ) { fileChannel . transferFrom ( rbc , 0 , Long . MAX_VALUE ) ; } }", "nl": "Downloads resource to a file potentially very efficiently ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public < T > T getBean ( final Class < T > type ) { String name = resolveBeanName ( type ) ; return ( T ) getBean ( name ) ; }", "nl": "Returns Petite bean instance . Bean name will be resolved from provided type ."}}
{"translation": {"code": "protected void registerAsConsumer ( final ClassScanner classScanner ) { classScanner . registerEntryConsumer ( classPathEntry -> { final String entryName = classPathEntry . name ( ) ; if ( entryName . endsWith ( actionClassSuffix ) ) { try { acceptActionClass ( classPathEntry . loadClass ( ) ) ; } catch ( Exception ex ) { log . debug ( \"Invalid Madvoc action, ignoring: \" + entryName ) ; } } else if ( classPathEntry . isTypeSignatureInUse ( MADVOC_COMPONENT_ANNOTATION ) ) { try { acceptMadvocComponentClass ( classPathEntry . loadClass ( ) ) ; } catch ( Exception ex ) { log . debug ( \"Invalid Madvoc component ignoring: {}\" + entryName ) ; } } } ) ; }", "nl": "Parses class name that matches madvoc - related names ."}}
{"translation": {"code": "public static Properties createFromClasspath ( final String ... rootTemplate ) { Properties p = new Properties ( ) ; return loadFromClasspath ( p , rootTemplate ) ; }", "nl": "Creates properties from classpath ."}}
{"translation": {"code": "public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }", "nl": "Prepares parameters for further processing ."}}
{"translation": {"code": "public static boolean isAllEmpty ( final String ... strings ) { for ( String string : strings ) { if ( ! isEmpty ( string ) ) { return false ; } } return true ; }", "nl": "Determines if string array contains empty strings ."}}
{"translation": {"code": "public static boolean isAllBlank ( final String ... strings ) { for ( String string : strings ) { if ( ! isBlank ( string ) ) { return false ; } } return true ; }", "nl": "Determines if string array contains just blank strings ."}}
{"translation": {"code": "public static void cropAll ( final String ... strings ) { for ( int i = 0 ; i < strings . length ; i ++ ) { String string = strings [ i ] ; if ( string != null ) { string = crop ( strings [ i ] ) ; } strings [ i ] = string ; } }", "nl": "Crops all elements of string array ."}}
{"translation": {"code": "public static String trimLeft ( final String src ) { int len = src . length ( ) ; int st = 0 ; while ( ( st < len ) && ( CharUtil . isWhitespace ( src . charAt ( st ) ) ) ) { st ++ ; } return st > 0 ? src . substring ( st ) : src ; }", "nl": "Trim whitespaces from the left ."}}
{"translation": {"code": "public static Properties createFromString ( final String data ) throws IOException { Properties p = new Properties ( ) ; loadFromString ( p , data ) ; return p ; }", "nl": "Creates properties from string ."}}
{"translation": {"code": "public static void loadFromString ( final Properties p , final String data ) throws IOException { try ( ByteArrayInputStream is = new ByteArrayInputStream ( data . getBytes ( StringPool . ISO_8859_1 ) ) ) { p . load ( is ) ; } }", "nl": "Loads properties from string ."}}
{"translation": {"code": "public static String trimRight ( final String src ) { int len = src . length ( ) ; int count = len ; while ( ( len > 0 ) && ( CharUtil . isWhitespace ( src . charAt ( len - 1 ) ) ) ) { len -- ; } return ( len < count ) ? src . substring ( 0 , len ) : src ; }", "nl": "Trim whitespaces from the right ."}}
{"translation": {"code": "public static int indexOfWhitespace ( final String string , final int startindex , final int endindex ) { for ( int i = startindex ; i < endindex ; i ++ ) { if ( CharUtil . isWhitespace ( string . charAt ( i ) ) ) { return i ; } } return - 1 ; }", "nl": "Returns first index of a whitespace character starting from specified index offset ."}}
{"translation": {"code": "public static char [ ] renderBody ( final JspFragment body ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( body , writer ) ; return writer . toCharArray ( ) ; }", "nl": "Renders tag body to char array ."}}
{"translation": {"code": "public static boolean endsWithChar ( final String s , final char c ) { if ( s . length ( ) == 0 ) { return false ; } return s . charAt ( s . length ( ) - 1 ) == c ; }", "nl": "Returns if string ends with provided character ."}}
{"translation": {"code": "public static String renderBodyToString ( final JspFragment body ) throws JspException { char [ ] result = renderBody ( body ) ; return new String ( result ) ; }", "nl": "Renders tag body to string ."}}
{"translation": {"code": "@ Override public DbSession getDbSession ( ) { log . debug ( \"Requesting db TX manager session\" ) ; final DbJtxTransaction jtx = ( DbJtxTransaction ) jtxTxManager . getTransaction ( ) ; if ( jtx == null ) { throw new DbSqlException ( \"No transaction is in progress and DbSession can't be provided. \" + \"It seems that transaction manager is not used to begin a transaction.\" ) ; } return jtx . requestResource ( ) ; }", "nl": "Returns session from JTX transaction manager and started transaction ."}}
{"translation": {"code": "@ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }", "nl": "Builds new transaction instance ."}}
{"translation": {"code": "public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( \"Can't zlib folder\" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }", "nl": "Compresses a file into zlib archive ."}}
{"translation": {"code": "public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }", "nl": "Decompress gzip archive ."}}
{"translation": {"code": "public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( \"Can't gzip folder\" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }", "nl": "Compresses a file into gzip archive ."}}
{"translation": {"code": "public static String resolveProperty ( final Map map , final String key ) { String value = getProperty ( map , key ) ; if ( value == null ) { return null ; } value = stp . parse ( value , macroName -> getProperty ( map , macroName ) ) ; return value ; }", "nl": "Returns property with resolved variables ."}}
{"translation": {"code": "public static void resolveAllVariables ( final Properties prop ) { for ( Object o : prop . keySet ( ) ) { String key = ( String ) o ; String value = resolveProperty ( prop , key ) ; prop . setProperty ( key , value ) ; } }", "nl": "Resolves all variables ."}}
{"translation": {"code": "public static String getProperty ( final Map map , final String key , final String defaultValue ) { Object val = map . get ( key ) ; return ( val instanceof String ) ? ( String ) val : defaultValue ; }", "nl": "Returns String property from a map ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }", "nl": "Once when value is read from result set prepare it to match destination type ."}}
{"translation": {"code": "public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }", "nl": "Stores value in database . Value is casted to sql type ."}}
{"translation": {"code": "public void register ( final Class type , final Class < ? extends SqlType > sqlTypeClass ) { types . put ( type , lookupSqlType ( sqlTypeClass ) ) ; }", "nl": "Registers sql type for provided type ."}}
{"translation": {"code": "public SqlType lookup ( final Class clazz ) { SqlType sqlType ; for ( Class x = clazz ; x != null ; x = x . getSuperclass ( ) ) { sqlType = types . get ( clazz ) ; if ( sqlType != null ) { return sqlType ; } Class [ ] interfaces = x . getInterfaces ( ) ; for ( Class i : interfaces ) { sqlType = types . get ( i ) ; if ( sqlType != null ) { return sqlType ; } } } return null ; }", "nl": "Retrieves SQL type for provided type . All subclasses and interfaces are examined for matching sql type ."}}
{"translation": {"code": "public DbSqlBuilder updateColumn ( final Object entity , final String columnRef ) { final Object value = BeanUtil . pojo . getProperty ( entity , columnRef ) ; return updateColumn ( entity , columnRef , value ) ; }", "nl": "Reads property value and updates the DB ."}}
{"translation": {"code": "public static void addToZip ( final ZipOutputStream zos , final File file , String path , final String comment , final boolean recursive ) throws IOException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . toString ( ) ) ; } if ( path == null ) { path = file . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = file . isDirectory ( ) ; if ( isDir ) { // add folder record if ( ! StringUtil . endsWithChar ( path , ' ' ) ) { path += ' ' ; } } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( file . lastModified ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } if ( isDir ) { zipEntry . setSize ( 0 ) ; zipEntry . setCrc ( 0 ) ; } zos . putNextEntry ( zipEntry ) ; if ( ! isDir ) { InputStream is = new FileInputStream ( file ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } } zos . closeEntry ( ) ; // continue adding if ( recursive && file . isDirectory ( ) ) { boolean noRelativePath = StringUtil . isEmpty ( path ) ; final File [ ] children = file . listFiles ( ) ; if ( children != null && children . length != 0 ) { for ( File child : children ) { String childRelativePath = ( noRelativePath ? StringPool . EMPTY : path ) + child . getName ( ) ; addToZip ( zos , child , childRelativePath , comment , recursive ) ; } } } }", "nl": "Adds single entry to ZIP output stream ."}}
{"translation": {"code": "protected ActionRequest createActionRequest ( final String actionPath , final String [ ] actionPathChunks , final ActionRuntime actionRuntime , final Object action , final HttpServletRequest servletRequest , final HttpServletResponse servletResponse ) { return new ActionRequest ( this , actionPath , actionPathChunks , actionRuntime , action , servletRequest , servletResponse ) ; }", "nl": "Creates new action request ."}}
{"translation": {"code": "public static String join ( final Object [ ] array , final String separator ) { if ( array == null ) { return null ; } if ( array . length == 0 ) { return StringPool . EMPTY ; } if ( array . length == 1 ) { return String . valueOf ( array [ 0 ] ) ; } final StringBuilder sb = new StringBuilder ( array . length * 16 ) ; for ( int i = 0 ; i < array . length ; i ++ ) { if ( i > 0 ) { sb . append ( separator ) ; } sb . append ( array [ i ] ) ; } return sb . toString ( ) ; }", "nl": "Joins an array of objects into one string with separator ."}}
{"translation": {"code": "public static String resolveSchemaName ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }", "nl": "Resolves schema name from a type . Uses default schema name if not specified ."}}
{"translation": {"code": "protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }", "nl": "Collects all interceptors ."}}
{"translation": {"code": "protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }", "nl": "Removes expired tokens if token set is full ."}}
{"translation": {"code": "public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }", "nl": "Returns all cookies from client that matches provided name ."}}
{"translation": {"code": "protected int calculateTo ( final int from , final int count , final int size ) { int to = size ; if ( count != - 1 ) { to = from + count ; if ( to > size ) { to = size ; } } return to ; }", "nl": "Calculates TO ."}}
{"translation": {"code": "public static String insert ( final String src , final String insert , int offset ) { if ( offset < 0 ) { offset = 0 ; } if ( offset > src . length ( ) ) { offset = src . length ( ) ; } StringBuilder sb = new StringBuilder ( src ) ; sb . insert ( offset , insert ) ; return sb . toString ( ) ; }", "nl": "Inserts a string on provided offset ."}}
{"translation": {"code": "public static int indexOf ( Object [ ] array , Object value ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] . equals ( value ) ) { return i ; } } return - 1 ; }", "nl": "Finds the first occurrence in an array ."}}
{"translation": {"code": "public static String repeat ( final String source , int count ) { StringBand result = new StringBand ( count ) ; while ( count > 0 ) { result . append ( source ) ; count -- ; } return result . toString ( ) ; }", "nl": "Creates a new string that contains the provided string a number of times ."}}
{"translation": {"code": "public static String maxCommonPrefix ( final String one , final String two ) { final int minLength = Math . min ( one . length ( ) , two . length ( ) ) ; final StringBuilder sb = new StringBuilder ( minLength ) ; for ( int pos = 0 ; pos < minLength ; pos ++ ) { final char currentChar = one . charAt ( pos ) ; if ( currentChar != two . charAt ( pos ) ) { break ; } sb . append ( currentChar ) ; } return sb . toString ( ) ; }", "nl": "Returns max common prefix of two strings ."}}
{"translation": {"code": "public static String reverse ( final String s ) { StringBuilder result = new StringBuilder ( s . length ( ) ) ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { result . append ( s . charAt ( i ) ) ; } return result . toString ( ) ; }", "nl": "Reverse a string ."}}
{"translation": {"code": "public MethodDescriptor [ ] getAllMethodDescriptors ( ) { if ( allMethods == null ) { final List < MethodDescriptor > allMethodsList = new ArrayList <> ( ) ; for ( MethodDescriptor [ ] methodDescriptors : methodsMap . values ( ) ) { Collections . addAll ( allMethodsList , methodDescriptors ) ; } final MethodDescriptor [ ] allMethods = allMethodsList . toArray ( new MethodDescriptor [ 0 ] ) ; Arrays . sort ( allMethods , Comparator . comparing ( md -> md . getMethod ( ) . getName ( ) ) ) ; this . allMethods = allMethods ; } return allMethods ; }", "nl": "Returns all methods . Cached . Lazy ."}}
{"translation": {"code": "public boolean isGetParameter ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return true ; } } return false ; }", "nl": "Checks if some parameter is in GET parameters ."}}
{"translation": {"code": "public < E > E createEntityInstance ( final Class < E > type ) { try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new DbOomException ( ex ) ; } }", "nl": "Creates new entity instances ."}}
{"translation": {"code": "public void init ( String name , final String superName , final String suffix , final String reqProxyClassName ) { int lastSlash = name . lastIndexOf ( ' ' ) ; this . targetPackage = lastSlash == - 1 ? StringPool . EMPTY : name . substring ( 0 , lastSlash ) . replace ( ' ' , ' ' ) ; this . targetClassname = name . substring ( lastSlash + 1 ) ; this . nextSupername = superName ; this . superName = name ; // create proxy name if ( reqProxyClassName != null ) { if ( reqProxyClassName . startsWith ( DOT ) ) { name = name . substring ( 0 , lastSlash ) + ' ' + reqProxyClassName . substring ( 1 ) ; } else if ( reqProxyClassName . endsWith ( DOT ) ) { name = reqProxyClassName . replace ( ' ' , ' ' ) + this . targetClassname ; } else { name = reqProxyClassName . replace ( ' ' , ' ' ) ; } } // add optional suffix if ( suffix != null ) { name += suffix ; } this . thisReference = name ; this . superReference = this . superName ; }", "nl": "Work data initialization ."}}
{"translation": {"code": "public static String findCommonPrefix ( final String ... strings ) { StringBuilder prefix = new StringBuilder ( ) ; int index = 0 ; char c = 0 ; loop : while ( true ) { for ( int i = 0 ; i < strings . length ; i ++ ) { String s = strings [ i ] ; if ( index == s . length ( ) ) { break loop ; } if ( i == 0 ) { c = s . charAt ( index ) ; } else { if ( s . charAt ( index ) != c ) { break loop ; } } } index ++ ; prefix . append ( c ) ; } return prefix . length ( ) == 0 ? StringPool . EMPTY : prefix . toString ( ) ; }", "nl": "Finds common prefix for several strings . Returns an empty string if arguments do not have a common prefix ."}}
{"translation": {"code": "public static String readRequestBodyFromReader ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }", "nl": "Reads HTTP request body using the request reader . Once body is read it cannot be read again!"}}
{"translation": {"code": "public static boolean validateAgaintIPAdressV4Format ( final String input ) { if ( input == null ) { return false ; } int hitDots = 0 ; char [ ] data = input . toCharArray ( ) ; for ( int i = 0 ; i < data . length ; i ++ ) { char c = data [ i ] ; int b = 0 ; do { if ( c < ' ' || c > ' ' ) { return false ; } b = ( b * 10 + c ) - 48 ; if ( ++ i >= data . length ) { break ; } c = data [ i ] ; } while ( c != ' ' ) ; if ( b > 255 ) { return false ; } hitDots ++ ; } return hitDots == 4 ; }", "nl": "Checks given string against IP address v4 format ."}}
{"translation": {"code": "public static int getIpAsInt ( final String ipAddress ) { int ipIntValue = 0 ; String [ ] tokens = StringUtil . splitc ( ipAddress , ' ' ) ; for ( String token : tokens ) { if ( ipIntValue > 0 ) { ipIntValue <<= 8 ; } ipIntValue += Integer . parseInt ( token ) ; } return ipIntValue ; }", "nl": "Returns IP address as integer ."}}
{"translation": {"code": "public static String shorten ( String s , int length , final String suffix ) { length -= suffix . length ( ) ; if ( s . length ( ) > length ) { for ( int j = length ; j >= 0 ; j -- ) { if ( CharUtil . isWhitespace ( s . charAt ( j ) ) ) { length = j ; break ; } } String temp = s . substring ( 0 , length ) ; s = temp . concat ( suffix ) ; } return s ; }", "nl": "Shorten string to given length ."}}
{"translation": {"code": "public static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }", "nl": "Stores context path in server context and request scope ."}}
{"translation": {"code": "@ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }", "nl": "Returns file walking iterator ."}}
{"translation": {"code": "public String path ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return path ; }", "nl": "Returns path value ."}}
{"translation": {"code": "protected void addSetInjectionPoint ( final SetInjectionPoint sip ) { if ( sets == null ) { sets = new SetInjectionPoint [ 1 ] ; sets [ 0 ] = sip ; } else { sets = ArraysUtil . append ( sets , sip ) ; } }", "nl": "Adds set injection point ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public static < T > T [ ] remove ( T [ ] buffer , int offset , int length , Class < T > componentType ) { int len2 = buffer . length - length ; T [ ] temp = ( T [ ] ) Array . newInstance ( componentType , len2 ) ; System . arraycopy ( buffer , 0 , temp , 0 , offset ) ; System . arraycopy ( buffer , offset + length , temp , offset , len2 - offset ) ; return temp ; }", "nl": "Removes sub - array ."}}
{"translation": {"code": "public static String compressChars ( final String s , final char c ) { int len = s . length ( ) ; StringBuilder sb = new StringBuilder ( len ) ; boolean wasChar = false ; for ( int i = 0 ; i < len ; i ++ ) { char c1 = s . charAt ( i ) ; if ( c1 == c ) { if ( wasChar ) { continue ; } wasChar = true ; } else { wasChar = false ; } sb . append ( c1 ) ; } if ( sb . length ( ) == len ) { return s ; } return sb . toString ( ) ; }", "nl": "Compress multiple occurrences of given char into one appearance ."}}
{"translation": {"code": "public static String title ( final String string ) { char [ ] chars = string . toCharArray ( ) ; boolean wasWhitespace = true ; for ( int i = 0 ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( CharUtil . isWhitespace ( c ) ) { wasWhitespace = true ; } else { if ( wasWhitespace ) { chars [ i ] = Character . toUpperCase ( c ) ; } else { chars [ i ] = Character . toLowerCase ( c ) ; } wasWhitespace = false ; } } return new String ( chars ) ; }", "nl": "Makes a title - cased string from given input ."}}
{"translation": {"code": "protected void resolveColumnDbSqlType ( final Connection connection , final DbEntityColumnDescriptor dec ) { if ( dec . dbSqlType != SqlType . DB_SQLTYPE_UNKNOWN ) { return ; } ResultSet rs = null ; DbEntityDescriptor ded = dec . getDbEntityDescriptor ( ) ; try { DatabaseMetaData dmd = connection . getMetaData ( ) ; rs = dmd . getColumns ( null , ded . getSchemaName ( ) , ded . getTableName ( ) , dec . getColumnName ( ) ) ; if ( rs . next ( ) ) { dec . dbSqlType = rs . getInt ( \"DATA_TYPE\" ) ; } else { dec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; if ( log . isWarnEnabled ( ) ) { log . warn ( \"Column SQL type not available: \" + ded . toString ( ) + ' ' + dec . getColumnName ( ) ) ; } } } catch ( SQLException sex ) { dec . dbSqlType = SqlType . DB_SQLTYPE_NOT_AVAILABLE ; if ( log . isWarnEnabled ( ) ) { log . warn ( \"Column SQL type not resolved: \" + ded . toString ( ) + ' ' + dec . getColumnName ( ) , sex ) ; } } finally { DbUtil . close ( rs ) ; } }", "nl": "Resolves column db sql type and populates it in column descriptor if missing ."}}
{"translation": {"code": "public static void unzip ( final String zipFile , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir ) , patterns ) ; }", "nl": "Extracts zip file content to the target directory ."}}
{"translation": {"code": "public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = false ; Class < ? extends SqlType > sqlTypeClass = null ; // read ID annotation DbId dbId = null ; if ( property . getFieldDescriptor ( ) != null ) { dbId = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getReadMethodDescriptor ( ) != null ) { dbId = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId == null && property . getWriteMethodDescriptor ( ) != null ) { dbId = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbId . class ) ; } if ( dbId != null ) { columnName = dbId . value ( ) . trim ( ) ; sqlTypeClass = dbId . sqlType ( ) ; isId = true ; } else { DbColumn dbColumn = null ; if ( property . getFieldDescriptor ( ) != null ) { dbColumn = property . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getReadMethodDescriptor ( ) != null ) { dbColumn = property . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn == null && property . getWriteMethodDescriptor ( ) != null ) { dbColumn = property . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( DbColumn . class ) ; } if ( dbColumn != null ) { columnName = dbColumn . value ( ) . trim ( ) ; sqlTypeClass = dbColumn . sqlType ( ) ; } else { if ( isAnnotated ) { return null ; } } } if ( StringUtil . isEmpty ( columnName ) ) { // default annotation value columnName = columnNamingStrategy . convertPropertyNameToColumnName ( property . getName ( ) ) ; } else { if ( ! columnNamingStrategy . isStrictAnnotationNames ( ) ) { columnName = columnNamingStrategy . applyToColumnName ( columnName ) ; } } if ( sqlTypeClass == SqlType . class ) { sqlTypeClass = null ; } return new DbEntityColumnDescriptor ( dbEntityDescriptor , quoteIfRequired ( columnName , columnNamingStrategy . isAlwaysQuoteNames ( ) , columnNamingStrategy . getQuoteChar ( ) ) , property . getName ( ) , property . getType ( ) , isId , sqlTypeClass ) ; }", "nl": "Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name ."}}
{"translation": {"code": "protected DbEntityDescriptor findColumnRef ( final String columnRef ) { DbEntityDescriptor ded = templateData . findTableDescriptorByColumnRef ( columnRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( \"Invalid column reference: [\" + columnRef + \"]\" ) ; } return ded ; }", "nl": "Finds a table that contains given column ."}}
{"translation": {"code": "public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }", "nl": "Finds entity descriptor of a table that contains provided column reference ."}}
{"translation": {"code": "protected void addPath ( final File path ) { if ( ! path . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( path ) ; }", "nl": "Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files ."}}
{"translation": {"code": "protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }", "nl": "Initializes file walking . Separates input files and folders ."}}
{"translation": {"code": "public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }", "nl": "Loads all method arguments before INVOKESTATIC call ."}}
{"translation": {"code": "public String getParameter ( final String paramName ) { if ( requestParameters == null ) { return null ; } String [ ] values = requestParameters . get ( paramName ) ; if ( ( values != null ) && ( values . length > 0 ) ) { return values [ 0 ] ; } return null ; }", "nl": "Returns single value of a parameter . If parameter name is used for more then one parameter only the first one will be returned ."}}
{"translation": {"code": "public FileUpload getFile ( final String paramName ) { if ( requestFiles == null ) { return null ; } FileUpload [ ] values = requestFiles . get ( paramName ) ; if ( ( values != null ) && ( values . length > 0 ) ) { return values [ 0 ] ; } return null ; }", "nl": "Returns uploaded file ."}}
{"translation": {"code": "public FileUpload [ ] getFiles ( final String paramName ) { if ( requestFiles == null ) { return null ; } return requestFiles . get ( paramName ) ; }", "nl": "Returns all uploaded files the given request parameter has ."}}
{"translation": {"code": "public void parseRequestStream ( final InputStream inputStream , final String encoding ) throws IOException { setParsed ( ) ; MultipartRequestInputStream input = new MultipartRequestInputStream ( inputStream ) ; input . readBoundary ( ) ; while ( true ) { FileUploadHeader header = input . readDataHeader ( encoding ) ; if ( header == null ) { break ; } if ( header . isFile ) { String fileName = header . fileName ; if ( fileName . length ( ) > 0 ) { if ( header . contentType . indexOf ( \"application/x-macbinary\" ) > 0 ) { input . skipBytes ( 128 ) ; } } FileUpload newFile = fileUploadFactory . create ( input ) ; newFile . processStream ( ) ; if ( fileName . length ( ) == 0 ) { // file was specified, but no name was provided, therefore it was not uploaded if ( newFile . getSize ( ) == 0 ) { newFile . size = - 1 ; } } putFile ( header . formFieldName , newFile ) ; } else { // no file, therefore it is regular form parameter. FastByteArrayOutputStream fbos = new FastByteArrayOutputStream ( ) ; input . copyAll ( fbos ) ; String value = encoding != null ? new String ( fbos . toByteArray ( ) , encoding ) : new String ( fbos . toByteArray ( ) ) ; putParameter ( header . formFieldName , value ) ; } input . skipBytes ( 1 ) ; input . mark ( 1 ) ; // read byte, but may be end of stream int nextByte = input . read ( ) ; if ( nextByte == - 1 || nextByte == ' ' ) { input . reset ( ) ; break ; } input . reset ( ) ; } }", "nl": "Extracts uploaded files and parameters from the request data ."}}
{"translation": {"code": "public String [ ] getParameterValues ( final String paramName ) { if ( requestParameters == null ) { return null ; } return requestParameters . get ( paramName ) ; }", "nl": "Returns all values all of the values the given request parameter has ."}}
{"translation": {"code": "public void start ( ) throws IOException { serverSocket = new ServerSocket ( listenPort , socketBacklog ) ; serverSocket . setReuseAddress ( true ) ; executorService = Executors . newFixedThreadPool ( threadPoolSize ) ; running = true ; while ( running ) { Socket socket = serverSocket . accept ( ) ; socket . setKeepAlive ( false ) ; executorService . execute ( onSocketConnection ( socket ) ) ; } executorService . shutdown ( ) ; }", "nl": "Starts HTTP tunnel . Method ends when the tunnel is stopped ."}}
{"translation": {"code": "void convertToWriter ( final Writer writer , final Properties properties , final Map < String , Properties > profiles ) throws IOException { final BufferedWriter bw = getBufferedWriter ( writer ) ; writeBaseAndProfileProperties ( bw , properties , profiles ) ; writeProfilePropertiesThatAreNotInTheBase ( bw , properties , profiles ) ; bw . flush ( ) ; }", "nl": "Convert Java Properties to Jodd Props format"}}
{"translation": {"code": "@ Override public boolean accept ( final Scope referenceScope ) { Class < ? extends Scope > refScopeType = referenceScope . getClass ( ) ; if ( refScopeType == ProtoScope . class ) { return true ; } if ( refScopeType == SingletonScope . class ) { return true ; } if ( refScopeType == ThreadLocalScope . class ) { return true ; } return false ; }", "nl": "Defines allowed referenced scopes that can be injected into the thread - local scoped bean ."}}
{"translation": {"code": "protected String createMixingMessage ( final BeanDefinition targetBeanDefinition , final BeanDefinition refBeanDefinition ) { return \"Scopes mixing detected: \" + refBeanDefinition . name + \"@\" + refBeanDefinition . scope . getClass ( ) . getSimpleName ( ) + \" -> \" + targetBeanDefinition . name + \"@\" + targetBeanDefinition . scope . getClass ( ) . getSimpleName ( ) ; }", "nl": "Creates mixed scope message ."}}
{"translation": {"code": "protected Object createScopedProxyBean ( final PetiteContainer petiteContainer , final BeanDefinition refBeanDefinition ) { Class beanType = refBeanDefinition . type ; Class proxyClass = proxyClasses . get ( beanType ) ; if ( proxyClass == null ) { // create proxy class only once if ( refBeanDefinition instanceof ProxettaBeanDefinition ) { // special case, double proxy! ProxettaBeanDefinition pbd = ( ProxettaBeanDefinition ) refBeanDefinition ; ProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspects ( ArraysUtil . insert ( pbd . proxyAspects , aspect , 0 ) ) ; proxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; proxetta . setVariableClassName ( true ) ; ProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( pbd . originalTarget ) ; proxyClass = builder . define ( ) ; proxyClasses . put ( beanType , proxyClass ) ; } else { ProxyProxetta proxetta = Proxetta . proxyProxetta ( ) . withAspect ( aspect ) ; proxetta . setClassNameSuffix ( \"$ScopedProxy\" ) ; proxetta . setVariableClassName ( true ) ; ProxyProxettaFactory builder = proxetta . proxy ( ) . setTarget ( beanType ) ; proxyClass = builder . define ( ) ; proxyClasses . put ( beanType , proxyClass ) ; } } Object proxy ; try { proxy = ClassUtil . newInstance ( proxyClass ) ; Field field = proxyClass . getField ( \"$__petiteContainer$0\" ) ; field . set ( proxy , petiteContainer ) ; field = proxyClass . getField ( \"$__name$0\" ) ; field . set ( proxy , refBeanDefinition . name ) ; } catch ( Exception ex ) { throw new PetiteException ( ex ) ; } return proxy ; }", "nl": "Creates scoped proxy bean for given bean definition ."}}
{"translation": {"code": "public void registerPathAlias ( final String alias , final String path ) { final String existing = pathAliases . put ( alias , path ) ; if ( existing != null ) { throw new MadvocException ( \"Duplicated alias detected: [\" + alias + \"] for paths: \" + path + \", \" + existing ) ; } }", "nl": "Registers new path alias ."}}
{"translation": {"code": "public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }", "nl": "Builds an OPTIONS request ."}}
{"translation": {"code": "public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }", "nl": "Builds a DELETE request ."}}
{"translation": {"code": "public static String buildQuery ( final HttpMultiMap < ? > queryMap , final String encoding ) { if ( queryMap . isEmpty ( ) ) { return StringPool . EMPTY ; } int queryMapSize = queryMap . size ( ) ; StringBand query = new StringBand ( queryMapSize * 4 ) ; int count = 0 ; for ( Map . Entry < String , ? > entry : queryMap ) { String key = entry . getKey ( ) ; key = URLCoder . encodeQueryParam ( key , encoding ) ; Object value = entry . getValue ( ) ; if ( value == null ) { if ( count != 0 ) { query . append ( ' ' ) ; } query . append ( key ) ; count ++ ; } else { if ( count != 0 ) { query . append ( ' ' ) ; } query . append ( key ) ; count ++ ; query . append ( ' ' ) ; String valueString = URLCoder . encodeQueryParam ( value . toString ( ) , encoding ) ; query . append ( valueString ) ; } } return query . toString ( ) ; }", "nl": "Builds a query string from given query map ."}}
{"translation": {"code": "public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }", "nl": "Builds a TRACE request ."}}
{"translation": {"code": "public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , \"Basic \" + base64 ) ; } return this ; }", "nl": "Enables basic authentication by adding required header ."}}
{"translation": {"code": "public static String prepareHeaderParameterName ( final String headerName ) { // special cases if ( headerName . equals ( \"etag\" ) ) { return HttpBase . HEADER_ETAG ; } if ( headerName . equals ( \"www-authenticate\" ) ) { return \"WWW-Authenticate\" ; } char [ ] name = headerName . toCharArray ( ) ; boolean capitalize = true ; for ( int i = 0 ; i < name . length ; i ++ ) { char c = name [ i ] ; if ( c == ' ' ) { capitalize = true ; continue ; } if ( capitalize ) { name [ i ] = Character . toUpperCase ( c ) ; capitalize = false ; } else { name [ i ] = Character . toLowerCase ( c ) ; } } return new String ( name ) ; }", "nl": "Makes nice header names ."}}
{"translation": {"code": "public static HttpMultiMap < String > parseQuery ( final String query , final boolean decode ) { final HttpMultiMap < String > queryMap = HttpMultiMap . newCaseInsensitiveMap ( ) ; if ( StringUtil . isBlank ( query ) ) { return queryMap ; } int lastNdx = 0 ; while ( lastNdx < query . length ( ) ) { int ndx = query . indexOf ( ' ' , lastNdx ) ; if ( ndx == - 1 ) { ndx = query . length ( ) ; } final String paramAndValue = query . substring ( lastNdx , ndx ) ; ndx = paramAndValue . indexOf ( ' ' ) ; if ( ndx == - 1 ) { queryMap . add ( paramAndValue , null ) ; } else { String name = paramAndValue . substring ( 0 , ndx ) ; if ( decode ) { name = URLDecoder . decodeQuery ( name ) ; } String value = paramAndValue . substring ( ndx + 1 ) ; if ( decode ) { value = URLDecoder . decodeQuery ( value ) ; } queryMap . add ( name , value ) ; } lastNdx += paramAndValue . length ( ) + 1 ; } return queryMap ; }", "nl": "Parses query from give query string . Values are optionally decoded ."}}
{"translation": {"code": "public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }", "nl": "Builds a PUT request ."}}
{"translation": {"code": "public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }", "nl": "Builds a HEAD request ."}}
{"translation": {"code": "public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }", "nl": "Adds many query parameters at once . Although it accepts objects each value will be converted to string ."}}
{"translation": {"code": "public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }", "nl": "Adds all parameters from the provided map ."}}
{"translation": {"code": "@ Override protected Buffer buffer ( final boolean fullRequest ) { // INITIALIZATION // host port if ( header ( HEADER_HOST ) == null ) { setHostHeader ( ) ; } // form Buffer formBuffer = formBuffer ( ) ; // query string String queryString = queryString ( ) ; // user-agent if ( header ( \"User-Agent\" ) == null ) { header ( \"User-Agent\" , Defaults . userAgent ) ; } // POST method requires Content-Type to be set if ( method . equals ( \"POST\" ) && ( contentLength ( ) == null ) ) { contentLength ( 0 ) ; } // BUILD OUT Buffer request = new Buffer ( ) ; request . append ( method ) . append ( SPACE ) . append ( path ) ; if ( query != null && ! query . isEmpty ( ) ) { request . append ( ' ' ) ; request . append ( queryString ) ; } request . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; populateHeaderAndBody ( request , formBuffer , fullRequest ) ; return request ; }", "nl": "Prepares the request buffer ."}}
{"translation": {"code": "public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host ) ; } return this ; }", "nl": "Sets request host name ."}}
{"translation": {"code": "public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }", "nl": "Builds a GET request ."}}
{"translation": {"code": "public static HttpRequest post ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }", "nl": "Builds a POST request ."}}
{"translation": {"code": "public HttpRequest queryString ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( queryString , decode ) ; return this ; }", "nl": "Sets query from provided query string . Previous query values are discarded ."}}
{"translation": {"code": "public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }", "nl": "Generates query string . All values are URL encoded ."}}
{"translation": {"code": "public HttpRequest path ( String path ) { // this must be the only place that sets the path if ( ! path . startsWith ( StringPool . SLASH ) ) { path = StringPool . SLASH + path ; } int ndx = path . indexOf ( ' ' ) ; if ( ndx != - 1 ) { String queryString = path . substring ( ndx + 1 ) ; path = path . substring ( 0 , ndx ) ; query = HttpUtil . parseQuery ( queryString , true ) ; } else { query = HttpMultiMap . newCaseInsensitiveMap ( ) ; } this . path = path ; return this ; }", "nl": "Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded ."}}
{"translation": {"code": "public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }", "nl": "Sets Host header from current host and port ."}}
{"translation": {"code": "public HttpResponse unzip ( ) { String contentEncoding = contentEncoding ( ) ; if ( contentEncoding != null && contentEncoding ( ) . equals ( \"gzip\" ) ) { if ( body != null ) { headerRemove ( HEADER_CONTENT_ENCODING ) ; try { ByteArrayInputStream in = new ByteArrayInputStream ( body . getBytes ( StringPool . ISO_8859_1 ) ) ; GZIPInputStream gzipInputStream = new GZIPInputStream ( in ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; StreamUtil . copy ( gzipInputStream , out ) ; body ( out . toString ( StringPool . ISO_8859_1 ) ) ; } catch ( IOException ioex ) { throw new HttpException ( ioex ) ; } } } return this ; }", "nl": "Unzips GZip - ed body content removes the content - encoding header and sets the new content - length value ."}}
{"translation": {"code": "@ Override protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return true ; }", "nl": "Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties ."}}
{"translation": {"code": "public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( true ) ; visit ( ) ; }", "nl": "Performs the copying ."}}
{"translation": {"code": "public void visit ( ) { String [ ] properties = resolveProperties ( source , declared ) ; for ( String name : properties ) { if ( name == null ) { continue ; } if ( ! rules . match ( name , blacklist ) ) { continue ; } Object value ; String propertyName = name ; if ( isSourceMap ) { propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } if ( declared ) { value = BeanUtil . declared . getProperty ( source , propertyName ) ; } else { value = BeanUtil . pojo . getProperty ( source , propertyName ) ; } if ( value == null && ignoreNullValues ) { continue ; } if ( value instanceof String && StringUtil . isEmpty ( ( String ) value ) ) { continue ; } visitProperty ( name , value ) ; } }", "nl": "Starts visiting properties ."}}
{"translation": {"code": "protected Object invokeProvider ( final ProviderDefinition provider ) { if ( provider . method != null ) { final Object bean ; if ( provider . beanName != null ) { // instance factory method bean = getBean ( provider . beanName ) ; } else { // static factory method bean = null ; } try { return provider . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid provider method: \" + provider . method . getName ( ) , ex ) ; } } throw new PetiteException ( \"Invalid provider\" ) ; }", "nl": "Invokes provider to get a bean ."}}
{"translation": {"code": "public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( \"://\" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }", "nl": "Returns just host url without path and query ."}}
{"translation": {"code": "public static String extractMediaType ( final String contentType ) { int index = contentType . indexOf ( ' ' ) ; if ( index == - 1 ) { return contentType ; } return contentType . substring ( 0 , index ) ; }", "nl": "Extracts media - type from value of Content Type header ."}}
{"translation": {"code": "public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( beanName ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; } // resolve all references String value = PropertiesUtil . resolveProperty ( params , key ) ; entry . setValue ( value ) ; } if ( list . isEmpty ( ) ) { return StringPool . EMPTY_ARRAY ; } else { return list . toArray ( new String [ 0 ] ) ; } }", "nl": "Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters ."}}
{"translation": {"code": "public ProviderDefinition [ ] resolve ( final Class type , final String name ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( ) ; List < ProviderDefinition > list = new ArrayList <> ( ) ; for ( MethodDescriptor methodDescriptor : methods ) { Method method = methodDescriptor . getMethod ( ) ; PetiteProvider petiteProvider = method . getAnnotation ( PetiteProvider . class ) ; if ( petiteProvider == null ) { continue ; } String providerName = petiteProvider . value ( ) ; if ( StringUtil . isBlank ( providerName ) ) { // default provider name providerName = method . getName ( ) ; if ( providerName . endsWith ( \"Provider\" ) ) { providerName = StringUtil . substring ( providerName , 0 , - 8 ) ; } } ProviderDefinition providerDefinition ; if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { providerDefinition = new ProviderDefinition ( providerName , method ) ; } else { providerDefinition = new ProviderDefinition ( providerName , name , method ) ; } list . add ( providerDefinition ) ; } ProviderDefinition [ ] providers ; if ( list . isEmpty ( ) ) { providers = ProviderDefinition . EMPTY ; } else { providers = list . toArray ( new ProviderDefinition [ 0 ] ) ; } return providers ; }", "nl": "Resolves all providers in the class"}}
{"translation": {"code": "protected void cacheResultSetEntities ( final Object [ ] result ) { if ( entitiesCache == null ) { entitiesCache = new HashMap <> ( ) ; } for ( int i = 0 ; i < result . length ; i ++ ) { Object object = result [ i ] ; if ( object == null ) { continue ; } DbEntityDescriptor ded = cachedDbEntityDescriptors [ i ] ; if ( ded == null ) { // not a type, continue continue ; } // calculate key Object key ; if ( ded . hasIdColumn ( ) ) { //noinspection unchecked key = ded . getKeyValue ( object ) ; } else { key = object ; } Object cachedObject = entitiesCache . get ( key ) ; if ( cachedObject == null ) { // object is not in the cache, add it entitiesCache . put ( key , object ) ; } else { // object is in the cache, replace it result [ i ] = cachedObject ; } } }", "nl": "Caches returned entities . Replaces new instances with existing ones ."}}
{"translation": {"code": "private boolean zzRefill ( ) { if ( zzBuffer == null ) { zzBuffer = zzChars ; zzEndRead += zzChars . length ; return false ; } return true ; }", "nl": "Refills the input buffer ."}}
{"translation": {"code": "private static char [ ] zzUnpackCMap ( final String packed ) { char [ ] map = new char [ 0x110000 ] ; int i = 0 ; /* index in packed string  */ int j = 0 ; /* index in unpacked array */ while ( i < 128 ) { int count = packed . charAt ( i ++ ) ; char value = packed . charAt ( i ++ ) ; do map [ j ++ ] = value ; while ( -- count > 0 ) ; } return map ; }", "nl": "Unpacks the compressed character translation table ."}}
{"translation": {"code": "@ Override protected synchronized Class < ? > loadClass ( final String className , final boolean resolve ) throws ClassNotFoundException { // check first if the class has already been loaded Class < ? > c = findLoadedClass ( className ) ; if ( c != null ) { if ( resolve ) { resolveClass ( c ) ; } return c ; } // class not loaded yet Loading loading = resolveLoading ( parentFirst , className ) ; if ( parentFirst ) { // PARENT FIRST if ( loading . withParent ) { try { c = parentClassLoader . loadClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } if ( c == null ) { if ( loading . withLoader ) { c = this . findClass ( className ) ; } else { throw new ClassNotFoundException ( \"Class not found: \" + className ) ; } } } else { // THIS FIRST if ( loading . withLoader ) { try { c = this . findClass ( className ) ; } catch ( ClassNotFoundException ignore ) { } } if ( c == null ) { if ( loading . withParent ) { c = parentClassLoader . loadClass ( className ) ; } else { throw new ClassNotFoundException ( \"Class not found: \" + className ) ; } } } if ( resolve ) { resolveClass ( c ) ; } return c ; }", "nl": "Loads class using parent - first or parent - last strategy ."}}
{"translation": {"code": "@ Override public URL getResource ( final String resourceName ) { URL url = null ; Loading loading = resolveResourceLoading ( parentFirst , resourceName ) ; if ( parentFirst ) { // PARENT FIRST if ( loading . withParent ) { url = parentClassLoader . getResource ( resourceName ) ; } if ( url == null ) { if ( loading . withLoader ) { url = this . findResource ( resourceName ) ; } } } else { // THIS FIRST if ( loading . withLoader ) { url = this . findResource ( resourceName ) ; } if ( url == null ) { if ( loading . withParent ) { url = parentClassLoader . getResource ( resourceName ) ; } } } return url ; }", "nl": "Returns a resource using parent - first or parent - last strategy ."}}
{"translation": {"code": "protected Loading resolveLoading ( final boolean parentFirstStrategy , final String className ) { boolean withParent = true ; boolean withLoader = true ; if ( parentFirstStrategy ) { if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } else if ( isMatchingRules ( className , parentOnlyRules ) ) { withLoader = false ; } } else { if ( isMatchingRules ( className , parentOnlyRules ) ) { withLoader = false ; } else if ( isMatchingRules ( className , loaderOnlyRules ) ) { withParent = false ; } } return new Loading ( withParent , withLoader ) ; }", "nl": "Resolves loading rules ."}}
{"translation": {"code": "public void add ( final Enumeration < T > enumeration ) { if ( allEnumerations . contains ( enumeration ) ) { throw new IllegalArgumentException ( \"Duplicate enumeration\" ) ; } allEnumerations . add ( enumeration ) ; }", "nl": "Adds an enumeration to this composite ."}}
{"translation": {"code": "public static < T > Collection < T > collectionOf ( final Iterator < ? extends T > iterator ) { final List < T > list = new ArrayList <> ( ) ; while ( iterator . hasNext ( ) ) { list . add ( iterator . next ( ) ) ; } return list ; }", "nl": "Returns a collection containing all elements of the iterator ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public static < T > T [ ] join ( T [ ] ... arrays ) { Class < T > componentType = ( Class < T > ) arrays . getClass ( ) . getComponentType ( ) . getComponentType ( ) ; return join ( componentType , arrays ) ; }", "nl": "Joins arrays . Component type is resolved from the array argument ."}}
{"translation": {"code": "public static void injectTargetIntoWrapper ( final Object target , final Object wrapper ) { injectTargetIntoWrapper ( target , wrapper , ProxettaNames . wrapperTargetFieldName ) ; }", "nl": "Injects target instance into proxy using default target field name ."}}
{"translation": {"code": "public static Class resolveTargetClass ( final Class proxy ) { final String name = proxy . getName ( ) ; if ( name . endsWith ( ProxettaNames . proxyClassNameSuffix ) ) { return proxy . getSuperclass ( ) ; } if ( name . endsWith ( ProxettaNames . wrapperClassNameSuffix ) ) { return getTargetWrapperType ( proxy ) ; } return proxy ; }", "nl": "Returns target class if proxetta applied on given class . If not returns given class as result ."}}
{"translation": {"code": "public static Class getTargetWrapperType ( final Class wrapperClass ) { try { final Field field = wrapperClass . getDeclaredField ( ProxettaNames . wrapperTargetFieldName ) ; return field . getType ( ) ; } catch ( NoSuchFieldException nsfex ) { throw new ProxettaException ( nsfex ) ; } }", "nl": "Returns wrapper target type ."}}
{"translation": {"code": "public Object execute ( ) throws Exception { String methodName = ProxyTarget . targetMethodName ( ) ; Class [ ] argTypes = ProxyTarget . createArgumentsClassArray ( ) ; Object [ ] args = ProxyTarget . createArgumentsArray ( ) ; // lookup method on target object class (and not #targetClass!() Class type = _target . getClass ( ) ; Method method = type . getMethod ( methodName , argTypes ) ; // remember context classloader ClassLoader contextClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; Object result ; try { // change class loader Thread . currentThread ( ) . setContextClassLoader ( type . getClassLoader ( ) ) ; // invoke result = method . invoke ( _target , args ) ; } finally { // return context classloader Thread . currentThread ( ) . setContextClassLoader ( contextClassLoader ) ; } return ProxyTarget . returnValue ( result ) ; }", "nl": "Looks up for method in target object and invokes it using reflection ."}}
{"translation": {"code": "public static < T > T applyAdvice ( final Class < T > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) { // advice not yet created adviceClass = PROXY_PROXETTA . proxy ( ) . setTarget ( targetClass ) . define ( ) ; cache . put ( targetClass , adviceClass ) ; } // create new advice instance and injects target instance to it try { Object advice = ClassUtil . newInstance ( adviceClass ) ; Field field = adviceClass . getField ( \"$___target$0\" ) ; field . set ( advice , targetClass ) ; return ( T ) advice ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }", "nl": "Applies advice on given target class and returns proxy instance ."}}
{"translation": {"code": "public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field field = proxyClass . getField ( \"$___target$0\" ) ; field . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }", "nl": "Injects target into proxy ."}}
{"translation": {"code": "public static String stripChar ( final String string , final char c ) { if ( string . length ( ) == 0 ) { return string ; } if ( string . length ( ) == 1 ) { if ( string . charAt ( 0 ) == c ) { return StringPool . EMPTY ; } return string ; } int left = 0 ; int right = string . length ( ) ; if ( string . charAt ( left ) == c ) { left ++ ; } if ( string . charAt ( right - 1 ) == c ) { right -- ; } return string . substring ( left , right ) ; }", "nl": "Strips leading and trailing char from given string ."}}
{"translation": {"code": "public void addRootPackage ( final String rootPackage , String mapping ) { if ( packages == null ) { packages = new String [ 0 ] ; } if ( mappings == null ) { mappings = new String [ 0 ] ; } // fix mapping if ( mapping . length ( ) > 0 ) { // mapping must start with the slash if ( ! mapping . startsWith ( StringPool . SLASH ) ) { mapping = StringPool . SLASH + mapping ; } // mapping must NOT end with the slash if ( mapping . endsWith ( StringPool . SLASH ) ) { mapping = StringUtil . substring ( mapping , 0 , - 1 ) ; } } // detect duplicates for ( int i = 0 ; i < packages . length ; i ++ ) { if ( packages [ i ] . equals ( rootPackage ) ) { if ( mappings [ i ] . equals ( mapping ) ) { // both package and the mappings are the same return ; } throw new MadvocException ( \"Different mappings for the same root package: \" + rootPackage ) ; } } packages = ArraysUtil . append ( packages , rootPackage ) ; mappings = ArraysUtil . append ( mappings , mapping ) ; }", "nl": "Adds root package and its path mapping . Duplicate root packages are ignored if mapping path is equals otherwise exception is thrown ."}}
{"translation": {"code": "public void addRootPackageOf ( final Class actionClass , final String mapping ) { addRootPackage ( actionClass . getPackage ( ) . getName ( ) , mapping ) ; }", "nl": "Sets root package to package of given class ."}}
{"translation": {"code": "public String findRootPackageForActionPath ( final String actionPath ) { if ( mappings == null ) { return null ; } int ndx = - 1 ; int delta = Integer . MAX_VALUE ; for ( int i = 0 ; i < mappings . length ; i ++ ) { String mapping = mappings [ i ] ; boolean found = false ; if ( actionPath . equals ( mapping ) ) { found = true ; } else { mapping += StringPool . SLASH ; if ( actionPath . startsWith ( mapping ) ) { found = true ; } } if ( found ) { int distance = actionPath . length ( ) - mapping . length ( ) ; if ( distance < delta ) { ndx = i ; delta = distance ; } } } if ( ndx == - 1 ) { return null ; } return packages [ ndx ] ; }", "nl": "Finds closest root package for the given action path ."}}
{"translation": {"code": "public FindFile exclude ( final String ... patterns ) { for ( String pattern : patterns ) { rules . exclude ( pattern ) ; } return this ; }", "nl": "Defines exclude patterns ."}}
{"translation": {"code": "public FindFile include ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }", "nl": "Defines include patterns ."}}
{"translation": {"code": "protected void renderAttribute ( final Node node , final Attribute attribute , final Appendable appendable ) throws IOException { String name = resolveAttributeName ( node , attribute ) ; String value = attribute . getValue ( ) ; appendable . append ( name ) ; if ( value != null ) { appendable . append ( ' ' ) ; appendable . append ( ' ' ) ; appendable . append ( HtmlEncoder . attributeDoubleQuoted ( value ) ) ; appendable . append ( ' ' ) ; } }", "nl": "Renders attribute ."}}
{"translation": {"code": "protected String resolveAttributeName ( final Node node , final Attribute attribute ) { switch ( attributeCase ) { case DEFAULT : return attribute . getName ( ) ; case RAW : return attribute . getRawName ( ) ; case LOWERCASE : return attribute . getRawName ( ) . toLowerCase ( ) ; case UPPERCASE : return attribute . getRawName ( ) . toUpperCase ( ) ; } return null ; }", "nl": "Renders attribute name ."}}
{"translation": {"code": "protected String resolveNodeName ( final Node node ) { switch ( tagCase ) { case DEFAULT : return node . getNodeName ( ) ; case RAW : return node . getNodeRawName ( ) ; case LOWERCASE : return node . getNodeRawName ( ) . toLowerCase ( ) ; case UPPERCASE : return node . getNodeRawName ( ) . toUpperCase ( ) ; } return null ; }", "nl": "Renders node name ."}}
{"translation": {"code": "protected void removeLastChildNodeIfEmptyText ( final Node parentNode , final boolean closedTag ) { if ( parentNode == null ) { return ; } Node lastChild = parentNode . getLastChild ( ) ; if ( lastChild == null ) { return ; } if ( lastChild . getNodeType ( ) != Node . NodeType . TEXT ) { return ; } if ( closedTag ) { if ( parentNode . getChildNodesCount ( ) == 1 ) { return ; } } Text text = ( Text ) lastChild ; if ( text . isBlank ( ) ) { lastChild . detachFromParent ( ) ; } }", "nl": "Removes last child node if contains just empty text ."}}
{"translation": {"code": "protected Element createElementNode ( final Tag tag ) { boolean hasVoidTags = htmlVoidRules != null ; boolean isVoid = false ; boolean selfClosed = false ; if ( hasVoidTags ) { isVoid = htmlVoidRules . isVoidTag ( tag . getName ( ) ) ; // HTML and XHTML if ( isVoid ) { // it's void tag, lookup the flag selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; } } else { // XML, no voids, lookup the flag selfClosed = domBuilder . config . isSelfCloseVoidTags ( ) ; } return new Element ( rootNode , tag , isVoid , selfClosed ) ; }", "nl": "Creates new element with correct configuration ."}}
{"translation": {"code": "@ Override public void tag ( final Tag tag ) { if ( ! enabled ) { return ; } TagType tagType = tag . getType ( ) ; Element node ; switch ( tagType ) { case START : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { removeLastChildNodeIfEmptyText ( parentNode , false ) ; } node = createElementNode ( tag ) ; if ( domBuilder . config . isImpliedEndTags ( ) ) { while ( true ) { String parentNodeName = parentNode . getNodeName ( ) ; if ( ! implRules . implicitlyCloseParentTagOnNewTag ( parentNodeName , node . getNodeName ( ) ) ) { break ; } parentNode = parentNode . getParentNode ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Implicitly closed tag <\" + node . getNodeName ( ) + \"> \" ) ; } } } parentNode . addChild ( node ) ; if ( ! node . isVoidElement ( ) ) { parentNode = node ; } break ; case END : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { removeLastChildNodeIfEmptyText ( parentNode , true ) ; } String tagName = tag . getName ( ) . toString ( ) ; Node matchingParent = findMatchingParentOpenTag ( tagName ) ; if ( matchingParent == parentNode ) { // regular situation parentNode = parentNode . getParentNode ( ) ; break ; } if ( matchingParent == null ) { // matching open tag not found, remove it error ( \"Orphan closed tag ignored: </\" + tagName + \"> \" + tag . getTagPosition ( ) ) ; break ; } // try to close it implicitly if ( domBuilder . config . isImpliedEndTags ( ) ) { boolean fixed = false ; while ( implRules . implicitlyCloseParentTagOnTagEnd ( parentNode . getNodeName ( ) , tagName ) ) { parentNode = parentNode . getParentNode ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"Implicitly closed tag <\" + tagName + \">\" ) ; } if ( parentNode == matchingParent ) { parentNode = matchingParent . parentNode ; fixed = true ; break ; } } if ( fixed ) { break ; } } // matching tag found, but it is not a regular situation // therefore close all unclosed tags in between fixUnclosedTagsUpToMatchingParent ( tag , matchingParent ) ; break ; case SELF_CLOSING : if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { removeLastChildNodeIfEmptyText ( parentNode , false ) ; } node = createElementNode ( tag ) ; parentNode . addChild ( node ) ; break ; } }", "nl": "Visits tags ."}}
{"translation": {"code": "@ Override public void end ( ) { if ( parentNode != rootNode ) { Node thisNode = parentNode ; while ( thisNode != rootNode ) { if ( domBuilder . config . isImpliedEndTags ( ) ) { if ( implRules . implicitlyCloseTagOnEOF ( thisNode . getNodeName ( ) ) ) { thisNode = thisNode . getParentNode ( ) ; continue ; } } error ( \"Unclosed tag closed: <\" + thisNode . getNodeName ( ) + \">\" ) ; thisNode = thisNode . getParentNode ( ) ; } } // remove whitespaces if ( domBuilder . config . isIgnoreWhitespacesBetweenTags ( ) ) { removeLastChildNodeIfEmptyText ( parentNode , true ) ; } // foster if ( domBuilder . config . isUseFosterRules ( ) ) { HtmlFosterRules fosterRules = new HtmlFosterRules ( ) ; fosterRules . fixFosterElements ( rootNode ) ; } // elapsed rootNode . end ( ) ; if ( log . isDebugEnabled ( ) ) { log . debug ( \"LagartoDom tree created in \" + rootNode . getElapsedTime ( ) + \" ms\" ) ; } }", "nl": "Finishes the tree building . Closes unclosed tags ."}}
{"translation": {"code": "protected void fixElements ( ) { for ( Element fosterElement : fosterElements ) { // find parent table Element lastTable = findLastTable ( fosterElement ) ; Node fosterElementParent = fosterElement . getParentNode ( ) ; // filter our foster element Node [ ] fosterChilds = fosterElement . getChildNodes ( ) ; for ( Node fosterChild : fosterChilds ) { if ( fosterChild . getNodeType ( ) == Node . NodeType . ELEMENT ) { if ( isOneOfTableElements ( ( Element ) fosterChild ) ) { // move all child table elements outside // the foster element fosterChild . detachFromParent ( ) ; fosterElementParent . insertBefore ( fosterChild , fosterElement ) ; } } } // finally, move foster element above the table fosterElement . detachFromParent ( ) ; lastTable . getParentNode ( ) . insertBefore ( fosterElement , lastTable ) ; } }", "nl": "Performs the fix for elements ."}}
{"translation": {"code": "protected Element findLastTable ( final Node node ) { Node tableNode = node ; while ( tableNode != null ) { if ( tableNode . getNodeType ( ) == Node . NodeType . ELEMENT ) { String tableNodeName = tableNode . getNodeName ( ) . toLowerCase ( ) ; if ( tableNodeName . equals ( \"table\" ) ) { break ; } } tableNode = tableNode . getParentNode ( ) ; } return ( Element ) tableNode ; }", "nl": "Finds the last table in stack of open elements ."}}
{"translation": {"code": "public static String encodeFragment ( final String fragment , final String encoding ) { return encodeUriComponent ( fragment , encoding , URIPart . FRAGMENT ) ; }", "nl": "Encodes the given URI fragment with the given encoding ."}}
{"translation": {"code": "public static String encodeQueryParam ( final String queryParam , final String encoding ) { return encodeUriComponent ( queryParam , encoding , URIPart . QUERY_PARAM ) ; }", "nl": "Encodes the given URI query parameter with the given encoding ."}}
{"translation": {"code": "public static String encodePath ( final String path , final String encoding ) { return encodeUriComponent ( path , encoding , URIPart . PATH ) ; }", "nl": "Encodes the given URI path with the given encoding ."}}
{"translation": {"code": "public static String encodePort ( final String port , final String encoding ) { return encodeUriComponent ( port , encoding , URIPart . PORT ) ; }", "nl": "Encodes the given URI port with the given encoding ."}}
{"translation": {"code": "private static String encodeUriComponent ( final String source , final String encoding , final URIPart uriPart ) { if ( source == null ) { return null ; } byte [ ] bytes = encodeBytes ( StringUtil . getBytes ( source , encoding ) , uriPart ) ; char [ ] chars = new char [ bytes . length ] ; for ( int i = 0 ; i < bytes . length ; i ++ ) { chars [ i ] = ( char ) bytes [ i ] ; } return new String ( chars ) ; }", "nl": "Encodes single URI component ."}}
{"translation": {"code": "public static String encodeScheme ( final String scheme , final String encoding ) { return encodeUriComponent ( scheme , encoding , URIPart . SCHEME ) ; }", "nl": "Encodes the given URI scheme with the given encoding ."}}
{"translation": {"code": "public static String encodeHost ( final String host , final String encoding ) { return encodeUriComponent ( host , encoding , URIPart . HOST ) ; }", "nl": "Encodes the given URI host with the given encoding ."}}
{"translation": {"code": "public static String encodeQuery ( final String query , final String encoding ) { return encodeUriComponent ( query , encoding , URIPart . QUERY ) ; }", "nl": "Encodes the given URI query with the given encoding ."}}
{"translation": {"code": "public HttpResponse sendRequest ( HttpRequest httpRequest ) { elapsedTime = System . currentTimeMillis ( ) ; // send request httpRequest . followRedirects ( false ) ; while ( true ) { this . httpRequest = httpRequest ; HttpResponse previousResponse = this . httpResponse ; this . httpResponse = null ; addDefaultHeaders ( httpRequest ) ; addCookies ( httpRequest ) ; // send request if ( catchTransportExceptions ) { try { this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; } catch ( HttpException httpException ) { httpResponse = new HttpResponse ( ) ; httpResponse . assignHttpRequest ( httpRequest ) ; httpResponse . statusCode ( 503 ) ; httpResponse . statusPhrase ( \"Service unavailable. \" + ExceptionUtil . message ( httpException ) ) ; } } else { this . httpResponse = _sendRequest ( httpRequest , previousResponse ) ; } readCookies ( httpResponse ) ; int statusCode = httpResponse . statusCode ( ) ; // 301: moved permanently if ( statusCode == 301 ) { String newPath = httpResponse . location ( ) ; if ( newPath == null ) { break ; } httpRequest = HttpRequest . get ( newPath ) ; continue ; } // 302: redirect, 303: see other if ( statusCode == 302 || statusCode == 303 ) { String newPath = httpResponse . location ( ) ; if ( newPath == null ) { break ; } httpRequest = HttpRequest . get ( newPath ) ; continue ; } // 307: temporary redirect, 308: permanent redirect if ( statusCode == 307 || statusCode == 308 ) { String newPath = httpResponse . location ( ) ; if ( newPath == null ) { break ; } String originalMethod = httpRequest . method ( ) ; httpRequest = new HttpRequest ( ) . method ( originalMethod ) . set ( newPath ) ; continue ; } break ; } elapsedTime = System . currentTimeMillis ( ) - elapsedTime ; return this . httpResponse ; }", "nl": "Sends new request as a browser . Before sending all browser cookies are added to the request . After sending the cookies are read from the response . Moreover status codes 301 and 302 are automatically handled . Returns very last response ."}}
{"translation": {"code": "private void setName ( final String name ) { if ( name . contains ( \";\" ) || name . contains ( \",\" ) || name . startsWith ( \"$\" ) ) { throw new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; } for ( int n = 0 ; n < name . length ( ) ; n ++ ) { char c = name . charAt ( n ) ; if ( c <= 0x20 || c >= 0x7f ) { throw new IllegalArgumentException ( \"Invalid cookie name:\" + name ) ; } } this . name = name ; }", "nl": "Sets the cookie name and checks for validity ."}}
{"translation": {"code": "protected void addCookies ( final HttpRequest httpRequest ) { // prepare all cookies List < Cookie > cookiesList = new ArrayList <> ( ) ; if ( ! cookies . isEmpty ( ) ) { for ( Map . Entry < String , Cookie > cookieEntry : cookies ) { cookiesList . add ( cookieEntry . getValue ( ) ) ; } httpRequest . cookies ( cookiesList . toArray ( new Cookie [ 0 ] ) ) ; } }", "nl": "Add cookies to the request ."}}
{"translation": {"code": "protected void readCookies ( final HttpResponse httpResponse ) { Cookie [ ] newCookies = httpResponse . cookies ( ) ; for ( Cookie cookie : newCookies ) { cookies . add ( cookie . getName ( ) , cookie ) ; } }", "nl": "Reads cookies from response and adds to cookies list ."}}
{"translation": {"code": "public static String stripFromChar ( final String string , final char c ) { int ndx = string . indexOf ( c ) ; if ( ndx == - 1 ) { return string ; } return string . substring ( 0 , ndx ) ; }", "nl": "Strips everything from the first appearance of given char . Character IS NOT included in the returned string ."}}
{"translation": {"code": "public static String stripToChar ( final String string , final char c ) { int ndx = string . indexOf ( c ) ; if ( ndx == - 1 ) { return string ; } return string . substring ( ndx ) ; }", "nl": "Strips everything up to the first appearance of given char . Character IS included in the returned string ."}}
{"translation": {"code": "protected T [ ] convertToSingleElementArray ( final Object value ) { T [ ] singleElementArray = createArray ( 1 ) ; singleElementArray [ 0 ] = convertType ( value ) ; return singleElementArray ; }", "nl": "Creates an array with single element ."}}
{"translation": {"code": "public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( \"Initializing Madvoc WebApp\" ) ; //// params & props for ( final Map < String , Object > params : paramsList ) { madvocContainer . defineParams ( params ) ; } for ( final Props props : propsList ) { madvocContainer . defineParams ( props ) ; } propsList = null ; //// components registerMadvocComponents ( ) ; madvocComponents . forEach ( madvocComponent -> madvocContainer . registerComponent ( madvocComponent . type ( ) , madvocComponent . consumer ( ) ) ) ; madvocComponents = null ; madvocComponentInstances . forEach ( madvocContainer :: registerComponentInstance ) ; madvocComponentInstances = null ; configureDefaults ( ) ; //// listeners madvocContainer . fireEvent ( Init . class ) ; //// component configuration componentConfigs . accept ( madvocContainer ) ; componentConfigs = null ; initialized ( ) ; madvocContainer . fireEvent ( Start . class ) ; if ( ! madvocRouterConsumers . isEmpty ( ) ) { final MadvocRouter madvocRouter = MadvocRouter . create ( ) ; madvocContainer . registerComponentInstance ( madvocRouter ) ; madvocRouterConsumers . accept ( madvocRouter ) ; } madvocRouterConsumers = null ; started ( ) ; madvocContainer . fireEvent ( Ready . class ) ; ready ( ) ; return this ; }", "nl": "Initializes and starts web application ."}}
{"translation": {"code": "protected FieldDescriptor findField ( final String fieldName ) { FieldDescriptor fieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; if ( fieldDescriptor != null ) { return fieldDescriptor ; } // field descriptor not found in this class // try to locate it in the superclasses Class [ ] superclasses = classDescriptor . getAllSuperclasses ( ) ; for ( Class superclass : superclasses ) { ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( superclass ) ; fieldDescriptor = classDescriptor . getFieldDescriptor ( fieldName , true ) ; if ( fieldDescriptor != null ) { return fieldDescriptor ; } } // nothing found return null ; }", "nl": "Locates property field . Field is being searched also in all superclasses of current class ."}}
{"translation": {"code": "protected String [ ] getAllBeanPropertyNames ( final Class type , final boolean declared ) { ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; PropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; ArrayList < String > names = new ArrayList <> ( propertyDescriptors . length ) ; for ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { MethodDescriptor getter = propertyDescriptor . getReadMethodDescriptor ( ) ; if ( getter != null ) { if ( getter . matchDeclared ( declared ) ) { names . add ( propertyDescriptor . getName ( ) ) ; } } else if ( includeFields ) { FieldDescriptor field = propertyDescriptor . getFieldDescriptor ( ) ; if ( field != null ) { if ( field . matchDeclared ( declared ) ) { names . add ( field . getName ( ) ) ; } } } } return names . toArray ( new String [ 0 ] ) ; }", "nl": "Returns all bean property names ."}}
{"translation": {"code": "protected HashMap < String , PropertyDescriptor > inspectProperties ( ) { boolean scanAccessible = classDescriptor . isScanAccessible ( ) ; Class type = classDescriptor . getType ( ) ; HashMap < String , PropertyDescriptor > map = new HashMap <> ( ) ; Method [ ] methods = scanAccessible ? ClassUtil . getAccessibleMethods ( type ) : ClassUtil . getSupportedMethods ( type ) ; for ( int iteration = 0 ; iteration < 2 ; iteration ++ ) { // first find the getters, and then the setters! for ( Method method : methods ) { if ( Modifier . isStatic ( method . getModifiers ( ) ) ) { continue ; // ignore static methods } boolean add = false ; boolean issetter = false ; String propertyName ; if ( iteration == 0 ) { propertyName = ClassUtil . getBeanPropertyGetterName ( method ) ; if ( propertyName != null ) { add = true ; issetter = false ; } } else { propertyName = ClassUtil . getBeanPropertySetterName ( method ) ; if ( propertyName != null ) { add = true ; issetter = true ; } } if ( add ) { MethodDescriptor methodDescriptor = classDescriptor . getMethodDescriptor ( method . getName ( ) , method . getParameterTypes ( ) , true ) ; addProperty ( map , propertyName , methodDescriptor , issetter ) ; } } } if ( classDescriptor . isIncludeFieldsAsProperties ( ) ) { FieldDescriptor [ ] fieldDescriptors = classDescriptor . getAllFieldDescriptors ( ) ; String [ ] prefix = classDescriptor . getPropertyFieldPrefix ( ) ; for ( FieldDescriptor fieldDescriptor : fieldDescriptors ) { Field field = fieldDescriptor . getField ( ) ; if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { continue ; // ignore static fields } String name = field . getName ( ) ; if ( prefix != null ) { for ( String p : prefix ) { if ( ! name . startsWith ( p ) ) { continue ; } name = name . substring ( p . length ( ) ) ; break ; } } if ( ! map . containsKey ( name ) ) { // add missing field as a potential property map . put ( name , createPropertyDescriptor ( name , fieldDescriptor ) ) ; } } } return map ; }", "nl": "Inspects all properties of target type ."}}
{"translation": {"code": "public Setter getSetter ( final boolean declared ) { loadPropertyDescriptor ( ) ; return propertyDescriptor != null ? propertyDescriptor . getSetter ( declared ) : null ; }", "nl": "Returns setter ."}}
{"translation": {"code": "public Getter getGetter ( final boolean declared ) { loadPropertyDescriptor ( ) ; return propertyDescriptor != null ? propertyDescriptor . getGetter ( declared ) : null ; }", "nl": "Returns getter ."}}
{"translation": {"code": "private void loadPropertyDescriptor ( ) { if ( updateProperty ) { if ( cd == null ) { propertyDescriptor = null ; } else { propertyDescriptor = cd . getPropertyDescriptor ( name , true ) ; } updateProperty = false ; } }", "nl": "Loads property descriptor if property was updated ."}}
{"translation": {"code": "public String getValue ( final String ... profiles ) { if ( hasMacro ) { return propsData . resolveMacros ( value , profiles ) ; } return value ; }", "nl": "Returns the property value with replaced macros ."}}
{"translation": {"code": "public PropsEntries profile ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String profile : profiles ) { addProfiles ( profile ) ; } return this ; }", "nl": "Enables profiles to iterate ."}}
{"translation": {"code": "protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }", "nl": "Reads class or method annotation for action filters ."}}
{"translation": {"code": "protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }", "nl": "Returns all action wrappers . Returns a copy in new set ."}}
{"translation": {"code": "protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }", "nl": "Collects all filters ."}}
{"translation": {"code": "@ Override protected < R extends ActionFilter > R createWrapper ( final Class < R > wrapperClass ) { return petiteContainer . createBean ( wrapperClass ) ; }", "nl": "Acquires filter from Petite container ."}}
{"translation": {"code": "protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( \"Invalid Madvoc wrapper: \" + wrapperClass , ex ) ; } }", "nl": "Creates new wrapper ."}}
{"translation": {"code": "public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }", "nl": "Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers ."}}
{"translation": {"code": "@ Override public T next ( ) { if ( hasNext == null ) { hasNext = Boolean . valueOf ( moveToNext ( ) ) ; } if ( hasNext == false ) { throw new NoSuchElementException ( ) ; } if ( ! entityAwareMode ) { hasNext = null ; return newElement ; } count ++ ; T result = previousElement ; previousElement = newElement ; hasNext = null ; return result ; }", "nl": "Returns next mapped object ."}}
{"translation": {"code": "private void grow ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) { // special case, min capacity is larger then a grow newCapacity = minCapacity + 512 ; } buffer = Arrays . copyOf ( buffer , newCapacity ) ; }", "nl": "Grows the buffer ."}}
{"translation": {"code": "@ Override public FastCharBuffer append ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( csq . charAt ( i ) ) ; } return this ; }", "nl": "Appends character sequence to buffer ."}}
{"translation": {"code": "public static Logger getLogger ( final String name ) { if ( loggers == null ) { return loggerProvider . apply ( name ) ; } return loggers . computeIfAbsent ( name , loggerProvider ) ; }", "nl": "Returns logger for given name . Repeated calls to this method with the same argument should return the very same instance of the logger ."}}
{"translation": {"code": "protected void print ( final Level level , final String message , final Throwable throwable ) { if ( ! isEnabled ( level ) ) { return ; } StringBuilder msg = new StringBuilder ( ) . append ( slf . getElapsedTime ( ) ) . append ( ' ' ) . append ( ' ' ) . append ( level ) . append ( ' ' ) . append ( ' ' ) . append ( getCallerClass ( ) ) . append ( ' ' ) . append ( ' ' ) . append ( ' ' ) . append ( message ) ; System . out . println ( msg . toString ( ) ) ; if ( throwable != null ) { throwable . printStackTrace ( System . out ) ; } }", "nl": "Prints error message if level is enabled ."}}
{"translation": {"code": "protected Socket createSocket ( final String host , final int port , final int connectionTimeout ) throws IOException { final SocketFactory socketFactory = getSocketFactory ( proxy , false , false , connectionTimeout ) ; if ( connectionTimeout < 0 ) { return socketFactory . createSocket ( host , port ) ; } else { // creates unconnected socket Socket socket = socketFactory . createSocket ( ) ; socket . connect ( new InetSocketAddress ( host , port ) , connectionTimeout ) ; return socket ; } }", "nl": "Creates a socket using socket factory ."}}
{"translation": {"code": "public static ProxyInfo socks4Proxy ( final String proxyAddress , final int proxyPort , final String proxyUser ) { return new ProxyInfo ( ProxyType . SOCKS4 , proxyAddress , proxyPort , proxyUser , null ) ; }", "nl": "Creates SOCKS4 proxy ."}}
{"translation": {"code": "public static ProxyInfo socks5Proxy ( final String proxyAddress , final int proxyPort , final String proxyUser , final String proxyPassword ) { return new ProxyInfo ( ProxyType . SOCKS5 , proxyAddress , proxyPort , proxyUser , proxyPassword ) ; }", "nl": "Creates SOCKS5 proxy ."}}
{"translation": {"code": "public static ProxyInfo httpProxy ( final String proxyAddress , final int proxyPort , final String proxyUser , final String proxyPassword ) { return new ProxyInfo ( ProxyType . HTTP , proxyAddress , proxyPort , proxyUser , proxyPassword ) ; }", "nl": "Creates HTTP proxy ."}}
{"translation": {"code": "private Socket createSocks4ProxySocket ( final String host , final int port ) { Socket socket = null ; final String proxyHost = proxy . getProxyAddress ( ) ; final int proxyPort = proxy . getProxyPort ( ) ; final String user = proxy . getProxyUsername ( ) ; try { socket = Sockets . connect ( proxyHost , proxyPort , connectionTimeout ) ; final InputStream in = socket . getInputStream ( ) ; final OutputStream out = socket . getOutputStream ( ) ; socket . setTcpNoDelay ( true ) ; byte [ ] buf = new byte [ 1024 ] ; // 1) CONNECT int index = 0 ; buf [ index ++ ] = 4 ; buf [ index ++ ] = 1 ; buf [ index ++ ] = ( byte ) ( port >>> 8 ) ; buf [ index ++ ] = ( byte ) ( port & 0xff ) ; InetAddress addr = InetAddress . getByName ( host ) ; byte [ ] byteAddress = addr . getAddress ( ) ; for ( byte byteAddres : byteAddress ) { buf [ index ++ ] = byteAddres ; } if ( user != null ) { System . arraycopy ( user . getBytes ( ) , 0 , buf , index , user . length ( ) ) ; index += user . length ( ) ; } buf [ index ++ ] = 0 ; out . write ( buf , 0 , index ) ; // 2) RESPONSE int len = 6 ; int s = 0 ; while ( s < len ) { int i = in . read ( buf , s , len - s ) ; if ( i <= 0 ) { throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"stream is closed\" ) ; } s += i ; } if ( buf [ 0 ] != 0 ) { throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned VN \" + buf [ 0 ] ) ; } if ( buf [ 1 ] != 90 ) { try { socket . close ( ) ; } catch ( Exception ignore ) { } throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , \"proxy returned CD \" + buf [ 1 ] ) ; } byte [ ] temp = new byte [ 2 ] ; in . read ( temp , 0 , 2 ) ; return socket ; } catch ( RuntimeException rtex ) { closeSocket ( socket ) ; throw rtex ; } catch ( Exception ex ) { closeSocket ( socket ) ; throw new HttpException ( ProxyInfo . ProxyType . SOCKS4 , ex . toString ( ) , ex ) ; } }", "nl": "Connects to the SOCKS4 proxy and returns proxified socket ."}}
{"translation": {"code": "protected SocketFactory getSocketFactory ( final ProxyInfo proxy , final boolean ssl , final boolean trustAllCertificates , final int connectionTimeout ) throws IOException { switch ( proxy . getProxyType ( ) ) { case NONE : if ( ssl ) { return getDefaultSSLSocketFactory ( trustAllCertificates ) ; } else { return SocketFactory . getDefault ( ) ; } case HTTP : return new HTTPProxySocketFactory ( proxy , connectionTimeout ) ; case SOCKS4 : return new Socks4ProxySocketFactory ( proxy , connectionTimeout ) ; case SOCKS5 : return new Socks5ProxySocketFactory ( proxy , connectionTimeout ) ; default : return null ; } }", "nl": "Returns socket factory based on proxy type and SSL requirements ."}}
{"translation": {"code": "@ Override public void sessionDestroyed ( final HttpSessionEvent httpSessionEvent ) { HttpSession session = httpSessionEvent . getSession ( ) ; sessionMap . remove ( session . getId ( ) ) ; for ( HttpSessionListener listener : listeners ) { listener . sessionDestroyed ( httpSessionEvent ) ; } }", "nl": "Removes session from a map and broadcasts event to registered listeners ."}}
{"translation": {"code": "@ Override public void sessionCreated ( final HttpSessionEvent httpSessionEvent ) { HttpSession session = httpSessionEvent . getSession ( ) ; sessionMap . putIfAbsent ( session . getId ( ) , session ) ; for ( HttpSessionListener listener : listeners ) { listener . sessionCreated ( httpSessionEvent ) ; } }", "nl": "Stores session in map and broadcasts event to registered listeners ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) protected Map < String , BeanData > getSessionMap ( final HttpSession session ) { SessionBeans sessionBeans = ( SessionBeans ) session . getAttribute ( SESSION_BEANS_NAME ) ; if ( sessionBeans == null ) { return null ; } return sessionBeans . getBeanMap ( ) ; }", "nl": "Returns instance map from http session ."}}
{"translation": {"code": "@ Override public void shutdown ( ) { if ( destroyableBeans == null ) { return ; } for ( final BeanData destroyableBean : destroyableBeans ) { destroyableBean . callDestroyMethods ( ) ; } destroyableBeans . clear ( ) ; }", "nl": "Shutdowns the scope and calls all collected destroyable beans ."}}
{"translation": {"code": "@ Override public void shutdown ( ) { for ( final BeanData beanData : instances . values ( ) ) { beanData . callDestroyMethods ( ) ; } instances . clear ( ) ; }", "nl": "Iterate all beans and invokes registered destroy methods ."}}
{"translation": {"code": "protected void destroyBean ( final BeanData beanData ) { if ( destroyableBeans == null ) { return ; } if ( ! isBeanDestroyable ( beanData ) ) { return ; } if ( destroyableBeans . remove ( beanData ) ) { beanData . callDestroyMethods ( ) ; } }", "nl": "Removes destroyable bean from the list and calls it destroy methods . If bean is not destroyable does nothing . Bean gets destroyed only once ."}}
{"translation": {"code": "protected void addDestroyMethodPoints ( final DestroyMethodPoint [ ] methods ) { if ( destroyMethods == null ) { destroyMethods = methods ; } else { destroyMethods = ArraysUtil . join ( destroyMethods , methods ) ; } }", "nl": "Adds destroy methods ."}}
{"translation": {"code": "public void shutdown ( ) { scopes . forEachValue ( Scope :: shutdown ) ; externalsCache . clear ( ) ; beans . clear ( ) ; beansAlt . clear ( ) ; scopes . clear ( ) ; providers . clear ( ) ; beanCollections . clear ( ) ; }", "nl": "Shutdowns container . After container is down it can t be used anymore ."}}
{"translation": {"code": "protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }", "nl": "Creates instance map and stores it in the request ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }", "nl": "Returns instance map from http request ."}}
{"translation": {"code": "public HttpResponse close ( ) { HttpConnection httpConnection = httpRequest . httpConnection ; if ( httpConnection != null ) { httpConnection . close ( ) ; httpRequest . httpConnection = null ; } return this ; }", "nl": "Closes requests connection if it was open . Should be called when using keep - alive connections . Otherwise connection will be already closed ."}}
{"translation": {"code": "@ Override public Class loadClass ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { String arrayClassName = prepareArrayClassnameForLoading ( className ) ; if ( ( className . indexOf ( ' ' ) == - 1 ) && ( arrayClassName == null ) ) { // maybe a primitive int primitiveNdx = getPrimitiveClassNameIndex ( className ) ; if ( primitiveNdx >= 0 ) { return PRIMITIVE_TYPES [ primitiveNdx ] ; } } // try #1 - using provided class loader if ( classLoader != null ) { Class klass = loadClass ( className , arrayClassName , classLoader ) ; if ( klass != null ) { return klass ; } } // try #2 - using thread class loader ClassLoader currentThreadClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( ( currentThreadClassLoader != null ) && ( currentThreadClassLoader != classLoader ) ) { Class klass = loadClass ( className , arrayClassName , currentThreadClassLoader ) ; if ( klass != null ) { return klass ; } } // try #3 - using caller classloader, similar as Class.forName() //Class callerClass = ReflectUtil.getCallerClass(2); Class callerClass = ClassUtil . getCallerClass ( ) ; ClassLoader callerClassLoader = callerClass . getClassLoader ( ) ; if ( ( callerClassLoader != classLoader ) && ( callerClassLoader != currentThreadClassLoader ) ) { Class klass = loadClass ( className , arrayClassName , callerClassLoader ) ; if ( klass != null ) { return klass ; } } // try #4 - everything failed, try alternative array loader if ( arrayClassName != null ) { try { return loadArrayClassByComponentType ( className , classLoader ) ; } catch ( ClassNotFoundException ignore ) { } } throw new ClassNotFoundException ( \"Class not found: \" + className ) ; }", "nl": "Loads class by name ."}}
{"translation": {"code": "private static int getPrimitiveClassNameIndex ( final String className ) { int dotIndex = className . indexOf ( ' ' ) ; if ( dotIndex != - 1 ) { return - 1 ; } return Arrays . binarySearch ( PRIMITIVE_TYPE_NAMES , className ) ; }", "nl": "Detects if provided class name is a primitive type . Returns > = 0 number if so ."}}
{"translation": {"code": "protected Class loadArrayClassByComponentType ( final String className , final ClassLoader classLoader ) throws ClassNotFoundException { int ndx = className . indexOf ( ' ' ) ; int multi = StringUtil . count ( className , ' ' ) ; String componentTypeName = className . substring ( 0 , ndx ) ; Class componentType = loadClass ( componentTypeName , classLoader ) ; if ( multi == 1 ) { return Array . newInstance ( componentType , 0 ) . getClass ( ) ; } int [ ] multiSizes ; if ( multi == 2 ) { multiSizes = new int [ ] { 0 , 0 } ; } else if ( multi == 3 ) { multiSizes = new int [ ] { 0 , 0 , 0 } ; } else { multiSizes = ( int [ ] ) Array . newInstance ( int . class , multi ) ; } return Array . newInstance ( componentType , multiSizes ) . getClass ( ) ; }", "nl": "Loads array class using component type ."}}
{"translation": {"code": "protected String lookupAlias ( final String alias ) { String value = actionsManager . lookupPathAlias ( alias ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }", "nl": "Lookups value as an alias and if not found as a default alias ."}}
{"translation": {"code": "protected Map < String , BeanData > registerSessionBeans ( final HttpSession httpSession ) { SessionBeans sessionBeans = new SessionBeans ( ) ; httpSession . setAttribute ( SESSION_BEANS_NAME , sessionBeans ) ; return sessionBeans . getBeanMap ( ) ; }", "nl": "Registers new session destroy callback if not already registered ."}}
{"translation": {"code": "protected String [ ] createTypesTableNames ( final Class [ ] types ) { String [ ] names = new String [ types . length ] ; for ( int i = 0 ; i < types . length ; i ++ ) { if ( types [ i ] == null ) { names [ i ] = null ; continue ; } DbEntityDescriptor ded = dbEntityManager . lookupType ( types [ i ] ) ; if ( ded != null ) { String tableName = ded . getTableName ( ) ; tableName = tableName . toUpperCase ( ) ; names [ i ] = tableName ; } } return names ; }", "nl": "Creates table names for given types ."}}
{"translation": {"code": "public Object getIdValue ( final E object ) { final String propertyName = getIdPropertyName ( ) ; return BeanUtil . declared . getProperty ( object , propertyName ) ; }", "nl": "Returns ID value for given entity instance ."}}
{"translation": {"code": "public void setIdValue ( final E object , final Object value ) { final String propertyName = getIdPropertyName ( ) ; BeanUtil . declared . setProperty ( object , propertyName , value ) ; }", "nl": "Sets ID value for given entity ."}}
{"translation": {"code": "public String getKeyValue ( final E object ) { Object idValue = getIdValue ( object ) ; String idValueString = idValue == null ? StringPool . NULL : idValue . toString ( ) ; return type . getName ( ) . concat ( StringPool . COLON ) . concat ( idValueString ) ; }", "nl": "Returns unique key for this entity . Returned key is built from entity class and id value ."}}
{"translation": {"code": "public < E > List < E > listAll ( final Class < E > target ) { return query ( dbOom . entities ( ) . from ( target ) ) . autoClose ( ) . list ( target ) ; }", "nl": "List all entities ."}}
{"translation": {"code": "public < E > List < E > findRelated ( final Class < E > target , final Object source ) { return query ( dbOom . entities ( ) . findForeign ( target , source ) ) . autoClose ( ) . list ( target ) ; }", "nl": "Finds related entity ."}}
{"translation": {"code": "public long count ( final Class entityType ) { return query ( dbOom . entities ( ) . count ( entityType ) ) . autoClose ( ) . executeCount ( ) ; }", "nl": "Counts number of all entities ."}}
{"translation": {"code": "public void deleteById ( final Object entity ) { if ( entity != null ) { int result = query ( dbOom . entities ( ) . deleteById ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; if ( result != 0 ) { // now reset the ID value Class type = entity . getClass ( ) ; DbEntityDescriptor ded = dbOom . entityManager ( ) . lookupType ( type ) ; setEntityId ( ded , entity , 0 ) ; } } }", "nl": "Delete single object by its id . Resets ID value ."}}
{"translation": {"code": "public < ID > void deleteById ( final Class entityType , final ID id ) { query ( dbOom . entities ( ) . deleteById ( entityType , id ) ) . autoClose ( ) . executeUpdate ( ) ; }", "nl": "Deleted single entity by its id ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public < E > E findOne ( final Object criteria ) { return ( E ) query ( dbOom . entities ( ) . find ( criteria ) ) . autoClose ( ) . find ( criteria . getClass ( ) ) ; }", "nl": "Finds one entity for given criteria ."}}
{"translation": {"code": "public < E > E findOneByProperty ( final Class < E > entityType , final String name , final Object value ) { return query ( dbOom . entities ( ) . findByColumn ( entityType , name , value ) ) . autoClose ( ) . find ( entityType ) ; }", "nl": "Finds single entity by matching property ."}}
{"translation": {"code": "public < E , ID > E findById ( final Class < E > entityType , final ID id ) { return query ( dbOom . entities ( ) . findById ( entityType , id ) ) . autoClose ( ) . find ( entityType ) ; }", "nl": "Finds single entity by its id ."}}
{"translation": {"code": "public < E > E updateProperty ( final E entity , final String name ) { Object value = BeanUtil . declared . getProperty ( entity , name ) ; query ( dbOom . entities ( ) . updateColumn ( entity , name , value ) ) . autoClose ( ) . executeUpdate ( ) ; return entity ; }", "nl": "Updates property in the database by storing the current property value ."}}
{"translation": {"code": "public void save ( final Object entity ) { final DbQuery q = query ( dbOom . entities ( ) . insert ( entity ) ) ; q . autoClose ( ) . executeUpdate ( ) ; }", "nl": "Simply inserts object into the database ."}}
{"translation": {"code": "protected < E , ID > void setEntityId ( final DbEntityDescriptor < E > ded , final E entity , final ID newIdValue ) { ded . setIdValue ( entity , newIdValue ) ; }", "nl": "Sets new ID value for entity ."}}
{"translation": {"code": "public < E > E updateProperty ( final E entity , final String name , final Object newValue ) { query ( dbOom . entities ( ) . updateColumn ( entity , name , newValue ) ) . autoClose ( ) . executeUpdate ( ) ; BeanUtil . declared . setProperty ( entity , name , newValue ) ; return entity ; }", "nl": "Updates single property in database and in the bean ."}}
{"translation": {"code": "public void update ( final Object entity ) { query ( dbOom . entities ( ) . updateAll ( entity ) ) . autoClose ( ) . executeUpdate ( ) ; }", "nl": "Updates single entity ."}}
{"translation": {"code": "@ Override protected String locateTarget ( final ActionRequest actionRequest , String path ) { String target ; if ( path . endsWith ( StringPool . SLASH ) ) { path = path + defaultViewPageName ; } for ( final String ext : defaultViewExtensions ) { target = path + ext ; if ( targetExists ( actionRequest , target ) ) { return target ; } } return null ; }", "nl": "Locates target using path with various extensions appended ."}}
{"translation": {"code": "protected void targetNotFound ( final ActionRequest actionRequest , final String actionAndResultPath ) throws IOException { final HttpServletResponse response = actionRequest . getHttpServletResponse ( ) ; if ( ! response . isCommitted ( ) ) { response . sendError ( SC_NOT_FOUND , \"Result not found: \" + actionAndResultPath ) ; } }", "nl": "Called when target not found . By default sends 404 to the response ."}}
{"translation": {"code": "protected String resolveTarget ( final ActionRequest actionRequest , final String resultValue ) { String resultBasePath = actionRequest . getActionRuntime ( ) . getResultBasePath ( ) ; ResultPath resultPath = resultMapper . resolveResultPath ( resultBasePath , resultValue ) ; String actionPath = resultPath . path ( ) ; String path = actionPath ; String value = resultPath . value ( ) ; if ( StringUtil . isEmpty ( value ) ) { value = null ; } String target ; while ( true ) { // variant #1: with value if ( value != null ) { if ( path == null ) { // only value remains int lastSlashNdx = actionPath . lastIndexOf ( ' ' ) ; if ( lastSlashNdx != - 1 ) { target = actionPath . substring ( 0 , lastSlashNdx + 1 ) + value ; } else { target = ' ' + value ; } } else { target = path + ' ' + value ; } target = locateTarget ( actionRequest , target ) ; if ( target != null ) { break ; } } if ( path != null ) { // variant #2: without value target = locateTarget ( actionRequest , path ) ; if ( target != null ) { break ; } } // continue if ( path == null ) { // path not found return null ; } int dotNdx = MadvocUtil . lastIndexOfDotAfterSlash ( path ) ; if ( dotNdx == - 1 ) { path = null ; } else { path = path . substring ( 0 , dotNdx ) ; } } return target ; }", "nl": "Locates the target file from action path and the result value ."}}
{"translation": {"code": "protected InjectionPoint buildInjectionPoint ( final String annotationValue , final String propertyName , final Class propertyType , final Class < ? extends MadvocScope > scope ) { final String value = annotationValue . trim ( ) ; final String name , targetName ; if ( StringUtil . isNotBlank ( value ) ) { name = value ; targetName = propertyName ; } else { name = propertyName ; targetName = null ; } return new InjectionPoint ( propertyType , name , targetName , scopeResolver . defaultOrScopeType ( scope ) ) ; }", "nl": "Builds injection point ."}}
{"translation": {"code": "public void injectContext ( final Object targetObject ) { final Class targetType = targetObject . getClass ( ) ; final ScopeData scopeData = scopeDataInspector . inspectClassScopesWithCache ( targetType ) ; final Targets targets = new Targets ( targetObject , scopeData ) ; // inject no context scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( targets ) ) ; // inject special case scopeResolver . forScope ( ParamsScope . class , scope -> scope . inject ( targets ) ) ; // inject servlet context final ServletContext servletContext = madvocController . getApplicationContext ( ) ; if ( servletContext != null ) { scopeResolver . forEachScope ( madvocScope -> madvocScope . inject ( servletContext , targets ) ) ; } }", "nl": "Inject context into target ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) protected Collection < T > createCollection ( final int length ) { if ( collectionType . isInterface ( ) ) { if ( collectionType == List . class ) { if ( length > 0 ) { return new ArrayList <> ( length ) ; } else { return new ArrayList <> ( ) ; } } if ( collectionType == Set . class ) { if ( length > 0 ) { return new HashSet <> ( length ) ; } else { return new HashSet <> ( ) ; } } throw new TypeConversionException ( \"Unknown collection: \" + collectionType . getName ( ) ) ; } if ( length > 0 ) { try { Constructor < Collection < T >> ctor = ( Constructor < Collection < T > > ) collectionType . getConstructor ( int . class ) ; return ctor . newInstance ( Integer . valueOf ( length ) ) ; } catch ( Exception ex ) { // ignore exception } } try { return collectionType . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( Exception ex ) { throw new TypeConversionException ( ex ) ; } }", "nl": "Creates new collection of target component type . Default implementation uses reflection to create an collection of target type . Override it for better performances ."}}
{"translation": {"code": "protected Collection < T > convertToSingleElementCollection ( final Object value ) { Collection < T > collection = createCollection ( 0 ) ; //noinspection unchecked collection . add ( ( T ) value ) ; return collection ; }", "nl": "Creates a collection with single element ."}}
{"translation": {"code": "protected Collection < T > convertValueToCollection ( Object value ) { if ( value instanceof Iterable ) { Iterable iterable = ( Iterable ) value ; Collection < T > collection = createCollection ( 0 ) ; for ( Object element : iterable ) { collection . add ( convertType ( element ) ) ; } return collection ; } if ( value instanceof CharSequence ) { value = CsvUtil . toStringArray ( value . toString ( ) ) ; } Class type = value . getClass ( ) ; if ( type . isArray ( ) ) { // convert arrays Class componentType = type . getComponentType ( ) ; if ( componentType . isPrimitive ( ) ) { return convertPrimitiveArrayToCollection ( value , componentType ) ; } else { Object [ ] array = ( Object [ ] ) value ; Collection < T > result = createCollection ( array . length ) ; for ( Object a : array ) { result . add ( convertType ( a ) ) ; } return result ; } } // everything else: return convertToSingleElementCollection ( value ) ; }", "nl": "Converts non - collection value to collection ."}}
{"translation": {"code": "protected Collection < T > convertCollectionToCollection ( final Collection value ) { Collection < T > collection = createCollection ( value . size ( ) ) ; for ( Object v : value ) { collection . add ( convertType ( v ) ) ; } return collection ; }", "nl": "Converts collection value to target collection . Each element is converted to target component type ."}}
{"translation": {"code": "@ SuppressWarnings ( \"AutoBoxing\" ) protected Collection < T > convertPrimitiveArrayToCollection ( final Object value , final Class primitiveComponentType ) { Collection < T > result = null ; if ( primitiveComponentType == int . class ) { int [ ] array = ( int [ ] ) value ; result = createCollection ( array . length ) ; for ( int a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == long . class ) { long [ ] array = ( long [ ] ) value ; result = createCollection ( array . length ) ; for ( long a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == float . class ) { float [ ] array = ( float [ ] ) value ; result = createCollection ( array . length ) ; for ( float a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == double . class ) { double [ ] array = ( double [ ] ) value ; result = createCollection ( array . length ) ; for ( double a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == short . class ) { short [ ] array = ( short [ ] ) value ; result = createCollection ( array . length ) ; for ( short a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == byte . class ) { byte [ ] array = ( byte [ ] ) value ; result = createCollection ( array . length ) ; for ( byte a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == char . class ) { char [ ] array = ( char [ ] ) value ; result = createCollection ( array . length ) ; for ( char a : array ) { result . add ( convertType ( a ) ) ; } } else if ( primitiveComponentType == boolean . class ) { boolean [ ] array = ( boolean [ ] ) value ; result = createCollection ( array . length ) ; for ( boolean a : array ) { result . add ( convertType ( a ) ) ; } } return result ; }", "nl": "Converts primitive array to target collection ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) protected Object convertToCollection ( final Object value , final Class destinationType , final Class componentType ) { return typeConverterManager . convertToCollection ( value , destinationType , componentType ) ; }", "nl": "Converter to collection ."}}
{"translation": {"code": "public < ID > void increaseProperty ( final Class entityType , final ID id , final String name , final Number delta ) { query ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , true ) ) . autoClose ( ) . executeUpdate ( ) ; }", "nl": "Increases a property ."}}
{"translation": {"code": "public < ID > void decreaseProperty ( final Class entityType , final ID id , final String name , final Number delta ) { query ( dbOom . entities ( ) . increaseColumn ( entityType , id , name , delta , false ) ) . autoClose ( ) . executeUpdate ( ) ; }", "nl": "Decreases a property ."}}
{"translation": {"code": "public static String toUpperCase ( final String s , Locale locale ) { if ( s == null ) { return null ; } StringBuilder sb = null ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c > 127 ) { // found non-ascii char, fallback to the slow unicode detection if ( locale == null ) { locale = Locale . getDefault ( ) ; } return s . toUpperCase ( locale ) ; } if ( ( c >= ' ' ) && ( c <= ' ' ) ) { if ( sb == null ) { sb = new StringBuilder ( s ) ; } sb . setCharAt ( i , ( char ) ( c - 32 ) ) ; } } if ( sb == null ) { return s ; } return sb . toString ( ) ; }", "nl": "Converts all of the characters in the string to upper case based on the locale ."}}
{"translation": {"code": "public final boolean matchUpperCase ( final char [ ] uppercaseTarget ) { if ( ndx + uppercaseTarget . length > total ) { return false ; } int j = ndx ; for ( int i = 0 ; i < uppercaseTarget . length ; i ++ , j ++ ) { final char c = CharUtil . toUpperAscii ( input [ j ] ) ; if ( c != uppercaseTarget [ i ] ) { return false ; } } return true ; }", "nl": "Matches char buffer given in uppercase with content at current location that will be converted to upper case to make case - insensitive matching ."}}
{"translation": {"code": "protected final CharSequence charSequence ( final int from , final int to ) { if ( from == to ) { return CharArraySequence . EMPTY ; } return CharArraySequence . of ( input , from , to - from ) ; }", "nl": "Creates char sub - sequence from the input ."}}
{"translation": {"code": "public int findLast ( int low , int high ) { int ndx = - 1 ; while ( low <= high ) { int mid = ( low + high ) >>> 1 ; int delta = compare ( mid ) ; if ( delta > 0 ) { high = mid - 1 ; } else { if ( delta == 0 ) { ndx = mid ; } low = mid + 1 ; } } if ( ndx == - 1 ) { return - ( low + 1 ) ; } return ndx ; }", "nl": "Finds very last index of given element in inclusive index range . Returns negative value if element is not found ."}}
{"translation": {"code": "protected void _error ( String message ) { if ( config . calculatePosition ) { Position currentPosition = position ( ndx ) ; message = message . concat ( StringPool . SPACE ) . concat ( currentPosition . toString ( ) ) ; } else { message = message . concat ( \" [@\" ) . concat ( Integer . toString ( ndx ) ) . concat ( StringPool . RIGHT_SQ_BRACKET ) ; } visitor . error ( message ) ; }", "nl": "Prepares error message and reports it to the visitor ."}}
{"translation": {"code": "protected void emitComment ( final int from , final int to ) { if ( config . enableConditionalComments ) { // CC: downlevel-hidden starting if ( match ( CC_IF , from ) ) { int endBracketNdx = find ( ' ' , from + 3 , to ) ; CharSequence expression = charSequence ( from + 1 , endBracketNdx ) ; ndx = endBracketNdx + 1 ; char c = input [ ndx ] ; if ( c != ' ' ) { errorInvalidToken ( ) ; } visitor . condComment ( expression , true , true , false ) ; state = DATA_STATE ; return ; } if ( to > CC_ENDIF2 . length && match ( CC_ENDIF2 , to - CC_ENDIF2 . length ) ) { // CC: downlevel-hidden ending visitor . condComment ( _ENDIF , false , true , true ) ; state = DATA_STATE ; return ; } } CharSequence comment = charSequence ( from , to ) ; visitor . comment ( comment ) ; commentStart = - 1 ; }", "nl": "Emits a comment . Also checks for conditional comments!"}}
{"translation": {"code": "@ Override protected void initialize ( final char [ ] input ) { super . initialize ( input ) ; this . tag = new ParsedTag ( ) ; this . doctype = new ParsedDoctype ( ) ; this . text = new char [ 1024 ] ; this . textLen = 0 ; this . parsingTime = - 1 ; }", "nl": "Initializes parser ."}}
{"translation": {"code": "public LagartoDomBuilderConfig setParsingErrorLogLevelName ( String logLevel ) { logLevel = logLevel . trim ( ) . toUpperCase ( ) ; parsingErrorLogLevel = Logger . Level . valueOf ( logLevel ) ; return this ; }", "nl": "Sets parsing error log level as a name ."}}
{"translation": {"code": "protected SSLSocket createSSLSocket ( final String host , final int port , final int connectionTimeout , final boolean trustAll , final boolean verifyHttpsHost ) throws IOException { final SocketFactory socketFactory = getSocketFactory ( proxy , true , trustAll , connectionTimeout ) ; final Socket socket ; if ( connectionTimeout < 0 ) { socket = socketFactory . createSocket ( host , port ) ; } else { // creates unconnected socket // unfortunately, this does not work always //\t\t\tsslSocket = (SSLSocket) socketFactory.createSocket(); //\t\t\tsslSocket.connect(new InetSocketAddress(host, port), connectionTimeout); // // Note: SSLSocketFactory has several create() methods. // Those that take arguments all connect immediately // and have no options for specifying a connection timeout. // // So, we have to create a socket and connect it (with a // connection timeout), then have the SSLSocketFactory wrap // the already-connected socket. // socket = Sockets . connect ( host , port , connectionTimeout ) ; //sock.setSoTimeout(readTimeout); //socket.connect(new InetSocketAddress(host, port), connectionTimeout); // continue to wrap this plain socket with ssl socket... } // wrap plain socket in an SSL socket SSLSocket sslSocket ; if ( socket instanceof SSLSocket ) { sslSocket = ( SSLSocket ) socket ; } else { if ( socketFactory instanceof SSLSocketFactory ) { sslSocket = ( SSLSocket ) ( ( SSLSocketFactory ) socketFactory ) . createSocket ( socket , host , port , true ) ; } else { sslSocket = ( SSLSocket ) ( getDefaultSSLSocketFactory ( trustAll ) ) . createSocket ( socket , host , port , true ) ; } } // sslSocket is now ready if ( secureEnabledProtocols != null ) { final String [ ] values = StringUtil . splitc ( secureEnabledProtocols , ' ' ) ; StringUtil . trimAll ( values ) ; sslSocket . setEnabledProtocols ( values ) ; } // set SSL parameters to allow host name verifier if ( verifyHttpsHost ) { final SSLParameters sslParams = new SSLParameters ( ) ; sslParams . setEndpointIdentificationAlgorithm ( \"HTTPS\" ) ; sslSocket . setSSLParameters ( sslParams ) ; } return sslSocket ; }", "nl": "Creates a SSL socket . Enables default secure enabled protocols if specified ."}}
{"translation": {"code": "public String toInnerHtml ( final Node node , final Appendable appendable ) { NodeVisitor renderer = createRenderer ( appendable ) ; node . visitChildren ( renderer ) ; return appendable . toString ( ) ; }", "nl": "Renders node children to appendable ."}}
{"translation": {"code": "public String toHtml ( final Node node , final Appendable appendable ) { NodeVisitor renderer = createRenderer ( appendable ) ; node . visit ( renderer ) ; return appendable . toString ( ) ; }", "nl": "Renders node to appendable ."}}
{"translation": {"code": "protected String resolveHttpMethodFromMethodName ( final String methodName ) { int i = 0 ; while ( i < methodName . length ( ) ) { if ( CharUtil . isUppercaseAlpha ( methodName . charAt ( i ) ) ) { break ; } i ++ ; } final String name = methodName . substring ( 0 , i ) . toUpperCase ( ) ; for ( final HttpMethod httpMethod : HttpMethod . values ( ) ) { if ( httpMethod . equalsName ( name ) ) { return httpMethod . name ( ) ; } } return null ; }", "nl": "Resolves HTTP method name from method name . If method name or first camel - case word of a method equals to a HTTP method it will be used as that HTTP methods ."}}
{"translation": {"code": "public Method resolveActionMethod ( final Class < ? > actionClass , final String methodName ) { MethodDescriptor methodDescriptor = ClassIntrospector . get ( ) . lookup ( actionClass ) . getMethodDescriptor ( methodName , false ) ; if ( methodDescriptor == null ) { throw new MadvocException ( \"Public method not found: \" + actionClass . getSimpleName ( ) + \"#\" + methodName ) ; } return methodDescriptor . getMethod ( ) ; }", "nl": "Resolves action method for given action class ane method name ."}}
{"translation": {"code": "public static Target ofValue ( final Object value , final ScopeData scopeData ) { return new Target ( value , null , scopeData , null , VALUE_INSTANCE_CREATOR ) ; }", "nl": "Creates a common target over a value with known scope data ."}}
{"translation": {"code": "public String [ ] resolveParamNames ( final Method actionClassMethod ) { MethodParameter [ ] methodParameters = Paramo . resolveParameters ( actionClassMethod ) ; String [ ] names = new String [ methodParameters . length ] ; for ( int i = 0 ; i < methodParameters . length ; i ++ ) { names [ i ] = methodParameters [ i ] . getName ( ) ; } return names ; }", "nl": "Returns method parameter names ."}}
{"translation": {"code": "public Class < ? extends Annotation > detectAnnotationType ( final Annotation [ ] annotations ) { for ( final Annotation annotation : annotations ) { if ( annotation instanceof In ) { return annotation . annotationType ( ) ; } else if ( annotation instanceof Out ) { return annotation . annotationType ( ) ; } } return null ; }", "nl": "Scans annotation and returns type of Madvoc annotations ."}}
{"translation": {"code": "public Class getType ( ) { if ( type == null ) { if ( fieldDescriptor != null ) { type = fieldDescriptor . getRawType ( ) ; } else if ( readMethodDescriptor != null ) { type = getGetter ( true ) . getGetterRawType ( ) ; //type = readMethodDescriptor.getGetterRawType(); } else if ( writeMethodDescriptor != null ) { type = getSetter ( true ) . getSetterRawType ( ) ; //type = writeMethodDescriptor.getSetterRawType(); } } return type ; }", "nl": "Returns property type . Raw types are detected ."}}
{"translation": {"code": "protected Object parseArrayContent ( Class targetType , Class componentType ) { // detect special case if ( targetType == Object . class ) { targetType = List . class ; } // continue targetType = replaceWithMappedTypeForPath ( targetType ) ; if ( componentType == null && targetType != null && targetType . isArray ( ) ) { componentType = targetType . getComponentType ( ) ; } path . push ( VALUES ) ; componentType = replaceWithMappedTypeForPath ( componentType ) ; Collection < Object > target = newArrayInstance ( targetType ) ; boolean koma = false ; mainloop : while ( true ) { skipWhiteSpaces ( ) ; char c = input [ ndx ] ; if ( c == ' ' ) { if ( koma ) { syntaxError ( \"Trailing comma\" ) ; } ndx ++ ; path . pop ( ) ; return target ; } Object value = parseValue ( componentType , null , null ) ; target . add ( value ) ; skipWhiteSpaces ( ) ; c = input [ ndx ] ; switch ( c ) { case ' ' : ndx ++ ; break mainloop ; case ' ' : ndx ++ ; koma = true ; break ; default : syntaxError ( \"Invalid char: expected ] or ,\" ) ; } } path . pop ( ) ; if ( targetType != null ) { return convertType ( target , targetType ) ; } return target ; }", "nl": "Parses arrays once when open bracket has been consumed ."}}
{"translation": {"code": "protected String parseStringContent ( final char quote ) { final int startNdx = ndx ; // roll-out until the end of the string or the escape char while ( true ) { final char c = input [ ndx ] ; if ( c == quote ) { // no escapes found, just use existing string ndx ++ ; return new String ( input , startNdx , ndx - 1 - startNdx ) ; } if ( c == ' ' ) { break ; } ndx ++ ; } // escapes found, proceed differently textLen = ndx - startNdx ; growEmpty ( ) ; //\t\tfor (int i = startNdx, j = 0; j < textLen; i++, j++) { //\t\t\ttext[j] = input[i]; //\t\t} System . arraycopy ( input , startNdx , text , 0 , textLen ) ; // escape char, process everything until the end while ( true ) { char c = input [ ndx ] ; if ( c == quote ) { // done ndx ++ ; final String str = new String ( text , 0 , textLen ) ; textLen = 0 ; return str ; } if ( c == ' ' ) { // escape char found ndx ++ ; c = input [ ndx ] ; switch ( c ) { case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : c = ' ' ; break ; case ' ' : ndx ++ ; c = parseUnicode ( ) ; break ; default : if ( looseMode ) { if ( c != ' ' ) { c = ' ' ; ndx -- ; } } else { syntaxError ( \"Invalid escape char: \" + c ) ; } } } text [ textLen ] = c ; textLen ++ ; growAndCopy ( ) ; ndx ++ ; } }", "nl": "Parses string content once when starting quote has been consumed ."}}
{"translation": {"code": "protected String parseString ( ) { char quote = ' ' ; if ( looseMode ) { quote = consumeOneOf ( ' ' , ' ' ) ; if ( quote == 0 ) { return parseUnquotedStringContent ( ) ; } } else { consume ( quote ) ; } return parseStringContent ( quote ) ; }", "nl": "Parses a string ."}}
{"translation": {"code": "protected Number parseNumber ( ) { final int startIndex = ndx ; char c = input [ ndx ] ; boolean isDouble = false ; boolean isExp = false ; if ( c == ' ' ) { ndx ++ ; } while ( true ) { if ( isEOF ( ) ) { break ; } c = input [ ndx ] ; if ( c >= ' ' && c <= ' ' ) { ndx ++ ; continue ; } if ( c <= 32 ) { // white space break ; } if ( c == ' ' || c == ' ' || c == ' ' ) { // delimiter break ; } if ( c == ' ' ) { isDouble = true ; } else if ( c == ' ' || c == ' ' ) { isExp = true ; } ndx ++ ; } final String value = new String ( input , startIndex , ndx - startIndex ) ; if ( isDouble ) { return Double . valueOf ( value ) ; } long longNumber ; if ( isExp ) { longNumber = Double . valueOf ( value ) . longValue ( ) ; } else { if ( value . length ( ) >= 19 ) { // if string is 19 chars and longer, it can be over the limit BigInteger bigInteger = new BigInteger ( value ) ; if ( isGreaterThanLong ( bigInteger ) ) { return bigInteger ; } longNumber = bigInteger . longValue ( ) ; } else { longNumber = Long . parseLong ( value ) ; } } if ( ( longNumber >= Integer . MIN_VALUE ) && ( longNumber <= Integer . MAX_VALUE ) ) { return ( int ) longNumber ; } return longNumber ; }", "nl": "Parses JSON numbers ."}}
{"translation": {"code": "public static Path parse ( final String path ) { return path == null ? new Path ( ) : new Path ( StringUtil . splitc ( path , ' ' ) ) ; }", "nl": "Parses input dot - separated string that represents a path ."}}
{"translation": {"code": "protected Class replaceWithMappedTypeForPath ( final Class target ) { if ( mappings == null ) { return target ; } Class newType ; // first try alt paths Path altPath = path . getAltPath ( ) ; if ( altPath != null ) { if ( ! altPath . equals ( path ) ) { newType = mappings . get ( altPath ) ; if ( newType != null ) { return newType ; } } } // now check regular paths newType = mappings . get ( path ) ; if ( newType != null ) { return newType ; } return target ; }", "nl": "Replaces type with mapped type for current path ."}}
{"translation": {"code": "protected void reset ( ) { this . ndx = 0 ; this . textLen = 0 ; this . path = new Path ( ) ; this . notFirstObject = false ; if ( useAltPaths ) { path . altPath = new Path ( ) ; } if ( classMetadataName != null ) { mapToBean = createMapToBean ( classMetadataName ) ; } }", "nl": "Resets JSON parser so it can be reused ."}}
{"translation": {"code": "protected char parseUnicode ( ) { int i0 = CharUtil . hex2int ( input [ ndx ++ ] ) ; int i1 = CharUtil . hex2int ( input [ ndx ++ ] ) ; int i2 = CharUtil . hex2int ( input [ ndx ++ ] ) ; int i3 = CharUtil . hex2int ( input [ ndx ] ) ; return ( char ) ( ( i0 << 12 ) + ( i1 << 8 ) + ( i2 << 4 ) + i3 ) ; }", "nl": "Parses 4 characters and returns unicode character ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public < T extends ActionFilter > MadvocRouter filter ( final Class < T > actionFilterClass ) { filtersManager . resolve ( actionFilterClass ) ; return this ; }", "nl": "Returns action filter instance for further configuration ."}}
{"translation": {"code": "protected TypeData _lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } return typeData ; }", "nl": "Lookups type data and creates one if missing ."}}
{"translation": {"code": "public TypeData lookupTypeData ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }", "nl": "Returns all includes for given type . Returns an empty array when no includes are defined ."}}
{"translation": {"code": "public String serialize ( final Object source ) { FastCharBuffer fastCharBuffer = new FastCharBuffer ( ) ; serialize ( source , fastCharBuffer ) ; return fastCharBuffer . toString ( ) ; }", "nl": "Serializes object into source ."}}
{"translation": {"code": "public void serialize ( final Object source , final Appendable target ) { JsonContext jsonContext = createJsonContext ( target ) ; jsonContext . serialize ( source ) ; }", "nl": "Serializes object into provided appendable ."}}
{"translation": {"code": "private Object generifyList ( final List list , final Class componentType ) { for ( int i = 0 ; i < list . size ( ) ; i ++ ) { Object element = list . get ( i ) ; if ( element != null ) { if ( element instanceof Map ) { Object bean = map2bean ( ( Map ) element , componentType ) ; list . set ( i , bean ) ; } else { Object value = convert ( element , componentType ) ; list . set ( i , value ) ; } } } return list ; }", "nl": "Converts type of all list elements to match the component type ."}}
{"translation": {"code": "public Object map2bean ( final Map map , Class targetType ) { Object target = null ; // create targets type String className = ( String ) map . get ( classMetadataName ) ; if ( className == null ) { if ( targetType == null ) { // nothing to do, no information about target type found target = map ; } } else { checkClassName ( jsonParser . classnameWhitelist , className ) ; try { targetType = ClassLoaderUtil . loadClass ( className ) ; } catch ( ClassNotFoundException cnfex ) { throw new JsonException ( cnfex ) ; } } if ( target == null ) { target = jsonParser . newObjectInstance ( targetType ) ; } ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target . getClass ( ) ) ; boolean targetIsMap = target instanceof Map ; for ( Object key : map . keySet ( ) ) { String keyName = key . toString ( ) ; if ( classMetadataName != null ) { if ( keyName . equals ( classMetadataName ) ) { continue ; } } PropertyDescriptor pd = cd . getPropertyDescriptor ( keyName , declared ) ; if ( ! targetIsMap && pd == null ) { // target property does not exist, continue continue ; } // value is one of JSON basic types, like Number, Map, List... Object value = map . get ( key ) ; Class propertyType = pd == null ? null : pd . getType ( ) ; Class componentType = pd == null ? null : pd . resolveComponentType ( true ) ; if ( value != null ) { if ( value instanceof List ) { if ( componentType != null && componentType != String . class ) { value = generifyList ( ( List ) value , componentType ) ; } } else if ( value instanceof Map ) { // if the value we want to inject is a Map... if ( ! ClassUtil . isTypeOf ( propertyType , Map . class ) ) { // ... and if target is NOT a map value = map2bean ( ( Map ) value , propertyType ) ; } else { // target is also a Map, but we might need to generify it Class keyType = pd == null ? null : pd . resolveKeyType ( true ) ; if ( keyType != String . class || componentType != String . class ) { // generify value = generifyMap ( ( Map ) value , keyType , componentType ) ; } } } } if ( targetIsMap ) { ( ( Map ) target ) . put ( keyName , value ) ; } else { try { setValue ( target , pd , value ) ; } catch ( Exception ignore ) { ignore . printStackTrace ( ) ; } } } return target ; }", "nl": "Converts map to target type ."}}
{"translation": {"code": "public void register ( final Class type , final TypeJsonSerializer typeJsonSerializer ) { map . put ( type , typeJsonSerializer ) ; cache . clear ( ) ; }", "nl": "Registers new serializer ."}}
{"translation": {"code": "private void setValue ( final Object target , final PropertyDescriptor pd , Object value ) throws InvocationTargetException , IllegalAccessException { Class propertyType ; Setter setter = pd . getSetter ( true ) ; if ( setter != null ) { if ( value != null ) { propertyType = setter . getSetterRawType ( ) ; value = jsonParser . convertType ( value , propertyType ) ; } setter . invokeSetter ( target , value ) ; } }", "nl": "Sets the property value ."}}
{"translation": {"code": "public String resolveJsonName ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }", "nl": "Returns different name of a property if set by annotation ."}}
{"translation": {"code": "public String resolveRealName ( final Class type , final String jsonName ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveRealName ( jsonName ) ; }", "nl": "Returns real property name for given JSON property ."}}
{"translation": {"code": "public Class resolveComponentType ( final boolean declared ) { Class componentType = null ; Getter getter = getGetter ( declared ) ; if ( getter != null ) { componentType = getter . getGetterRawComponentType ( ) ; } if ( componentType == null ) { FieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; if ( fieldDescriptor != null ) { componentType = fieldDescriptor . getRawComponentType ( ) ; } } return componentType ; }", "nl": "Resolves component type for given property descriptor ."}}
{"translation": {"code": "public Class resolveKeyType ( final boolean declared ) { Class keyType = null ; Getter getter = getGetter ( declared ) ; if ( getter != null ) { keyType = getter . getGetterRawKeyComponentType ( ) ; } if ( keyType == null ) { FieldDescriptor fieldDescriptor = getFieldDescriptor ( ) ; if ( fieldDescriptor != null ) { keyType = fieldDescriptor . getRawKeyComponentType ( ) ; } } return keyType ; }", "nl": "Resolves key type for given property descriptor ."}}
{"translation": {"code": "protected < K , V > Map < K , V > generifyMap ( final Map < Object , Object > map , final Class < K > keyType , final Class < V > valueType ) { if ( keyType == String . class ) { // only value type is changed, we can make value replacements for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object value = entry . getValue ( ) ; Object newValue = convert ( value , valueType ) ; if ( value != newValue ) { entry . setValue ( newValue ) ; } } return ( Map < K , V > ) map ; } // key is changed too, we need a new map Map < K , V > newMap = new HashMap <> ( map . size ( ) ) ; for ( Map . Entry < Object , Object > entry : map . entrySet ( ) ) { Object key = entry . getKey ( ) ; Object newKey = convert ( key , keyType ) ; Object value = entry . getValue ( ) ; Object newValue = convert ( value , valueType ) ; newMap . put ( ( K ) newKey , ( V ) newValue ) ; } return newMap ; }", "nl": "Change map elements to match key and value types ."}}
{"translation": {"code": "public Path push ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }", "nl": "Push element to the path ."}}
{"translation": {"code": "private Object readProperty ( final Object source , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }", "nl": "Reads property using property descriptor ."}}
{"translation": {"code": "protected K get ( final K [ ] array , final int index ) { return ( K ) Array . get ( array , index ) ; }", "nl": "Returns array s element at given index ."}}
{"translation": {"code": "public boolean matchIgnoredPropertyTypes ( final Class propertyType , final boolean excludeMaps , final boolean include ) { if ( ! include ) { return false ; } if ( propertyType != null ) { if ( ! jsonSerializer . deep ) { ClassDescriptor propertyTypeClassDescriptor = ClassIntrospector . get ( ) . lookup ( propertyType ) ; if ( propertyTypeClassDescriptor . isArray ( ) ) { return false ; } if ( propertyTypeClassDescriptor . isCollection ( ) ) { return false ; } if ( excludeMaps ) { if ( propertyTypeClassDescriptor . isMap ( ) ) { return false ; } } } // still not excluded, continue with excluded types and type names // + excluded types if ( jsonSerializer . excludedTypes != null ) { for ( Class excludedType : jsonSerializer . excludedTypes ) { if ( ClassUtil . isTypeOf ( propertyType , excludedType ) ) { return false ; } } } // + exclude type names final String propertyTypeName = propertyType . getName ( ) ; if ( jsonSerializer . excludedTypeNames != null ) { for ( String excludedTypeName : jsonSerializer . excludedTypeNames ) { if ( Wildcard . match ( propertyTypeName , excludedTypeName ) ) { return false ; } } } } return true ; }", "nl": "Matches property types that are ignored by default ."}}
{"translation": {"code": "public JsonSerializer excludeTypes ( final Class ... types ) { if ( excludedTypes == null ) { excludedTypes = types ; } else { excludedTypes = ArraysUtil . join ( excludedTypes , types ) ; } return this ; }", "nl": "Excludes types . Supports interfaces and subclasses as well ."}}
{"translation": {"code": "public static Class [ ] resolveAllInterfaces ( final Class type ) { Set < Class > bag = new LinkedHashSet <> ( ) ; _resolveAllInterfaces ( type , bag ) ; return bag . toArray ( new Class [ 0 ] ) ; }", "nl": "Resolves all interfaces of a type . No duplicates are returned . Direct interfaces are prior the interfaces of subclasses in the returned array ."}}
{"translation": {"code": "protected void addRule ( final D ruleDefinition , final boolean include ) { if ( rules == null ) { rules = new ArrayList <> ( ) ; } if ( include ) { includesCount ++ ; } else { excludesCount ++ ; } Rule < R > newRule = new Rule <> ( makeRule ( ruleDefinition ) , include ) ; if ( rules . contains ( newRule ) ) { return ; } rules . add ( newRule ) ; }", "nl": "Adds a rule . Duplicates are not allowed and will be ignored ."}}
{"translation": {"code": "protected boolean processIncludes ( final V value , boolean include ) { if ( includesCount > 0 ) { if ( ! include ) { for ( Rule < R > rule : rules ) { if ( ! rule . include ) { continue ; } if ( inExRuleMatcher . accept ( value , rule . value , true ) ) { include = true ; break ; } } } } return include ; }", "nl": "Process includes rules ."}}
{"translation": {"code": "public boolean apply ( final V value , final boolean blacklist , boolean flag ) { if ( rules == null ) { return flag ; } if ( blacklist ) { flag = processExcludes ( value , flag ) ; flag = processIncludes ( value , flag ) ; } else { flag = processIncludes ( value , flag ) ; flag = processExcludes ( value , flag ) ; } return flag ; }", "nl": "Applies rules on given flag . Flag is only changed if at least one rule matched . Otherwise the same value is returned . This way you can chain several rules and have the rule engine change the flag only when a rule is matched ."}}
{"translation": {"code": "@ Override public boolean accept ( final String propertyName , final String rule , final boolean include ) { return propertyName . equals ( rule ) ; }", "nl": "Compares property name to the rules ."}}
{"translation": {"code": "protected boolean processExcludes ( final V value , boolean include ) { if ( excludesCount > 0 ) { if ( include ) { for ( Rule < R > rule : rules ) { if ( rule . include ) { continue ; } if ( inExRuleMatcher . accept ( value , rule . value , false ) ) { include = false ; break ; } } } } return include ; }", "nl": "Process excludes rules ."}}
{"translation": {"code": "protected TypeData findSubclassTypeData ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) { // current type has annotation, don't find anything, let type data be created return null ; } ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; // lookup superclasses Class [ ] superClasses = cd . getAllSuperclasses ( ) ; for ( Class superClass : superClasses ) { if ( superClass . getAnnotation ( defaultAnnotation ) != null ) { // annotated subclass founded! return _lookupTypeData ( superClass ) ; } } Class [ ] interfaces = cd . getAllInterfaces ( ) ; for ( Class interfaze : interfaces ) { if ( interfaze . getAnnotation ( defaultAnnotation ) != null ) { // annotated subclass founded! return _lookupTypeData ( interfaze ) ; } } return null ; }", "nl": "Finds type data of first annotated superclass or interface ."}}
{"translation": {"code": "protected void popName ( ) { if ( isPushed ) { if ( pushedComma ) { writeComma ( ) ; } String name = pushedName ; pushedName = null ; isPushed = false ; writeName ( name ) ; } }", "nl": "Writes stored name to JSON string . Cleans storage ."}}
{"translation": {"code": "public void write ( final CharSequence charSequence ) { popName ( ) ; try { out . append ( charSequence ) ; } catch ( IOException ioex ) { throw new JsonException ( ioex ) ; } }", "nl": "Appends char sequence to the buffer . Used for numbers nulls booleans etc ."}}
{"translation": {"code": "public void writeString ( final String value ) { popName ( ) ; write ( StringPool . QUOTE ) ; int len = value . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { char c = value . charAt ( i ) ; switch ( c ) { case ' ' : write ( \"\\\\\\\"\" ) ; break ; case ' ' : write ( \"\\\\\\\\\" ) ; break ; case ' ' : if ( strictStringEncoding ) { write ( \"\\\\/\" ) ; } else { write ( c ) ; } break ; case ' ' : write ( \"\\\\b\" ) ; break ; case ' ' : write ( \"\\\\f\" ) ; break ; case ' ' : write ( \"\\\\n\" ) ; break ; case ' ' : write ( \"\\\\r\" ) ; break ; case ' ' : write ( \"\\\\t\" ) ; break ; default : if ( Character . isISOControl ( c ) ) { unicode ( c ) ; } else { write ( c ) ; } } } write ( StringPool . QUOTE ) ; }", "nl": "Write a quoted and escaped value to the output ."}}
{"translation": {"code": "protected void unicode ( final char c ) { write ( \"\\\\u\" ) ; int n = c ; for ( int i = 0 ; i < 4 ; ++ i ) { int digit = ( n & 0xf000 ) >> 12 ; char hex = CharUtil . int2hex ( digit ) ; write ( hex ) ; n <<= 4 ; } }", "nl": "Writes unicode representation of a character ."}}
{"translation": {"code": "protected Object convertType ( final Object value , final Class targetType ) { final Class valueClass = value . getClass ( ) ; if ( valueClass == targetType ) { return value ; } try { return TypeConverterManager . get ( ) . convertType ( value , targetType ) ; } catch ( Exception ex ) { if ( ! strictTypes ) { return null ; } throw new JsonException ( \"Type conversion failed\" , ex ) ; } }", "nl": "Converts type of the given value ."}}
{"translation": {"code": "protected void injectValueIntoObject ( final Object target , final PropertyDescriptor pd , final Object value ) { Object convertedValue = value ; if ( value != null ) { Class targetClass = pd . getType ( ) ; convertedValue = convertType ( value , targetClass ) ; } try { Setter setter = pd . getSetter ( true ) ; if ( setter != null ) { setter . invokeSetter ( target , convertedValue ) ; } } catch ( Exception ex ) { throw new JsonException ( ex ) ; } }", "nl": "Injects value into the targets property ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) protected Collection < Object > newArrayInstance ( final Class targetType ) { if ( targetType == null || targetType == List . class || targetType == Collection . class || targetType . isArray ( ) ) { return listSupplier . get ( ) ; } if ( targetType == Set . class ) { return new HashSet <> ( ) ; } try { return ( Collection < Object > ) targetType . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( Exception e ) { throw new JsonException ( e ) ; } }", "nl": "Creates new type for JSON array objects . It returns a collection . Later the collection will be converted into the target type ."}}
{"translation": {"code": "public void visit ( ) { ClassDescriptor classDescriptor = ClassIntrospector . get ( ) . lookup ( type ) ; if ( classMetadataName != null ) { // process first 'meta' fields 'class' onProperty ( classMetadataName , null , false ) ; } PropertyDescriptor [ ] propertyDescriptors = classDescriptor . getAllPropertyDescriptors ( ) ; for ( PropertyDescriptor propertyDescriptor : propertyDescriptors ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { String propertyName = propertyDescriptor . getName ( ) ; boolean isTransient = false ; // check for transient flag FieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; if ( fieldDescriptor != null ) { isTransient = Modifier . isTransient ( fieldDescriptor . getField ( ) . getModifiers ( ) ) ; } onProperty ( propertyName , propertyDescriptor , isTransient ) ; } } }", "nl": "Visits a type ."}}
{"translation": {"code": "protected PropertyDescriptor [ ] lookupAnnotatedProperties ( final Class type ) { PropertyDescriptor [ ] properties = annotatedProperties . get ( type ) ; if ( properties != null ) { return properties ; } ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; List < PropertyDescriptor > list = new ArrayList <> ( ) ; for ( PropertyDescriptor propertyDescriptor : allProperties ) { Annotation ann = null ; if ( propertyDescriptor . getFieldDescriptor ( ) != null ) { ann = propertyDescriptor . getFieldDescriptor ( ) . getField ( ) . getAnnotation ( annotations ) ; } if ( ann == null && propertyDescriptor . getWriteMethodDescriptor ( ) != null ) { ann = propertyDescriptor . getWriteMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; } if ( ann == null && propertyDescriptor . getReadMethodDescriptor ( ) != null ) { ann = propertyDescriptor . getReadMethodDescriptor ( ) . getMethod ( ) . getAnnotation ( annotations ) ; } if ( ann != null ) { list . add ( propertyDescriptor ) ; } } if ( list . isEmpty ( ) ) { properties = EMPTY ; } else { properties = list . toArray ( new PropertyDescriptor [ 0 ] ) ; } annotatedProperties . put ( type , properties ) ; return properties ; }", "nl": "Lookups for annotated properties . Caches all annotated properties on the first action class scan ."}}
{"translation": {"code": "@ Override public final boolean serialize ( final JsonContext jsonContext , final T value ) { if ( jsonContext . pushValue ( value ) ) { // prevent circular dependencies return false ; } serializeValue ( jsonContext , value ) ; jsonContext . popValue ( ) ; return true ; }", "nl": "Detects circular dependencies and pushes value as current type context ."}}
{"translation": {"code": "protected String parseUnquotedStringContent ( ) { final int startNdx = ndx ; while ( true ) { final char c = input [ ndx ] ; if ( c <= ' ' || CharUtil . equalsOne ( c , UNQUOTED_DELIMETERS ) ) { final int currentNdx = ndx ; // done skipWhiteSpaces ( ) ; return new String ( input , startNdx , currentNdx - startNdx ) ; } ndx ++ ; } }", "nl": "Parses un - quoted string content ."}}
{"translation": {"code": "public static void storeIntoArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }", "nl": "Stores element on stack into an array ."}}
{"translation": {"code": "public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }", "nl": "Creates new array ."}}
{"translation": {"code": "public static InputStream getClassAsStream ( final String className , final ClassLoader classLoader ) throws IOException { return getResourceAsStream ( ClassUtil . convertClassNameToFileName ( className ) , classLoader ) ; }", "nl": "Opens a class of the specified name for reading using provided class loader ."}}
{"translation": {"code": "protected void init ( ) { File [ ] filesArray = dir . listFiles ( ) ; filesCount = 0 ; if ( filesArray != null ) { filesCount = filesArray . length ; for ( File file : filesArray ) { if ( ! acceptFile ( file ) ) { continue ; } map . put ( file , new MutableLong ( file . lastModified ( ) ) ) ; } } }", "nl": "Initializes dir watcher by reading all files from watched folder ."}}
{"translation": {"code": "protected boolean acceptFile ( final File file ) { if ( ! file . isFile ( ) ) { return false ; // ignore non-files } String fileName = file . getName ( ) ; if ( ignoreDotFiles ) { if ( fileName . startsWith ( StringPool . DOT ) ) { return false ; // ignore hidden files } } if ( patterns == null ) { return true ; } return Wildcard . matchOne ( fileName , patterns ) != - 1 ; }", "nl": "Accepts if a file is going to be watched ."}}
{"translation": {"code": "public DirWatcher useWatchFile ( final String name ) { watchFile = new File ( dir , name ) ; if ( ! watchFile . isFile ( ) || ! watchFile . exists ( ) ) { try { FileUtil . touch ( watchFile ) ; } catch ( IOException ioex ) { throw new DirWatcherException ( \"Invalid watch file: \" + name , ioex ) ; } } watchFileLastAccessTime = watchFile . lastModified ( ) ; return this ; }", "nl": "Enables usage of provided watch file ."}}
{"translation": {"code": "public void start ( final long pollingInterval ) { if ( timer == null ) { if ( ! startBlank ) { init ( ) ; } timer = new Timer ( true ) ; timer . schedule ( new WatchTask ( ) , 0 , pollingInterval ) ; } }", "nl": "Starts the watcher ."}}
{"translation": {"code": "protected void onChange ( final DirWatcherEvent . Type type , final File file ) { listeners . accept ( new DirWatcherEvent ( type , file ) ) ; }", "nl": "Triggers listeners on file change ."}}
{"translation": {"code": "public Buffer append ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) { // nothing to append return buffer ; } list . addAll ( buffer . list ) ; last = buffer . last ; size += buffer . size ; return this ; }", "nl": "Appends other buffer to this one ."}}
{"translation": {"code": "public void writeTo ( final Writer writer ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }", "nl": "Writes content to the writer ."}}
{"translation": {"code": "public void writeTo ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }", "nl": "Writes content to the output stream ."}}
{"translation": {"code": "public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException { // start final int size = size ( ) ; final int callbackSize = progressListener . callbackSize ( size ) ; int count = 0 ; // total count int step = 0 ; // step is offset in current chunk progressListener . transferred ( count ) ; // loop for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] bytes = fastByteBuffer . toArray ( ) ; int offset = 0 ; while ( offset < bytes . length ) { // calc the remaining sending chunk size int chunk = callbackSize - step ; // check if this chunk size fits the bytes array if ( offset + chunk > bytes . length ) { chunk = bytes . length - offset ; } // writes the chunk out . write ( bytes , offset , chunk ) ; offset += chunk ; step += chunk ; count += chunk ; // listener if ( step >= callbackSize ) { progressListener . transferred ( count ) ; step -= callbackSize ; } } } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; int remaining = uploadable . getSize ( ) ; try { while ( remaining > 0 ) { // calc the remaining sending chunk size int chunk = callbackSize - step ; // check if this chunk size fits the remaining size if ( chunk > remaining ) { chunk = remaining ; } // writes remaining chunk StreamUtil . copy ( inputStream , out , chunk ) ; remaining -= chunk ; step += chunk ; count += chunk ; // listener if ( step >= callbackSize ) { progressListener . transferred ( count ) ; step -= callbackSize ; } } } finally { StreamUtil . close ( inputStream ) ; } } } // end if ( step != 0 ) { progressListener . transferred ( count ) ; } }", "nl": "Writes content to the output stream using progress listener to track the sending progress ."}}
{"translation": {"code": "public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }", "nl": "Builds a PATCH request ."}}
{"translation": {"code": "public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }", "nl": "Builds a CONNECT request ."}}
{"translation": {"code": "public static String toHexString ( final byte [ ] bytes ) { char [ ] chars = new char [ bytes . length * 2 ] ; int i = 0 ; for ( byte b : bytes ) { chars [ i ++ ] = CharUtil . int2hex ( ( b & 0xF0 ) >> 4 ) ; chars [ i ++ ] = CharUtil . int2hex ( b & 0x0F ) ; } return new String ( chars ) ; }", "nl": "Converts bytes to hex string ."}}
{"translation": {"code": "protected TypeJsonSerializer lookupSerializer ( final Class type ) { TypeJsonSerializer tjs = map . get ( type ) ; if ( tjs == null ) { if ( defaultSerializerMap != null ) { tjs = defaultSerializerMap . map . get ( type ) ; } } return tjs ; }", "nl": "Get type serializer from map . First the current map is used . If element is missing default map will be used if exist ."}}
{"translation": {"code": "public String random ( int count , final char start , final char end ) { if ( count == 0 ) { return StringPool . EMPTY ; } final char [ ] result = new char [ count ] ; final int len = end - start + 1 ; while ( count -- > 0 ) { result [ count ] = ( char ) ( rnd . nextInt ( len ) + start ) ; } return new String ( result ) ; }", "nl": "Creates random string whose length is the number of characters specified . Characters are chosen from the provided range ."}}
{"translation": {"code": "public String randomRanges ( int count , final char ... ranges ) { if ( count == 0 ) { return StringPool . EMPTY ; } int i = 0 ; int len = 0 ; final int [ ] lens = new int [ ranges . length ] ; while ( i < ranges . length ) { int gap = ranges [ i + 1 ] - ranges [ i ] + 1 ; len += gap ; lens [ i ] = len ; i += 2 ; } final char [ ] result = new char [ count ] ; while ( count -- > 0 ) { char c = 0 ; int r = rnd . nextInt ( len ) ; for ( i = 0 ; i < ranges . length ; i += 2 ) { if ( r < lens [ i ] ) { r += ranges [ i ] ; if ( i != 0 ) { r -= lens [ i - 2 ] ; } c = ( char ) r ; break ; } } result [ count ] = c ; } return new String ( result ) ; }", "nl": "Creates random string whose length is the number of characters specified . Characters are chosen from the multiple sets defined by range pairs . All ranges must be in acceding order ."}}
{"translation": {"code": "public String random ( int count , final char [ ] chars ) { if ( count == 0 ) { return StringPool . EMPTY ; } final char [ ] result = new char [ count ] ; while ( count -- > 0 ) { result [ count ] = chars [ rnd . nextInt ( chars . length ) ] ; } return new String ( result ) ; }", "nl": "Creates random string whose length is the number of characters specified . Characters are chosen from the set of characters specified ."}}
{"translation": {"code": "@ Override public T get ( ) { if ( ! initialized ) { synchronized ( this ) { if ( ! initialized ) { final T t = supplier . get ( ) ; value = t ; initialized = true ; supplier = null ; return t ; } } } return value ; }", "nl": "Returns the value . Value will be computed on first call ."}}
{"translation": {"code": "public HttpBrowser setDefaultHeader ( final String name , final String value ) { defaultHeaders . addHeader ( name , value ) ; return this ; }", "nl": "Adds default header to all requests ."}}
{"translation": {"code": "protected void addDefaultHeaders ( final HttpRequest httpRequest ) { for ( Map . Entry < String , String > entry : defaultHeaders . entries ( ) ) { String name = entry . getKey ( ) ; if ( ! httpRequest . headers . contains ( name ) ) { httpRequest . headers . add ( name , entry . getValue ( ) ) ; } } }", "nl": "Add default headers to the request . If request already has a header set default header will be ignored ."}}
{"translation": {"code": "public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }", "nl": "Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;"}}
{"translation": {"code": "protected C createProxyObject ( Class < C > target ) { target = ProxettaUtil . resolveTargetClass ( target ) ; Class proxyClass = cache . get ( target ) ; if ( proxyClass == null ) { proxyClass = proxetta . defineProxy ( target ) ; cache . put ( target , proxyClass ) ; } C proxy ; try { proxy = ( C ) ClassUtil . newInstance ( proxyClass ) ; } catch ( Exception ex ) { throw new PathrefException ( ex ) ; } return proxy ; }", "nl": "Creates proxy object ."}}
{"translation": {"code": "protected void append ( final String methodName ) { if ( path . length ( ) != 0 ) { path += StringPool . DOT ; } if ( methodName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ) { path = StringUtil . substring ( path , 0 , - 1 ) ; } path += methodName ; }", "nl": "Appends method name to existing path ."}}
{"translation": {"code": "public static InputStream getResourceAsStream ( final String resourceName , final ClassLoader callingClass , final boolean useCache ) throws IOException { URL url = getResourceUrl ( resourceName , callingClass ) ; if ( url != null ) { URLConnection urlConnection = url . openConnection ( ) ; urlConnection . setUseCaches ( useCache ) ; return urlConnection . getInputStream ( ) ; } return null ; }", "nl": "Opens a resource of the specified name for reading . Controls caching that is important when the same jar is reloaded using custom classloader ."}}
{"translation": {"code": "@ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( \"unchecked\" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( \"No next() entry in the iteration\" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }", "nl": "Returns iterator of all entries ."}}
{"translation": {"code": "public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }", "nl": "Returns all values associated with the name ."}}
{"translation": {"code": "public HttpMultiMap < V > clear ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }", "nl": "Clears the map ."}}
{"translation": {"code": "private int hash ( final String name ) { int h = 0 ; for ( int i = name . length ( ) - 1 ; i >= 0 ; i -- ) { char c = name . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }", "nl": "Calculates hash value of the input string ."}}
{"translation": {"code": "public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }", "nl": "Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values ."}}
{"translation": {"code": "public T includeAs ( final Class template ) { blacklist = false ; String [ ] properties = getAllBeanPropertyNames ( template , false ) ; include ( properties ) ; return _this ( ) ; }", "nl": "Defines included property names as public properties of given template class . Sets to black list mode ."}}
{"translation": {"code": "public T exclude ( final String ... excludes ) { for ( String ex : excludes ) { rules . exclude ( ex ) ; } return _this ( ) ; }", "nl": "Defines excluded property names ."}}
{"translation": {"code": "public T include ( final String ... includes ) { for ( String in : includes ) { rules . include ( in ) ; } return _this ( ) ; }", "nl": "Defines included property names ."}}
{"translation": {"code": "public Cookie [ ] cookies ( ) { List < String > newCookies = headers ( \"set-cookie\" ) ; if ( newCookies == null ) { return new Cookie [ 0 ] ; } List < Cookie > cookieList = new ArrayList <> ( newCookies . size ( ) ) ; for ( String cookieValue : newCookies ) { try { Cookie cookie = new Cookie ( cookieValue ) ; cookieList . add ( cookie ) ; } catch ( Exception ex ) { // ignore } } return cookieList . toArray ( new Cookie [ 0 ] ) ; }", "nl": "Returns list of valid cookies sent from server . If no cookie found returns an empty array . Invalid cookies are ignored ."}}
{"translation": {"code": "public HttpRequest cookies ( final Cookie ... cookies ) { if ( cookies . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = true ; for ( Cookie cookie : cookies ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( \"; \" ) ; } first = false ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( \"cookie\" , cookieString . toString ( ) ) ; return this ; }", "nl": "Sets cookies to the request ."}}
{"translation": {"code": "protected Loading resolveResourceLoading ( final boolean parentFirstStrategy , String resourceName ) { if ( matchResourcesAsPackages ) { resourceName = StringUtil . replaceChar ( resourceName , ' ' , ' ' ) ; } return resolveLoading ( parentFirstStrategy , resourceName ) ; }", "nl": "Resolves resources ."}}
{"translation": {"code": "public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }", "nl": "Defines source detects a map ."}}
{"translation": {"code": "protected void writeRegion ( final Writer out , final char [ ] pageContent , final DecoraTag decoraTag , final DecoraTag [ ] decoraTags ) throws IOException { int regionStart = decoraTag . getRegionStart ( ) ; int regionLen = decoraTag . getRegionLength ( ) ; int regionEnd = regionStart + regionLen ; for ( DecoraTag innerDecoraTag : decoraTags ) { if ( decoraTag == innerDecoraTag ) { continue ; } if ( decoraTag . isRegionUndefined ( ) ) { continue ; } if ( innerDecoraTag . isInsideOtherTagRegion ( decoraTag ) ) { // write everything from region start to the inner Decora tag out . write ( pageContent , regionStart , innerDecoraTag . getRegionTagStart ( ) - regionStart ) ; regionStart = innerDecoraTag . getRegionTagEnd ( ) ; } } // write remaining content of the region out . write ( pageContent , regionStart , regionEnd - regionStart ) ; }", "nl": "Writes region to output but extracts all inner regions ."}}
{"translation": {"code": "protected void writeDecoratedPage ( final Writer out , final char [ ] decoratorContent , final char [ ] pageContent , final DecoraTag [ ] decoraTags ) throws IOException { int ndx = 0 ; for ( DecoraTag decoraTag : decoraTags ) { // [1] just copy content before the Decora tag int decoratorLen = decoraTag . getStartIndex ( ) - ndx ; if ( decoratorLen <= 0 ) { continue ; } out . write ( decoratorContent , ndx , decoratorLen ) ; ndx = decoraTag . getEndIndex ( ) ; // [2] now write region at the place of Decora tag int regionLen = decoraTag . getRegionLength ( ) ; if ( regionLen == 0 ) { if ( decoraTag . hasDefaultValue ( ) ) { out . write ( decoratorContent , decoraTag . getDefaultValueStart ( ) , decoraTag . getDefaultValueLength ( ) ) ; } } else { writeRegion ( out , pageContent , decoraTag , decoraTags ) ; } } // write remaining content out . write ( decoratorContent , ndx , decoratorContent . length - ndx ) ; }", "nl": "Writes decorated content ."}}
{"translation": {"code": "protected void parsePage ( final char [ ] pageContent , final DecoraTag [ ] decoraTags ) { LagartoParser lagartoParser = new LagartoParser ( pageContent ) ; PageRegionExtractor writer = new PageRegionExtractor ( decoraTags ) ; lagartoParser . parse ( writer ) ; }", "nl": "Parses target page and extracts Decora regions for replacements ."}}
{"translation": {"code": "public void startRegion ( final int start , final int tagLen , final int deepLevel ) { this . regionStart = start + tagLen ; this . regionLength = 0 ; this . regionTagStart = start ; this . deepLevel = deepLevel ; }", "nl": "Starts defining region by setting the start index and reset region length to zero ."}}
{"translation": {"code": "@ Override public void init ( final FilterConfig filterConfig ) throws ServletException { // final String decoraManagerClass = filterConfig . getInitParameter ( PARAM_DECORA_MANAGER ) ; if ( decoraManagerClass != null ) { try { final Class decoraManagerType = ClassLoaderUtil . loadClass ( decoraManagerClass ) ; decoraManager = ( DecoraManager ) ClassUtil . newInstance ( decoraManagerType ) ; } catch ( Exception ex ) { log . error ( \"Unable to load Decora manager class: \" + decoraManagerClass , ex ) ; throw new ServletException ( ex ) ; } } else { decoraManager = createDecoraManager ( ) ; } // final String decoraParserClass = filterConfig . getInitParameter ( PARAM_DECORA_PARSER ) ; if ( decoraParserClass != null ) { try { final Class decoraParserType = ClassLoaderUtil . loadClass ( decoraParserClass ) ; decoraParser = ( DecoraParser ) ClassUtil . newInstance ( decoraParserType ) ; } catch ( Exception ex ) { log . error ( \"Unable to load Decora parser class: \" + decoraParserClass , ex ) ; throw new ServletException ( ex ) ; } } else { decoraParser = createDecoraParser ( ) ; } // final String decoraCache = filterConfig . getInitParameter ( PARAM_DECORA_CACHE ) ; if ( decoraCache != null ) { cached = Converter . get ( ) . toBoolean ( decoraCache , false ) ; } }", "nl": "Initializes Decora filter . Loads manager and parser from init parameters ."}}
{"translation": {"code": "@ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( \"If-Modified-Since\" ) ; if ( lastModified > - 1 && ! response . containsHeader ( \"Last-Modified\" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( \"Last-Modified\" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }", "nl": "todo move to BufferResponseWrapper ?"}}
{"translation": {"code": "protected void defineDecoraTag ( ) { DecoraTag decoraTag = decoraTagDefaultValueStart == 0 ? new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagEnd ) : new DecoraTag ( decoraTagName , decoraIdName , decoraTagStart , decoraTagEnd , decoraTagDefaultValueStart , decoraTagDefaultValueEnd - decoraTagDefaultValueStart ) ; decoraTags . add ( decoraTag ) ; decoraTagName = null ; decoraIdName = null ; closingTagName = null ; decoraTagDefaultValueStart = 0 ; }", "nl": "Defines Decora tag position inside decorator content . Resets current Decora tag tracking ."}}
{"translation": {"code": "protected void onIdAttrStart ( final Tag tag ) { String id = tag . getId ( ) . toString ( ) . substring ( 7 ) ; String tagName ; String idName ; int dashIndex = id . indexOf ( ' ' ) ; if ( dashIndex == - 1 ) { tagName = id ; idName = null ; } else { tagName = id . substring ( 0 , dashIndex ) ; idName = id . substring ( dashIndex + 1 ) ; } if ( tag . getType ( ) == TagType . SELF_CLOSING ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName ; decoraIdName = idName ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; defineDecoraTag ( ) ; return ; } if ( tag . getType ( ) == TagType . START ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName ; decoraIdName = idName ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; closingTagName = tag . getName ( ) . toString ( ) ; closingTagDeepLevel = tag . getDeepLevel ( ) ; } }", "nl": "Handle open and empty ID attribute tags ."}}
{"translation": {"code": "protected void onDecoraTag ( final Tag tag ) { String tagName = tag . getName ( ) . toString ( ) ; if ( tag . getType ( ) == TagType . SELF_CLOSING ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName . substring ( 7 ) ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; defineDecoraTag ( ) ; return ; } if ( tag . getType ( ) == TagType . START ) { checkNestedDecoraTags ( ) ; decoraTagName = tagName . substring ( 7 ) ; decoraTagStart = tag . getTagPosition ( ) ; decoraTagDefaultValueStart = tag . getTagPosition ( ) + tag . getTagLength ( ) ; return ; } // closed tag type decoraTagEnd = tag . getTagPosition ( ) + tag . getTagLength ( ) ; decoraTagDefaultValueEnd = tag . getTagPosition ( ) ; defineDecoraTag ( ) ; }", "nl": "Handle Decora tags ."}}
{"translation": {"code": "public void decorate ( final Writer writer , final char [ ] pageContent , final char [ ] decoraContent ) throws IOException { DecoraTag [ ] decoraTags = parseDecorator ( decoraContent ) ; parsePage ( pageContent , decoraTags ) ; writeDecoratedPage ( writer , decoraContent , pageContent , decoraTags ) ; }", "nl": "Decorates page content with decorator template and outputs the result ."}}
{"translation": {"code": "public File lookupBundleFile ( String bundleId ) { if ( ( mirrors != null ) && ( ! mirrors . isEmpty ( ) ) ) { String realBundleId = mirrors . remove ( bundleId ) ; if ( realBundleId != null ) { bundleId = realBundleId ; } } return createBundleFile ( bundleId ) ; }", "nl": "Lookups for bundle file ."}}
{"translation": {"code": "@ Override public int doAfterBody ( ) throws JspException { BodyContent body = getBodyContent ( ) ; JspWriter out = body . getEnclosingWriter ( ) ; String bodytext = populateForm ( body . getString ( ) , name -> value ( name , pageContext ) ) ; try { out . print ( bodytext ) ; } catch ( IOException ioex ) { throw new JspException ( ioex ) ; } return SKIP_BODY ; }", "nl": "Performs smart form population ."}}
{"translation": {"code": "public synchronized void reset ( ) { if ( strategy == Strategy . ACTION_MANAGED ) { actionBundles . clear ( ) ; mirrors . clear ( ) ; } final FindFile ff = new FindFile ( ) ; ff . includeDirs ( false ) ; ff . searchPath ( new File ( bundleFolder , staplerPath ) ) ; File f ; int count = 0 ; while ( ( f = ff . nextFile ( ) ) != null ) { f . delete ( ) ; count ++ ; } if ( log . isInfoEnabled ( ) ) { log . info ( \"reset: \" + count + \" bundle files deleted.\" ) ; } }", "nl": "Clears all settings and removes all created bundle files from file system ."}}
{"translation": {"code": "protected String fixCssRelativeUrls ( final String content , final String src ) { final String path = FileNameUtil . getPath ( src ) ; final Matcher matcher = CSS_URL_PATTERN . matcher ( content ) ; final StringBuilder sb = new StringBuilder ( content . length ( ) ) ; int start = 0 ; while ( matcher . find ( ) ) { sb . append ( content , start , matcher . start ( ) ) ; final String matchedUrl = StringUtil . removeChars ( matcher . group ( 1 ) , \"'\\\"\" ) ; final String url ; if ( matchedUrl . startsWith ( \"https://\" ) || matchedUrl . startsWith ( \"http://\" ) || matchedUrl . startsWith ( \"data:\" ) ) { url = \"url('\" + matchedUrl + \"')\" ; } else { url = fixRelativeUrl ( matchedUrl , path ) ; } sb . append ( url ) ; start = matcher . end ( ) ; } sb . append ( content . substring ( start ) ) ; return sb . toString ( ) ; }", "nl": "Returns the content with all relative URLs fixed ."}}
{"translation": {"code": "public synchronized String registerBundle ( final String contextPath , final String actionPath , final String tempBundleId , final String bundleContentType , final List < String > sources ) { if ( tempBundleId == null || sources . isEmpty ( ) ) { if ( strategy == Strategy . ACTION_MANAGED ) { // page does not include any resource source file actionBundles . put ( actionPath , StringPool . EMPTY ) ; } return null ; } // create unique digest from the collected sources String [ ] sourcesArray = sources . toArray ( new String [ 0 ] ) ; for ( int i = 0 , sourcesArrayLength = sourcesArray . length ; i < sourcesArrayLength ; i ++ ) { sourcesArray [ i ] = sourcesArray [ i ] . trim ( ) . toLowerCase ( ) ; } if ( sortResources ) { Arrays . sort ( sourcesArray ) ; } StringBand sb = new StringBand ( sourcesArray . length ) ; for ( String src : sourcesArray ) { sb . append ( src ) ; } String sourcesString = sb . toString ( ) ; String bundleId = createDigest ( sourcesString ) ; bundleId += ' ' + bundleContentType ; // bundle appears for the first time, create the bundle if ( strategy == Strategy . ACTION_MANAGED ) { actionBundles . put ( actionPath , bundleId ) ; mirrors . put ( tempBundleId , bundleId ) ; } try { createBundle ( contextPath , actionPath , bundleId , sources ) ; } catch ( IOException ioex ) { throw new HtmlStaplerException ( \"Can't create bundle\" , ioex ) ; } return bundleId ; }", "nl": "Registers new bundle that consist of provided list of source paths . Returns the real bundle id as provided one is just a temporary bundle id ."}}
{"translation": {"code": "public File lookupGzipBundleFile ( final File file ) throws IOException { String path = file . getPath ( ) + ZipUtil . GZIP_EXT ; File gzipFile = new File ( path ) ; if ( ! gzipFile . exists ( ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"gzip bundle to \" + path ) ; } ZipUtil . gzip ( file ) ; } return gzipFile ; }", "nl": "Locates gzipped version of bundle file . If gzip file does not exist it will be created ."}}
{"translation": {"code": "public void end ( ) { if ( newAction ) { bundleId = bundlesManager . registerBundle ( contextPath , actionPath , bundleId , bundleContentType , sources ) ; } }", "nl": "Called on end of parsing ."}}
{"translation": {"code": "protected void readFilterConfigParameters ( final FilterConfig filterConfig , final Object target , final String ... parameters ) { for ( String parameter : parameters ) { String value = filterConfig . getInitParameter ( parameter ) ; if ( value != null ) { BeanUtil . declared . setProperty ( target , parameter , value ) ; } } }", "nl": "Reads filter config parameters and set into destination target ."}}
{"translation": {"code": "protected String valueToString ( final String name , final Object valueObject ) { if ( ! valueObject . getClass ( ) . isArray ( ) ) { return valueObject . toString ( ) ; } // array String [ ] array = ( String [ ] ) valueObject ; if ( valueNameIndexes == null ) { valueNameIndexes = new HashMap <> ( ) ; } MutableInteger index = valueNameIndexes . get ( name ) ; if ( index == null ) { index = new MutableInteger ( 0 ) ; valueNameIndexes . put ( name , index ) ; } if ( index . value >= array . length ) { return null ; } String result = array [ index . value ] ; index . value ++ ; return result ; }", "nl": "Converts value to a string ."}}
{"translation": {"code": "protected void sendBundleFile ( final HttpServletResponse resp , final File bundleFile ) throws IOException { OutputStream out = resp . getOutputStream ( ) ; FileInputStream fileInputStream = new FileInputStream ( bundleFile ) ; try { StreamUtil . copy ( fileInputStream , out ) ; } finally { StreamUtil . close ( fileInputStream ) ; } }", "nl": "Outputs bundle file to the response ."}}
{"translation": {"code": "protected void createBundle ( final String contextPath , final String actionPath , final String bundleId , final List < String > sources ) throws IOException { final File bundleFile = createBundleFile ( bundleId ) ; if ( bundleFile . exists ( ) ) { return ; } StringBand sb = new StringBand ( sources . size ( ) * 2 ) ; for ( String src : sources ) { if ( sb . length ( ) != 0 ) { sb . append ( StringPool . NEWLINE ) ; } String content ; if ( isExternalResource ( src ) ) { content = downloadString ( src ) ; } else { if ( ! downloadLocal ) { // load local resource from file system String localFile = webRoot ; if ( src . startsWith ( contextPath + ' ' ) ) { src = src . substring ( contextPath . length ( ) ) ; } if ( src . startsWith ( StringPool . SLASH ) ) { // absolute path localFile += src ; } else { // relative path localFile += ' ' + FileNameUtil . getPathNoEndSeparator ( actionPath ) + ' ' + src ; } // trim link parameters, if any int qmndx = localFile . indexOf ( ' ' ) ; if ( qmndx != - 1 ) { localFile = localFile . substring ( 0 , qmndx ) ; } try { content = FileUtil . readString ( localFile ) ; } catch ( IOException ioex ) { if ( notFoundExceptionEnabled ) { throw ioex ; } if ( log . isWarnEnabled ( ) ) { log . warn ( ioex . getMessage ( ) ) ; } content = null ; } } else { // download local resource String localUrl = localAddressAndPort ; if ( src . startsWith ( StringPool . SLASH ) ) { localUrl += contextPath + src ; } else { localUrl += contextPath + FileNameUtil . getPath ( actionPath ) + ' ' + src ; } content = downloadString ( localUrl ) ; } if ( content != null ) { if ( isCssResource ( src ) ) { content = fixCssRelativeUrls ( content , src ) ; } } } if ( content != null ) { content = onResourceContent ( content ) ; sb . append ( content ) ; } } FileUtil . writeString ( bundleFile , sb . toString ( ) ) ; if ( log . isInfoEnabled ( ) ) { log . info ( \"Bundle created: \" + bundleId ) ; } }", "nl": "Creates bundle file by loading resource files content . If bundle file already exist it will not be recreated!"}}
{"translation": {"code": "protected String createDigest ( final String source ) { final DigestEngine digestEngine = DigestEngine . sha256 ( ) ; final byte [ ] bytes = digestEngine . digest ( CharUtil . toSimpleByteArray ( source ) ) ; String digest = Base32 . encode ( bytes ) ; if ( uniqueDigestKey != null ) { digest += uniqueDigestKey ; } return digest ; }", "nl": "Creates digest i . e . bundle id from given string . Returned digest must be filename safe for all platforms ."}}
{"translation": {"code": "protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; } // check if we should include the field boolean include = true ; if ( value != null ) { // + all collections are not serialized by default include = jsonContext . matchIgnoredPropertyTypes ( value . getClass ( ) , false , include ) ; // + path queries: excludes/includes include = jsonContext . matchPathToQueries ( include ) ; } // done if ( ! include ) { currentPath . pop ( ) ; return count ; } if ( key == null ) { jsonContext . pushName ( null , count > 0 ) ; } else { jsonContext . pushName ( key . toString ( ) , count > 0 ) ; } jsonContext . serialize ( value ) ; if ( jsonContext . isNamePopped ( ) ) { count ++ ; } currentPath . pop ( ) ; return count ; }", "nl": "Serializes key and a value ."}}
{"translation": {"code": "public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }", "nl": "Adds byte content into the zip as a file ."}}
{"translation": {"code": "private static byte [ ] fromHex ( final String hex ) { final byte [ ] binary = new byte [ hex . length ( ) / 2 ] ; for ( int i = 0 ; i < binary . length ; i ++ ) { binary [ i ] = ( byte ) Integer . parseInt ( hex . substring ( 2 * i , 2 * i + 2 ) , 16 ) ; } return binary ; }", "nl": "Converts a string of hexadecimal characters into a byte array ."}}
{"translation": {"code": "public String createHash ( final char [ ] password ) { // Generate a random salt SecureRandom random = new SecureRandom ( ) ; byte [ ] salt = new byte [ saltBytes ] ; random . nextBytes ( salt ) ; // Hash the password byte [ ] hash = pbkdf2 ( password , salt , pbkdf2Iterations , hashBytes ) ; // format iterations:salt:hash return pbkdf2Iterations + \":\" + StringUtil . toHexString ( salt ) + \":\" + StringUtil . toHexString ( hash ) ; }", "nl": "Returns a salted PBKDF2 hash of the password ."}}
{"translation": {"code": "private static byte [ ] pbkdf2 ( final char [ ] password , final byte [ ] salt , final int iterations , final int bytes ) { PBEKeySpec spec = new PBEKeySpec ( password , salt , iterations , bytes * 8 ) ; try { SecretKeyFactory skf = SecretKeyFactory . getInstance ( PBKDF2_ALGORITHM ) ; return skf . generateSecret ( spec ) . getEncoded ( ) ; } catch ( NoSuchAlgorithmException ignore ) { return null ; } catch ( InvalidKeySpecException e ) { throw new IllegalArgumentException ( e ) ; } }", "nl": "Computes the PBKDF2 hash of a password ."}}
{"translation": {"code": "public static long getLongLittleEndian ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 ) // no mask needed | ( ( buf [ offset + 6 ] & 0xff L ) << 48 ) | ( ( buf [ offset + 5 ] & 0xff L ) << 40 ) | ( ( buf [ offset + 4 ] & 0xff L ) << 32 ) | ( ( buf [ offset + 3 ] & 0xff L ) << 24 ) | ( ( buf [ offset + 2 ] & 0xff L ) << 16 ) | ( ( buf [ offset + 1 ] & 0xff L ) << 8 ) | ( ( buf [ offset ] & 0xff L ) ) ; // no shift needed }", "nl": "Gets a long from a byte buffer in little endian byte order ."}}
{"translation": {"code": "public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ; // flush & close not needed for StringWriter-instance StreamUtil . copy ( reader , writer ) ; return writer . toString ( ) ; } }", "nl": "Reads path content ."}}
{"translation": {"code": "public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }", "nl": "Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods ."}}
{"translation": {"code": "protected HttpResponse _sendRequest ( final HttpRequest httpRequest , final HttpResponse previouseResponse ) { if ( ! keepAlive ) { httpRequest . open ( httpConnectionProvider ) ; } else { // keeping alive if ( previouseResponse == null ) { httpRequest . open ( httpConnectionProvider ) . connectionKeepAlive ( true ) ; } else { httpRequest . keepAlive ( previouseResponse , true ) ; } } return httpRequest . send ( ) ; }", "nl": "Opens connection and sends a response ."}}
{"translation": {"code": "public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }", "nl": "Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different ."}}
{"translation": {"code": "public static String removeQuotes ( final String string ) { if ( ( startsWithChar ( string , ' ' ) && endsWithChar ( string , ' ' ) ) || ( startsWithChar ( string , ' ' ) && endsWithChar ( string , ' ' ) ) || ( startsWithChar ( string , ' ' ) && endsWithChar ( string , ' ' ) ) ) { return substring ( string , 1 , - 1 ) ; } return string ; }", "nl": "Removes starting and ending single or double quotes ."}}
{"translation": {"code": "public static ProcessResult run ( final Process process ) throws InterruptedException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , baos , OUTPUT_PREFIX ) ; final StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , baos , ERROR_PREFIX ) ; outputGobbler . start ( ) ; errorGobbler . start ( ) ; final int result = process . waitFor ( ) ; outputGobbler . waitFor ( ) ; errorGobbler . waitFor ( ) ; return new ProcessResult ( result , baos . toString ( ) ) ; }", "nl": "Executes a process and returns the process output and exit code ."}}
{"translation": {"code": "public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }", "nl": "Finds all files and returns list of founded files ."}}
{"translation": {"code": "public ProcessRunner . ProcessResult run ( ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; out = err = baos ; try { baos . write ( StringUtil . join ( cmdLine , ' ' ) . getBytes ( ) ) ; baos . write ( StringPool . BYTES_NEW_LINE ) ; } catch ( IOException ignore ) { } ProcessBuilder processBuilder = new ProcessBuilder ( ) ; processBuilder . command ( cmdLine ) ; if ( cleanEnvironment ) { processBuilder . environment ( ) . clear ( ) ; } if ( env != null ) { processBuilder . environment ( ) . putAll ( env ) ; } processBuilder . directory ( workingDirectory ) ; Process process = null ; try { process = processBuilder . start ( ) ; } catch ( IOException ioex ) { return writeException ( baos , ioex ) ; } StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , out , outPrefix ) ; StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , err , errPrefix ) ; outputGobbler . start ( ) ; errorGobbler . start ( ) ; int result ; try { result = process . waitFor ( ) ; } catch ( InterruptedException iex ) { return writeException ( baos , iex ) ; } outputGobbler . waitFor ( ) ; errorGobbler . waitFor ( ) ; return new ProcessRunner . ProcessResult ( result , baos . toString ( ) ) ; }", "nl": "Runs command and returns process result ."}}
{"translation": {"code": "public CommandLine args ( final String ... arguments ) { if ( arguments != null && arguments . length > 0 ) { Collections . addAll ( cmdLine , arguments ) ; } return this ; }", "nl": "Adds several arguments ."}}
{"translation": {"code": "public CommandLine env ( final String key , final String value ) { if ( env == null ) { env = new HashMap <> ( ) ; } env . put ( key , value ) ; return this ; }", "nl": "Sets environment variable ."}}
{"translation": {"code": "public static String join ( final Collection collection , final char separator ) { if ( collection == null ) { return null ; } if ( collection . size ( ) == 0 ) { return StringPool . EMPTY ; } final StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; final Iterator it = collection . iterator ( ) ; for ( int i = 0 ; i < collection . size ( ) ; i ++ ) { if ( i > 0 ) { sb . append ( separator ) ; } sb . append ( it . next ( ) ) ; } return sb . toString ( ) ; }", "nl": "Joins an collection of objects into one string with separator ."}}
{"translation": {"code": "public static ThreadFactory daemonThreadFactory ( final String name , final int priority ) { return new ThreadFactory ( ) { private AtomicInteger count = new AtomicInteger ( ) ; @ Override public Thread newThread ( final Runnable r ) { Thread thread = new Thread ( r ) ; thread . setName ( name + ' ' + count . incrementAndGet ( ) ) ; thread . setDaemon ( true ) ; thread . setPriority ( priority ) ; return thread ; } } ; }", "nl": "Creates new daemon thread factory ."}}
{"translation": {"code": "public static List < String > listZip ( final File zipFile ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( zipFile ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }", "nl": "Lists zip content ."}}
{"translation": {"code": "public String on ( final String string ) { if ( ! enabled ) { return string ; } final StringBuilder sb = new StringBuilder ( ) ; if ( prefix != null ) { sb . append ( prefix ) . append ( \"m\" ) ; } sb . append ( string ) ; if ( suffix != null ) { sb . append ( suffix ) . append ( \"m\" ) ; } return sb . toString ( ) ; }", "nl": "Returns chalked string ."}}
{"translation": {"code": "protected SSLSocketFactory getDefaultSSLSocketFactory ( final boolean trustAllCertificates ) throws IOException { if ( trustAllCertificates ) { try { SSLContext sc = SSLContext . getInstance ( sslProtocol ) ; sc . init ( null , TrustManagers . TRUST_ALL_CERTS , new java . security . SecureRandom ( ) ) ; return sc . getSocketFactory ( ) ; } catch ( NoSuchAlgorithmException | KeyManagementException e ) { throw new IOException ( e ) ; } } else { return ( SSLSocketFactory ) SSLSocketFactory . getDefault ( ) ; } }", "nl": "Returns default SSL socket factory allowing setting trust managers ."}}
{"translation": {"code": "public static String encode ( final String string , final String encoding ) { return encodeUriComponent ( string , encoding , URIPart . UNRESERVED ) ; }", "nl": "Encodes string using default RFCP rules ."}}
{"translation": {"code": "public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }", "nl": "Calculates relative path of target path on base path ."}}
{"translation": {"code": "public DbServer detectDatabaseAndConfigureDbOom ( final ConnectionProvider cp , final DbOomConfig dbOomConfig ) { cp . init ( ) ; final Connection connection = cp . getConnection ( ) ; final DbServer dbServer = detectDatabase ( connection ) ; cp . closeConnection ( connection ) ; dbServer . accept ( dbOomConfig ) ; return dbServer ; }", "nl": "Detects database and configure DbOom engine ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T newInstance ( final Class < T > clazz , final Object ... params ) throws InstantiationException , IllegalAccessException , InvocationTargetException , NoSuchMethodException { if ( params . length == 0 ) { return newInstance ( clazz ) ; } final Class < ? > [ ] paramTypes = getClasses ( params ) ; final Constructor < ? > constructor = findConstructor ( clazz , paramTypes ) ; if ( constructor == null ) { throw new InstantiationException ( \"No constructor matched parameter types.\" ) ; } return ( T ) constructor . newInstance ( params ) ; }", "nl": "Creates new instance of given class with given optional arguments ."}}
{"translation": {"code": "public static < T > Constructor < T > findConstructor ( final Class < T > clazz , final Class < ? > ... parameterTypes ) { final Constructor < ? > [ ] constructors = clazz . getConstructors ( ) ; Class < ? > [ ] pts ; for ( Constructor < ? > constructor : constructors ) { pts = constructor . getParameterTypes ( ) ; if ( isAllAssignableFrom ( pts , parameterTypes ) ) { return ( Constructor < T > ) constructor ; } } return null ; }", "nl": "Finds constructor with given parameter types . First matched ctor is returned ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < T > T proxyOf ( final T target , final Class < ? extends Aspect > aspectClass ) { final Aspect aspect ; try { aspect = ClassUtil . newInstance ( aspectClass , target ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( \"Can't create new instance of aspect class\" , e ) ; } return ( T ) newProxyInstance ( target . getClass ( ) . getClassLoader ( ) , aspect , target . getClass ( ) . getInterfaces ( ) ) ; }", "nl": "Creates a proxy of given target and the aspect ."}}
{"translation": {"code": "public static Throwable unwrapThrowable ( final Throwable wrappedThrowable ) { Throwable unwrapped = wrappedThrowable ; while ( true ) { if ( unwrapped instanceof InvocationTargetException ) { unwrapped = ( ( InvocationTargetException ) unwrapped ) . getTargetException ( ) ; } else if ( unwrapped instanceof UndeclaredThrowableException ) { unwrapped = ( ( UndeclaredThrowableException ) unwrapped ) . getUndeclaredThrowable ( ) ; } else { return unwrapped ; } } }", "nl": "Unwraps invocation and undeclared exceptions to real cause ."}}
{"translation": {"code": "protected String shortenClassName ( final String className ) { int lastDotIndex = className . lastIndexOf ( ' ' ) ; if ( lastDotIndex == - 1 ) { return className ; } StringBuilder shortClassName = new StringBuilder ( className . length ( ) ) ; int start = 0 ; while ( true ) { shortClassName . append ( className . charAt ( start ) ) ; int next = className . indexOf ( ' ' , start ) ; if ( next == lastDotIndex ) { break ; } start = next + 1 ; shortClassName . append ( ' ' ) ; } shortClassName . append ( className . substring ( lastDotIndex ) ) ; return shortClassName . toString ( ) ; }", "nl": "Returns shorten class name ."}}
{"translation": {"code": "protected String getCallerClass ( ) { Exception exception = new Exception ( ) ; StackTraceElement [ ] stackTrace = exception . getStackTrace ( ) ; for ( StackTraceElement stackTraceElement : stackTrace ) { String className = stackTraceElement . getClassName ( ) ; if ( className . equals ( SimpleLoggerProvider . class . getName ( ) ) ) { continue ; } if ( className . equals ( SimpleLogger . class . getName ( ) ) ) { continue ; } if ( className . equals ( Logger . class . getName ( ) ) ) { continue ; } return shortenClassName ( className ) + ' ' + stackTraceElement . getMethodName ( ) + ' ' + stackTraceElement . getLineNumber ( ) ; } return \"N/A\" ; }", "nl": "Returns called class ."}}
{"translation": {"code": "public void addHeader ( final String name , final String value ) { List < String > valuesList = super . getAll ( name ) ; if ( valuesList . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valuesList . add ( value ) ; super . addAll ( name , valuesList ) ; }", "nl": "Adds new header value . If existing value exist it will be removed so the store the new key value ."}}
{"translation": {"code": "public String getString ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }", "nl": "Returns the string value with the specified key ."}}
{"translation": {"code": "public Float getFloat ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }", "nl": "Returns the float value with the specified key ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }", "nl": "Returns the value with the specified key as an object ."}}
{"translation": {"code": "public JsonObject put ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }", "nl": "Puts a string into the JSON object with the specified key ."}}
{"translation": {"code": "public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }", "nl": "returns the integer value with the specified key ."}}
{"translation": {"code": "public JsonArray add ( Object value ) { Objects . requireNonNull ( value ) ; value = JsonObject . resolveValue ( value ) ; list . add ( value ) ; return this ; }", "nl": "Adds an object to the JSON array ."}}
{"translation": {"code": "public Double getDouble ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }", "nl": "Returns the double value with the specified key ."}}
{"translation": {"code": "public JsonArray addAll ( final JsonArray array ) { Objects . requireNonNull ( array ) ; list . addAll ( array . list ) ; return this ; }", "nl": "Appends all of the elements in the specified array to the end of this JSON array ."}}
{"translation": {"code": "public Long getLong ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }", "nl": "Returns the long value with the specified key ."}}
{"translation": {"code": "public Object remove ( final int pos ) { Object removed = list . remove ( pos ) ; if ( removed instanceof Map ) { return new JsonObject ( ( Map ) removed ) ; } if ( removed instanceof ArrayList ) { return new JsonArray ( ( List ) removed ) ; } return removed ; }", "nl": "Removes the value at the specified position in the JSON array ."}}
{"translation": {"code": "public < K , V > Map < K , V > parseAsMap ( final String string , final Class < K > keyType , final Class < V > valueType ) { return new JsonParser ( ) . map ( JsonParser . KEYS , keyType ) . map ( JsonParser . VALUES , valueType ) . parse ( string ) ; }", "nl": "Parses input JSON to a list with specified key and value types ."}}
{"translation": {"code": "public < T > List < T > parseAsList ( final String string , final Class < T > componentType ) { return new JsonParser ( ) . map ( JsonParser . VALUES , componentType ) . parse ( string ) ; }", "nl": "Parses input JSON to a list with specified component type ."}}
{"translation": {"code": "public Map < String , String > parseSignatureForGenerics ( final String signature , final boolean isInterface ) { if ( signature == null ) { return Collections . emptyMap ( ) ; } final Map < String , String > genericsMap = new HashMap <> ( ) ; SignatureReader sr = new SignatureReader ( signature ) ; StringBuilder sb = new StringBuilder ( ) ; TraceSignatureVisitor v = new TraceSignatureVisitor ( sb , isInterface ) { String genericName ; @ Override public void visitFormalTypeParameter ( final String name ) { genericName = name ; super . visitFormalTypeParameter ( name ) ; } @ Override public void visitClassType ( final String name ) { if ( genericName != null ) { genericsMap . put ( genericName , ' ' + name + ' ' ) ; genericName = null ; } super . visitClassType ( name ) ; } } ; sr . accept ( v ) ; return genericsMap ; }", "nl": "Parses signature for generic information and returns a map where key is generic name and value is raw type . Returns an empty map if signature does not define any generics ."}}
{"translation": {"code": "private String resolveRawTypeName ( String typeName ) { if ( typeName == null ) { return null ; } boolean isArray = typeName . startsWith ( StringPool . LEFT_SQ_BRACKET ) ; if ( isArray ) { typeName = typeName . substring ( 1 ) ; } String rawTypeName ; if ( generics . containsKey ( typeName ) ) { rawTypeName = generics . get ( typeName ) ; } else { rawTypeName = declaredTypeGeneric . getOrDefault ( typeName , typeName ) ; } if ( isArray ) { rawTypeName = ' ' + rawTypeName ; } return rawTypeName ; }", "nl": "Resolves raw type name using the generics information from the class or method information ."}}
{"translation": {"code": "public static JarFile jarFileOf ( final Class < ? > klass ) { URL url = klass . getResource ( \"/\" + klass . getName ( ) . replace ( ' ' , ' ' ) + \".class\" ) ; if ( url == null ) { return null ; } String s = url . getFile ( ) ; int beginIndex = s . indexOf ( \"file:\" ) + \"file:\" . length ( ) ; int endIndex = s . indexOf ( \".jar!\" ) ; if ( endIndex == - 1 ) { return null ; } endIndex += \".jar\" . length ( ) ; String f = s . substring ( beginIndex , endIndex ) ; // decode URL string - it may contain encoded chars (e.g. whitespaces) which are not supported for file-instances f = URLDecoder . decode ( f , \"UTF-8\" ) ; File file = new File ( f ) ; try { return file . exists ( ) ? new JarFile ( file ) : null ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Returns the jar file from which the given class is loaded ; or null if no such jar file can be located ."}}
{"translation": {"code": "public static Class < ? > childClassOf ( final Class < ? > parentClass , final Object instance ) { if ( instance == null || instance == Object . class ) { return null ; } if ( parentClass != null ) { if ( parentClass . isInterface ( ) ) { return null ; } } Class < ? > childClass = instance . getClass ( ) ; while ( true ) { Class < ? > parent = childClass . getSuperclass ( ) ; if ( parent == parentClass ) { return childClass ; } if ( parent == null ) { return null ; } childClass = parent ; } }", "nl": "Returns the class of the immediate subclass of the given parent class for the given object instance ; or null if such immediate subclass cannot be uniquely identified for the given object instance ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) public void registerAnnotations ( final Class < ? extends Annotation > [ ] annotations ) { this . annotations = annotations ; this . annotationParsers = new AnnotationParser [ annotations . length ] ; for ( int i = 0 ; i < annotations . length ; i ++ ) { annotationParsers [ i ] = TransactionAnnotationValues . parserFor ( annotations [ i ] ) ; } }", "nl": "Registers new TX annotations ."}}
{"translation": {"code": "public WrapperProxettaFactory setTargetInterface ( final Class targetInterface ) { if ( ! targetInterface . isInterface ( ) ) { throw new ProxettaException ( \"Not an interface: \" + targetInterface . getName ( ) ) ; } this . targetInterface = targetInterface ; return this ; }", "nl": "Defines the interface of the resulting class ."}}
{"translation": {"code": "public String getHtml ( ) { LagartoDomBuilderConfig lagartoDomBuilderConfig ; if ( ownerDocument == null ) { lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; } else { lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; return lagartoHtmlRenderer . toHtml ( this , new StringBuilder ( ) ) ; }", "nl": "Generates HTML ."}}
{"translation": {"code": "public String getTextContent ( ) { StringBuilder sb = new StringBuilder ( getChildNodesCount ( ) + 1 ) ; appendTextContent ( sb ) ; return sb . toString ( ) ; }", "nl": "Returns the text content of this node and its descendants ."}}
{"translation": {"code": "public Node getPreviousSiblingName ( ) { if ( nodeName == null ) { return null ; } initSiblingNames ( ) ; int index = siblingNameIndex - 1 ; for ( int i = siblingIndex ; i >= 0 ; i -- ) { Node sibling = parentNode . childNodes . get ( i ) ; if ( ( index == sibling . siblingNameIndex ) && nodeName . equals ( sibling . getNodeName ( ) ) ) { return sibling ; } } return null ; }", "nl": "Returns this node s previous sibling element with the same name ."}}
{"translation": {"code": "protected void changeOwnerDocument ( final Node node , final Document ownerDocument ) { node . ownerDocument = ownerDocument ; int childCount = node . getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node child = node . getChild ( i ) ; changeOwnerDocument ( child , ownerDocument ) ; } }", "nl": "Changes owner document for given node and all its children ."}}
{"translation": {"code": "protected void initChildNodes ( final Node newNode ) { if ( childNodes == null ) { childNodes = new ArrayList <> ( ) ; } if ( ownerDocument != null ) { if ( newNode . ownerDocument != ownerDocument ) { changeOwnerDocument ( newNode , ownerDocument ) ; } } }", "nl": "Initializes child nodes list when needed . Also fix owner document for new node if needed ."}}
{"translation": {"code": "MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( \"Parameter names not available for method: \" + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }", "nl": "Returns method parameters once when method is parsed . If method has no parameters an empty array is returned ."}}
{"translation": {"code": "public String encrypt ( final String str ) { try { byte [ ] utf8 = StringUtil . getBytes ( str ) ; // encode the string into bytes using utf-8 byte [ ] enc = ecipher . doFinal ( utf8 ) ; // encrypt return Base64 . encodeToString ( enc ) ; // encode bytes to base64 to get a string } catch ( Throwable ignore ) { return null ; } }", "nl": "Symmetrically encrypts the string ."}}
{"translation": {"code": "protected void initSiblingNames ( ) { if ( siblingNameIndex == - 1 ) { List < Node > siblings = parentNode . childNodes ; int index = 0 ; for ( int i = 0 , siblingsSize = siblings . size ( ) ; i < siblingsSize ; i ++ ) { Node sibling = siblings . get ( i ) ; if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { sibling . siblingNameIndex = index ++ ; } } } }", "nl": "Initializes siblings elements of the same name ."}}
{"translation": {"code": "public String getInnerHtml ( ) { LagartoDomBuilderConfig lagartoDomBuilderConfig ; if ( ownerDocument == null ) { lagartoDomBuilderConfig = ( ( Document ) this ) . getConfig ( ) ; } else { lagartoDomBuilderConfig = ownerDocument . getConfig ( ) ; } LagartoHtmlRenderer lagartoHtmlRenderer = lagartoDomBuilderConfig . getLagartoHtmlRenderer ( ) ; return lagartoHtmlRenderer . toInnerHtml ( this , new StringBuilder ( ) ) ; }", "nl": "Generates inner HTML ."}}
{"translation": {"code": "public static MethodParameter [ ] resolveParameters ( final AccessibleObject methodOrCtor ) { Class [ ] paramTypes ; Class declaringClass ; String name ; if ( methodOrCtor instanceof Method ) { Method method = ( Method ) methodOrCtor ; paramTypes = method . getParameterTypes ( ) ; name = method . getName ( ) ; declaringClass = method . getDeclaringClass ( ) ; } else { Constructor constructor = ( Constructor ) methodOrCtor ; paramTypes = constructor . getParameterTypes ( ) ; declaringClass = constructor . getDeclaringClass ( ) ; name = CTOR_METHOD ; } if ( paramTypes . length == 0 ) { return MethodParameter . EMPTY_ARRAY ; } InputStream stream ; try { stream = ClassLoaderUtil . getClassAsStream ( declaringClass ) ; } catch ( IOException ioex ) { throw new ParamoException ( \"Failed to read class bytes: \" + declaringClass . getName ( ) , ioex ) ; } if ( stream == null ) { throw new ParamoException ( \"Class not found: \" + declaringClass ) ; } try { ClassReader reader = new ClassReader ( stream ) ; MethodFinder visitor = new MethodFinder ( declaringClass , name , paramTypes ) ; reader . accept ( visitor , 0 ) ; return visitor . getResolvedParameters ( ) ; } catch ( IOException ioex ) { throw new ParamoException ( ioex ) ; } finally { StreamUtil . close ( stream ) ; } }", "nl": "Resolves method parameters from a method or constructor . Returns an empty array when target does not contain any parameter . No caching is involved in this process i . e . class bytecode is examined every time this method is called ."}}
{"translation": {"code": "protected void initChildElementNodes ( ) { if ( childElementNodes == null ) { childElementNodes = new Element [ childElementNodesCount ] ; int childCount = getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node child = getChild ( i ) ; if ( child . siblingElementIndex >= 0 ) { childElementNodes [ child . siblingElementIndex ] = ( Element ) child ; } } } }", "nl": "Initializes list of child elements ."}}
{"translation": {"code": "public boolean check ( ) { if ( childNodes == null ) { return true ; } // children int siblingElementIndex = 0 ; for ( int i = 0 , childNodesSize = childNodes . size ( ) ; i < childNodesSize ; i ++ ) { Node childNode = childNodes . get ( i ) ; if ( childNode . siblingIndex != i ) { return false ; } if ( childNode . getNodeType ( ) == NodeType . ELEMENT ) { if ( childNode . siblingElementIndex != siblingElementIndex ) { return false ; } siblingElementIndex ++ ; } } if ( childElementNodesCount != siblingElementIndex ) { return false ; } // child element nodes if ( childElementNodes != null ) { if ( childElementNodes . length != childElementNodesCount ) { return false ; } int childCount = getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node child = getChild ( i ) ; if ( child . siblingElementIndex >= 0 ) { if ( childElementNodes [ child . siblingElementIndex ] != child ) { return false ; } } } } // sibling names if ( siblingNameIndex != - 1 ) { List < Node > siblings = parentNode . childNodes ; int index = 0 ; for ( int i = 0 , siblingsSize = siblings . size ( ) ; i < siblingsSize ; i ++ ) { Node sibling = siblings . get ( i ) ; if ( sibling . siblingNameIndex == - 1 && nodeType == NodeType . ELEMENT && nodeName . equals ( sibling . getNodeName ( ) ) ) { if ( sibling . siblingNameIndex != index ++ ) { return false ; } } } } // process children for ( Node childNode : childNodes ) { if ( ! childNode . check ( ) ) { return false ; } } return true ; }", "nl": "Checks the health of child nodes . Useful during complex tree manipulation to check if everything is OK . Not optimized for speed should be used just for testing purposes ."}}
{"translation": {"code": "public static String decode ( final String source , final String encoding ) { return decode ( source , encoding , false ) ; }", "nl": "Decodes URL elements . This method may be used for all parts of URL except for the query parts since it does not decode the + character ."}}
{"translation": {"code": "public String decrypt ( String str ) { try { str = StringUtil . replaceChar ( str , ' ' , ' ' ) ; // replace spaces with chars. byte [ ] dec = Base64 . decode ( str ) ; // decode base64 to get bytes byte [ ] utf8 = dcipher . doFinal ( dec ) ; // decrypt return new String ( utf8 , UTF_8 ) ; // decode using utf-8 } catch ( Throwable ignore ) { return null ; } }", "nl": "Symmetrically decrypts the string ."}}
{"translation": {"code": "public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( \"Can't call getWriter() after getOutputStream()\" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) { // do not close the print writer after rendering // since it will remove reference to bufferedWriter } } ; } return outWriter ; }", "nl": "Returns a writer ."}}
{"translation": {"code": "public static String decodeQuery ( final String source , final String encoding ) { return decode ( source , encoding , true ) ; }", "nl": "Decodes query name or value ."}}
{"translation": {"code": "protected String getActionClassName ( final Object action ) { Class clazz = action . getClass ( ) ; clazz = ProxettaUtil . resolveTargetClass ( clazz ) ; return clazz . getName ( ) ; }", "nl": "Returns correct action class name . Detects Proxetta classes ."}}
{"translation": {"code": "protected void visitChildren ( final NodeVisitor nodeVisitor ) { if ( childNodes != null ) { for ( int i = 0 , childNodesSize = childNodes . size ( ) ; i < childNodesSize ; i ++ ) { Node childNode = childNodes . get ( i ) ; childNode . visit ( nodeVisitor ) ; } } }", "nl": "Visits children nodes ."}}
{"translation": {"code": "public void init ( final long [ ] key , final long [ ] tweak ) { final int newNw = key . length ; // only create new arrays if the value of N{w} changes (different key size) if ( nw != newNw ) { nw = newNw ; switch ( nw ) { case WORDS_4 : pi = PI4 ; rpi = RPI4 ; r = R4 ; break ; case WORDS_8 : pi = PI8 ; rpi = RPI8 ; r = R8 ; break ; case WORDS_16 : pi = PI16 ; rpi = RPI16 ; r = R16 ; break ; default : throw new RuntimeException ( \"Invalid threefish key\" ) ; } this . k = new long [ nw + 1 ] ; // instantiation of these fields here for performance reasons vd = new long [ nw ] ; // v is the intermediate value v{d} at round d ed = new long [ nw ] ; // ed is the value of e{d} at round d fd = new long [ nw ] ; // fd is the value of f{d} at round d ksd = new long [ nw ] ; // ksd is the value of k{s} at round d } System . arraycopy ( key , 0 , this . k , 0 , key . length ) ; long knw = EXTENDED_KEY_SCHEDULE_CONST ; for ( int i = 0 ; i < nw ; i ++ ) { knw ^= this . k [ i ] ; } this . k [ nw ] = knw ; // set tweak values t [ 0 ] = tweak [ 0 ] ; t [ 1 ] = tweak [ 1 ] ; t [ 2 ] = t [ 0 ] ^ t [ 1 ] ; }", "nl": "Initialize the cipher using the key and the tweak value ."}}
{"translation": {"code": "protected String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }", "nl": "Creates alias ."}}
{"translation": {"code": "public static PseudoClass lookupPseudoClass ( final String pseudoClassName ) { PseudoClass pseudoClass = PSEUDO_CLASS_MAP . get ( pseudoClassName ) ; if ( pseudoClass == null ) { throw new CSSellyException ( \"Unsupported pseudo class: \" + pseudoClassName ) ; } return pseudoClass ; }", "nl": "Lookups pseudo class for given pseudo class name ."}}
{"translation": {"code": "public static void registerPseudoClass ( final Class < ? extends PseudoClass > pseudoClassType ) { PseudoClass pseudoClass ; try { pseudoClass = ClassUtil . newInstance ( pseudoClassType ) ; } catch ( Exception ex ) { throw new CSSellyException ( ex ) ; } PSEUDO_CLASS_MAP . put ( pseudoClass . getPseudoClassName ( ) , pseudoClass ) ; }", "nl": "Registers pseudo class ."}}
{"translation": {"code": "public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }", "nl": "Converter JTX transaction mode to DB transaction mode ."}}
{"translation": {"code": "public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Locale stored to session: \" + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }", "nl": "Saves Locale to HTTP session ."}}
{"translation": {"code": "protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }", "nl": "Converts segment of byte array into long array ."}}
{"translation": {"code": "@ Override public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }", "nl": "Encrypts a block ."}}
{"translation": {"code": "public void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }", "nl": "Initializes cipher in a simple way ."}}
{"translation": {"code": "protected Document doParse ( final LagartoParser lagartoParser ) { lagartoParser . setConfig ( config ) ; LagartoDOMBuilderTagVisitor domBuilderTagVisitor = new LagartoDOMBuilderTagVisitor ( this ) ; lagartoParser . parse ( domBuilderTagVisitor ) ; return domBuilderTagVisitor . getDocument ( ) ; }", "nl": "Parses the content using provided lagarto parser ."}}
{"translation": {"code": "public void injectTargetIntoWrapper ( final Object target , final Object wrapper ) { ProxettaUtil . injectTargetIntoWrapper ( target , wrapper , targetFieldName ) ; }", "nl": "Injects target into wrapper ."}}
{"translation": {"code": "@ Override public Document parse ( final char [ ] content ) { LagartoParser lagartoParser = new LagartoParser ( content ) ; return doParse ( lagartoParser ) ; }", "nl": "Creates DOM tree from provided content ."}}
{"translation": {"code": "public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }", "nl": "Returns current locale from session . s"}}
{"translation": {"code": "private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) { // just put in the main key first ksd [ i ] = k [ ( s + i ) % ( nw + 1 ) ] ; // don't add anything for i = 0,...,Nw - 4 if ( i == nw - 3 ) { // second to last ksd [ i ] += t [ s % TWEAK_VALUES ] ; } else if ( i == nw - 2 ) { // first to last ksd [ i ] += t [ ( s + 1 ) % TWEAK_VALUES ] ; } else if ( i == nw - 1 ) { // last ksd [ i ] += s ; } } }", "nl": "Creates the subkeys ."}}
{"translation": {"code": "public static String resolveValidationMessage ( final HttpServletRequest request , final Violation violation ) { ValidationConstraint vc = violation . getConstraint ( ) ; String key = vc != null ? vc . getClass ( ) . getName ( ) : violation . getName ( ) ; String msg = LocalizationUtil . findMessage ( request , key ) ; if ( msg != null ) { return beanTemplateParser . parseWithBean ( msg , violation ) ; } return null ; }", "nl": "Prepares validation messages . Key is either validation constraint class name or violation name ."}}
{"translation": {"code": "private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; // NOTE performance: darn, creation on stack! // right shift x [ 1 ] = ( y [ 1 ] << ( Long . SIZE - rotr ) ) | ( y [ 1 ] >>> rotr ) ; x [ 0 ] = y [ 0 ] - x [ 1 ] ; }", "nl": "Implementation of the un - MIX function ."}}
{"translation": {"code": "private void mix ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ; // java left rotation for a long y [ 1 ] = ( x [ 1 ] << rotl ) | ( x [ 1 ] >>> ( Long . SIZE - rotl ) ) ; y [ 1 ] ^= y [ 0 ] ; }", "nl": "Implementation of the MIX function ."}}
{"translation": {"code": "public boolean next ( ) { if ( ! looping ) { return false ; } if ( last ) { return false ; } if ( count == 0 ) { value = start ; first = true ; } else { value += step ; first = false ; } count ++ ; last = isLastIteration ( value + step ) ; return true ; }", "nl": "Iterates to next value at the beginning of the loop ."}}
{"translation": {"code": "public String getCssPath ( ) { StringBuilder path = new StringBuilder ( ) ; Node node = this ; while ( node != null ) { String nodeName = node . getNodeName ( ) ; if ( nodeName != null ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( ' ' ) . append ( nodeName ) ; String id = node . getAttribute ( \"id\" ) ; if ( id != null ) { sb . append ( ' ' ) . append ( id ) ; } path . insert ( 0 , sb ) ; } node = node . getParentNode ( ) ; } if ( path . charAt ( 0 ) == ' ' ) { return path . substring ( 1 ) ; } return path . toString ( ) ; }", "nl": "Returns CSS path to this node from document root ."}}
{"translation": {"code": "@ Override public void doFilter ( final ServletRequest request , final ServletResponse response , final FilterChain chain ) throws IOException , ServletException { HttpServletRequest httpRequest = ( HttpServletRequest ) request ; HttpServletResponse httpResponse = ( HttpServletResponse ) response ; if ( isRequestedSessionIdFromURL ( httpRequest ) ) { HttpSession session = httpRequest . getSession ( false ) ; if ( session != null ) { session . invalidate ( ) ; // clear session if session id in URL } } // wrap response to remove URL encoding HttpServletResponseWrapper wrappedResponse = new HttpServletResponseWrapper ( httpResponse ) { @ Override public String encodeRedirectUrl ( final String url ) { return url ; } @ Override public String encodeRedirectURL ( final String url ) { return url ; } @ Override public String encodeUrl ( final String url ) { return url ; } @ Override public String encodeURL ( final String url ) { return url ; } } ; chain . doFilter ( request , wrappedResponse ) ; }", "nl": "Filters requests to remove URL - based session identifiers ."}}
{"translation": {"code": "public LagartoDOMBuilder enableXhtmlMode ( ) { config . ignoreWhitespacesBetweenTags = false ; // collect all whitespaces config . setCaseSensitive ( true ) ; // XHTML is case sensitive config . setEnableRawTextModes ( false ) ; // all tags are parsed in the same way config . enabledVoidTags = true ; // list of void tags config . selfCloseVoidTags = true ; // self close void tags config . impliedEndTags = false ; // no implied tag ends config . setEnableConditionalComments ( false ) ; // don't enable IE conditional comments config . setParseXmlTags ( false ) ; // enable XML mode in parsing return this ; }", "nl": "Enables XHTML mode ."}}
{"translation": {"code": "protected boolean validateAction ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }", "nl": "Validates action . Profiles are reset after the invocation ."}}
{"translation": {"code": "public void configureWith ( final ServletContext servletContext ) { webAppClassName = servletContext . getInitParameter ( PARAM_MADVOC_WEBAPP ) ; paramsFiles = Converter . get ( ) . toStringArray ( servletContext . getInitParameter ( PARAM_MADVOC_PARAMS ) ) ; madvocConfiguratorClassName = servletContext . getInitParameter ( PARAM_MADVOC_CONFIGURATOR ) ; }", "nl": "Configures Madvoc by reading context init parameters ."}}
{"translation": {"code": "@ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { //\t\tif ((access & AsmUtil.ACC_FINAL) != 0) { //\t\t\treturn null;\t// skip finals //\t\t} MethodSignatureVisitor msign = createMethodSignature ( access , name , desc , signature , exceptions , thisReference , this . generics ) ; String key = ProxettaAsmUtil . createMethodSignaturesKey ( access , name , desc , thisReference ) ; methodSignatures . put ( key , msign ) ; allMethodSignatures . add ( msign . getCleanSignature ( ) ) ; return new MethodAnnotationReader ( msign ) ; }", "nl": "Stores method signature for target method ."}}
{"translation": {"code": "protected void addViolation ( final String name , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , invalidValue ) ) ; }", "nl": "Adds action violation ."}}
{"translation": {"code": "protected String unescape ( final String value ) { if ( value . indexOf ( ' ' ) == - 1 ) { return value ; } return StringUtil . remove ( value , ' ' ) ; }", "nl": "Unescapes CSS string by removing all backslash characters from it ."}}
{"translation": {"code": "public boolean accept ( final List < Node > currentResults , final Node node , final int index ) { // match attributes int totalSelectors = selectorsCount ( ) ; for ( int i = 0 ; i < totalSelectors ; i ++ ) { Selector selector = getSelector ( i ) ; // just attr name existence switch ( selector . getType ( ) ) { case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( currentResults , node , index ) ) { return false ; } break ; case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( currentResults , node , index ) ) { return false ; } break ; default : } } return true ; }", "nl": "Accepts node within current results ."}}
{"translation": {"code": "public void runJoy ( final Consumer < JoddJoyRuntime > consumer ) { final JoddJoy joddJoy = new JoddJoy ( ) ; final JoddJoyRuntime joyRuntime = joddJoy . startOnlyBackend ( ) ; joddJoy . withDb ( joyDb -> setJtxManager ( joyRuntime . getJtxManager ( ) ) ) ; final JtxTransaction tx = startRwTx ( ) ; final Print print = new Print ( ) ; try { print . line ( \"START\" , 80 ) ; print . newLine ( ) ; consumer . accept ( joyRuntime ) ; print . newLine ( ) ; print . line ( \"END\" , 80 ) ; if ( tx != null ) { tx . commit ( ) ; } } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; if ( tx != null ) { tx . rollback ( ) ; } } joddJoy . stop ( ) ; }", "nl": "Runs JOY in standalone mode with only backend ."}}
{"translation": {"code": "@ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = wd . dest . visitAnnotation ( desc , visible ) ; // [A3] return new AnnotationVisitorAdapter ( destAnn ) ; }", "nl": "Copies all destination type annotations to the target ."}}
{"translation": {"code": "protected void process ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( \"Target missing: \" + targetClassName ) ; } // create class reader final ClassReader classReader ; try { classReader = new ClassReader ( targetInputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( \"Error reading class input stream\" , ioex ) ; } // reads information final TargetClassInfoReader targetClassInfoReader = new TargetClassInfoReader ( proxetta . getClassLoader ( ) ) ; classReader . accept ( targetClassInfoReader , 0 ) ; this . destClassWriter = new ClassWriter ( ClassWriter . COMPUTE_MAXS | ClassWriter . COMPUTE_FRAMES ) ; // create proxy if ( log . isDebugEnabled ( ) ) { log . debug ( \"processing: \" + classReader . getClassName ( ) ) ; } WorkData wd = process ( classReader , targetClassInfoReader ) ; // store important data proxyApplied = wd . proxyApplied ; proxyClassName = wd . thisReference . replace ( ' ' , ' ' ) ; }", "nl": "Reads the target and creates destination class ."}}
{"translation": {"code": "@ Override public void visit ( final int version , int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { wd . init ( name , superName , this . suffix , this . reqProxyClassName ) ; // change access of destination access &= ~ AsmUtil . ACC_ABSTRACT ; // write destination class final int v = ProxettaAsmUtil . resolveJavaVersion ( version ) ; wd . dest . visit ( v , access , wd . thisReference , signature , wd . superName , null ) ; wd . proxyAspects = new ProxyAspectData [ aspects . length ] ; for ( int i = 0 ; i < aspects . length ; i ++ ) { wd . proxyAspects [ i ] = new ProxyAspectData ( wd , aspects [ i ] , i ) ; } }", "nl": "Creates destination subclass header from current target class . Destination name is created from targets by adding a suffix and optionally a number . Destination extends the target ."}}
{"translation": {"code": "public static PseudoFunction < ? > lookupPseudoFunction ( final String pseudoFunctionName ) { PseudoFunction pseudoFunction = PSEUDO_FUNCTION_MAP . get ( pseudoFunctionName ) ; if ( pseudoFunction == null ) { throw new CSSellyException ( \"Unsupported pseudo function: \" + pseudoFunctionName ) ; } return pseudoFunction ; }", "nl": "Lookups pseudo function for given pseudo function name ."}}
{"translation": {"code": "public static void registerPseudoFunction ( final Class < ? extends PseudoFunction > pseudoFunctionType ) { PseudoFunction pseudoFunction ; try { pseudoFunction = ClassUtil . newInstance ( pseudoFunctionType ) ; } catch ( Exception ex ) { throw new CSSellyException ( ex ) ; } PSEUDO_FUNCTION_MAP . put ( pseudoFunction . getPseudoFunctionName ( ) , pseudoFunction ) ; }", "nl": "Registers pseudo function ."}}
{"translation": {"code": "public T setTarget ( final Class target ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( target ) ; if ( targetInputStream == null ) { throw new ProxettaException ( \"Target class not found: \" + target . getName ( ) ) ; } targetClass = target ; targetClassName = target . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( \"Unable to stream class: \" + target . getName ( ) , ioex ) ; } return _this ( ) ; }", "nl": "Defines class as a target ."}}
{"translation": {"code": "public boolean isContaining ( final String include ) { if ( value == null ) { return false ; } if ( splits == null ) { splits = StringUtil . splitc ( value , ' ' ) ; } for ( String s : splits ) { if ( s . equals ( include ) ) { return true ; } } return false ; }", "nl": "Returns true if attribute is containing some value ."}}
{"translation": {"code": "protected boolean matchElement ( final Node node ) { if ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) { return false ; } String element = getElement ( ) ; String nodeName = node . getNodeName ( ) ; return element . equals ( StringPool . STAR ) || element . equals ( nodeName ) ; }", "nl": "Matches element to css selector . All non - element types are ignored ."}}
{"translation": {"code": "@ Override public boolean accept ( final Node node ) { // match element name with node name if ( ! matchElement ( node ) ) { return false ; } // match attributes int totalSelectors = selectorsCount ( ) ; for ( int i = 0 ; i < totalSelectors ; i ++ ) { Selector selector = getSelector ( i ) ; // just attr name existence switch ( selector . getType ( ) ) { case ATTRIBUTE : if ( ! ( ( AttributeSelector ) selector ) . accept ( node ) ) { return false ; } break ; case PSEUDO_CLASS : if ( ! ( ( PseudoClassSelector ) selector ) . accept ( node ) ) { return false ; } break ; case PSEUDO_FUNCTION : if ( ! ( ( PseudoFunctionSelector ) selector ) . accept ( node ) ) { return false ; } break ; } } return true ; }", "nl": "Accepts single node ."}}
{"translation": {"code": "protected TransactionAnnotationValues readTransactionAnnotation ( final Method method ) { for ( AnnotationParser annotationParser : annotationParsers ) { TransactionAnnotationValues tad = TransactionAnnotationValues . of ( annotationParser , method ) ; if ( tad != null ) { return tad ; } } return null ; }", "nl": "Finds TX annotation ."}}
{"translation": {"code": "protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( \"Target class not found: \" + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( \"Unable to get stream class name: \" + targetName , ioex ) ; } return _this ( ) ; }", "nl": "Defines class name as a target . Class will not be loaded by classloader!"}}
{"translation": {"code": "protected T setTarget ( final InputStream target ) { assertTargetIsNotDefined ( ) ; targetInputStream = target ; targetClass = null ; targetClassName = null ; return _this ( ) ; }", "nl": "Defines class input stream as a target ."}}
{"translation": {"code": "public String resolveScope ( final Class type , final String methodName ) { if ( scopePattern == null ) { return null ; } String ctx = scopePattern ; ctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_CLASS , type . getName ( ) ) ; ctx = StringUtil . replace ( ctx , JTXCTX_PATTERN_METHOD , methodName ) ; return ctx ; }", "nl": "Resolves tx scope from scope pattern ."}}
{"translation": {"code": "protected < T extends Node > T cloneTo ( final T dest ) { //\t\tdest.nodeValue = nodeValue;\t\t// already  in clone implementations! dest . parentNode = parentNode ; if ( attributes != null ) { dest . attributes = new ArrayList <> ( attributes . size ( ) ) ; for ( int i = 0 , attributesSize = attributes . size ( ) ; i < attributesSize ; i ++ ) { Attribute attr = attributes . get ( i ) ; dest . attributes . add ( attr . clone ( ) ) ; } } if ( childNodes != null ) { dest . childNodes = new ArrayList <> ( childNodes . size ( ) ) ; for ( int i = 0 , childNodesSize = childNodes . size ( ) ; i < childNodesSize ; i ++ ) { Node child = childNodes . get ( i ) ; Node childClone = child . clone ( ) ; childClone . parentNode = dest ; // fix parent! dest . childNodes . add ( childClone ) ; } } return dest ; }", "nl": "Copies all non - final values to the empty cloned object . Cache - related values are not copied ."}}
{"translation": {"code": "public void detachFromParent ( ) { if ( parentNode == null ) { return ; } if ( parentNode . childNodes != null ) { parentNode . childNodes . remove ( siblingIndex ) ; parentNode . reindexChildren ( ) ; } parentNode = null ; }", "nl": "Removes this node from DOM tree ."}}
{"translation": {"code": "public void addChild ( final Node ... nodes ) { if ( nodes . length == 0 ) { return ; // nothing to add } for ( Node node : nodes ) { node . detachFromParent ( ) ; node . parentNode = this ; initChildNodes ( node ) ; childNodes . add ( node ) ; } reindexChildrenOnAdd ( nodes . length ) ; }", "nl": "Appends several child nodes at once . Reindex is done only once after all children are added ."}}
{"translation": {"code": "public void insertChild ( final Node node , final int index ) { node . detachFromParent ( ) ; node . parentNode = this ; try { initChildNodes ( node ) ; childNodes . add ( index , node ) ; } catch ( IndexOutOfBoundsException ignore ) { throw new LagartoDOMException ( \"Invalid node index: \" + index ) ; } reindexChildren ( ) ; }", "nl": "Inserts node at given index ."}}
{"translation": {"code": "public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( \"Can't call getOutputStream() after getWriter()\" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }", "nl": "Returns a servlet output stream ."}}
{"translation": {"code": "public void removeAllChilds ( ) { List < Node > removedNodes = childNodes ; childNodes = null ; childElementNodes = null ; childElementNodesCount = 0 ; if ( removedNodes != null ) { for ( int i = 0 , removedNodesSize = removedNodes . size ( ) ; i < removedNodesSize ; i ++ ) { Node removedNode = removedNodes . get ( i ) ; removedNode . detachFromParent ( ) ; } } }", "nl": "Removes all child nodes . Each child node will be detached from this parent ."}}
{"translation": {"code": "@ Override public void visitEnd ( ) { // prepare class annotations if ( classAnnotations != null ) { annotations = classAnnotations . toArray ( new AnnotationInfo [ 0 ] ) ; classAnnotations = null ; } List < String > superList = new ArrayList <> ( ) ; Set < String > allInterfaces = new HashSet <> ( ) ; if ( nextInterfaces != null ) { allInterfaces . addAll ( nextInterfaces ) ; } // check all public super methods that are not overridden in superclass while ( nextSupername != null ) { InputStream inputStream = null ; ClassReader cr ; try { inputStream = ClassLoaderUtil . getClassAsStream ( nextSupername , classLoader ) ; cr = new ClassReader ( inputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( \"Unable to inspect super class: \" + nextSupername , ioex ) ; } finally { StreamUtil . close ( inputStream ) ; } superList . add ( nextSupername ) ; superClassReaders . add ( cr ) ; // remember the super class reader cr . accept ( new SuperClassVisitor ( ) , 0 ) ; if ( cr . getInterfaces ( ) != null ) { Collections . addAll ( allInterfaces , cr . getInterfaces ( ) ) ; } } superClasses = superList . toArray ( new String [ 0 ] ) ; // check all interface methods that are not overridden in super-interface Set < String > todoInterfaces = new HashSet <> ( allInterfaces ) ; Set < String > newCollectedInterfaces = new HashSet <> ( ) ; while ( true ) { for ( String next : todoInterfaces ) { InputStream inputStream = null ; ClassReader cr ; try { inputStream = ClassLoaderUtil . getClassAsStream ( next , classLoader ) ; cr = new ClassReader ( inputStream ) ; } catch ( IOException ioex ) { throw new ProxettaException ( \"Unable to inspect super interface: \" + next , ioex ) ; } finally { StreamUtil . close ( inputStream ) ; } superClassReaders . add ( cr ) ; // remember the super class reader cr . accept ( new SuperClassVisitor ( ) , 0 ) ; if ( cr . getInterfaces ( ) != null ) { for ( String newInterface : cr . getInterfaces ( ) ) { if ( ! allInterfaces . contains ( newInterface ) && ! todoInterfaces . contains ( newInterface ) ) { // new interface found newCollectedInterfaces . add ( newInterface ) ; } } } } // perform collection allInterfaces . addAll ( todoInterfaces ) ; if ( newCollectedInterfaces . isEmpty ( ) ) { // no new interface found break ; } todoInterfaces . clear ( ) ; todoInterfaces . addAll ( newCollectedInterfaces ) ; newCollectedInterfaces . clear ( ) ; } }", "nl": "Stores signatures for all super public methods not already overridden by target class . All this methods will be accepted for proxyfication ."}}
{"translation": {"code": "public SetInjectionPoint [ ] resolve ( final Class type , final boolean autowire ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; List < SetInjectionPoint > list = new ArrayList <> ( ) ; PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; for ( PropertyDescriptor propertyDescriptor : allProperties ) { if ( propertyDescriptor . isGetterOnly ( ) ) { continue ; } Class propertyType = propertyDescriptor . getType ( ) ; if ( ! ClassUtil . isTypeOf ( propertyType , Collection . class ) ) { continue ; } MethodDescriptor writeMethodDescriptor = propertyDescriptor . getWriteMethodDescriptor ( ) ; FieldDescriptor fieldDescriptor = propertyDescriptor . getFieldDescriptor ( ) ; PetiteInject ref = null ; if ( writeMethodDescriptor != null ) { ref = writeMethodDescriptor . getMethod ( ) . getAnnotation ( PetiteInject . class ) ; } if ( ref == null && fieldDescriptor != null ) { ref = fieldDescriptor . getField ( ) . getAnnotation ( PetiteInject . class ) ; } if ( ( ! autowire ) && ( ref == null ) ) { continue ; } list . add ( new SetInjectionPoint ( propertyDescriptor ) ) ; } SetInjectionPoint [ ] fields ; if ( list . isEmpty ( ) ) { fields = SetInjectionPoint . EMPTY ; } else { fields = list . toArray ( new SetInjectionPoint [ 0 ] ) ; } return fields ; }", "nl": "Resolves all collections for given type ."}}
{"translation": {"code": "protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( \"Invalid debug folder: \" + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = \"proxetta-\" + System . currentTimeMillis ( ) ; } fileName += \".class\" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( \"Error writing class as \" + file , ioex ) ; } }", "nl": "Writes created class content to output folder for debugging purposes ."}}
{"translation": {"code": "public void insertAfter ( final Node [ ] newChilds , final Node refChild ) { if ( newChilds . length == 0 ) { return ; } int siblingIndex = refChild . getSiblingIndex ( ) + 1 ; if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { refChild . parentNode . addChild ( newChilds ) ; } else { refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; } }", "nl": "Inserts several child nodes after referent node ."}}
{"translation": {"code": "public void insertAfter ( final Node newChild , final Node refChild ) { int siblingIndex = refChild . getSiblingIndex ( ) + 1 ; if ( siblingIndex == refChild . parentNode . getChildNodesCount ( ) ) { refChild . parentNode . addChild ( newChild ) ; } else { refChild . parentNode . insertChild ( newChild , siblingIndex ) ; } }", "nl": "Inserts node after provided node ."}}
{"translation": {"code": "public void insertBefore ( final Node [ ] newChilds , final Node refChild ) { if ( newChilds . length == 0 ) { return ; } int siblingIndex = refChild . getSiblingIndex ( ) ; refChild . parentNode . insertChild ( newChilds , siblingIndex ) ; }", "nl": "Inserts several child nodes before provided node ."}}
{"translation": {"code": "public synchronized JtxTransactionMode getTxMode ( final Class type , final String methodName , final Class [ ] methodArgTypes , final String unique ) { String signature = type . getName ( ) + ' ' + methodName + ' ' + unique ; JtxTransactionMode txMode = txmap . get ( signature ) ; if ( txMode == null ) { if ( ! txmap . containsKey ( signature ) ) { final Method m ; try { m = type . getMethod ( methodName , methodArgTypes ) ; } catch ( NoSuchMethodException nsmex ) { throw new ProxettaException ( nsmex ) ; } final TransactionAnnotationValues txAnn = readTransactionAnnotation ( m ) ; if ( txAnn != null ) { txMode = new JtxTransactionMode ( txAnn . propagation ( ) , txAnn . isolation ( ) , txAnn . readOnly ( ) , txAnn . timeout ( ) ) ; } else { txMode = defaultTransactionMode ; } txmap . put ( signature , txMode ) ; } } return txMode ; }", "nl": "Reads transaction mode from method annotation . Annotations are cached for better performances ."}}
{"translation": {"code": "protected MethodSignatureVisitor createMethodSignature ( final int access , final String methodName , final String description , final String signature , final String [ ] exceptions , final String classname , final Map < String , String > declaredTypeGenerics ) { MethodSignatureVisitor v = new MethodSignatureVisitor ( methodName , access , classname , description , exceptions , signature , declaredTypeGenerics , this ) ; new SignatureReader ( signature != null ? signature : description ) . accept ( v ) ; return v ; }", "nl": "Creates method signature from method name ."}}
{"translation": {"code": "public Class define ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( \"Proxy created: \" + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( \"Class definition failed\" , ex ) ; } }", "nl": "Defines class ."}}
{"translation": {"code": "protected void processSuperMethods ( ) { for ( ClassReader cr : targetClassInfo . superClassReaders ) { cr . accept ( new EmptyClassVisitor ( ) { String declaredClassName ; @ Override public void visit ( final int version , final int access , final String name , final String signature , final String superName , final String [ ] interfaces ) { declaredClassName = name ; } @ Override public MethodVisitor visitMethod ( final int access , final String name , final String desc , final String signature , final String [ ] exceptions ) { if ( name . equals ( INIT ) || name . equals ( CLINIT ) ) { return null ; } MethodSignatureVisitor msign = targetClassInfo . lookupMethodSignatureVisitor ( access , name , desc , declaredClassName ) ; if ( msign == null ) { return null ; } return applyProxy ( msign ) ; } } , 0 ) ; } }", "nl": "Checks for all public super methods that are not overridden ."}}
{"translation": {"code": "protected void makeProxyConstructor ( ) { MethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PRIVATE | AsmUtil . ACC_FINAL , ProxettaNames . initMethodName , DESC_VOID , null , null ) ; mv . visitCode ( ) ; if ( wd . adviceInits != null ) { for ( String name : wd . adviceInits ) { mv . visitVarInsn ( ALOAD , 0 ) ; mv . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , name , DESC_VOID , false ) ; } } mv . visitInsn ( RETURN ) ; mv . visitMaxs ( 0 , 0 ) ; mv . visitEnd ( ) ; }", "nl": "Creates init method that simply calls all advice constructor methods in correct order . This created init method is called from each destination s constructor ."}}
{"translation": {"code": "protected void makeStaticInitBlock ( ) { if ( wd . adviceClinits != null ) { MethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_STATIC , CLINIT , DESC_VOID , null , null ) ; mv . visitCode ( ) ; for ( String name : wd . adviceClinits ) { mv . visitMethodInsn ( INVOKESTATIC , wd . thisReference , name , DESC_VOID , false ) ; } mv . visitInsn ( RETURN ) ; mv . visitMaxs ( 0 , 0 ) ; mv . visitEnd ( ) ; } }", "nl": "Creates static initialization block that simply calls all advice static init methods in correct order ."}}
{"translation": {"code": "protected void createEmptyCtor ( ) { final MethodVisitor mv = wd . dest . visitMethod ( AsmUtil . ACC_PUBLIC , INIT , \"()V\" , null , null ) ; mv . visitCode ( ) ; mv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; mv . visitMethodInsn ( Opcodes . INVOKESPECIAL , AsmUtil . SIGNATURE_JAVA_LANG_OBJECT , INIT , \"()V\" , false ) ; mv . visitInsn ( Opcodes . RETURN ) ; mv . visitMaxs ( 1 , 1 ) ; mv . visitEnd ( ) ; }", "nl": "Created empty default constructor ."}}
{"translation": {"code": "protected void createSimpleMethodWrapper ( final MethodSignatureVisitor msign ) { int access = msign . getAccessFlags ( ) ; access &= ~ ACC_ABSTRACT ; access &= ~ ACC_NATIVE ; MethodVisitor mv = wd . dest . visitMethod ( access , msign . getMethodName ( ) , msign . getDescription ( ) , msign . getAsmMethodSignature ( ) , msign . getExceptions ( ) ) ; mv . visitCode ( ) ; mv . visitVarInsn ( ALOAD , 0 ) ; mv . visitFieldInsn ( GETFIELD , wd . thisReference , wd . wrapperRef , wd . wrapperType ) ; loadVirtualMethodArguments ( mv , msign ) ; if ( wd . wrapInterface ) { mv . visitMethodInsn ( INVOKEINTERFACE , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , true ) ; } else { mv . visitMethodInsn ( INVOKEVIRTUAL , wd . wrapperType . substring ( 1 , wd . wrapperType . length ( ) - 1 ) , msign . getMethodName ( ) , msign . getDescription ( ) , false ) ; } ProxettaAsmUtil . prepareReturnValue ( mv , msign , 0 ) ; visitReturn ( mv , msign , true ) ; mv . visitMaxs ( 0 , 0 ) ; mv . visitEnd ( ) ; }", "nl": "Creates simple method wrapper without proxy ."}}
{"translation": {"code": "public byte [ ] create ( ) { process ( ) ; byte [ ] result = toByteArray ( ) ; dumpClassInDebugFolder ( result ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Proxy not applied: \" + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( \"Proxy created \" + StringUtil . toSafeString ( targetClassName ) ) ; } return result ; }", "nl": "Returns byte array of created class ."}}
{"translation": {"code": "public void insertBefore ( final Node newChild , final Node refChild ) { int siblingIndex = refChild . getSiblingIndex ( ) ; refChild . parentNode . insertChild ( newChild , siblingIndex ) ; }", "nl": "Inserts node before provided node ."}}
{"translation": {"code": "public Object newInstance ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( \"Invalid Proxetta class\" , ex ) ; } }", "nl": "Creates new instance of created class . Assumes default no - arg constructor ."}}
{"translation": {"code": "public String getPseudoFunctionName ( ) { String name = getClass ( ) . getSimpleName ( ) . toLowerCase ( ) ; name = name . replace ( ' ' , ' ' ) ; return name ; }", "nl": "Returns pseudo - function name ."}}
{"translation": {"code": "@ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int p = 0 ; p < tmd . proxyData . length ; p ++ ) { tmd . selectCurrentProxy ( p ) ; createProxyMethod ( tmd ) ; } }", "nl": "Finally builds proxy methods if applied to current method ."}}
{"translation": {"code": "protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , false ) ; } visitReturn ( methodVisitor , tmd . msign , false ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }", "nl": "Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method ."}}
{"translation": {"code": "public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( \"Provider method not found: \" + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }", "nl": "Registers static method provider ."}}
{"translation": {"code": "public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }", "nl": "Iterates all beans that are of given type ."}}
{"translation": {"code": "public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }", "nl": "Defines many parameters at once ."}}
{"translation": {"code": "public static String typeToTyperef ( final Class type ) { if ( ! type . isArray ( ) ) { if ( ! type . isPrimitive ( ) ) { return ' ' + typeToSignature ( type ) + ' ' ; } if ( type == int . class ) { return \"I\" ; } if ( type == long . class ) { return \"J\" ; } if ( type == boolean . class ) { return \"Z\" ; } if ( type == double . class ) { return \"D\" ; } if ( type == float . class ) { return \"F\" ; } if ( type == short . class ) { return \"S\" ; } if ( type == void . class ) { return \"V\" ; } if ( type == byte . class ) { return \"B\" ; } if ( type == char . class ) { return \"C\" ; } } return type . getName ( ) ; }", "nl": "Converts type to byteccode type ref ."}}
{"translation": {"code": "public static String typedescToSignature ( final String desc , final MutableInteger from ) { int fromIndex = from . get ( ) ; from . value ++ ; // default usage for most cases switch ( desc . charAt ( fromIndex ) ) { case ' ' : return \"byte\" ; case ' ' : return \"char\" ; case ' ' : return \"double\" ; case ' ' : return \"float\" ; case ' ' : return \"int\" ; case ' ' : return \"long\" ; case ' ' : return \"short\" ; case ' ' : return \"boolean\" ; case ' ' : return \"void\" ; case ' ' : int index = desc . indexOf ( ' ' , fromIndex ) ; if ( index < 0 ) { throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; } from . set ( index + 1 ) ; String str = desc . substring ( fromIndex + 1 , index ) ; return str . replace ( ' ' , ' ' ) ; case ' ' : return desc . substring ( from . value ) ; case ' ' : StringBuilder brackets = new StringBuilder ( ) ; int n = fromIndex ; while ( desc . charAt ( n ) == ' ' ) { // count opening brackets brackets . append ( \"[]\" ) ; n ++ ; } from . value = n ; String type = typedescToSignature ( desc , from ) ; // the rest of the string denotes a `<field_type>' return type + brackets ; default : if ( from . value == 0 ) { throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; } // generics! return desc . substring ( from . value ) ; } }", "nl": "Returns java - like signature of a bytecode - like description . Only first description is parsed ."}}
{"translation": {"code": "public static String typeref2Name ( final String desc ) { if ( desc . charAt ( 0 ) != TYPE_REFERENCE ) { throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; } String name = desc . substring ( 1 , desc . length ( ) - 1 ) ; return name . replace ( ' ' , ' ' ) ; }", "nl": "Converts type reference to java - name ."}}
{"translation": {"code": "public static String typedesc2ClassName ( final String desc ) { String className = desc ; switch ( desc . charAt ( 0 ) ) { case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : if ( desc . length ( ) != 1 ) { throw new IllegalArgumentException ( INVALID_BASE_TYPE + desc ) ; } break ; case ' ' : className = className . substring ( 1 , className . length ( ) - 1 ) ; break ; case ' ' : // uses less-known feature of class loaders for loading array types // using bytecode-like signatures. className = className . replace ( ' ' , ' ' ) ; break ; default : throw new IllegalArgumentException ( INVALID_TYPE_DESCRIPTION + desc ) ; } return className ; }", "nl": "Converts bytecode - like description to java class name that can be loaded with a classloader . Uses less - known feature of class loaders for loading array classes ."}}
{"translation": {"code": "protected void put ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ; // update position pointers if ( first == null ) { first = propsEntry ; } else { last . next = propsEntry ; } last = propsEntry ; // add to the map map . put ( key , propsEntry ) ; }", "nl": "Puts key - value pair into the map with respect of appending duplicate properties"}}
{"translation": {"code": "public byte [ ] encrypt ( final byte [ ] content ) { FastByteBuffer fbb = new FastByteBuffer ( ) ; int length = content . length + 1 ; int blockCount = length / blockSizeInBytes ; int remaining = length ; int offset = 0 ; for ( int i = 0 ; i < blockCount ; i ++ ) { if ( remaining == blockSizeInBytes ) { break ; } byte [ ] encrypted = encryptBlock ( content , offset ) ; fbb . append ( encrypted ) ; offset += blockSizeInBytes ; remaining -= blockSizeInBytes ; } if ( remaining != 0 ) { // process remaining bytes byte [ ] block = new byte [ blockSizeInBytes ] ; System . arraycopy ( content , offset , block , 0 , remaining - 1 ) ; block [ remaining - 1 ] = TERMINATOR ; byte [ ] encrypted = encryptBlock ( block , 0 ) ; fbb . append ( encrypted ) ; } return fbb . toArray ( ) ; }", "nl": "Encrypts complete content block by block ."}}
{"translation": {"code": "public byte [ ] decrypt ( final byte [ ] encryptedContent ) { FastByteBuffer fbb = new FastByteBuffer ( ) ; int length = encryptedContent . length ; int blockCount = length / blockSizeInBytes ; int offset = 0 ; for ( int i = 0 ; i < blockCount - 1 ; i ++ ) { byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; fbb . append ( decrypted ) ; offset += blockSizeInBytes ; } // process last block byte [ ] decrypted = decryptBlock ( encryptedContent , offset ) ; // find terminator int ndx = blockSizeInBytes - 1 ; while ( ndx >= 0 ) { if ( decrypted [ ndx ] == TERMINATOR ) { break ; } ndx -- ; } fbb . append ( decrypted , 0 , ndx ) ; return fbb . toArray ( ) ; }", "nl": "Decrypts the whole content block by block ."}}
{"translation": {"code": "protected void justAdd ( final String key , final String value , final ArrayList < String > keyProfiles , final Operator operator ) { if ( operator == Operator . COPY ) { HashMap < String , Object > target = new HashMap <> ( ) ; String [ ] profiles = null ; if ( keyProfiles != null ) { profiles = keyProfiles . toArray ( new String [ 0 ] ) ; } String [ ] sources = StringUtil . splitc ( value , ' ' ) ; for ( String source : sources ) { source = source . trim ( ) ; // try to extract profile for parsing String [ ] lookupProfiles = profiles ; String lookupProfilesString = null ; int leftIndex = source . indexOf ( ' ' ) ; if ( leftIndex != - 1 ) { int rightIndex = source . indexOf ( ' ' ) ; lookupProfilesString = source . substring ( leftIndex + 1 , rightIndex ) ; source = source . substring ( 0 , leftIndex ) . concat ( source . substring ( rightIndex + 1 ) ) ; lookupProfiles = StringUtil . splitc ( lookupProfilesString , ' ' ) ; StringUtil . trimAll ( lookupProfiles ) ; } String [ ] wildcards = new String [ ] { source + \".*\" } ; propsData . extract ( target , lookupProfiles , wildcards , null ) ; for ( Map . Entry < String , Object > entry : target . entrySet ( ) ) { String entryKey = entry . getKey ( ) ; String suffix = entryKey . substring ( source . length ( ) ) ; String newKey = key + suffix ; String newValue = \"${\" + entryKey ; if ( lookupProfilesString != null ) { newValue += \"<\" + lookupProfilesString + \">\" ; } newValue += \"}\" ; if ( profiles == null ) { propsData . putBaseProperty ( newKey , newValue , false ) ; } else { for ( final String p : profiles ) { propsData . putProfileProperty ( newKey , newValue , p , false ) ; } } } } return ; } boolean append = operator == Operator . QUICK_APPEND ; if ( keyProfiles == null ) { propsData . putBaseProperty ( key , value , append ) ; return ; } for ( final String p : keyProfiles ) { propsData . putProfileProperty ( key , value , p , append ) ; } }", "nl": "Core key - value addition ."}}
{"translation": {"code": "protected void extractProfilesAndAdd ( final String key , final String value , final Operator operator ) { String fullKey = key ; int ndx = fullKey . indexOf ( PROFILE_LEFT ) ; if ( ndx == - 1 ) { justAdd ( fullKey , value , null , operator ) ; return ; } // extract profiles ArrayList < String > keyProfiles = new ArrayList <> ( ) ; while ( true ) { ndx = fullKey . indexOf ( PROFILE_LEFT ) ; if ( ndx == - 1 ) { break ; } final int len = fullKey . length ( ) ; int ndx2 = fullKey . indexOf ( PROFILE_RIGHT , ndx + 1 ) ; if ( ndx2 == - 1 ) { ndx2 = len ; } // remember profile final String profile = fullKey . substring ( ndx + 1 , ndx2 ) ; keyProfiles . add ( profile ) ; // extract profile from key ndx2 ++ ; final String right = ( ndx2 == len ) ? StringPool . EMPTY : fullKey . substring ( ndx2 ) ; fullKey = fullKey . substring ( 0 , ndx ) + right ; } if ( fullKey . startsWith ( StringPool . DOT ) ) { // check for special case when only profile is defined in section fullKey = fullKey . substring ( 1 ) ; } // add value to extracted profiles justAdd ( fullKey , value , keyProfiles , operator ) ; }", "nl": "Extracts profiles from the key name and adds key - value to them ."}}
{"translation": {"code": "protected void add ( final String section , final String key , final StringBuilder value , final boolean trim , final Operator operator ) { // ignore lines without : or = if ( key == null ) { return ; } String fullKey = key ; if ( section != null ) { if ( fullKey . length ( ) != 0 ) { fullKey = section + ' ' + fullKey ; } else { fullKey = section ; } } String v = value . toString ( ) ; if ( trim ) { if ( valueTrimLeft && valueTrimRight ) { v = v . trim ( ) ; } else if ( valueTrimLeft ) { v = StringUtil . trimLeft ( v ) ; } else { v = StringUtil . trimRight ( v ) ; } } if ( v . length ( ) == 0 && skipEmptyProps ) { return ; } extractProfilesAndAdd ( fullKey , v , operator ) ; }", "nl": "Adds accumulated value to key and current section ."}}
{"translation": {"code": "public void putBaseProperty ( final String key , final String value , final boolean append ) { put ( null , baseProperties , key , value , append ) ; }", "nl": "Adds base property ."}}
{"translation": {"code": "public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }", "nl": "Adds profile property ."}}
{"translation": {"code": "public PropsEntry getProfileProperty ( final String profile , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( profile ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }", "nl": "Returns profile property ."}}
{"translation": {"code": "public String resolveMacros ( String value , final String ... profiles ) { // create string template parser that will be used internally StringTemplateParser stringTemplateParser = new StringTemplateParser ( ) ; stringTemplateParser . setResolveEscapes ( false ) ; if ( ! ignoreMissingMacros ) { stringTemplateParser . setReplaceMissingKey ( false ) ; } else { stringTemplateParser . setReplaceMissingKey ( true ) ; stringTemplateParser . setMissingKeyReplacement ( StringPool . EMPTY ) ; } final Function < String , String > macroResolver = macroName -> { String [ ] lookupProfiles = profiles ; int leftIndex = macroName . indexOf ( ' ' ) ; if ( leftIndex != - 1 ) { int rightIndex = macroName . indexOf ( ' ' ) ; String profiles1 = macroName . substring ( leftIndex + 1 , rightIndex ) ; macroName = macroName . substring ( 0 , leftIndex ) . concat ( macroName . substring ( rightIndex + 1 ) ) ; lookupProfiles = StringUtil . splitc ( profiles1 , ' ' ) ; StringUtil . trimAll ( lookupProfiles ) ; } return lookupValue ( macroName , lookupProfiles ) ; } ; // start parsing int loopCount = 0 ; while ( loopCount ++ < MAX_INNER_MACROS ) { final String newValue = stringTemplateParser . parse ( value , macroResolver ) ; if ( newValue . equals ( value ) ) { break ; } if ( skipEmptyProps ) { if ( newValue . length ( ) == 0 ) { return null ; } } value = newValue ; } return value ; }", "nl": "Resolves all macros in this props set . Called on property lookup ."}}
{"translation": {"code": "public Map extract ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; } // make sure prefix ends with a dot if ( prefix != null ) { if ( ! StringUtil . endsWithChar ( prefix , ' ' ) ) { prefix += StringPool . DOT ; } } if ( profiles != null ) { for ( String profile : profiles ) { while ( true ) { final Map < String , PropsEntry > map = this . profileProperties . get ( profile ) ; if ( map != null ) { extractMap ( target , map , profiles , wildcardPatterns , prefix ) ; } final int ndx = profile . lastIndexOf ( ' ' ) ; if ( ndx == - 1 ) { break ; } profile = profile . substring ( 0 , ndx ) ; } } } extractMap ( target , this . baseProperties , profiles , wildcardPatterns , prefix ) ; return target ; }", "nl": "Extracts props to target map . This is all - in - one method that does many things at once ."}}
{"translation": {"code": "private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }", "nl": "Cycically extract a word of key material ."}}
{"translation": {"code": "protected int findInsertionPoint ( final E o , int low , int high ) { while ( low <= high ) { int mid = ( low + high ) >>> 1 ; int delta = compare ( get ( mid ) , o ) ; if ( delta > 0 ) { high = mid - 1 ; } else { low = mid + 1 ; } } return low ; }", "nl": "Conducts a binary search to find the index where Object should be inserted ."}}
{"translation": {"code": "@ Override public boolean addAll ( final Collection < ? extends E > c ) { Iterator < ? extends E > i = c . iterator ( ) ; boolean changed = false ; while ( i . hasNext ( ) ) { boolean ret = add ( i . next ( ) ) ; if ( ! changed ) { changed = ret ; } } return changed ; }", "nl": "Add all of the elements in the given collection to this list ."}}
{"translation": {"code": "public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( \"Invalid salt version\" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( \"Invalid salt revision\" ) ; } off = 4 ; } // Extract number of rounds if ( salt . charAt ( off + 2 ) > ' ' ) { throw new IllegalArgumentException ( \"Missing salt rounds\" ) ; } rounds = Integer . parseInt ( salt . substring ( off , off + 2 ) ) ; real_salt = salt . substring ( off + 3 , off + 25 ) ; try { passwordb = ( password + ( minor >= ' ' ? \"\\000\" : \"\" ) ) . getBytes ( \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { throw new AssertionError ( \"UTF-8 is not supported\" ) ; } saltb = decode_base64 ( real_salt , BCRYPT_SALT_LEN ) ; B = new BCrypt ( ) ; hashed = B . crypt_raw ( passwordb , saltb , rounds , ( int [ ] ) bf_crypt_ciphertext . clone ( ) ) ; rs . append ( \"$2\" ) ; if ( minor >= ' ' ) { rs . append ( minor ) ; } rs . append ( ' ' ) ; if ( rounds < 10 ) { rs . append ( ' ' ) ; } if ( rounds > 30 ) { throw new IllegalArgumentException ( \"rounds exceeds maximum (30)\" ) ; } rs . append ( rounds ) . append ( ' ' ) . append ( encode_base64 ( saltb , saltb . length ) ) . append ( encode_base64 ( hashed , bf_crypt_ciphertext . length * 4 - 1 ) ) ; return rs . toString ( ) ; }", "nl": "Hash a password using the OpenBSD bcrypt scheme ."}}
{"translation": {"code": "public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( \"UTF-8\" ) ; try_bytes = try_pw . getBytes ( \"UTF-8\" ) ; } catch ( UnsupportedEncodingException uee ) { return false ; } if ( hashed_bytes . length != try_bytes . length ) { return false ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }", "nl": "Check that a plaintext password matches a previously hashed one ."}}
{"translation": {"code": "public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( \"Bean not found: \" + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( \"Provider method not found: \" + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }", "nl": "Registers instance method provider ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }", "nl": "Applies proxetta on bean class before bean registration ."}}
{"translation": {"code": "public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( \"Destroy method not found: \" + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }", "nl": "Registers destroy method ."}}
{"translation": {"code": "public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + \" suitable methods found as injection points for: \" + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( \"Method not found: \" + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }", "nl": "Registers method injection point ."}}
{"translation": {"code": "public static String encode ( final byte [ ] bytes ) { StringBuilder base32 = new StringBuilder ( ( bytes . length * 8 + 4 ) / 5 ) ; int currByte , digit , i = 0 ; while ( i < bytes . length ) { // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes [ i ++ ] & 255 ; base32 . append ( CHARS [ currByte >> 3 ] ) ; digit = ( currByte & 7 ) << 2 ; if ( i >= bytes . length ) { base32 . append ( CHARS [ digit ] ) ; break ; } // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes [ i ++ ] & 255 ; base32 . append ( CHARS [ digit | ( currByte >> 6 ) ] ) ; base32 . append ( CHARS [ ( currByte >> 1 ) & 31 ] ) ; digit = ( currByte & 1 ) << 4 ; if ( i >= bytes . length ) { base32 . append ( CHARS [ digit ] ) ; break ; } // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes [ i ++ ] & 255 ; base32 . append ( CHARS [ digit | ( currByte >> 4 ) ] ) ; digit = ( currByte & 15 ) << 1 ; if ( i >= bytes . length ) { base32 . append ( CHARS [ digit ] ) ; break ; } // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes [ i ++ ] & 255 ; base32 . append ( CHARS [ digit | ( currByte >> 7 ) ] ) ; base32 . append ( CHARS [ ( currByte >> 2 ) & 31 ] ) ; digit = ( currByte & 3 ) << 3 ; if ( i >= bytes . length ) { base32 . append ( CHARS [ digit ] ) ; break ; } // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes [ i ++ ] & 255 ; base32 . append ( CHARS [ digit | ( currByte >> 5 ) ] ) ; base32 . append ( CHARS [ currByte & 31 ] ) ; } return base32 . toString ( ) ; }", "nl": "Encode an array of binary bytes into a Base32 string ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ; // try: setter if ( setter != null ) { invokeSetter ( setter , bp , value ) ; return ; } // try: put(\"property\", value) if ( bp . isMap ( ) ) { ( ( Map ) bp . bean ) . put ( bp . name , value ) ; return ; } if ( isSilent ) { return ; } throw new BeanException ( \"Simple property not found: \" + bp . name , bp ) ; }", "nl": "Sets a value of simple property ."}}
{"translation": {"code": "@ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }", "nl": "Returns value of bean s property ."}}
{"translation": {"code": "@ Override public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }", "nl": "Extract the first name of this reference ."}}
{"translation": {"code": "public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }", "nl": "Converts property name to column name ."}}
{"translation": {"code": "public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = false ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = true ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = false ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }", "nl": "Converts column name to property name ."}}
{"translation": {"code": "public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }", "nl": "Applies column naming strategy to given column name hint . Returns full column name ."}}
{"translation": {"code": "public void start ( final int startIndex ) { this . tagStartIndex = startIndex ; this . name = null ; this . idNdx = - 1 ; this . attributesCount = 0 ; this . tagLength = 0 ; this . modified = false ; this . type = TagType . START ; this . rawTag = false ; }", "nl": "Starts the tag with the index of first < . Resets all tag data ."}}
{"translation": {"code": "public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }", "nl": "Starts with the scanner ."}}
{"translation": {"code": "public static < T > BinarySearch < T > forArray ( final T [ ] array , final Comparator < T > comparator ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" } ) protected int compare ( final int index , final T element ) { return comparator . compare ( array [ index ] , element ) ; } @ Override protected int getLastIndex ( ) { return array . length - 1 ; } } ; }", "nl": "Creates binary search wrapper over an array with given comparator ."}}
{"translation": {"code": "private char fixAccent ( final char c ) { for ( int i = 0 ; i < ACCENT_CHARS . length ; i += 2 ) { final char accentChar = ACCENT_CHARS [ i ] ; if ( accentChar == c ) { return ACCENT_CHARS [ i + 1 ] ; } } return c ; }", "nl": "Fixes accent char ."}}
{"translation": {"code": "public static < T extends Comparable > BinarySearch < T > forArray ( final T [ ] array ) { return new BinarySearch < T > ( ) { @ Override @ SuppressWarnings ( { \"unchecked\" } ) protected int compare ( final int index , final T element ) { return array [ index ] . compareTo ( element ) ; } @ Override protected int getLastIndex ( ) { return array . length - 1 ; } } ; }", "nl": "Creates binary search wrapper over an array ."}}
{"translation": {"code": "public ProviderDefinition [ ] resolveProviderDefinitions ( final Class type , final String name ) { return providerResolver . resolve ( type , name ) ; }", "nl": "Resolves provider definition defined in a bean ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Invalid Petite scope: \" + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }", "nl": "Resolves and registers scope from a scope type ."}}
{"translation": {"code": "public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; } // remove existing bean BeanDefinition existing = removeBean ( name ) ; if ( existing != null ) { if ( petiteConfig . getDetectDuplicatedBeanNames ( ) ) { throw new PetiteException ( \"Duplicated bean name detected while registering class '\" + type . getName ( ) + \"'. Petite bean class '\" + existing . type . getName ( ) + \"' is already registered with the name: \" + name ) ; } } // check if type is valid if ( type . isInterface ( ) ) { throw new PetiteException ( \"PetiteBean can not be an interface: \" + type . getName ( ) ) ; } // registration if ( log . isDebugEnabled ( ) ) { log . info ( \"Petite bean: [\" + name + \"] --> \" + type . getName ( ) + \" @ \" + scopeType . getSimpleName ( ) + \":\" + wiringMode . toString ( ) ) ; } // register Scope scope = resolveScope ( scopeType ) ; BeanDefinition < T > beanDefinition = createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; registerBean ( name , beanDefinition ) ; // providers ProviderDefinition [ ] providerDefinitions = petiteResolvers . resolveProviderDefinitions ( type , name ) ; if ( providerDefinitions != null ) { for ( ProviderDefinition providerDefinition : providerDefinitions ) { providers . put ( providerDefinition . name , providerDefinition ) ; } } // define if ( define ) { beanDefinition . ctor = petiteResolvers . resolveCtorInjectionPoint ( beanDefinition . type ( ) ) ; beanDefinition . properties = PropertyInjectionPoint . EMPTY ; beanDefinition . methods = MethodInjectionPoint . EMPTY ; beanDefinition . initMethods = InitMethodPoint . EMPTY ; beanDefinition . destroyMethods = DestroyMethodPoint . EMPTY ; } // return return beanDefinition ; }", "nl": "Registers or defines a bean ."}}
{"translation": {"code": "public Class defineProxy ( final Class target ) { ProxyProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( target ) ; return builder . define ( ) ; }", "nl": "Generates new class ."}}
{"translation": {"code": "protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ; // store null as value to mark that alt name is duplicate } } else { beansAlt . put ( altName , beanDefinition ) ; } } }", "nl": "Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered ."}}
{"translation": {"code": "public void removeBean ( final Class type ) { // collect bean names Set < String > beanNames = new HashSet <> ( ) ; for ( BeanDefinition def : beans . values ( ) ) { if ( def . type . equals ( type ) ) { beanNames . add ( def . name ) ; } } // remove collected bean names for ( String beanName : beanNames ) { removeBean ( beanName ) ; } }", "nl": "Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed ."}}
{"translation": {"code": "protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }", "nl": "Resolves bean names for give type ."}}
{"translation": {"code": "public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + \" suitable constructor found as injection point for: \" + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( \"Constructor not found: \" + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }", "nl": "Registers constructor injection point ."}}
{"translation": {"code": "public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }", "nl": "Registers property injection point ."}}
{"translation": {"code": "public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( \"Property not found: \" + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }", "nl": "Registers set injection point ."}}
{"translation": {"code": "protected int [ ] compareDigits ( final String str1 , int ndx1 , final String str2 , int ndx2 ) { // iterate all digits in the first string int zeroCount1 = 0 ; while ( charAt ( str1 , ndx1 ) == ' ' ) { zeroCount1 ++ ; ndx1 ++ ; } int len1 = 0 ; while ( true ) { final char char1 = charAt ( str1 , ndx1 ) ; final boolean isDigitChar1 = CharUtil . isDigit ( char1 ) ; if ( ! isDigitChar1 ) { break ; } len1 ++ ; ndx1 ++ ; } // iterate all digits in the second string and compare with the first int zeroCount2 = 0 ; while ( charAt ( str2 , ndx2 ) == ' ' ) { zeroCount2 ++ ; ndx2 ++ ; } int len2 = 0 ; int ndx1_new = ndx1 - len1 ; int equalNumbers = 0 ; while ( true ) { final char char2 = charAt ( str2 , ndx2 ) ; final boolean isDigitChar2 = CharUtil . isDigit ( char2 ) ; if ( ! isDigitChar2 ) { break ; } if ( equalNumbers == 0 && ( ndx1_new < ndx1 ) ) { equalNumbers = charAt ( str1 , ndx1_new ++ ) - char2 ; } len2 ++ ; ndx2 ++ ; } // compare if ( len1 != len2 ) { // numbers are not equals size return new int [ ] { len1 - len2 } ; } if ( equalNumbers != 0 ) { return new int [ ] { equalNumbers } ; } // numbers are equal, but number of zeros is different return new int [ ] { 0 , zeroCount1 - zeroCount2 , ndx1 , ndx2 } ; }", "nl": "Compare digits at certain position in two strings . The longest run of digits wins . That aside the greatest value wins ."}}
{"translation": {"code": "public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( \"Init method not found: \" + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }", "nl": "Registers init method ."}}
{"translation": {"code": "public String [ ] getProfilesFor ( final String propKeyNameWildcard ) { HashSet < String > profiles = new HashSet <> ( ) ; profile : for ( Map . Entry < String , Map < String , PropsEntry > > entries : data . profileProperties . entrySet ( ) ) { String profileName = entries . getKey ( ) ; Map < String , PropsEntry > value = entries . getValue ( ) ; for ( String propKeyName : value . keySet ( ) ) { if ( Wildcard . equalsOrMatch ( propKeyName , propKeyNameWildcard ) ) { profiles . add ( profileName ) ; continue profile ; } } } return profiles . toArray ( new String [ 0 ] ) ; }", "nl": "Returns all the profiles that define certain prop s key name . Key name is given as a wildcard or it can be matched fully ."}}
{"translation": {"code": "public void waitFor ( ) { try { synchronized ( lock ) { if ( ! end ) { lock . wait ( ) ; } } } catch ( InterruptedException ignore ) { Thread . currentThread ( ) . interrupt ( ) ; } }", "nl": "Waits for gobbler to end ."}}
{"translation": {"code": "protected void resolveActiveProfiles ( ) { if ( activeProfilesProp == null ) { activeProfiles = null ; return ; } final PropsEntry pv = data . getBaseProperty ( activeProfilesProp ) ; if ( pv == null ) { // no active profile set as the property, exit return ; } final String value = pv . getValue ( ) ; if ( StringUtil . isBlank ( value ) ) { activeProfiles = null ; return ; } activeProfiles = StringUtil . splitc ( value , ' ' ) ; StringUtil . trimAll ( activeProfiles ) ; }", "nl": "Resolves active profiles from special property . This property can be only a base property! If default active property is not defined nothing happens . Otherwise it will replace currently active profiles ."}}
{"translation": {"code": "public List < Node > select ( final String query ) { Collection < List < CssSelector >> selectorsCollection = CSSelly . parse ( query ) ; return select ( selectorsCollection ) ; }", "nl": "Selects nodes using CSS3 selector query ."}}
{"translation": {"code": "public Props load ( final Map < ? , ? > p ) { for ( final Map . Entry < ? , ? > entry : p . entrySet ( ) ) { final String name = entry . getKey ( ) . toString ( ) ; final Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } data . putBaseProperty ( name , value . toString ( ) , false ) ; } return this ; }", "nl": "Loads base properties from the provided java properties . Null values are ignored ."}}
{"translation": {"code": "public Props load ( final InputStream in ) throws IOException { final Writer out = new FastCharArrayWriter ( ) ; StreamUtil . copy ( in , out ) ; parse ( out . toString ( ) ) ; return this ; }", "nl": "Loads properties from input stream . Stream is not closed at the end ."}}
{"translation": {"code": "public String applyToTableName ( final String tableName ) { String entityName = convertTableNameToEntityName ( tableName ) ; return convertEntityNameToTableName ( entityName ) ; }", "nl": "Applies table naming strategy to given table name hint . Returns full table name ."}}
{"translation": {"code": "@ Override public void text ( final CharSequence text ) { if ( ! strip ) { super . text ( text ) ; return ; } int textLength = text . length ( ) ; char [ ] dest = new char [ textLength ] ; int ndx = 0 ; boolean regularChar = true ; for ( int i = 0 ; i < textLength ; i ++ ) { char c = text . charAt ( i ) ; if ( CharUtil . isWhitespace ( c ) ) { if ( regularChar ) { regularChar = false ; c = ' ' ; } else { continue ; } } else { regularChar = true ; } dest [ ndx ] = c ; ndx ++ ; } if ( regularChar || ( ndx != 1 ) ) { super . text ( CharBuffer . wrap ( dest , 0 , ndx ) ) ; strippedCharsCount += textLength - ndx ; } else { strippedCharsCount += textLength ; } }", "nl": "Cleans unnecessary whitespaces ."}}
{"translation": {"code": "protected static String changeReturnType ( final String desc , final String type ) { int ndx = desc . indexOf ( ' ' ) ; return desc . substring ( 0 , ndx + 1 ) + type ; }", "nl": "Changes return type ."}}
{"translation": {"code": "protected static String prependArgument ( final String desc , final String type ) { int ndx = desc . indexOf ( ' ' ) ; ndx ++ ; return desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; }", "nl": "Prepends argument to the existing description ."}}
{"translation": {"code": "@ Override public PrintWriter getWriter ( ) throws IOException { preResponseCommit ( ) ; if ( buffer == null ) { return getResponse ( ) . getWriter ( ) ; } return buffer . getWriter ( ) ; }", "nl": "Returns buffered writer if buffering is enabled otherwise returns the original writer ."}}
{"translation": {"code": "@ Override public ServletOutputStream getOutputStream ( ) throws IOException { preResponseCommit ( ) ; if ( buffer == null ) { return getResponse ( ) . getOutputStream ( ) ; } return buffer . getOutputStream ( ) ; }", "nl": "Returns buffered output stream if buffering is enabled otherwise returns the original stream ."}}
{"translation": {"code": "public void writeContentToResponse ( final char [ ] content ) throws IOException { if ( buffer == null ) { return ; } if ( buffer . isUsingStream ( ) ) { ServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; String encoding = getContentTypeEncoding ( ) ; if ( encoding == null ) { outputStream . write ( CharUtil . toByteArray ( content ) ) ; } else { outputStream . write ( CharUtil . toByteArray ( content , encoding ) ) ; } outputStream . flush ( ) ; } else { Writer out = getResponse ( ) . getWriter ( ) ; out . write ( content ) ; out . flush ( ) ; } }", "nl": "Writes content to original output stream using either output stream or writer depending on how the content was buffered . It is assumed that provided content is a modified wrapped content ."}}
{"translation": {"code": "@ Override public void setContentType ( final String type ) { super . setContentType ( type ) ; contentTypeResolver = new ContentTypeHeaderResolver ( type ) ; if ( bufferContentType ( type , contentTypeResolver . getMimeType ( ) , contentTypeResolver . getEncoding ( ) ) ) { enableBuffering ( ) ; } else { disableBuffering ( ) ; } }", "nl": "Sets the content type and enables or disables buffering ."}}
{"translation": {"code": "public void print ( final String string ) throws IOException { if ( isBufferStreamBased ( ) ) { String encoding = getContentTypeEncoding ( ) ; byte [ ] bytes ; if ( encoding == null ) { bytes = string . getBytes ( ) ; } else { bytes = string . getBytes ( encoding ) ; } buffer . getOutputStream ( ) . write ( bytes ) ; return ; } // make sure at least writer is initialized buffer . getWriter ( ) . write ( string ) ; }", "nl": "Appends string to the buffer ."}}
{"translation": {"code": "protected JsonResult login ( ) { T authToken ; authToken = loginViaBasicAuth ( servletRequest ) ; if ( authToken == null ) { authToken = loginViaRequestParams ( servletRequest ) ; } if ( authToken == null ) { log . warn ( \"Login failed.\" ) ; return JsonResult . of ( HttpStatus . error401 ( ) . unauthorized ( \"Login failed.\" ) ) ; } log . info ( \"login OK!\" ) ; final UserSession < T > userSession = new UserSession <> ( authToken , userAuth . tokenValue ( authToken ) ) ; userSession . start ( servletRequest , servletResponse ) ; // return token return tokenAsJson ( authToken ) ; }", "nl": "Authenticate user and start user session ."}}
{"translation": {"code": "protected static String appendArgument ( final String desc , final String type ) { int ndx = desc . indexOf ( ' ' ) ; return desc . substring ( 0 , ndx ) + type + desc . substring ( ndx ) ; }", "nl": "Appends argument to the existing description ."}}
{"translation": {"code": "protected T loginViaBasicAuth ( final HttpServletRequest servletRequest ) { final String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; if ( username == null ) { return null ; } final String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; return userAuth . login ( username , password ) ; }", "nl": "Tries to login user with basic authentication ."}}
{"translation": {"code": "protected JsonResult logout ( ) { log . debug ( \"logout user\" ) ; UserSession . stop ( servletRequest , servletResponse ) ; return JsonResult . of ( HttpStatus . ok ( ) ) ; }", "nl": "Logout hook ."}}
{"translation": {"code": "public Props load ( final File file , final String encoding ) throws IOException { parse ( FileUtil . readString ( file , encoding ) ) ; return this ; }", "nl": "Loads properties from the file in provided encoding ."}}
{"translation": {"code": "public Props load ( final File file ) throws IOException { final String extension = FileNameUtil . getExtension ( file . getAbsolutePath ( ) ) ; final String data ; if ( extension . equalsIgnoreCase ( \"properties\" ) ) { data = FileUtil . readString ( file , StringPool . ISO_8859_1 ) ; } else { data = FileUtil . readString ( file ) ; } parse ( data ) ; return this ; }", "nl": "Loads props from the file . Assumes UTF8 encoding unless the file ends with . properties than it uses ISO 8859 - 1 ."}}
{"translation": {"code": "public boolean match ( final int value ) { if ( a == 0 ) { return value == b ; } if ( a > 0 ) { if ( value < b ) { return false ; } return ( value - b ) % a == 0 ; } if ( value > b ) { return false ; } return ( b - value ) % ( - a ) == 0 ; }", "nl": "Matches expression with the value ."}}
{"translation": {"code": "public static int calcFirstItemIndexOfPage ( final PageRequest pageRequest , final int total ) { return calcFirstItemIndexOfPage ( pageRequest . getPage ( ) , pageRequest . getSize ( ) , total ) ; }", "nl": "Calculates first item index of the page ."}}
{"translation": {"code": "public static int calcFirstItemIndexOfPage ( int page , final int pageSize , final int total ) { if ( total == 0 ) { return 0 ; } if ( page < 1 ) { page = 1 ; } int first = ( page - 1 ) * pageSize ; if ( first >= total ) { first = ( ( total - 1 ) / pageSize ) * pageSize ; // first item on the last page } return first ; }", "nl": "Calculates the first item index of requested page ."}}
{"translation": {"code": "@ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ; // [A4] return new AnnotationVisitorAdapter ( destAnn ) ; }", "nl": "Copies target method annotations ."}}
{"translation": {"code": "protected void createFirstChainDelegate_Start ( ) { // check invalid access flags int access = msign . getAccessFlags ( ) ; if ( ! wd . allowFinalMethods ) { if ( ( access & AsmUtil . ACC_FINAL ) != 0 ) { // detect final throw new ProxettaException ( \"Unable to create proxy for final method: \" + msign + \". Remove final modifier or change the pointcut definition.\" ) ; } } // create proxy methods tmd = new TargetMethodData ( msign , aspectList ) ; access &= ~ ACC_NATIVE ; access &= ~ ACC_ABSTRACT ; methodVisitor = wd . dest . visitMethod ( access , tmd . msign . getMethodName ( ) , tmd . msign . getDescription ( ) , tmd . msign . getAsmMethodSignature ( ) , null ) ; }", "nl": "Starts creation of first chain delegate ."}}
{"translation": {"code": "public String [ ] getAllProfiles ( ) { String [ ] profiles = new String [ data . profileProperties . size ( ) ] ; int index = 0 ; for ( String profileName : data . profileProperties . keySet ( ) ) { profiles [ index ] = profileName ; index ++ ; } return profiles ; }", "nl": "Returns all profiles names ."}}
{"translation": {"code": "protected void processSelectors ( final List < Node > results , final List < CssSelector > selectors ) { List < Node > selectedNodes = select ( rootNode , selectors ) ; for ( Node selectedNode : selectedNodes ) { if ( ! results . contains ( selectedNode ) ) { results . add ( selectedNode ) ; } } }", "nl": "Process selectors and keep adding results ."}}
{"translation": {"code": "public List < Node > select ( final Collection < List < CssSelector > > selectorsCollection ) { List < Node > results = new ArrayList <> ( ) ; for ( List < CssSelector > selectors : selectorsCollection ) { processSelectors ( results , selectors ) ; } return results ; }", "nl": "Selected nodes using pre - parsed CSS selectors . Take in consideration collection type for results grouping order ."}}
{"translation": {"code": "protected void walkDescendantsIteratively ( final LinkedList < Node > nodes , final CssSelector cssSelector , final List < Node > result ) { while ( ! nodes . isEmpty ( ) ) { Node node = nodes . removeFirst ( ) ; selectAndAdd ( node , cssSelector , result ) ; // append children in walking order to be processed right after this node int childCount = node . getChildNodesCount ( ) ; for ( int i = childCount - 1 ; i >= 0 ; i -- ) { nodes . addFirst ( node . getChild ( i ) ) ; } } }", "nl": "Walks over the child notes maintaining the tree order and not using recursion ."}}
{"translation": {"code": "public void addInnerMap ( String prefix , final Map < ? , ? > map , final String profile ) { if ( ! StringUtil . endsWithChar ( prefix , ' ' ) ) { prefix += StringPool . DOT ; } for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) { String key = entry . getKey ( ) . toString ( ) ; key = prefix + key ; setValue ( key , entry . getValue ( ) . toString ( ) , profile ) ; } }", "nl": "Adds child map to the props on given prefix ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Map < String , Object > innerMap ( final String prefix ) { initialize ( ) ; return data . extract ( null , activeProfiles , null , prefix ) ; }", "nl": "Returns inner map from the props with given prefix . Keys in returned map will not have the prefix ."}}
{"translation": {"code": "public void extractSubProps ( final Map target , final String ... wildcardPatterns ) { initialize ( ) ; data . extract ( target , activeProfiles , wildcardPatterns , null ) ; }", "nl": "Extracts subset of properties that matches given wildcards ."}}
{"translation": {"code": "public String getPseudoClassName ( ) { String name = getClass ( ) . getSimpleName ( ) . toLowerCase ( ) ; name = name . replace ( ' ' , ' ' ) ; return name ; }", "nl": "Returns pseudo - class name from simple class name ."}}
{"translation": {"code": "public void extractProps ( final Map target , final String ... profiles ) { initialize ( ) ; data . extract ( target , profiles , null , null ) ; }", "nl": "Extract props of given profiles ."}}
{"translation": {"code": "public void extractProps ( final Map target ) { initialize ( ) ; data . extract ( target , activeProfiles , null , null ) ; }", "nl": "Extracts props belonging to active profiles ."}}
{"translation": {"code": "public void setValue ( final String key , final String value , final String profile ) { if ( profile == null ) { data . putBaseProperty ( key , value , false ) ; } else { data . putProfileProperty ( key , value , profile , false ) ; } initialized = false ; }", "nl": "Sets value on some profile ."}}
{"translation": {"code": "public Props loadFromClasspath ( final String ... patterns ) { ClassScanner . create ( ) . registerEntryConsumer ( entryData -> { String usedEncoding = JoddCore . encoding ; if ( StringUtil . endsWithIgnoreCase ( entryData . name ( ) , \".properties\" ) ) { usedEncoding = StringPool . ISO_8859_1 ; } final String encoding = usedEncoding ; UncheckedException . runAndWrapException ( ( ) -> load ( entryData . openInputStream ( ) , encoding ) ) ; } ) . includeResources ( true ) . ignoreException ( true ) . excludeCommonJars ( ) . excludeAllEntries ( true ) . includeEntries ( patterns ) . scanDefaultClasspath ( ) . start ( ) ; return this ; }", "nl": "Loads props and properties from the classpath ."}}
{"translation": {"code": "protected int calculateLength ( ) { int len = 0 ; for ( int i = 0 ; i < index ; i ++ ) { len += array [ i ] . length ( ) ; } return len ; }", "nl": "Calculates string length ."}}
{"translation": {"code": "protected void expandCapacity ( ) { String [ ] newArray = new String [ array . length << 1 ] ; System . arraycopy ( array , 0 , newArray , 0 , index ) ; array = newArray ; }", "nl": "Expands internal string array by multiplying its size by 2 ."}}
{"translation": {"code": "public Node selectFirst ( final String query ) { List < Node > selectedNodes = select ( query ) ; if ( selectedNodes . isEmpty ( ) ) { return null ; } return selectedNodes . get ( 0 ) ; }", "nl": "Selects nodes using CSS3 selector query and returns the very first one ."}}
{"translation": {"code": "public StringBand append ( String s ) { if ( s == null ) { s = StringPool . NULL ; } if ( index >= array . length ) { expandCapacity ( ) ; } array [ index ++ ] = s ; length += s . length ( ) ; return this ; }", "nl": "Appends a string ."}}
{"translation": {"code": "public void setIndex ( final int newIndex ) { if ( newIndex < 0 ) { throw new ArrayIndexOutOfBoundsException ( newIndex ) ; } if ( newIndex > array . length ) { String [ ] newArray = new String [ newIndex ] ; System . arraycopy ( array , 0 , newArray , 0 , index ) ; array = newArray ; } if ( newIndex > index ) { for ( int i = index ; i < newIndex ; i ++ ) { array [ i ] = StringPool . EMPTY ; } } else if ( newIndex < index ) { for ( int i = newIndex ; i < index ; i ++ ) { array [ i ] = null ; } } index = newIndex ; length = calculateLength ( ) ; }", "nl": "Specifies the new index ."}}
{"translation": {"code": "@ Override protected String buildOrderSql ( String sql , final String column , final boolean ascending ) { sql += \" order by \" + column ; if ( ! ascending ) { sql += \" desc\" ; } return sql ; }", "nl": "Appends ORDER BY keyword ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public Props load ( final Map < ? , ? > map , final String prefix ) { String realPrefix = prefix ; realPrefix += ' ' ; for ( final Map . Entry entry : map . entrySet ( ) ) { final String name = entry . getKey ( ) . toString ( ) ; final Object value = entry . getValue ( ) ; if ( value == null ) { continue ; } data . putBaseProperty ( realPrefix + name , value . toString ( ) , false ) ; } return this ; }", "nl": "Loads base properties from java Map using provided prefix . Null values are ignored ."}}
{"translation": {"code": "public static String detectName ( final char [ ] input , int ndx ) { final Ptr ptr = new Ptr ( ) ; int firstIndex = 0 ; int lastIndex = ENTITY_NAMES . length - 1 ; int len = input . length ; char [ ] lastName = null ; final BinarySearchBase binarySearch = new BinarySearchBase ( ) { @ Override protected int compare ( final int index ) { char [ ] name = ENTITY_NAMES [ index ] ; if ( ptr . offset >= name . length ) { return - 1 ; } return name [ ptr . offset ] - ptr . c ; } } ; while ( true ) { ptr . c = input [ ndx ] ; if ( ! CharUtil . isAlphaOrDigit ( ptr . c ) ) { return lastName != null ? new String ( lastName ) : null ; } firstIndex = binarySearch . findFirst ( firstIndex , lastIndex ) ; if ( firstIndex < 0 ) { return lastName != null ? new String ( lastName ) : null ; } char [ ] element = ENTITY_NAMES [ firstIndex ] ; if ( element . length == ptr . offset + 1 ) { // total match, remember position, continue for finding the longer name lastName = ENTITY_NAMES [ firstIndex ] ; } lastIndex = binarySearch . findLast ( firstIndex , lastIndex ) ; if ( firstIndex == lastIndex ) { // only one element found, check the rest for ( int i = ptr . offset ; i < element . length ; i ++ ) { if ( element [ i ] != input [ ndx ] ) { return lastName != null ? new String ( lastName ) : null ; } ndx ++ ; } return new String ( element ) ; } ptr . offset ++ ; ndx ++ ; if ( ndx == len ) { return lastName != null ? new String ( lastName ) : null ; } } }", "nl": "Detects the longest character reference name on given position in char array ."}}
{"translation": {"code": "public static String decode ( final String html ) { int ndx = html . indexOf ( ' ' ) ; if ( ndx == - 1 ) { return html ; } StringBuilder result = new StringBuilder ( html . length ( ) ) ; int lastIndex = 0 ; int len = html . length ( ) ; mainloop : while ( ndx != - 1 ) { result . append ( html . substring ( lastIndex , ndx ) ) ; lastIndex = ndx ; while ( html . charAt ( lastIndex ) != ' ' ) { lastIndex ++ ; if ( lastIndex == len ) { lastIndex = ndx ; break mainloop ; } } if ( html . charAt ( ndx + 1 ) == ' ' ) { // decimal/hex char c = html . charAt ( ndx + 2 ) ; int radix ; if ( ( c == ' ' ) || ( c == ' ' ) ) { radix = 16 ; ndx += 3 ; } else { radix = 10 ; ndx += 2 ; } String number = html . substring ( ndx , lastIndex ) ; int i = Integer . parseInt ( number , radix ) ; result . append ( ( char ) i ) ; lastIndex ++ ; } else { // token String encodeToken = html . substring ( ndx + 1 , lastIndex ) ; char [ ] replacement = ENTITY_MAP . get ( encodeToken ) ; if ( replacement == null ) { result . append ( ' ' ) ; lastIndex = ndx + 1 ; } else { result . append ( replacement ) ; lastIndex ++ ; } } ndx = html . indexOf ( ' ' , lastIndex ) ; } result . append ( html . substring ( lastIndex ) ) ; return result . toString ( ) ; }", "nl": "Decodes HTML text . Assumes that all character references are properly closed with semi - colon ."}}
{"translation": {"code": "protected String removeLastOrderBy ( String sql ) { int ndx = StringUtil . lastIndexOfIgnoreCase ( sql , \"order by\" ) ; if ( ndx != - 1 ) { int ndx2 = sql . lastIndexOf ( sql , ' ' ) ; if ( ndx > ndx2 ) { sql = sql . substring ( 0 , ndx ) ; } } return sql ; }", "nl": "Removes everything from last order by ."}}
{"translation": {"code": "protected String removeToFrom ( String sql ) { int from = 0 ; int fromCount = 1 ; int selectCount = 0 ; int lastNdx = 0 ; while ( true ) { int ndx = StringUtil . indexOfIgnoreCase ( sql , \"from\" , from ) ; if ( ndx == - 1 ) { break ; } // count selects in left part String left = sql . substring ( lastNdx , ndx ) ; selectCount += StringUtil . countIgnoreCase ( left , \"select\" ) ; if ( fromCount >= selectCount ) { sql = sql . substring ( ndx ) ; break ; } // find next 'from' lastNdx = ndx ; from = ndx + 4 ; fromCount ++ ; } return sql ; }", "nl": "Removes the first part of the sql up to the relevant from . Tries to detect sub - queries in the select part ."}}
{"translation": {"code": "protected String removeSelect ( String sql ) { int ndx = StringUtil . indexOfIgnoreCase ( sql , \"select\" ) ; if ( ndx != - 1 ) { sql = sql . substring ( ndx + 6 ) ; // select.length() } return sql ; }", "nl": "Removes the first select from the sql query ."}}
{"translation": {"code": "protected < T > PageData < T > page ( String sql , final Map params , final int page , final int pageSize , final String sortColumnName , final boolean ascending , final Class [ ] target ) { if ( sortColumnName != null ) { sql = buildOrderSql ( sql , sortColumnName , ascending ) ; } int from = ( page - 1 ) * pageSize ; String pageSql = buildPageSql ( sql , from , pageSize ) ; DbSqlBuilder dbsql = sql ( pageSql ) ; DbOomQuery query = query ( dbsql ) ; query . setMaxRows ( pageSize ) ; query . setFetchSize ( pageSize ) ; query . setMap ( params ) ; List < T > list = query . list ( pageSize , target ) ; query . close ( ) ; String countSql = buildCountSql ( sql ) ; dbsql = sql ( countSql ) ; query = query ( dbsql ) ; query . setMap ( params ) ; long count = query . executeCount ( ) ; query . close ( ) ; return new PageData <> ( page , ( int ) count , pageSize , list ) ; }", "nl": "Pages given page ."}}
{"translation": {"code": "protected boolean filter ( final List < Node > currentResults , final Node node , final CssSelector cssSelector , final int index ) { return cssSelector . accept ( currentResults , node , index ) ; }", "nl": "Filter nodes ."}}
{"translation": {"code": "protected void selectAndAdd ( final Node node , final CssSelector cssSelector , final List < Node > result ) { // ignore all nodes that are not elements if ( node . getNodeType ( ) != Node . NodeType . ELEMENT ) { return ; } boolean matched = cssSelector . accept ( node ) ; if ( matched ) { // check for duplicates if ( result . contains ( node ) ) { return ; } // no duplicate found, add it to the results result . add ( node ) ; } }", "nl": "Selects single node for single selector and appends it to the results ."}}
{"translation": {"code": "protected void walk ( final Node rootNode , final CssSelector cssSelector , final List < Node > result ) { // previous combinator determines the behavior CssSelector previousCssSelector = cssSelector . getPrevCssSelector ( ) ; Combinator combinator = previousCssSelector != null ? previousCssSelector . getCombinator ( ) : Combinator . DESCENDANT ; switch ( combinator ) { case DESCENDANT : LinkedList < Node > nodes = new LinkedList <> ( ) ; int childCount = rootNode . getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { nodes . add ( rootNode . getChild ( i ) ) ; // recursive //\t\t\t\t\tselectAndAdd(node, cssSelector, result); //\t\t\t\t\twalk(node, cssSelector, result); } walkDescendantsIteratively ( nodes , cssSelector , result ) ; break ; case CHILD : childCount = rootNode . getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node node = rootNode . getChild ( i ) ; selectAndAdd ( node , cssSelector , result ) ; } break ; case ADJACENT_SIBLING : Node node = rootNode . getNextSiblingElement ( ) ; if ( node != null ) { selectAndAdd ( node , cssSelector , result ) ; } break ; case GENERAL_SIBLING : node = rootNode ; while ( true ) { node = node . getNextSiblingElement ( ) ; if ( node == null ) { break ; } selectAndAdd ( node , cssSelector , result ) ; } break ; } }", "nl": "Finds nodes in the tree that matches single selector ."}}
{"translation": {"code": "@ Override protected String buildPageSql ( String sql , final int from , final int pageSize ) { sql = removeSelect ( sql ) ; return \"select LIMIT \" + from + ' ' + pageSize + sql ; }", "nl": "Builds page sql using LIMIT keyword after the SELECT ."}}
{"translation": {"code": "public static void setRequestBundleName ( final ServletRequest request , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Bundle name for this request: \" + bundleName ) ; } request . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }", "nl": "Sets bundle name for provided servlet request ."}}
{"translation": {"code": "public List < Violation > validate ( final Object target ) { return validate ( ValidationContext . resolveFor ( target . getClass ( ) ) , target ) ; }", "nl": "Validate object using context from the annotations ."}}
{"translation": {"code": "public List < Violation > validate ( final ValidationContext ctx , final Object target , final String targetName ) { for ( Map . Entry < String , List < Check > > entry : ctx . map . entrySet ( ) ) { String name = entry . getKey ( ) ; Object value = BeanUtil . declaredSilent . getProperty ( target , name ) ; String valueName = targetName != null ? ( targetName + ' ' + name ) : name ; // move up ValidationConstraintContext vcc = new ValidationConstraintContext ( this , target , valueName ) ; for ( Check check : entry . getValue ( ) ) { String [ ] checkProfiles = check . getProfiles ( ) ; if ( ! matchProfiles ( checkProfiles ) ) { continue ; } if ( check . getSeverity ( ) < severity ) { continue ; } ValidationConstraint constraint = check . getConstraint ( ) ; if ( ! constraint . isValid ( vcc , value ) ) { addViolation ( new Violation ( valueName , target , value , check ) ) ; } } } return getViolations ( ) ; }", "nl": "Performs validation of provided validation context and appends violations ."}}
{"translation": {"code": "public void useProfile ( final String profile ) { if ( profile == null ) { return ; } if ( this . enabledProfiles == null ) { this . enabledProfiles = new HashSet <> ( ) ; } this . enabledProfiles . add ( profile ) ; }", "nl": "Enables single profile ."}}
{"translation": {"code": "protected boolean matchProfiles ( final String [ ] checkProfiles ) { // test for all profiles if ( ( checkProfiles != null ) && ( checkProfiles . length == 1 ) && checkProfiles [ 0 ] . equals ( ALL_PROFILES ) ) { return true ; } if ( enabledProfiles == null || enabledProfiles . isEmpty ( ) ) { if ( validateAllProfilesByDefault ) { return true ; // all profiles are considered as enabled } // only default profile is enabled if ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { return true ; } for ( String profile : checkProfiles ) { if ( StringUtil . isEmpty ( profile ) ) { return true ; // default profile } if ( profile . equals ( DEFAULT_PROFILE ) ) { return true ; } } return false ; } // there are enabled profiles if ( ( checkProfiles == null ) || ( checkProfiles . length == 0 ) ) { return enabledProfiles . contains ( DEFAULT_PROFILE ) ; } boolean result = false ; for ( String profile : checkProfiles ) { boolean b = true ; boolean must = false ; if ( StringUtil . isEmpty ( profile ) ) { profile = DEFAULT_PROFILE ; } else if ( profile . charAt ( 0 ) == ' ' ) { profile = profile . substring ( 1 ) ; b = false ; } else if ( profile . charAt ( 0 ) == ' ' ) { profile = profile . substring ( 1 ) ; must = true ; } if ( enabledProfiles . contains ( profile ) ) { if ( ! b ) { return false ; } result = true ; } else { if ( must ) { return false ; } } } return result ; }", "nl": "Determine if any of checks profiles is among enabled profiles ."}}
{"translation": {"code": "protected void collectPropertyAnnotationChecks ( final List < Check > annChecks , final PropertyDescriptor propertyDescriptor ) { FieldDescriptor fd = propertyDescriptor . getFieldDescriptor ( ) ; if ( fd != null ) { Annotation [ ] annotations = fd . getField ( ) . getAnnotations ( ) ; collectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; } MethodDescriptor md = propertyDescriptor . getReadMethodDescriptor ( ) ; if ( md != null ) { Annotation [ ] annotations = md . getMethod ( ) . getAnnotations ( ) ; collectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; } md = propertyDescriptor . getWriteMethodDescriptor ( ) ; if ( md != null ) { Annotation [ ] annotations = md . getMethod ( ) . getAnnotations ( ) ; collectAnnotationChecks ( annChecks , propertyDescriptor . getType ( ) , propertyDescriptor . getName ( ) , annotations ) ; } }", "nl": "Process all annotations of provided properties ."}}
{"translation": {"code": "public void useProfiles ( final String ... enabledProfiles ) { if ( enabledProfiles == null ) { return ; } if ( this . enabledProfiles == null ) { this . enabledProfiles = new HashSet <> ( ) ; } Collections . addAll ( this . enabledProfiles , enabledProfiles ) ; }", "nl": "Enables list of profiles ."}}
{"translation": {"code": "protected void copyDefaultCheckProperties ( final Check destCheck , final Annotation annotation ) { Integer severity = ( Integer ) ClassUtil . readAnnotationValue ( annotation , ANN_SEVERITY ) ; destCheck . setSeverity ( severity . intValue ( ) ) ; String [ ] profiles = ( String [ ] ) ClassUtil . readAnnotationValue ( annotation , ANN_PROFILES ) ; destCheck . setProfiles ( profiles ) ; String message = ( String ) ClassUtil . readAnnotationValue ( annotation , ANN_MESSAGE ) ; destCheck . setMessage ( message ) ; }", "nl": "Copies default properties from annotation to the check ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" } ) protected void collectAnnotationChecks ( final List < Check > annChecks , final Class targetType , final String targetName , final Annotation [ ] annotations ) { for ( Annotation annotation : annotations ) { Constraint c = annotation . annotationType ( ) . getAnnotation ( Constraint . class ) ; Class < ? extends ValidationConstraint > constraintClass ; if ( c == null ) { // if constraint is not available, try lookup String constraintClassName = annotation . annotationType ( ) . getName ( ) + \"Constraint\" ; try { constraintClass = ClassLoaderUtil . loadClass ( constraintClassName , this . getClass ( ) . getClassLoader ( ) ) ; } catch ( ClassNotFoundException ingore ) { continue ; } } else { constraintClass = c . value ( ) ; } ValidationConstraint vc ; try { vc = newConstraint ( constraintClass , targetType ) ; } catch ( Exception ex ) { throw new VtorException ( \"Invalid constraint: \" + constraintClass . getClass ( ) . getName ( ) , ex ) ; } vc . configure ( annotation ) ; Check check = new Check ( targetName , vc ) ; copyDefaultCheckProperties ( check , annotation ) ; annChecks . add ( check ) ; } }", "nl": "Collect annotations for some target ."}}
{"translation": {"code": "public void addClassChecks ( final Class target ) { final List < Check > list = cache . get ( target , ( ) -> { final List < Check > newList = new ArrayList <> ( ) ; final ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( target ) ; final PropertyDescriptor [ ] allProperties = cd . getAllPropertyDescriptors ( ) ; for ( PropertyDescriptor propertyDescriptor : allProperties ) { collectPropertyAnnotationChecks ( newList , propertyDescriptor ) ; } return newList ; } ) ; addAll ( list ) ; }", "nl": "Parses class annotations and adds all checks ."}}
{"translation": {"code": "public static ValidationContext resolveFor ( final Class < ? > target ) { ValidationContext vc = new ValidationContext ( ) ; vc . addClassChecks ( target ) ; return vc ; }", "nl": "Resolve validation context for provided target class ."}}
{"translation": {"code": "public void add ( final Check check ) { String name = check . getName ( ) ; List < Check > list = map . computeIfAbsent ( name , k -> new ArrayList <> ( ) ) ; list . add ( check ) ; }", "nl": "Adds validation checks ."}}
{"translation": {"code": "public void validateWithin ( final ValidationContext vctx , final Object value ) { vtor . validate ( vctx , value , name ) ; }", "nl": "Validates provided context and value withing this constraint content ."}}
{"translation": {"code": "public < T > TypeConverter < T > lookup ( final Class < T > type ) { return converters . get ( type ) ; }", "nl": "Retrieves converter for provided type . Only registered types are matched therefore subclasses must be also registered ."}}
{"translation": {"code": "public < T > void register ( final Class < T > type , final TypeConverter < T > typeConverter ) { converters . put ( type , typeConverter ) ; }", "nl": "Registers a converter for specified type . User must register converter for all super - classes as well ."}}
{"translation": {"code": "private BeanReferences [ ] convertRefToReferences ( final String [ ] references ) { if ( references == null ) { return null ; } BeanReferences [ ] ref = new BeanReferences [ references . length ] ; for ( int i = 0 ; i < references . length ; i ++ ) { ref [ i ] = BeanReferences . of ( references [ i ] ) ; } return ref ; }", "nl": "Converts single string array to an array of bean references ."}}
{"translation": {"code": "private void removeAllDuplicateNames ( final BeanReferences [ ] allBeanReferences ) { for ( int i = 0 ; i < allBeanReferences . length ; i ++ ) { BeanReferences references = allBeanReferences [ i ] ; allBeanReferences [ i ] = references . removeDuplicateNames ( ) ; } }", "nl": "Removes duplicate names from bean references ."}}
{"translation": {"code": "private BeanReferences [ ] convertAnnValueToReferences ( String value ) { if ( value == null ) { return null ; } value = value . trim ( ) ; if ( value . length ( ) == 0 ) { return null ; } String [ ] refNames = Converter . get ( ) . toStringArray ( value ) ; BeanReferences [ ] references = new BeanReferences [ refNames . length ] ; for ( int i = 0 ; i < refNames . length ; i ++ ) { references [ i ] = BeanReferences . of ( refNames [ i ] . trim ( ) ) ; } return references ; }", "nl": "Converts comma - separated string into array of Bean references ."}}
{"translation": {"code": "public BeanReferences resolveReferenceFromValue ( final PropertyDescriptor propertyDescriptor , final String refName ) { BeanReferences references ; if ( refName == null || refName . isEmpty ( ) ) { references = buildDefaultReference ( propertyDescriptor ) ; } else { references = BeanReferences . of ( refName ) ; } references = references . removeDuplicateNames ( ) ; return references ; }", "nl": "Resolves reference from given values . Returns bean reference of given value or defaults if given name is blank ."}}
{"translation": {"code": "public BeanReferences [ ] resolveReferenceFromValues ( final Executable methodOrCtor , final String ... parameterReferences ) { BeanReferences [ ] references = convertRefToReferences ( parameterReferences ) ; if ( references == null || references . length == 0 ) { references = buildDefaultReferences ( methodOrCtor ) ; } if ( methodOrCtor . getParameterTypes ( ) . length != references . length ) { throw new PetiteException ( \"Different number of method parameters and references for: \" + methodOrCtor . getDeclaringClass ( ) . getName ( ) + ' ' + methodOrCtor . getName ( ) ) ; } removeAllDuplicateNames ( references ) ; return references ; }", "nl": "Takes given parameters references and returns reference set for given method or constructor ."}}
{"translation": {"code": "public BeanReferences [ ] readAllReferencesFromAnnotation ( final Executable methodOrCtor ) { PetiteInject petiteInject = methodOrCtor . getAnnotation ( PetiteInject . class ) ; final Parameter [ ] parameters = methodOrCtor . getParameters ( ) ; BeanReferences [ ] references ; final boolean hasAnnotationOnMethodOrCtor ; if ( petiteInject != null ) { references = convertAnnValueToReferences ( petiteInject . value ( ) ) ; hasAnnotationOnMethodOrCtor = true ; } else { references = new BeanReferences [ parameters . length ] ; hasAnnotationOnMethodOrCtor = false ; } int parametersWithAnnotationCount = 0 ; for ( int i = 0 ; i < parameters . length ; i ++ ) { Parameter parameter = parameters [ i ] ; petiteInject = parameter . getAnnotation ( PetiteInject . class ) ; if ( petiteInject == null ) { // no annotation on argument continue ; } // there is annotation on argument, override values String annotationValue = readAnnotationValue ( petiteInject ) ; if ( annotationValue != null ) { references [ i ] = BeanReferences . of ( annotationValue ) ; } parametersWithAnnotationCount ++ ; } if ( ! hasAnnotationOnMethodOrCtor ) { if ( parametersWithAnnotationCount == 0 ) { return null ; } if ( parametersWithAnnotationCount != parameters . length ) { throw new PetiteException ( \"All arguments must be annotated with PetiteInject\" ) ; } } references = updateReferencesWithDefaultsIfNeeded ( methodOrCtor , references ) ; removeAllDuplicateNames ( references ) ; return references ; }", "nl": "Extracts references from method or constructor annotation ."}}
{"translation": {"code": "private BeanReferences [ ] buildDefaultReferences ( final Executable methodOrCtor ) { final boolean useParamo = petiteConfig . getUseParamo ( ) ; final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; MethodParameter [ ] methodParameters = null ; if ( useParamo ) { methodParameters = Paramo . resolveParameters ( methodOrCtor ) ; } final Class [ ] paramTypes = methodOrCtor . getParameterTypes ( ) ; final BeanReferences [ ] references = new BeanReferences [ paramTypes . length ] ; for ( int j = 0 ; j < paramTypes . length ; j ++ ) { String [ ] ref = new String [ lookupReferences . length ] ; references [ j ] = BeanReferences . of ( ref ) ; for ( int i = 0 ; i < ref . length ; i ++ ) { switch ( lookupReferences [ i ] ) { case NAME : ref [ i ] = methodParameters != null ? methodParameters [ j ] . getName ( ) : null ; break ; case TYPE_SHORT_NAME : ref [ i ] = StringUtil . uncapitalize ( paramTypes [ j ] . getSimpleName ( ) ) ; break ; case TYPE_FULL_NAME : ref [ i ] = paramTypes [ j ] . getName ( ) ; break ; } } } return references ; }", "nl": "Builds default method references ."}}
{"translation": {"code": "public BeanReferences buildDefaultReference ( final PropertyDescriptor propertyDescriptor ) { final PetiteReferenceType [ ] lookupReferences = petiteConfig . getLookupReferences ( ) ; final String [ ] references = new String [ lookupReferences . length ] ; for ( int i = 0 ; i < references . length ; i ++ ) { switch ( lookupReferences [ i ] ) { case NAME : references [ i ] = propertyDescriptor . getName ( ) ; break ; case TYPE_SHORT_NAME : references [ i ] = StringUtil . uncapitalize ( propertyDescriptor . getType ( ) . getSimpleName ( ) ) ; break ; case TYPE_FULL_NAME : references [ i ] = propertyDescriptor . getType ( ) . getName ( ) ; break ; } } return BeanReferences . of ( references ) ; }", "nl": "Builds default field references ."}}
{"translation": {"code": "public BeanReferences removeDuplicateNames ( ) { if ( names . length < 2 ) { return this ; } int nullCount = 0 ; for ( int i = 1 ; i < names . length ; i ++ ) { String thisRef = names [ i ] ; if ( thisRef == null ) { nullCount ++ ; continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( names [ j ] == null ) { continue ; } if ( thisRef . equals ( names [ j ] ) ) { names [ i ] = null ; break ; } } } if ( nullCount == 0 ) { return this ; } String [ ] newRefs = new String [ names . length - nullCount ] ; int ndx = 0 ; for ( String name : names ) { if ( name == null ) { continue ; } newRefs [ ndx ] = name ; ndx ++ ; } return new BeanReferences ( newRefs ) ; }", "nl": "Removes later duplicated references in an array . Returns new instance of BeanReferences if there was changes otherwise returns the same instance ."}}
{"translation": {"code": "public < T > void registerComponent ( final String name , final Class < T > component , final Consumer < T > consumer ) { log . debug ( ( ) -> \"Madvoc WebApp component: [\" + name + \"] --> \" + component . getName ( ) ) ; madpc . removeBean ( name ) ; madpc . registerPetiteBean ( component , name , null , null , false , consumer ) ; }", "nl": "Registers Madvoc component with given name ."}}
{"translation": {"code": "protected void acceptMadvocComponentClass ( final Class componentClass ) { if ( componentClass == null ) { return ; } if ( ! checkClass ( componentClass ) ) { return ; } madvocComponents . add ( ( ) -> madvocContainer . registerComponent ( componentClass ) ) ; }", "nl": "Registers new Madvoc component ."}}
{"translation": {"code": "public Consumers < T > addAll ( final Consumer < T > ... consumers ) { Collections . addAll ( consumerList , consumers ) ; return this ; }", "nl": "Registers additional consumers ."}}
{"translation": {"code": "public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }", "nl": "Registers additional Madvoc components after the registration of default components ."}}
{"translation": {"code": "@ Override public JoyProxetta addProxyAspect ( final ProxyAspect proxyAspect ) { requireNotStarted ( proxetta ) ; this . proxyAspects . add ( proxyAspect ) ; return this ; }", "nl": "Adds a proxy aspect ."}}
{"translation": {"code": "@ Override @ SuppressWarnings ( \"unchecked\" ) public void start ( ) { initLogger ( ) ; if ( ! databaseEnabled ) { log . info ( \"DB not enabled.\" ) ; return ; } log . info ( \"DB start ----------\" ) ; final PetiteContainer petiteContainer = joyPetiteSupplier . get ( ) . getPetiteContainer ( ) ; // connection pool connectionProvider = createConnectionProviderIfNotSupplied ( ) ; petiteContainer . addBean ( beanNamePrefix ( ) + \"pool\" , connectionProvider ) ; if ( connectionProvider instanceof CoreConnectionPool ) { final CoreConnectionPool pool = ( CoreConnectionPool ) connectionProvider ; if ( pool . getDriver ( ) == null ) { databaseEnabled = false ; log . warn ( \"DB configuration not set (\" + beanNamePrefix ( ) + \"pool.*). DB will be disabled.\" ) ; return ; } } connectionProvider . init ( ) ; checkConnectionProvider ( ) ; // transactions manager jtxManager = createJtxTransactionManager ( connectionProvider ) ; jtxManager . setValidateExistingTransaction ( true ) ; final AnnotationTxAdviceManager annTxAdviceManager = new AnnotationTxAdviceManager ( new LeanJtxWorker ( jtxManager ) , jtxScopePattern ) ; AnnotationTxAdviceSupport . manager = annTxAdviceManager ; // create proxy joyProxettaSupplier . get ( ) . getProxetta ( ) . withAspect ( createTxProxyAspects ( annTxAdviceManager . getAnnotations ( ) ) ) ; final DbSessionProvider sessionProvider = new DbJtxSessionProvider ( jtxManager ) ; // querymap final long startTime = System . currentTimeMillis ( ) ; final QueryMap queryMap = new DbPropsQueryMap ( ) ; log . debug ( \"Queries loaded in \" + ( System . currentTimeMillis ( ) - startTime ) + \"ms.\" ) ; log . debug ( \"Total queries: \" + queryMap . size ( ) ) ; // dboom dbOom = DbOom . create ( ) . withConnectionProvider ( connectionProvider ) . withSessionProvider ( sessionProvider ) . withQueryMap ( queryMap ) . get ( ) ; dbOom . connect ( ) ; final DbEntityManager dbEntityManager = dbOom . entityManager ( ) ; dbEntityManager . reset ( ) ; petiteContainer . addBean ( beanNamePrefix ( ) + \"query\" , dbOom . queryConfig ( ) ) ; petiteContainer . addBean ( beanNamePrefix ( ) + \"oom\" , dbOom . config ( ) ) ; // automatic configuration if ( autoConfiguration ) { final AutomagicDbOomConfigurator automagicDbOomConfigurator = new AutomagicDbOomConfigurator ( dbEntityManager , true ) ; automagicDbOomConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; } dbEntityManagerConsumers . accept ( dbEntityManager ) ; log . info ( \"DB OK!\" ) ; }", "nl": "Initializes database . First creates connection pool . and transaction manager . Then Jodds DbEntityManager is configured . It is also configured automagically by scanning the class path for entities ."}}
{"translation": {"code": "protected void checkConnectionProvider ( ) { final Connection connection = connectionProvider . getConnection ( ) ; try { final DatabaseMetaData databaseMetaData = connection . getMetaData ( ) ; String name = databaseMetaData . getDatabaseProductName ( ) ; String version = databaseMetaData . getDatabaseProductVersion ( ) ; if ( log . isInfoEnabled ( ) ) { log . info ( \"Connected to database: \" + name + \" v\" + version ) ; } } catch ( SQLException sex ) { log . error ( \"DB connection failed: \" , sex ) ; } finally { connectionProvider . closeConnection ( connection ) ; } }", "nl": "Checks if connection provider can return a connection ."}}
{"translation": {"code": "public void stop ( ) { joyProps . stop ( ) ; try { joyDb . stop ( ) ; joyPetite . stop ( ) ; } catch ( Exception ignore ) { } if ( log != null ) { log . info ( \"Joy is down. Bye, bye!\" ) ; } }", "nl": "Stops the Joy ."}}
{"translation": {"code": "@ Override public void stop ( ) { if ( log != null ) { log . info ( \"PETITE stop\" ) ; } if ( petiteContainer != null ) { petiteContainer . shutdown ( ) ; } petiteContainer = null ; }", "nl": "Stops Petite container ."}}
{"translation": {"code": "@ Override public void start ( ) { initLogger ( ) ; log . info ( \"PETITE start  ----------\" ) ; petiteContainer = createPetiteContainer ( ) ; if ( externalsCache ) { petiteContainer . setExternalsCache ( TypeCache . createDefault ( ) ) ; } log . info ( \"Web application? \" + isWebApplication ) ; if ( ! isWebApplication ) { // make session scope to act as singleton scope // if this is not a web application (and http session is not available). petiteContainer . registerScope ( SessionScope . class , new SingletonScope ( petiteContainer ) ) ; } // load parameters from properties files petiteContainer . defineParameters ( joyPropsSupplier . get ( ) . getProps ( ) ) ; // automagic configuration if ( autoConfiguration ) { final AutomagicPetiteConfigurator automagicPetiteConfigurator = new AutomagicPetiteConfigurator ( petiteContainer ) ; automagicPetiteConfigurator . registerAsConsumer ( joyScannerSupplier . get ( ) . getClassScanner ( ) ) ; } petiteContainerConsumers . accept ( this . petiteContainer ) ; log . info ( \"PETITE OK!\" ) ; }", "nl": "Creates and initializes Petite container . It will be auto - magically configured by scanning the classpath ."}}
{"translation": {"code": "public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }", "nl": "Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist ."}}
{"translation": {"code": "public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }", "nl": "Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass ."}}
{"translation": {"code": "private void configureServletContext ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( \"decora\" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , true , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( \"madvoc\" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , true , contextPath ) ; }", "nl": "Configures servlet context ."}}
{"translation": {"code": "final boolean resolve ( final byte [ ] code , final int bytecodeOffset ) { this . flags |= FLAG_RESOLVED ; this . bytecodeOffset = bytecodeOffset ; if ( forwardReferences == null ) { return false ; } boolean hasAsmInstructions = false ; for ( int i = forwardReferences [ 0 ] ; i > 0 ; i -= 2 ) { final int sourceInsnBytecodeOffset = forwardReferences [ i - 1 ] ; final int reference = forwardReferences [ i ] ; final int relativeOffset = bytecodeOffset - sourceInsnBytecodeOffset ; int handle = reference & FORWARD_REFERENCE_HANDLE_MASK ; if ( ( reference & FORWARD_REFERENCE_TYPE_MASK ) == FORWARD_REFERENCE_TYPE_SHORT ) { if ( relativeOffset < Short . MIN_VALUE || relativeOffset > Short . MAX_VALUE ) { // Change the opcode of the jump instruction, in order to be able to find it later in // ClassReader. These ASM specific opcodes are similar to jump instruction opcodes, except // that the 2 bytes offset is unsigned (and can therefore represent values from 0 to // 65535, which is sufficient since the size of a method is limited to 65535 bytes). int opcode = code [ sourceInsnBytecodeOffset ] & 0xFF ; if ( opcode < Opcodes . IFNULL ) { // Change IFEQ ... JSR to ASM_IFEQ ... ASM_JSR. code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_OPCODE_DELTA ) ; } else { // Change IFNULL and IFNONNULL to ASM_IFNULL and ASM_IFNONNULL. code [ sourceInsnBytecodeOffset ] = ( byte ) ( opcode + Constants . ASM_IFNULL_OPCODE_DELTA ) ; } hasAsmInstructions = true ; } code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; code [ handle ] = ( byte ) relativeOffset ; } else { code [ handle ++ ] = ( byte ) ( relativeOffset >>> 24 ) ; code [ handle ++ ] = ( byte ) ( relativeOffset >>> 16 ) ; code [ handle ++ ] = ( byte ) ( relativeOffset >>> 8 ) ; code [ handle ] = ( byte ) relativeOffset ; } } return hasAsmInstructions ; }", "nl": "Sets the bytecode offset of this label to the given value and resolves the forward references to this label if any . This method must be called when this label is added to the bytecode of the method i . e . when its bytecode offset becomes known . This method fills in the blanks that where left in the bytecode by each forward reference previously added to this label ."}}
{"translation": {"code": "final void markSubroutine ( final short subroutineId ) { // Data flow algorithm: put this basic block in a list of blocks to process (which are blocks // belonging to subroutine subroutineId) and, while there are blocks to process, remove one from // the list, mark it as belonging to the subroutine, and add its successor basic blocks in the // control flow graph to the list of blocks to process (if not already done). Label listOfBlocksToProcess = this ; listOfBlocksToProcess . nextListElement = EMPTY_LIST ; while ( listOfBlocksToProcess != EMPTY_LIST ) { // Remove a basic block from the list of blocks to process. Label basicBlock = listOfBlocksToProcess ; listOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; basicBlock . nextListElement = null ; // If it is not already marked as belonging to a subroutine, mark it as belonging to // subroutineId and add its successors to the list of blocks to process (unless already done). if ( basicBlock . subroutineId == 0 ) { basicBlock . subroutineId = subroutineId ; listOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; } } }", "nl": "Finds the basic blocks that belong to the subroutine starting with the basic block corresponding to this label and marks these blocks as belonging to this subroutine . This method follows the control flow graph to find all the blocks that are reachable from the current basic block WITHOUT following any jsr target ."}}
{"translation": {"code": "final void addLineNumber ( final int lineNumber ) { if ( this . lineNumber == 0 ) { this . lineNumber = ( short ) lineNumber ; } else { if ( otherLineNumbers == null ) { otherLineNumbers = new int [ LINE_NUMBERS_CAPACITY_INCREMENT ] ; } int otherLineNumberIndex = ++ otherLineNumbers [ 0 ] ; if ( otherLineNumberIndex >= otherLineNumbers . length ) { int [ ] newLineNumbers = new int [ otherLineNumbers . length + LINE_NUMBERS_CAPACITY_INCREMENT ] ; System . arraycopy ( otherLineNumbers , 0 , newLineNumbers , 0 , otherLineNumbers . length ) ; otherLineNumbers = newLineNumbers ; } otherLineNumbers [ otherLineNumberIndex ] = lineNumber ; } }", "nl": "Adds a source line number corresponding to this label ."}}
{"translation": {"code": "final void addSubroutineRetSuccessors ( final Label subroutineCaller ) { // Data flow algorithm: put this basic block in a list blocks to process (which are blocks // belonging to a subroutine starting with this label) and, while there are blocks to process, // remove one from the list, put it in a list of blocks that have been processed, add a return // edge to the successor of subroutineCaller if applicable, and add its successor basic blocks // in the control flow graph to the list of blocks to process (if not already done). Label listOfProcessedBlocks = EMPTY_LIST ; Label listOfBlocksToProcess = this ; listOfBlocksToProcess . nextListElement = EMPTY_LIST ; while ( listOfBlocksToProcess != EMPTY_LIST ) { // Move a basic block from the list of blocks to process to the list of processed blocks. Label basicBlock = listOfBlocksToProcess ; listOfBlocksToProcess = basicBlock . nextListElement ; basicBlock . nextListElement = listOfProcessedBlocks ; listOfProcessedBlocks = basicBlock ; // Add an edge from this block to the successor of the caller basic block, if this block is // the end of a subroutine and if this block and subroutineCaller do not belong to the same // subroutine. if ( ( basicBlock . flags & FLAG_SUBROUTINE_END ) != 0 && basicBlock . subroutineId != subroutineCaller . subroutineId ) { basicBlock . outgoingEdges = new Edge ( basicBlock . outputStackSize , // By construction, the first outgoing edge of a basic block that ends with a jsr // instruction leads to the jsr continuation block, i.e. where execution continues // when ret is called (see {@link #FLAG_SUBROUTINE_CALLER}). subroutineCaller . outgoingEdges . successor , basicBlock . outgoingEdges ) ; } // Add its successors to the list of blocks to process. Note that {@link #pushSuccessors} does // not push basic blocks which are already in a list. Here this means either in the list of // blocks to process, or in the list of already processed blocks. This second list is // important to make sure we don't reprocess an already processed block. listOfBlocksToProcess = basicBlock . pushSuccessors ( listOfBlocksToProcess ) ; } // Reset the {@link #nextListElement} of all the basic blocks that have been processed to null, // so that this method can be called again with a different subroutine or subroutine caller. while ( listOfProcessedBlocks != EMPTY_LIST ) { Label newListOfProcessedBlocks = listOfProcessedBlocks . nextListElement ; listOfProcessedBlocks . nextListElement = null ; listOfProcessedBlocks = newListOfProcessedBlocks ; } }", "nl": "Finds the basic blocks that end a subroutine starting with the basic block corresponding to this label and for each one of them adds an outgoing edge to the basic block following the given subroutine call . In other words completes the control flow graph by adding the edges corresponding to the return from this subroutine when called from the given caller basic block ."}}
{"translation": {"code": "private void pop ( final int elements ) { if ( outputStackTop >= elements ) { outputStackTop -= elements ; } else { // If the number of elements to be popped is greater than the number of elements in the output // stack, clear it, and pop the remaining elements from the input stack. outputStackStart -= elements - outputStackTop ; outputStackTop = 0 ; } }", "nl": "Pops the given number of abstract types from the output frame stack ."}}
{"translation": {"code": "private void computeMaxStackAndLocal ( ) { // Complete the control flow graph with exception handler blocks. Handler handler = firstHandler ; while ( handler != null ) { Label handlerBlock = handler . handlerPc ; Label handlerRangeBlock = handler . startPc ; Label handlerRangeEnd = handler . endPc ; // Add handlerBlock as a successor of all the basic blocks in the exception handler range. while ( handlerRangeBlock != handlerRangeEnd ) { if ( ( handlerRangeBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) == 0 ) { handlerRangeBlock . outgoingEdges = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges ) ; } else { // If handlerRangeBlock is a JSR block, add handlerBlock after the first two outgoing // edges to preserve the hypothesis about JSR block successors order (see // {@link #visitJumpInsn}). handlerRangeBlock . outgoingEdges . nextEdge . nextEdge = new Edge ( Edge . EXCEPTION , handlerBlock , handlerRangeBlock . outgoingEdges . nextEdge . nextEdge ) ; } handlerRangeBlock = handlerRangeBlock . nextBasicBlock ; } handler = handler . nextHandler ; } // Complete the control flow graph with the successor blocks of subroutines, if needed. if ( hasSubroutines ) { // First step: find the subroutines. This step determines, for each basic block, to which // subroutine(s) it belongs. Start with the main \"subroutine\": short numSubroutines = 1 ; firstBasicBlock . markSubroutine ( numSubroutines ) ; // Then, mark the subroutines called by the main subroutine, then the subroutines called by // those called by the main subroutine, etc. for ( short currentSubroutine = 1 ; currentSubroutine <= numSubroutines ; ++ currentSubroutine ) { Label basicBlock = firstBasicBlock ; while ( basicBlock != null ) { if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 && basicBlock . subroutineId == currentSubroutine ) { Label jsrTarget = basicBlock . outgoingEdges . nextEdge . successor ; if ( jsrTarget . subroutineId == 0 ) { // If this subroutine has not been marked yet, find its basic blocks. jsrTarget . markSubroutine ( ++ numSubroutines ) ; } } basicBlock = basicBlock . nextBasicBlock ; } } // Second step: find the successors in the control flow graph of each subroutine basic block // 'r' ending with a RET instruction. These successors are the virtual successors of the basic // blocks ending with JSR instructions (see {@link #visitJumpInsn)} that can reach 'r'. Label basicBlock = firstBasicBlock ; while ( basicBlock != null ) { if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { // By construction, jsr targets are stored in the second outgoing edge of basic blocks // that ends with a jsr instruction (see {@link #FLAG_SUBROUTINE_CALLER}). Label subroutine = basicBlock . outgoingEdges . nextEdge . successor ; subroutine . addSubroutineRetSuccessors ( basicBlock ) ; } basicBlock = basicBlock . nextBasicBlock ; } } // Data flow algorithm: put the first basic block in a list of blocks to process (i.e. blocks // whose input stack size has changed) and, while there are blocks to process, remove one // from the list, update the input stack size of its successor blocks in the control flow // graph, and add these blocks to the list of blocks to process (if not already done). Label listOfBlocksToProcess = firstBasicBlock ; listOfBlocksToProcess . nextListElement = Label . EMPTY_LIST ; int maxStackSize = maxStack ; while ( listOfBlocksToProcess != Label . EMPTY_LIST ) { // Remove a basic block from the list of blocks to process. Note that we don't reset // basicBlock.nextListElement to null on purpose, to make sure we don't reprocess already // processed basic blocks. Label basicBlock = listOfBlocksToProcess ; listOfBlocksToProcess = listOfBlocksToProcess . nextListElement ; // Compute the (absolute) input stack size and maximum stack size of this block. int inputStackTop = basicBlock . inputStackSize ; int maxBlockStackSize = inputStackTop + basicBlock . outputStackMax ; // Update the absolute maximum stack size of the method. if ( maxBlockStackSize > maxStackSize ) { maxStackSize = maxBlockStackSize ; } // Update the input stack size of the successor blocks of basicBlock in the control flow // graph, and add these blocks to the list of blocks to process, if not already done. Edge outgoingEdge = basicBlock . outgoingEdges ; if ( ( basicBlock . flags & Label . FLAG_SUBROUTINE_CALLER ) != 0 ) { // Ignore the first outgoing edge of the basic blocks ending with a jsr: these are virtual // edges which lead to the instruction just after the jsr, and do not correspond to a // possible execution path (see {@link #visitJumpInsn} and // {@link Label#FLAG_SUBROUTINE_CALLER}). outgoingEdge = outgoingEdge . nextEdge ; } while ( outgoingEdge != null ) { Label successorBlock = outgoingEdge . successor ; if ( successorBlock . nextListElement == null ) { successorBlock . inputStackSize = ( short ) ( outgoingEdge . info == Edge . EXCEPTION ? 1 : inputStackTop + outgoingEdge . info ) ; successorBlock . nextListElement = listOfBlocksToProcess ; listOfBlocksToProcess = successorBlock ; } outgoingEdge = outgoingEdge . nextEdge ; } } this . maxStack = maxStackSize ; }", "nl": "Computes the maximum stack size of the method ."}}
{"translation": {"code": "public ByteVector putByteArray ( final byte [ ] byteArrayValue , final int byteOffset , final int byteLength ) { if ( length + byteLength > data . length ) { enlarge ( byteLength ) ; } if ( byteArrayValue != null ) { System . arraycopy ( byteArrayValue , byteOffset , data , length , byteLength ) ; } length += byteLength ; return this ; }", "nl": "Puts an array of bytes into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "public FieldVisitor visitField ( final int access , final String name , final String descriptor , final String signature , final Object value ) { if ( cv != null ) { return cv . visitField ( access , name , descriptor , signature , value ) ; } return null ; }", "nl": "Visits a field of the class ."}}
{"translation": {"code": "void putFieldInfo ( final ByteVector output ) { boolean useSyntheticAttribute = symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ; // Put the access_flags, name_index and descriptor_index fields. int mask = useSyntheticAttribute ? Opcodes . ACC_SYNTHETIC : 0 ; output . putShort ( accessFlags & ~ mask ) . putShort ( nameIndex ) . putShort ( descriptorIndex ) ; // Compute and put the attributes_count field. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. int attributesCount = 0 ; if ( constantValueIndex != 0 ) { ++ attributesCount ; } if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { ++ attributesCount ; } if ( signatureIndex != 0 ) { ++ attributesCount ; } if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { ++ attributesCount ; } if ( lastRuntimeVisibleAnnotation != null ) { ++ attributesCount ; } if ( lastRuntimeInvisibleAnnotation != null ) { ++ attributesCount ; } if ( lastRuntimeVisibleTypeAnnotation != null ) { ++ attributesCount ; } if ( lastRuntimeInvisibleTypeAnnotation != null ) { ++ attributesCount ; } if ( firstAttribute != null ) { attributesCount += firstAttribute . getAttributeCount ( ) ; } output . putShort ( attributesCount ) ; // Put the field_info attributes. // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if ( constantValueIndex != 0 ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ) . putInt ( 2 ) . putShort ( constantValueIndex ) ; } if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && useSyntheticAttribute ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ) . putInt ( 0 ) ; } if ( signatureIndex != 0 ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ) . putInt ( 2 ) . putShort ( signatureIndex ) ; } if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ) . putInt ( 0 ) ; } if ( lastRuntimeVisibleAnnotation != null ) { lastRuntimeVisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) , output ) ; } if ( lastRuntimeInvisibleAnnotation != null ) { lastRuntimeInvisibleAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) , output ) ; } if ( lastRuntimeVisibleTypeAnnotation != null ) { lastRuntimeVisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) , output ) ; } if ( lastRuntimeInvisibleTypeAnnotation != null ) { lastRuntimeInvisibleTypeAnnotation . putAnnotations ( symbolTable . addConstantUtf8 ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) , output ) ; } if ( firstAttribute != null ) { firstAttribute . putAttributes ( symbolTable , output ) ; } }", "nl": "Puts the content of the field_info JVMS structure generated by this FieldWriter into the given ByteVector ."}}
{"translation": {"code": "public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation of the field ."}}
{"translation": {"code": "final ByteVector put11 ( final int byteValue1 , final int byteValue2 ) { int currentLength = length ; if ( currentLength + 2 > data . length ) { enlarge ( 2 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) byteValue1 ; currentData [ currentLength ++ ] = ( byte ) byteValue2 ; length = currentLength ; return this ; }", "nl": "Puts two bytes into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "private void addForwardReference ( final int sourceInsnBytecodeOffset , final int referenceType , final int referenceHandle ) { if ( forwardReferences == null ) { forwardReferences = new int [ FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; } int lastElementIndex = forwardReferences [ 0 ] ; if ( lastElementIndex + 2 >= forwardReferences . length ) { int [ ] newValues = new int [ forwardReferences . length + FORWARD_REFERENCES_CAPACITY_INCREMENT ] ; System . arraycopy ( forwardReferences , 0 , newValues , 0 , forwardReferences . length ) ; forwardReferences = newValues ; } forwardReferences [ ++ lastElementIndex ] = sourceInsnBytecodeOffset ; forwardReferences [ ++ lastElementIndex ] = referenceType | referenceHandle ; forwardReferences [ 0 ] = lastElementIndex ; }", "nl": "Adds a forward reference to this label . This method must be called only for a true forward reference i . e . only if this label is not resolved yet . For backward references the relative bytecode offset of the reference can be and must be computed and stored directly ."}}
{"translation": {"code": "public void visitInnerClass ( final String name , final String outerName , final String innerName , final int access ) { if ( cv != null ) { cv . visitInnerClass ( name , outerName , innerName , access ) ; } }", "nl": "Visits information about an inner class . This inner class is not necessarily a member of the class being visited ."}}
{"translation": {"code": "public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( cv != null ) { return cv . visitAnnotation ( descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation of the class ."}}
{"translation": {"code": "public void visitOuterClass ( final String owner , final String name , final String descriptor ) { if ( cv != null ) { cv . visitOuterClass ( owner , name , descriptor ) ; } }", "nl": "Visits the enclosing class of the class . This method must be called only if the class has an enclosing class ."}}
{"translation": {"code": "public void visitProvide ( final String service , final String ... providers ) { if ( mv != null ) { mv . visitProvide ( service , providers ) ; } }", "nl": "Visit an implementation of a service ."}}
{"translation": {"code": "public ModuleVisitor visitModule ( final String name , final int access , final String version ) { if ( api < Opcodes . ASM6 ) { throw new UnsupportedOperationException ( \"This feature requires ASM6\" ) ; } if ( cv != null ) { return cv . visitModule ( name , access , version ) ; } return null ; }", "nl": "Visit the module corresponding to the class ."}}
{"translation": {"code": "static void putAbstractType ( final SymbolTable symbolTable , final int abstractType , final ByteVector output ) { int arrayDimensions = ( abstractType & Frame . DIM_MASK ) >> DIM_SHIFT ; if ( arrayDimensions == 0 ) { int typeValue = abstractType & VALUE_MASK ; switch ( abstractType & KIND_MASK ) { case CONSTANT_KIND : output . putByte ( typeValue ) ; break ; case REFERENCE_KIND : output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( symbolTable . getType ( typeValue ) . value ) . index ) ; break ; case UNINITIALIZED_KIND : output . putByte ( ITEM_UNINITIALIZED ) . putShort ( ( int ) symbolTable . getType ( typeValue ) . data ) ; break ; default : throw new AssertionError ( ) ; } } else { // Case of an array type, we need to build its descriptor first. StringBuilder typeDescriptor = new StringBuilder ( ) ; while ( arrayDimensions -- > 0 ) { typeDescriptor . append ( ' ' ) ; } if ( ( abstractType & KIND_MASK ) == REFERENCE_KIND ) { typeDescriptor . append ( ' ' ) . append ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) . append ( ' ' ) ; } else { switch ( abstractType & VALUE_MASK ) { case Frame . ITEM_ASM_BOOLEAN : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_ASM_BYTE : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_ASM_CHAR : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_ASM_SHORT : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_INTEGER : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_FLOAT : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_LONG : typeDescriptor . append ( ' ' ) ; break ; case Frame . ITEM_DOUBLE : typeDescriptor . append ( ' ' ) ; break ; default : throw new AssertionError ( ) ; } } output . putByte ( ITEM_OBJECT ) . putShort ( symbolTable . addConstantClass ( typeDescriptor . toString ( ) ) . index ) ; } }", "nl": "Put the given abstract type in the given ByteVector using the JVMS verification_type_info format used in StackMapTable attributes ."}}
{"translation": {"code": "private int getInitializedType ( final SymbolTable symbolTable , final int abstractType ) { if ( abstractType == UNINITIALIZED_THIS || ( abstractType & ( DIM_MASK | KIND_MASK ) ) == UNINITIALIZED_KIND ) { for ( int i = 0 ; i < initializationCount ; ++ i ) { int initializedType = initializations [ i ] ; int dim = initializedType & DIM_MASK ; int kind = initializedType & KIND_MASK ; int value = initializedType & VALUE_MASK ; if ( kind == LOCAL_KIND ) { initializedType = dim + inputLocals [ value ] ; } else if ( kind == STACK_KIND ) { initializedType = dim + inputStack [ inputStack . length - value ] ; } if ( abstractType == initializedType ) { if ( abstractType == UNINITIALIZED_THIS ) { return REFERENCE_KIND | symbolTable . addType ( symbolTable . getClassName ( ) ) ; } else { return REFERENCE_KIND | symbolTable . addType ( symbolTable . getType ( abstractType & VALUE_MASK ) . value ) ; } } } } return abstractType ; }", "nl": "Returns the initialized abstract type corresponding to the given abstract type ."}}
{"translation": {"code": "final int getAttributeCount ( ) { int count = 0 ; Attribute attribute = this ; while ( attribute != null ) { count += 1 ; attribute = attribute . nextAttribute ; } return count ; }", "nl": "Returns the number of attributes of the attribute list that begins with this attribute ."}}
{"translation": {"code": "private void addInitializedType ( final int abstractType ) { // Create and/or resize the initializations array if necessary. if ( initializations == null ) { initializations = new int [ 2 ] ; } int initializationsLength = initializations . length ; if ( initializationCount >= initializationsLength ) { int [ ] newInitializations = new int [ Math . max ( initializationCount + 1 , 2 * initializationsLength ) ] ; System . arraycopy ( initializations , 0 , newInitializations , 0 , initializationsLength ) ; initializations = newInitializations ; } // Store the abstract type. initializations [ initializationCount ++ ] = abstractType ; }", "nl": "Adds an abstract type to the list of types on which a constructor is invoked in the basic block ."}}
{"translation": {"code": "public ByteVector putShort ( final int shortValue ) { int currentLength = length ; if ( currentLength + 2 > data . length ) { enlarge ( 2 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue ; length = currentLength ; return this ; }", "nl": "Puts a short into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "private static int getAbstractTypeFromDescriptor ( final SymbolTable symbolTable , final String buffer , final int offset ) { String internalName ; switch ( buffer . charAt ( offset ) ) { case ' ' : return 0 ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : return INTEGER ; case ' ' : return FLOAT ; case ' ' : return LONG ; case ' ' : return DOUBLE ; case ' ' : internalName = buffer . substring ( offset + 1 , buffer . length ( ) - 1 ) ; return REFERENCE_KIND | symbolTable . addType ( internalName ) ; case ' ' : int elementDescriptorOffset = offset + 1 ; while ( buffer . charAt ( elementDescriptorOffset ) == ' ' ) { ++ elementDescriptorOffset ; } int typeValue ; switch ( buffer . charAt ( elementDescriptorOffset ) ) { case ' ' : typeValue = BOOLEAN ; break ; case ' ' : typeValue = CHAR ; break ; case ' ' : typeValue = BYTE ; break ; case ' ' : typeValue = SHORT ; break ; case ' ' : typeValue = INTEGER ; break ; case ' ' : typeValue = FLOAT ; break ; case ' ' : typeValue = LONG ; break ; case ' ' : typeValue = DOUBLE ; break ; case ' ' : internalName = buffer . substring ( elementDescriptorOffset + 1 , buffer . length ( ) - 1 ) ; typeValue = REFERENCE_KIND | symbolTable . addType ( internalName ) ; break ; default : throw new IllegalArgumentException ( ) ; } return ( ( elementDescriptorOffset - offset ) << DIM_SHIFT ) | typeValue ; default : throw new IllegalArgumentException ( ) ; } }", "nl": "Returns the abstract type corresponding to the given type descriptor ."}}
{"translation": {"code": "final void accept ( final MethodVisitor methodVisitor , final boolean visitLineNumbers ) { methodVisitor . visitLabel ( this ) ; if ( visitLineNumbers && lineNumber != 0 ) { methodVisitor . visitLineNumber ( lineNumber & 0xFFFF , this ) ; if ( otherLineNumbers != null ) { for ( int i = 1 ; i <= otherLineNumbers [ 0 ] ; ++ i ) { methodVisitor . visitLineNumber ( otherLineNumbers [ i ] , this ) ; } } } }", "nl": "Makes the given visitor visit this label and its source line numbers if applicable ."}}
{"translation": {"code": "private int getLocal ( final int localIndex ) { if ( outputLocals == null || localIndex >= outputLocals . length ) { // If this local has never been assigned in this basic block, it is still equal to its value // in the input frame. return LOCAL_KIND | localIndex ; } else { int abstractType = outputLocals [ localIndex ] ; if ( abstractType == 0 ) { // If this local has never been assigned in this basic block, so it is still equal to its // value in the input frame. abstractType = outputLocals [ localIndex ] = LOCAL_KIND | localIndex ; } return abstractType ; } }", "nl": "Returns the abstract type stored at the given local variable index in the output frame ."}}
{"translation": {"code": "private void setLocal ( final int localIndex , final int abstractType ) { // Create and/or resize the output local variables array if necessary. if ( outputLocals == null ) { outputLocals = new int [ 10 ] ; } int outputLocalsLength = outputLocals . length ; if ( localIndex >= outputLocalsLength ) { int [ ] newOutputLocals = new int [ Math . max ( localIndex + 1 , 2 * outputLocalsLength ) ] ; System . arraycopy ( outputLocals , 0 , newOutputLocals , 0 , outputLocalsLength ) ; outputLocals = newOutputLocals ; } // Set the local variable. outputLocals [ localIndex ] = abstractType ; }", "nl": "Replaces the abstract type stored at the given local variable index in the output frame ."}}
{"translation": {"code": "private void push ( final int abstractType ) { // Create and/or resize the output stack array if necessary. if ( outputStack == null ) { outputStack = new int [ 10 ] ; } int outputStackLength = outputStack . length ; if ( outputStackTop >= outputStackLength ) { int [ ] newOutputStack = new int [ Math . max ( outputStackTop + 1 , 2 * outputStackLength ) ] ; System . arraycopy ( outputStack , 0 , newOutputStack , 0 , outputStackLength ) ; outputStack = newOutputStack ; } // Pushes the abstract type on the output stack. outputStack [ outputStackTop ++ ] = abstractType ; // Updates the maximum size reached by the output stack, if needed (note that this size is // relative to the input stack size, which is not known yet). short outputStackSize = ( short ) ( outputStackStart + outputStackTop ) ; if ( outputStackSize > owner . outputStackMax ) { owner . outputStackMax = outputStackSize ; } }", "nl": "Pushes the given abstract type on the output frame stack ."}}
{"translation": {"code": "private void push ( final SymbolTable symbolTable , final String descriptor ) { int typeDescriptorOffset = descriptor . charAt ( 0 ) == ' ' ? descriptor . indexOf ( ' ' ) + 1 : 0 ; int abstractType = getAbstractTypeFromDescriptor ( symbolTable , descriptor , typeDescriptorOffset ) ; if ( abstractType != 0 ) { push ( abstractType ) ; if ( abstractType == LONG || abstractType == DOUBLE ) { push ( TOP ) ; } } }", "nl": "Pushes the abstract type corresponding to the given descriptor on the output frame stack ."}}
{"translation": {"code": "private void pop ( final String descriptor ) { char firstDescriptorChar = descriptor . charAt ( 0 ) ; if ( firstDescriptorChar == ' ' ) { pop ( ( Type . getArgumentsAndReturnSizes ( descriptor ) >> 2 ) - 1 ) ; } else if ( firstDescriptorChar == ' ' || firstDescriptorChar == ' ' ) { pop ( 2 ) ; } else { pop ( 1 ) ; } }", "nl": "Pops as many abstract types from the output frame stack as described by the given descriptor ."}}
{"translation": {"code": "final void put ( final ByteVector code , final int sourceInsnBytecodeOffset , final boolean wideReference ) { if ( ( flags & FLAG_RESOLVED ) == 0 ) { if ( wideReference ) { addForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_WIDE , code . length ) ; code . putInt ( - 1 ) ; } else { addForwardReference ( sourceInsnBytecodeOffset , FORWARD_REFERENCE_TYPE_SHORT , code . length ) ; code . putShort ( - 1 ) ; } } else { if ( wideReference ) { code . putInt ( bytecodeOffset - sourceInsnBytecodeOffset ) ; } else { code . putShort ( bytecodeOffset - sourceInsnBytecodeOffset ) ; } } }", "nl": "Puts a reference to this label in the bytecode of a method . If the bytecode offset of the label is known the relative bytecode offset between the label and the instruction referencing it is computed and written directly . Otherwise a null relative offset is written and a new forward reference is declared for this label ."}}
{"translation": {"code": "int computeFieldInfoSize ( ) { // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes. int size = 8 ; // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS. if ( constantValueIndex != 0 ) { // ConstantValue attributes always use 8 bytes. symbolTable . addConstantUtf8 ( Constants . CONSTANT_VALUE ) ; size += 8 ; } // Before Java 1.5, synthetic fields are represented with a Synthetic attribute. if ( ( accessFlags & Opcodes . ACC_SYNTHETIC ) != 0 && symbolTable . getMajorVersion ( ) < Opcodes . V1_5 ) { // Synthetic attributes always use 6 bytes. symbolTable . addConstantUtf8 ( Constants . SYNTHETIC ) ; size += 6 ; } if ( signatureIndex != 0 ) { // Signature attributes always use 8 bytes. symbolTable . addConstantUtf8 ( Constants . SIGNATURE ) ; size += 8 ; } // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead. if ( ( accessFlags & Opcodes . ACC_DEPRECATED ) != 0 ) { // Deprecated attributes always use 6 bytes. symbolTable . addConstantUtf8 ( Constants . DEPRECATED ) ; size += 6 ; } if ( lastRuntimeVisibleAnnotation != null ) { size += lastRuntimeVisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_ANNOTATIONS ) ; } if ( lastRuntimeInvisibleAnnotation != null ) { size += lastRuntimeInvisibleAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_ANNOTATIONS ) ; } if ( lastRuntimeVisibleTypeAnnotation != null ) { size += lastRuntimeVisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_VISIBLE_TYPE_ANNOTATIONS ) ; } if ( lastRuntimeInvisibleTypeAnnotation != null ) { size += lastRuntimeInvisibleTypeAnnotation . computeAnnotationsSize ( Constants . RUNTIME_INVISIBLE_TYPE_ANNOTATIONS ) ; } if ( firstAttribute != null ) { size += firstAttribute . computeAttributesSize ( symbolTable ) ; } return size ; }", "nl": "Returns the size of the field_info JVMS structure generated by this FieldWriter . Also adds the names of the attributes of this field in the constant pool ."}}
{"translation": {"code": "public ByteVector putByte ( final int byteValue ) { int currentLength = length ; if ( currentLength + 1 > data . length ) { enlarge ( 1 ) ; } data [ currentLength ++ ] = ( byte ) byteValue ; length = currentLength ; return this ; }", "nl": "Puts a byte into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "public ByteVector putLong ( final long longValue ) { int currentLength = length ; if ( currentLength + 8 > data . length ) { enlarge ( 8 ) ; } byte [ ] currentData = data ; int intValue = ( int ) ( longValue >>> 32 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) intValue ; intValue = ( int ) longValue ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) intValue ; length = currentLength ; return this ; }", "nl": "Puts a long into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "public AnnotationVisitor visitAnnotation ( final String name , final String descriptor ) { if ( av != null ) { return av . visitAnnotation ( name , descriptor ) ; } return null ; }", "nl": "Visits a nested annotation value of the annotation ."}}
{"translation": {"code": "public void visitEnum ( final String name , final String descriptor , final String value ) { if ( av != null ) { av . visitEnum ( name , descriptor , value ) ; } }", "nl": "Visits an enumeration value of the annotation ."}}
{"translation": {"code": "final ByteVector put122 ( final int byteValue , final int shortValue1 , final int shortValue2 ) { int currentLength = length ; if ( currentLength + 5 > data . length ) { enlarge ( 5 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) byteValue ; currentData [ currentLength ++ ] = ( byte ) ( shortValue1 >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue1 ; currentData [ currentLength ++ ] = ( byte ) ( shortValue2 >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue2 ; length = currentLength ; return this ; }", "nl": "Puts one byte and two shorts into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "public void visit ( final String name , final Object value ) { if ( av != null ) { av . visit ( name , value ) ; } }", "nl": "Visits a primitive value of the annotation ."}}
{"translation": {"code": "public ByteVector putInt ( final int intValue ) { int currentLength = length ; if ( currentLength + 4 > data . length ) { enlarge ( 4 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 24 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 16 ) ; currentData [ currentLength ++ ] = ( byte ) ( intValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) intValue ; length = currentLength ; return this ; }", "nl": "Puts an int into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "private static int parseType ( final String signature , final int startOffset , final SignatureVisitor signatureVisitor ) { int offset = startOffset ; // Current offset in the parsed signature. char currentChar = signature . charAt ( offset ++ ) ; // The signature character at 'offset'. // Switch based on the first character of the JavaTypeSignature, which indicates its kind. switch ( currentChar ) { case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : // Case of a BaseType or a VoidDescriptor. signatureVisitor . visitBaseType ( currentChar ) ; return offset ; case ' ' : // Case of an ArrayTypeSignature, a '[' followed by a JavaTypeSignature. return parseType ( signature , offset , signatureVisitor . visitArrayType ( ) ) ; case ' ' : // Case of TypeVariableSignature, an identifier between 'T' and ';'. int endOffset = signature . indexOf ( ' ' , offset ) ; signatureVisitor . visitTypeVariable ( signature . substring ( offset , endOffset ) ) ; return endOffset + 1 ; case ' ' : // Case of a ClassTypeSignature, which ends with ';'. // These signatures have a main class type followed by zero or more inner class types // (separated by '.'). Each can have type arguments, inside '<' and '>'. int start = offset ; // The start offset of the currently parsed main or inner class name. boolean visited = false ; // Whether the currently parsed class name has been visited. boolean inner = false ; // Whether we are currently parsing an inner class type. // Parses the signature, one character at a time. while ( true ) { currentChar = signature . charAt ( offset ++ ) ; if ( currentChar == ' ' || currentChar == ' ' ) { // If a '.' or ';' is encountered, this means we have fully parsed the main class name // or an inner class name. This name may already have been visited it is was followed by // type arguments between '<' and '>'. If not, we need to visit it here. if ( ! visited ) { String name = signature . substring ( start , offset - 1 ) ; if ( inner ) { signatureVisitor . visitInnerClassType ( name ) ; } else { signatureVisitor . visitClassType ( name ) ; } } // If we reached the end of the ClassTypeSignature return, otherwise start the parsing // of a new class name, which is necessarily an inner class name. if ( currentChar == ' ' ) { signatureVisitor . visitEnd ( ) ; break ; } start = offset ; visited = false ; inner = true ; } else if ( currentChar == ' ' ) { // If a '<' is encountered, this means we have fully parsed the main class name or an // inner class name, and that we now need to parse TypeArguments. First, we need to // visit the parsed class name. String name = signature . substring ( start , offset - 1 ) ; if ( inner ) { signatureVisitor . visitInnerClassType ( name ) ; } else { signatureVisitor . visitClassType ( name ) ; } visited = true ; // Now, parse the TypeArgument(s), one at a time. while ( ( currentChar = signature . charAt ( offset ) ) != ' ' ) { switch ( currentChar ) { case ' ' : // Unbounded TypeArgument. ++ offset ; signatureVisitor . visitTypeArgument ( ) ; break ; case ' ' : case ' ' : // Extends or Super TypeArgument. Use offset + 1 to skip the '+' or '-'. offset = parseType ( signature , offset + 1 , signatureVisitor . visitTypeArgument ( currentChar ) ) ; break ; default : // Instanceof TypeArgument. The '=' is implicit. offset = parseType ( signature , offset , signatureVisitor . visitTypeArgument ( ' ' ) ) ; break ; } } } } return offset ; default : throw new IllegalArgumentException ( ) ; } }", "nl": "Parses a JavaTypeSignature and makes the given visitor visit it ."}}
{"translation": {"code": "final ByteVector put112 ( final int byteValue1 , final int byteValue2 , final int shortValue ) { int currentLength = length ; if ( currentLength + 4 > data . length ) { enlarge ( 4 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) byteValue1 ; currentData [ currentLength ++ ] = ( byte ) byteValue2 ; currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue ; length = currentLength ; return this ; }", "nl": "Puts two bytes and a short into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "public String getClassName ( ) { switch ( sort ) { case VOID : return \"void\" ; case BOOLEAN : return \"boolean\" ; case CHAR : return \"char\" ; case BYTE : return \"byte\" ; case SHORT : return \"short\" ; case INT : return \"int\" ; case FLOAT : return \"float\" ; case LONG : return \"long\" ; case DOUBLE : return \"double\" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( \"[]\" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }", "nl": "Returns the binary name of the class corresponding to this type . This method must not be used on method types ."}}
{"translation": {"code": "int computeAttributesSize ( ) { symbolTable . addConstantUtf8 ( Constants . MODULE ) ; // 6 attribute header bytes, 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int size = 22 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; if ( packageCount > 0 ) { symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ; // 6 attribute header bytes, and 2 bytes for package_count. size += 8 + packageIndex . length ; } if ( mainClassIndex > 0 ) { symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ; // 6 attribute header bytes, and 2 bytes for main_class_index. size += 8 ; } return size ; }", "nl": "Returns the size of the Module ModulePackages and ModuleMainClass attributes generated by this ModuleWriter . Also add the names of these attributes in the constant pool ."}}
{"translation": {"code": "final ByteVector put12 ( final int byteValue , final int shortValue ) { int currentLength = length ; if ( currentLength + 3 > data . length ) { enlarge ( 3 ) ; } byte [ ] currentData = data ; currentData [ currentLength ++ ] = ( byte ) byteValue ; currentData [ currentLength ++ ] = ( byte ) ( shortValue >>> 8 ) ; currentData [ currentLength ++ ] = ( byte ) shortValue ; length = currentLength ; return this ; }", "nl": "Puts a byte and a short into this byte vector . The byte vector is automatically enlarged if necessary ."}}
{"translation": {"code": "void putAttributes ( final ByteVector output ) { // 6 bytes for name, flags and version, and 5 * 2 bytes for counts. int moduleAttributeLength = 16 + requires . length + exports . length + opens . length + usesIndex . length + provides . length ; output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE ) ) . putInt ( moduleAttributeLength ) . putShort ( moduleNameIndex ) . putShort ( moduleFlags ) . putShort ( moduleVersionIndex ) . putShort ( requiresCount ) . putByteArray ( requires . data , 0 , requires . length ) . putShort ( exportsCount ) . putByteArray ( exports . data , 0 , exports . length ) . putShort ( opensCount ) . putByteArray ( opens . data , 0 , opens . length ) . putShort ( usesCount ) . putByteArray ( usesIndex . data , 0 , usesIndex . length ) . putShort ( providesCount ) . putByteArray ( provides . data , 0 , provides . length ) ; if ( packageCount > 0 ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_PACKAGES ) ) . putInt ( 2 + packageIndex . length ) . putShort ( packageCount ) . putByteArray ( packageIndex . data , 0 , packageIndex . length ) ; } if ( mainClassIndex > 0 ) { output . putShort ( symbolTable . addConstantUtf8 ( Constants . MODULE_MAIN_CLASS ) ) . putInt ( 2 ) . putShort ( mainClassIndex ) ; } }", "nl": "Puts the Module ModulePackages and ModuleMainClass attributes generated by this ModuleWriter in the given ByteVector ."}}