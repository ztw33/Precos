{"translation": {"code": "public static URL [ ] of ( ClassLoader classLoader , Class clazz ) { if ( clazz == null ) { clazz = ClassPathURLs . class ; } if ( classLoader == null ) { classLoader = clazz . getClassLoader ( ) ; } final Set < URL > urls = new LinkedHashSet <> ( ) ; while ( classLoader != null ) { if ( classLoader instanceof URLClassLoader ) { final URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; return urlClassLoader . getURLs ( ) ; } final URL url = classModuleUrl ( classLoader , clazz ) ; if ( url != null ) { urls . add ( url ) ; } classLoader = classLoader . getParent ( ) ; } return urls . toArray ( new URL [ 0 ] ) ; }", "nl": "Returns urls for the classloader"}}
{"translation": {"code": "public static URL [ ] of ( ClassLoader classLoader , Class clazz ) { if ( clazz == null ) { clazz = ClassPathURLs . class ; } if ( classLoader == null ) { classLoader = clazz . getClassLoader ( ) ; } final Set < URL > urls = new LinkedHashSet <> ( ) ; while ( classLoader != null ) { if ( classLoader instanceof URLClassLoader ) { URLClassLoader urlClassLoader = ( URLClassLoader ) classLoader ; URL [ ] allURLS = urlClassLoader . getURLs ( ) ; Collections . addAll ( urls , allURLS ) ; break ; } URL classUrl = classModuleUrl ( classLoader , clazz ) ; if ( classUrl != null ) { urls . add ( classUrl ) ; } classUrl = classModuleUrl ( classLoader , ClassPathURLs . class ) ; if ( classUrl != null ) { urls . add ( classUrl ) ; } ModuleDescriptor moduleDescriptor = clazz . getModule ( ) . getDescriptor ( ) ; if ( moduleDescriptor != null ) { moduleDescriptor . requires ( ) . forEach ( req -> { ModuleLayer . boot ( ) . findModule ( req . name ( ) ) . ifPresent ( mod -> { ClassLoader moduleClassLoader = mod . getClassLoader ( ) ; if ( moduleClassLoader != null ) { URL url = moduleClassLoader . getResource ( MANIFEST ) ; if ( url != null ) { url = fixManifestUrl ( url ) ; urls . add ( url ) ; } } } ) ; } ) ; } classLoader = classLoader . getParent ( ) ; } return urls . toArray ( new URL [ 0 ] ) ; }", "nl": "Returns urls for the classloader ."}}
{"translation": {"code": "public FindFile onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }", "nl": "Registers file consumer"}}
{"translation": {"code": "public ClassScanner scan ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }", "nl": "Scans provided paths ."}}
{"translation": {"code": "public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }", "nl": "Sets excluded names that narrows included set of packages ."}}
{"translation": {"code": "public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }", "nl": "Sets included set of names that will be considered during configuration ."}}
{"translation": {"code": "public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }", "nl": "Specify included jars ."}}
{"translation": {"code": "protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }", "nl": "Resolves action config ."}}
{"translation": {"code": "public RawData as ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }", "nl": "Defines mime type by providing real mime type or just extension!"}}
{"translation": {"code": "public RouteChunk add ( final String newValue ) { RouteChunk routeChunk = new RouteChunk ( routes , this , newValue ) ; if ( children == null ) { children = new RouteChunk [ ] { routeChunk } ; } else { children = ArraysUtil . append ( children , routeChunk ) ; } return routeChunk ; }", "nl": "Adds a new child to the tree ."}}
{"translation": {"code": "public static File moveFileToDir ( final File srcFile , final File destDir ) throws IOException { checkExistsAndDirectory ( destDir ) ; return moveFile ( srcFile , file ( destDir , srcFile . getName ( ) ) ) ; }", "nl": "Moves a file to a directory ."}}
{"translation": {"code": "private static void _moveDirectory ( final File srcDest , File destDir ) throws IOException { if ( destDir . exists ( ) ) { checkIsDirectory ( destDir ) ; destDir = file ( destDir , destDir . getName ( ) ) ; destDir . mkdir ( ) ; } final boolean rename = srcDest . renameTo ( destDir ) ; if ( ! rename ) { _copyDirectory ( srcDest , destDir ) ; deleteDir ( srcDest ) ; } }", "nl": "Moves a directory ."}}
{"translation": {"code": "public static void delete ( final File dest ) throws IOException { if ( dest . isDirectory ( ) ) { deleteDir ( dest ) ; return ; } deleteFile ( dest ) ; }", "nl": "Smart delete of destination file or directory ."}}
{"translation": {"code": "public static boolean isBinary ( final File file ) throws IOException { byte [ ] bytes = readBytes ( file , 128 ) ; for ( byte b : bytes ) { if ( b < 32 && b != 9 && b != 10 && b != 13 ) { return true ; } } return false ; }", "nl": "Checks the start of the file for ASCII control characters"}}
{"translation": {"code": "public static void appendString ( final File dest , final String data , final String encoding ) throws IOException { outString ( dest , data , encoding , true ) ; }", "nl": "Appends String . append = true"}}
{"translation": {"code": "public static void writeString ( final File dest , final String data , final String encoding ) throws IOException { outString ( dest , data , encoding , false ) ; }", "nl": "Writes String . append = false"}}
{"translation": {"code": "public static byte [ ] readBytes ( final File file , final int count ) throws IOException { checkExists ( file ) ; checkIsFile ( file ) ; long numToRead = file . length ( ) ; if ( numToRead >= Integer . MAX_VALUE ) { throw new IOException ( \"File is larger then max array size\" ) ; } if ( count > NEGATIVE_ONE && count < numToRead ) { numToRead = count ; } byte [ ] bytes = new byte [ ( int ) numToRead ] ; RandomAccessFile randomAccessFile = new RandomAccessFile ( file , \"r\" ) ; randomAccessFile . readFully ( bytes ) ; randomAccessFile . close ( ) ; return bytes ; }", "nl": "Read file and returns byte array with contents ."}}
{"translation": {"code": "public static void appendBytes ( final File dest , final byte [ ] data , final int off , final int len ) throws IOException { outBytes ( dest , data , off , len , true ) ; }", "nl": "Appends bytes . append = true"}}
{"translation": {"code": "public static void writeChars ( final File dest , final char [ ] data , final String encoding ) throws IOException { outChars ( dest , data , encoding , false ) ; }", "nl": "Write characters . append = false"}}
{"translation": {"code": "private static void checkDirCopy ( final File srcDir , final File destDir ) throws IOException { checkExists ( srcDir ) ; checkIsDirectory ( srcDir ) ; if ( equals ( srcDir , destDir ) ) { throw new IOException ( \"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are equal\" ) ; } }", "nl": "Checks that srcDir exists that it is a directory and if srcDir and destDir are not equal ."}}
{"translation": {"code": "public String sendMail ( final Email email ) { try { final MimeMessage msg = createMessage ( email ) ; getService ( ) . sendMessage ( msg , msg . getAllRecipients ( ) ) ; return msg . getMessageID ( ) ; } catch ( final MessagingException msgexc ) { throw new MailException ( \"Failed to send email: \" + email , msgexc ) ; } }", "nl": "Prepares message and sends it . Returns Message ID of sent email ."}}
{"translation": {"code": "private void setHeaders ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { final Map < String , String > headers = emailWithData . headers ( ) ; if ( headers != null ) { for ( final Map . Entry < String , String > entry : headers . entrySet ( ) ) { msgToSet . setHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } } }", "nl": "Sets headers in msgToSet with headers from emailWithData ."}}
{"translation": {"code": "private void setSentDate ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { Date date = emailWithData . sentDate ( ) ; if ( date == null ) { date = new Date ( ) ; } msgToSet . setSentDate ( date ) ; }", "nl": "Sets sent date in msgToSet with sent date from emailWithData ."}}
{"translation": {"code": "public EmailAttachmentBuilder name ( final String name ) { if ( name != null && ! name . trim ( ) . isEmpty ( ) ) { this . name = name ; } return this ; }", "nl": "Sets file name ."}}
{"translation": {"code": "public EmailFilter not ( final EmailFilter emailFilter ) { final SearchTerm searchTerm = new NotTerm ( emailFilter . searchTerm ) ; concat ( searchTerm ) ; return this ; }", "nl": "Appends single filter as NOT ."}}
{"translation": {"code": "public EmailFilter and ( final EmailFilter ... emailFilters ) { final SearchTerm [ ] searchTerms = new SearchTerm [ emailFilters . length ] ; for ( int i = 0 ; i < emailFilters . length ; i ++ ) { searchTerms [ i ] = emailFilters [ i ] . searchTerm ; } concat ( new AndTerm ( searchTerms ) ) ; return this ; }", "nl": "Defines AND group of filters ."}}
{"translation": {"code": "public EmailFilter size ( final Operator comparison , final int size ) { final SearchTerm term = new SizeTerm ( comparison . value , size ) ; concat ( term ) ; return this ; }", "nl": "Defines filter for message size ."}}
{"translation": {"code": "private void setPeople ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { msgToSet . setFrom ( emailWithData . from ( ) . toInternetAddress ( ) ) ; msgToSet . setReplyTo ( EmailAddress . convert ( emailWithData . replyTo ( ) ) ) ; setRecipients ( emailWithData , msgToSet ) ; }", "nl": "Sets FROM REPLY - TO and recipients ."}}
{"translation": {"code": "public EmailFilter bcc ( final String bccAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . BCC , bccAddress ) ; concat ( toTerm ) ; return this ; }", "nl": "Defines filter for BCC field ."}}
{"translation": {"code": "public EmailFilter cc ( final String ccAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . CC , ccAddress ) ; concat ( toTerm ) ; return this ; }", "nl": "Defines filter for CC field ."}}
{"translation": {"code": "public EmailFilter to ( final String toAddress ) { final SearchTerm toTerm = new RecipientStringTerm ( RecipientType . TO , toAddress ) ; concat ( toTerm ) ; return this ; }", "nl": "Defines filter for TO field ."}}
{"translation": {"code": "public EmailFilter from ( final String fromAddress ) { final SearchTerm fromTerm = new FromStringTerm ( fromAddress ) ; concat ( fromTerm ) ; return this ; }", "nl": "Defines filter for FROM field ."}}
{"translation": {"code": "public EmailFilter messageId ( final String messageId ) { final SearchTerm msgIdTerm = new MessageIDTerm ( messageId ) ; concat ( msgIdTerm ) ; return this ; }", "nl": "Defines filter for message id ."}}
{"translation": {"code": "public EmailFilter subject ( final String subject ) { final SearchTerm subjectTerm = new SubjectTerm ( subject ) ; concat ( subjectTerm ) ; return this ; }", "nl": "Defines filter for SUBJECT field ."}}
{"translation": {"code": "public EmailFilter flag ( final Flag flag , final boolean value ) { final Flags flags = new Flags ( ) ; flags . add ( flag ) ; return flags ( flags , value ) ; }", "nl": "Defines filter for single flag ."}}
{"translation": {"code": "private void setRecipients ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { // TO final InternetAddress [ ] to = EmailAddress . convert ( emailWithData . to ( ) ) ; if ( to . length > 0 ) { msgToSet . setRecipients ( RecipientType . TO , to ) ; } // CC final InternetAddress [ ] cc = EmailAddress . convert ( emailWithData . cc ( ) ) ; if ( cc . length > 0 ) { msgToSet . setRecipients ( RecipientType . CC , cc ) ; } // BCC final InternetAddress [ ] bcc = EmailAddress . convert ( emailWithData . bcc ( ) ) ; if ( bcc . length > 0 ) { msgToSet . setRecipients ( RecipientType . BCC , bcc ) ; } }", "nl": "Sets TO CC and BCC in msgToSet with TO CC and BCC from emailWithData ."}}
{"translation": {"code": "private void setContent ( final EmailMessage emailWithData , final Part partToSet ) throws MessagingException { partToSet . setContent ( emailWithData . getContent ( ) , emailWithData . getMimeType ( ) + CHARSET + emailWithData . getEncoding ( ) ) ; }", "nl": "Sets emailWithData content into msgToSet ."}}
{"translation": {"code": "private void addBodyData ( final Email emailWithData , final MimeMessage msgToSet ) throws MessagingException { final List < EmailMessage > messages = emailWithData . messages ( ) ; final int totalMessages = messages . size ( ) ; // Need to use new list since filterEmbeddedAttachments(List) removes attachments from the source List final List < EmailAttachment < ? extends DataSource > > attachments = new ArrayList <> ( emailWithData . attachments ( ) ) ; if ( attachments . isEmpty ( ) && totalMessages == 1 ) { // special case: no attachments and just one content setContent ( messages . get ( 0 ) , msgToSet ) ; } else { final MimeMultipart multipart = new MimeMultipart ( ) ; final MimeMultipart msgMultipart = new MimeMultipart ( ALTERNATIVE ) ; multipart . addBodyPart ( getBaseBodyPart ( msgMultipart ) ) ; for ( final EmailMessage emailMessage : messages ) { msgMultipart . addBodyPart ( getBodyPart ( emailMessage , attachments ) ) ; } addAnyAttachments ( attachments , multipart ) ; msgToSet . setContent ( multipart ) ; } }", "nl": "Adds message data and attachments ."}}
{"translation": {"code": "public void writeToFile ( final File destination ) { InputStream input = null ; final OutputStream output ; try { input = getDataSource ( ) . getInputStream ( ) ; output = new FileOutputStream ( destination ) ; StreamUtil . copy ( input , output ) ; } catch ( final IOException ioex ) { throw new MailException ( ioex ) ; } finally { StreamUtil . close ( input ) ; } }", "nl": "Saves attachment to a file ."}}
{"translation": {"code": "public byte [ ] toByteArray ( ) { final FastByteArrayOutputStream out ; if ( size != - 1 ) { out = new FastByteArrayOutputStream ( size ) ; } else { out = new FastByteArrayOutputStream ( ) ; } writeToStream ( out ) ; return out . toByteArray ( ) ; }", "nl": "Returns byte content of the attachment ."}}
{"translation": {"code": "public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( \"Failed to connect to folder: \" + folderName , msgexc ) ; } }", "nl": "Opens new folder and closes previously opened folder ."}}
{"translation": {"code": "public void writeToStream ( final OutputStream out ) { InputStream input = null ; try { input = getDataSource ( ) . getInputStream ( ) ; StreamUtil . copy ( input , out ) ; } catch ( final IOException ioex ) { throw new MailException ( ioex ) ; } finally { StreamUtil . close ( input ) ; } }", "nl": "Saves attachment to the output stream ."}}
{"translation": {"code": "public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }", "nl": "Sets the FROM address by providing personal name and address ."}}
{"translation": {"code": "public T to ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }", "nl": "Appends TO address ."}}
{"translation": {"code": "public T htmlMessage ( final String html , final String encoding ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }", "nl": "Adds HTML message ."}}
{"translation": {"code": "public T replyTo ( final EmailAddress ... replyTo ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( replyTo ) ) ; return _this ( ) ; }", "nl": "Appends REPLY - TO addresses ."}}
{"translation": {"code": "protected MimeBodyPart createAttachmentBodyPart ( final EmailAttachment < ? extends DataSource > attachment ) throws MessagingException { final MimeBodyPart part = new MimeBodyPart ( ) ; final String attachmentName = attachment . getEncodedName ( ) ; if ( attachmentName != null ) { part . setFileName ( attachmentName ) ; } part . setDataHandler ( new DataHandler ( attachment . getDataSource ( ) ) ) ; if ( attachment . getContentId ( ) != null ) { part . setContentID ( StringPool . LEFT_CHEV + attachment . getContentId ( ) + StringPool . RIGHT_CHEV ) ; } if ( attachment . isInline ( ) ) { part . setDisposition ( INLINE ) ; } return part ; }", "nl": "Creates attachment body part . Handles regular and inline attachments ."}}
{"translation": {"code": "public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }", "nl": "Appends TO address by personal name and email address ."}}
{"translation": {"code": "public JsonParser lazy ( final boolean lazy ) { this . lazy = lazy ; this . mapSupplier = lazy ? LAZYMAP_SUPPLIER : HASHMAP_SUPPLIER ; this . listSupplier = lazy ? LAZYLIST_SUPPLIER : ARRAYLIST_SUPPLIER ; return this ; }", "nl": "Defines how JSON parser works . In non - lazy mode the whole JSON is parsed as it is . In the lazy mode not everything is parsed but some things are left lazy . This way we gain performance especially on partial usage of the whole JSON . However be aware that parser holds the input memory until the returned objects are disposed ."}}
{"translation": {"code": "public static byte [ ] getBytes ( final String string ) { try { return string . getBytes ( JoddCore . encoding ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } }", "nl": "Returns String bytes using Jodds default encoding ."}}
{"translation": {"code": "private Object resolveLazyValue ( Object value ) { if ( value instanceof Supplier ) { value = ( ( Supplier ) value ) . get ( ) ; } return value ; }", "nl": "Resolves lazy value during the parsing runtime ."}}
{"translation": {"code": "public static Calendar toCalendar ( final LocalDateTime localDateTime ) { return GregorianCalendar . from ( ZonedDateTime . of ( localDateTime , ZoneId . systemDefault ( ) ) ) ; }", "nl": "Converts local date time to Calendar ."}}
{"translation": {"code": "public static Date toDate ( final LocalDate localDate ) { return Date . from ( localDate . atStartOfDay ( ZoneId . systemDefault ( ) ) . toInstant ( ) ) ; }", "nl": "Converts local date to Date ."}}
{"translation": {"code": "public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }", "nl": "Reads HTTP request body using the request stream . Once body is read it cannot be read again!"}}
{"translation": {"code": "public void updateEmailFlags ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , true ) ; } catch ( MessagingException mex ) { throw new MailException ( \"Failed to fetch messages\" , mex ) ; } }", "nl": "Updates the email flags on the server ."}}
{"translation": {"code": "protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } } // new scope detected final MadvocScope newScope ; try { newScope = madpc . createBean ( madvocScopeType ) ; } catch ( Exception ex ) { throw new MadvocException ( \"Unable to create scope: \" + madvocScopeType , ex ) ; } allScopes . add ( newScope ) ; return newScope ; }", "nl": "Performs search for the scope class and returns it s instance ."}}
{"translation": {"code": "public void forEachTargetAndIn ( final MadvocScope scope , final BiConsumer < Target , InjectionPoint > biConsumer ) { for ( final Target target : targets ) { final ScopeData scopeData = target . scopeData ( ) ; if ( scopeData . in ( ) == null ) { continue ; } for ( final InjectionPoint in : scopeData . in ( ) ) { if ( in . scope ( ) != scope ) { continue ; } biConsumer . accept ( target , in ) ; } } }", "nl": "Iterates all targets and for each target iterates all IN injection points of given scope ."}}
{"translation": {"code": "public String readRequestBody ( ) { if ( requestBody == null ) { try { requestBody = ServletUtil . readRequestBodyFromStream ( getHttpServletRequest ( ) ) ; } catch ( IOException ioex ) { requestBody = StringPool . EMPTY ; } } return requestBody ; }", "nl": "Reads request body only once and returns it to user ."}}
{"translation": {"code": "public void visitTryCatchBlock ( final Label start , final Label end , final Label handler , final String type ) { if ( mv != null ) { mv . visitTryCatchBlock ( start , end , handler , type ) ; } }", "nl": "Visits a try catch block ."}}
{"translation": {"code": "public void visitMultiANewArrayInsn ( final String descriptor , final int numDimensions ) { if ( mv != null ) { mv . visitMultiANewArrayInsn ( descriptor , numDimensions ) ; } }", "nl": "Visits a MULTIANEWARRAY instruction ."}}
{"translation": {"code": "public void visitJumpInsn ( final int opcode , final Label label ) { if ( mv != null ) { mv . visitJumpInsn ( opcode , label ) ; } }", "nl": "Visits a jump instruction . A jump instruction is an instruction that may jump to another instruction ."}}
{"translation": {"code": "public AnnotationVisitor visitAnnotation ( final String descriptor , final boolean visible ) { if ( mv != null ) { return mv . visitAnnotation ( descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation of this method ."}}
{"translation": {"code": "public void visitParameter ( final String name , final int access ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { mv . visitParameter ( name , access ) ; } }", "nl": "Visits a parameter of this method ."}}
{"translation": {"code": "public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }", "nl": "Returns the size of values of this type . This method must not be used for method types ."}}
{"translation": {"code": "private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }", "nl": "Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table ."}}
{"translation": {"code": "public AnnotationVisitor visitParameterAnnotation ( final int parameter , final String descriptor , final boolean visible ) { if ( mv != null ) { return mv . visitParameterAnnotation ( parameter , descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation of a parameter this method ."}}
{"translation": {"code": "private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }", "nl": "Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "private void addConstantIntegerOrFloat ( final int index , final int tag , final int value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }", "nl": "Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table ."}}
{"translation": {"code": "private void endCurrentBasicBlockWithNoSuccessor ( ) { if ( compute == COMPUTE_ALL_FRAMES ) { Label nextBasicBlock = new Label ( ) ; nextBasicBlock . frame = new Frame ( nextBasicBlock ) ; nextBasicBlock . resolve ( code . data , code . length ) ; lastBasicBlock . nextBasicBlock = nextBasicBlock ; lastBasicBlock = nextBasicBlock ; currentBasicBlock = null ; } else if ( compute == COMPUTE_MAX_STACK_AND_LOCAL ) { currentBasicBlock . outputStackMax = ( short ) maxRelativeStackSize ; currentBasicBlock = null ; } }", "nl": "Ends the current basic block . This method must be used in the case where the current basic block does not have any successor ."}}
{"translation": {"code": "private void enlarge ( final int size ) { int doubleCapacity = 2 * data . length ; int minimalCapacity = length + size ; byte [ ] newData = new byte [ doubleCapacity > minimalCapacity ? doubleCapacity : minimalCapacity ] ; System . arraycopy ( data , 0 , newData , 0 , length ) ; data = newData ; }", "nl": "Enlarges this byte vector so that it can receive size more bytes ."}}
{"translation": {"code": "static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }", "nl": "Returns the number of elements of the Handler list that begins with the given element ."}}
{"translation": {"code": "private static byte [ ] readStream ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( \"Class not found\" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }", "nl": "Reads the given input stream and returns its content as a byte array ."}}
{"translation": {"code": "private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }", "nl": "Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset ."}}
{"translation": {"code": "private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }", "nl": "Reads a JVMS verification_type_info structure and stores it at the given index in the given array ."}}
{"translation": {"code": "private void addConstantLongOrDouble ( final int index , final int tag , final long value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }", "nl": "Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table ."}}
{"translation": {"code": "private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }", "nl": "Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "public AnnotationVisitor visitLocalVariableAnnotation ( final int typeRef , final TypePath typePath , final Label [ ] start , final Label [ ] end , final int [ ] index , final String descriptor , final boolean visible ) { if ( api < Opcodes . ASM5 ) { throw new UnsupportedOperationException ( REQUIRES_ASM5 ) ; } if ( mv != null ) { return mv . visitLocalVariableAnnotation ( typeRef , typePath , start , end , index , descriptor , visible ) ; } return null ; }", "nl": "Visits an annotation on a local variable type ."}}
{"translation": {"code": "Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }", "nl": "Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) { // TODO sort the arguments? The merge result should be independent of their order. long data = typeTableIndex1 | ( ( ( long ) typeTableIndex2 ) << 32 ) ; int hashCode = hash ( Symbol . MERGED_TYPE_TAG , typeTableIndex1 + typeTableIndex2 ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . MERGED_TYPE_TAG && entry . hashCode == hashCode && entry . data == data ) { return entry . info ; } entry = entry . next ; } String type1 = typeTable [ typeTableIndex1 ] . value ; String type2 = typeTable [ typeTableIndex2 ] . value ; int commonSuperTypeIndex = addType ( classWriter . getCommonSuperClass ( type1 , type2 ) ) ; put ( new Entry ( typeCount , Symbol . MERGED_TYPE_TAG , data , hashCode ) ) . info = commonSuperTypeIndex ; return commonSuperTypeIndex ; }", "nl": "Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type ."}}
{"translation": {"code": "void putConstantPool ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }", "nl": "Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value ."}}
{"translation": {"code": "private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }", "nl": "Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table ."}}
{"translation": {"code": "private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }", "nl": "Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table ."}}
{"translation": {"code": "Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; } // The bootstrap method arguments can be Constant_Dynamic values, which reference other // bootstrap methods. We must therefore add the bootstrap method arguments to the constant pool // and BootstrapMethods attribute first, so that the BootstrapMethods attribute is not modified // while adding the given bootstrap method to it, in the rest of this method. for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { addConstant ( bootstrapMethodArgument ) ; } // Write the bootstrap method in the BootstrapMethods table. This is necessary to be able to // compare it with existing ones, and will be reverted below if there is already a similar // bootstrap method. int bootstrapMethodOffset = bootstrapMethodsAttribute . length ; bootstrapMethodsAttribute . putShort ( addConstantMethodHandle ( bootstrapMethodHandle . getTag ( ) , bootstrapMethodHandle . getOwner ( ) , bootstrapMethodHandle . getName ( ) , bootstrapMethodHandle . getDesc ( ) , bootstrapMethodHandle . isInterface ( ) ) . index ) ; int numBootstrapArguments = bootstrapMethodArguments . length ; bootstrapMethodsAttribute . putShort ( numBootstrapArguments ) ; for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { bootstrapMethodsAttribute . putShort ( addConstant ( bootstrapMethodArgument ) . index ) ; } // Compute the length and the hash code of the bootstrap method. int bootstrapMethodlength = bootstrapMethodsAttribute . length - bootstrapMethodOffset ; int hashCode = bootstrapMethodHandle . hashCode ( ) ; for ( Object bootstrapMethodArgument : bootstrapMethodArguments ) { hashCode ^= bootstrapMethodArgument . hashCode ( ) ; } hashCode &= 0x7FFFFFFF ; // Add the bootstrap method to the symbol table or revert the above changes. return addBootstrapMethod ( bootstrapMethodOffset , bootstrapMethodlength , hashCode ) ; }", "nl": "Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method ."}}
{"translation": {"code": "int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }", "nl": "Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool ."}}
{"translation": {"code": "private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) { // Find attributOffset of the 'bootstrap_methods' array. byte [ ] inputBytes = classReader . b ; int currentAttributeOffset = classReader . getFirstAttributeOffset ( ) ; for ( int i = classReader . readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { String attributeName = classReader . readUTF8 ( currentAttributeOffset , charBuffer ) ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { bootstrapMethodCount = classReader . readUnsignedShort ( currentAttributeOffset + 6 ) ; break ; } currentAttributeOffset += 6 + classReader . readInt ( currentAttributeOffset + 2 ) ; } if ( bootstrapMethodCount > 0 ) { // Compute the offset and the length of the BootstrapMethods 'bootstrap_methods' array. int bootstrapMethodsOffset = currentAttributeOffset + 8 ; int bootstrapMethodsLength = classReader . readInt ( currentAttributeOffset + 2 ) - 2 ; bootstrapMethods = new ByteVector ( bootstrapMethodsLength ) ; bootstrapMethods . putByteArray ( inputBytes , bootstrapMethodsOffset , bootstrapMethodsLength ) ; // Add each bootstrap method in the symbol table entries. int currentOffset = bootstrapMethodsOffset ; for ( int i = 0 ; i < bootstrapMethodCount ; i ++ ) { int offset = currentOffset - bootstrapMethodsOffset ; int bootstrapMethodRef = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int numBootstrapArguments = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; int hashCode = classReader . readConst ( bootstrapMethodRef , charBuffer ) . hashCode ( ) ; while ( numBootstrapArguments -- > 0 ) { int bootstrapArgument = classReader . readUnsignedShort ( currentOffset ) ; currentOffset += 2 ; hashCode ^= classReader . readConst ( bootstrapArgument , charBuffer ) . hashCode ( ) ; } add ( new Entry ( i , Symbol . BOOTSTRAP_METHOD_TAG , offset , hashCode & 0x7FFFFFFF ) ) ; } } }", "nl": "Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable ."}}
{"translation": {"code": "private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }", "nl": "Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "final void setInputFrameFromApiFormat ( final SymbolTable symbolTable , final int numLocal , final Object [ ] local , final int numStack , final Object [ ] stack ) { int inputLocalIndex = 0 ; for ( int i = 0 ; i < numLocal ; ++ i ) { inputLocals [ inputLocalIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , local [ i ] ) ; if ( local [ i ] == Opcodes . LONG || local [ i ] == Opcodes . DOUBLE ) { inputLocals [ inputLocalIndex ++ ] = TOP ; } } while ( inputLocalIndex < inputLocals . length ) { inputLocals [ inputLocalIndex ++ ] = TOP ; } int numStackTop = 0 ; for ( int i = 0 ; i < numStack ; ++ i ) { if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { ++ numStackTop ; } } inputStack = new int [ numStack + numStackTop ] ; int inputStackIndex = 0 ; for ( int i = 0 ; i < numStack ; ++ i ) { inputStack [ inputStackIndex ++ ] = getAbstractTypeFromApiFormat ( symbolTable , stack [ i ] ) ; if ( stack [ i ] == Opcodes . LONG || stack [ i ] == Opcodes . DOUBLE ) { inputStack [ inputStackIndex ++ ] = TOP ; } } outputStackTop = 0 ; initializationCount = 0 ; }", "nl": "Sets the input frame from the given public API frame description ."}}
{"translation": {"code": "static int getAbstractTypeFromApiFormat ( final SymbolTable symbolTable , final Object type ) { if ( type instanceof Integer ) { return CONSTANT_KIND | ( ( Integer ) type ) . intValue ( ) ; } else if ( type instanceof String ) { String descriptor = Type . getObjectType ( ( String ) type ) . getDescriptor ( ) ; return getAbstractTypeFromDescriptor ( symbolTable , descriptor , 0 ) ; } else { return UNINITIALIZED_KIND | symbolTable . addUninitializedType ( \"\" , ( ( Label ) type ) . bytecodeOffset ) ; } }", "nl": "Returns the abstract type corresponding to the given public API frame element type ."}}
{"translation": {"code": "Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; // Note that we don't need to include isInterface in the hash computation, because it is // redundant with owner (we can't have the same owner with different isInterface values). int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == referenceKind && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } if ( referenceKind <= Opcodes . H_PUTSTATIC ) { constantPool . put112 ( tag , referenceKind , addConstantFieldref ( owner , name , descriptor ) . index ) ; } else { constantPool . put112 ( tag , referenceKind , addConstantMethodref ( owner , name , descriptor , isInterface ) . index ) ; } return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }", "nl": "Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "protected void printRoutes ( final int width ) { final ActionsManager actionsManager = webApp . madvocContainer ( ) . lookupComponent ( ActionsManager . class ) ; final List < ActionRuntime > actions = actionsManager . getAllActionRuntimes ( ) ; final Map < String , String > aliases = actionsManager . getAllAliases ( ) ; if ( actions . isEmpty ( ) ) { return ; } final Print print = new Print ( ) ; print . line ( \"Routes\" , width ) ; actions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { final String actionMethod = ar . getActionMethod ( ) ; print . out ( Chalk256 . chalk ( ) . yellow ( ) , actionMethod == null ? \"*\" : actionMethod , 7 ) ; print . space ( ) ; final String signature = ClassUtil . getShortClassName ( ProxettaUtil . resolveTargetClass ( ar . getActionClass ( ) ) , 2 ) + ' ' + ar . getActionClassMethod ( ) . getName ( ) ; print . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , ar . getActionPath ( ) , Chalk256 . chalk ( ) . blue ( ) , signature , width - 7 - 1 ) ; } ) ; if ( ! aliases . isEmpty ( ) ) { print . line ( \"Aliases\" , width ) ; actions . stream ( ) . sorted ( Comparator . comparing ( actionRuntime -> actionRuntime . getActionPath ( ) + ' ' + actionRuntime . getActionMethod ( ) ) ) . forEach ( ar -> { final String actionPath = ar . getActionPath ( ) ; for ( final Map . Entry < String , String > entry : aliases . entrySet ( ) ) { if ( entry . getValue ( ) . equals ( actionPath ) ) { print . space ( 8 ) ; print . outLeftRightNewLine ( Chalk256 . chalk ( ) . green ( ) , entry . getValue ( ) , Chalk256 . chalk ( ) . blue ( ) , entry . getKey ( ) , width - 8 ) ; } } } ) ; } print . line ( width ) ; }", "nl": "Prints routes to console ."}}
{"translation": {"code": "public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) { // implicit final int len = beanDefinition . name . length ( ) + 1 ; for ( final String param : beanDefinition . params ) { final Object value = paramManager . get ( param ) ; final String destination = param . substring ( len ) ; try { BeanUtil . declared . setProperty ( bean , destination , value ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Unable to set parameter: '\" + param + \"' to bean: \" + beanDefinition . name , ex ) ; } } } // explicit for ( final ValueInjectionPoint pip : beanDefinition . values ) { final String value = paramManager . parseKeyTemplate ( pip . valueTemplate ) ; try { BeanUtil . declared . setProperty ( bean , pip . property , value ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Unable to set value for: '\" + pip . valueTemplate + \"' to bean: \" + beanDefinition . name , ex ) ; } } }", "nl": "Injects all parameters ."}}
{"translation": {"code": "public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( \"No constructor (annotated, single or default) founded as injection point for: \" + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ; // wiring if ( beanDefinition . wiringMode != WiringMode . NONE ) { for ( int i = 0 ; i < paramNo ; i ++ ) { args [ i ] = pc . getBean ( beanDefinition . ctor . references [ i ] ) ; if ( args [ i ] == null ) { if ( ( beanDefinition . wiringMode == WiringMode . STRICT ) ) { throw new PetiteException ( \"Wiring constructor failed. References '\" + beanDefinition . ctor . references [ i ] + \"' not found for constructor: \" + beanDefinition . ctor . constructor ) ; } } } } // create instance final Object bean ; try { bean = beanDefinition . ctor . constructor . newInstance ( args ) ; } catch ( Exception ex ) { throw new PetiteException ( \"Failed to create new bean instance '\" + beanDefinition . type . getName ( ) + \"' using constructor: \" + beanDefinition . ctor . constructor , ex ) ; } return bean ; }", "nl": "Creates a new instance ."}}
{"translation": {"code": "protected static void setupSystemMailProperties ( ) { System . setProperty ( \"mail.mime.encodefilename\" , Boolean . valueOf ( Defaults . mailMimeEncodefilename ) . toString ( ) ) ; System . setProperty ( \"mail.mime.decodefilename\" , Boolean . valueOf ( Defaults . mailMimeDecodefilename ) . toString ( ) ) ; }", "nl": "Setups the system email properties ."}}
{"translation": {"code": "public String resolveRealName ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }", "nl": "Resolves real name from JSON name ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static < A > TypeCache < A > createDefault ( ) { return ( TypeCache < A > ) Defaults . implementation . get ( ) ; }", "nl": "Creates default implementation of the type cache ."}}
{"translation": {"code": "protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }", "nl": "Configure defaults ."}}
{"translation": {"code": "public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( \"Bearer \" ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }", "nl": "Returns Bearer token ."}}
{"translation": {"code": "protected T authenticateUserViaBasicAuth ( final ActionRequest actionRequest ) { final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; final String username = ServletUtil . resolveAuthUsername ( servletRequest ) ; if ( username == null ) { return null ; } final String password = ServletUtil . resolveAuthPassword ( servletRequest ) ; final T authToken = userAuth ( ) . login ( username , password ) ; if ( authToken == null ) { return null ; } return authToken ; }", "nl": "Tires to authenticate user via the basic authentication . Returns the token if user is authenticated ."}}
{"translation": {"code": "protected T authenticateUserViaToken ( final ActionRequest actionRequest ) { final HttpServletRequest servletRequest = actionRequest . getHttpServletRequest ( ) ; // then try the auth token final String token = ServletUtil . resolveAuthBearerToken ( servletRequest ) ; if ( token == null ) { return null ; } final T authToken = userAuth ( ) . validateToken ( token ) ; if ( authToken == null ) { return null ; } // granted final T newAuthToken = userAuth ( ) . rotateToken ( authToken ) ; actionRequest . getHttpServletResponse ( ) . setHeader ( \"Authentication\" , \"Bearer: \" + userAuth ( ) . tokenValue ( newAuthToken ) ) ; return newAuthToken ; }", "nl": "Tries to authenticate user via token . Returns the token if user is authenticated . Returned token may be rotated ."}}
{"translation": {"code": "public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }", "nl": "Syntax sugar ."}}
{"translation": {"code": "public Node [ ] filterChildNodes ( final Predicate < Node > nodePredicate ) { if ( childNodes == null ) { return new Node [ 0 ] ; } return childNodes . stream ( ) . filter ( nodePredicate ) . toArray ( Node [ ] :: new ) ; }", "nl": "Filters child nodes ."}}
{"translation": {"code": "public static String alignLeftAndPad ( final String text , final int size ) { int textLength = text . length ( ) ; if ( textLength > size ) { return text . substring ( 0 , size ) ; } final StringBuilder sb = new StringBuilder ( size ) ; sb . append ( text ) ; while ( textLength ++ < size ) { sb . append ( ' ' ) ; } return sb . toString ( ) ; }", "nl": "Puts the text to the left and pads with spaces until the size is reached ."}}
{"translation": {"code": "public static long getInt ( final String name , final int defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }", "nl": "Returns system property as an int ."}}
{"translation": {"code": "private String [ ] buildJrePackages ( final int javaVersionNumber ) { final ArrayList < String > packages = new ArrayList <> ( ) ; switch ( javaVersionNumber ) { case 9 : case 8 : case 7 : case 6 : case 5 : // in Java1.5, the apache stuff moved packages . add ( \"com.sun.org.apache\" ) ; // fall through... case 4 : if ( javaVersionNumber == 4 ) { packages . add ( \"org.apache.crimson\" ) ; packages . add ( \"org.apache.xalan\" ) ; packages . add ( \"org.apache.xml\" ) ; packages . add ( \"org.apache.xpath\" ) ; } packages . add ( \"org.ietf.jgss\" ) ; packages . add ( \"org.w3c.dom\" ) ; packages . add ( \"org.xml.sax\" ) ; // fall through... case 3 : packages . add ( \"org.omg\" ) ; packages . add ( \"com.sun.corba\" ) ; packages . add ( \"com.sun.jndi\" ) ; packages . add ( \"com.sun.media\" ) ; packages . add ( \"com.sun.naming\" ) ; packages . add ( \"com.sun.org.omg\" ) ; packages . add ( \"com.sun.rmi\" ) ; packages . add ( \"sunw.io\" ) ; packages . add ( \"sunw.util\" ) ; // fall through... case 2 : packages . add ( \"com.sun.java\" ) ; packages . add ( \"com.sun.image\" ) ; // fall through... case 1 : default : // core stuff packages . add ( \"sun\" ) ; packages . add ( \"java\" ) ; packages . add ( \"javax\" ) ; break ; } return packages . toArray ( new String [ 0 ] ) ; }", "nl": "Builds a set of java core packages ."}}
{"translation": {"code": "public static String convertTabsToSpaces ( final String line , final int tabWidth ) { int tab_index , tab_size ; int last_tab_index = 0 ; int added_chars = 0 ; if ( tabWidth == 0 ) { return StringUtil . remove ( line , ' ' ) ; } StringBuilder result = new StringBuilder ( ) ; while ( ( tab_index = line . indexOf ( ' ' , last_tab_index ) ) != - 1 ) { tab_size = tabWidth - ( ( tab_index + added_chars ) % tabWidth ) ; if ( tab_size == 0 ) { tab_size = tabWidth ; } added_chars += tab_size - 1 ; result . append ( line , last_tab_index , tab_index ) ; result . append ( StringUtil . repeat ( ' ' , tab_size ) ) ; last_tab_index = tab_index + 1 ; } if ( last_tab_index == 0 ) { return line ; } result . append ( line . substring ( last_tab_index ) ) ; return result . toString ( ) ; }", "nl": "Converts all tabs on a line to spaces according to the provided tab width . This is not a simple tab to spaces replacement since the resulting indentation remains the same ."}}
{"translation": {"code": "Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }", "nl": "Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item ."}}
{"translation": {"code": "public void visitNestHost ( final String nestHost ) { if ( api < Opcodes . ASM7 ) { throw new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; } if ( cv != null ) { cv . visitNestHost ( nestHost ) ; } }", "nl": "Visits the nest host class of the class . A nest is a set of classes of the same package that share access to their private members . One of these classes called the host lists the other members of the nest which in turn should link to the host of their nest . This method must be called only once and only if the visited class is a non - host member of a nest . A class is implicitly its own nest so it s invalid to call this method with the visited class name as argument ."}}
{"translation": {"code": "public void visitNestMember ( final String nestMember ) { if ( api < Opcodes . ASM7 ) { throw new UnsupportedOperationException ( \"This feature requires ASM7\" ) ; } if ( cv != null ) { cv . visitNestMember ( nestMember ) ; } }", "nl": "Visits a member of the nest . A nest is a set of classes of the same package that share access to their private members . One of these classes called the host lists the other members of the nest which in turn should link to the host of their nest . This method must be called only if the visited class is the host of a nest . A nest host is implicitly a member of its own nest so it s invalid to call this method with the visited class name as argument ."}}
{"translation": {"code": "public static int resolveJavaVersion ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return version > platformVersion ? version : platformVersion ; }", "nl": "Resolves Java version from current version ."}}
{"translation": {"code": "private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) { // Read the attribute_info's attribute_name and attribute_length fields. String attributeName = readUTF8 ( currentAttributeOffset , charBuffer ) ; int attributeLength = readInt ( currentAttributeOffset + 2 ) ; currentAttributeOffset += 6 ; if ( Constants . BOOTSTRAP_METHODS . equals ( attributeName ) ) { // Read the num_bootstrap_methods field and create an array of this size. currentBootstrapMethodOffsets = new int [ readUnsignedShort ( currentAttributeOffset ) ] ; // Compute and store the offset of each 'bootstrap_methods' array field entry. int currentBootstrapMethodOffset = currentAttributeOffset + 2 ; for ( int j = 0 ; j < currentBootstrapMethodOffsets . length ; ++ j ) { currentBootstrapMethodOffsets [ j ] = currentBootstrapMethodOffset ; // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each), // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2). currentBootstrapMethodOffset += 4 + readUnsignedShort ( currentBootstrapMethodOffset + 2 ) * 2 ; } return currentBootstrapMethodOffsets ; } currentAttributeOffset += attributeLength ; } return null ; }", "nl": "Reads the BootstrapMethods attribute to compute the offset of each bootstrap method ."}}
{"translation": {"code": "private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }", "nl": "Appends the descriptor corresponding to this type to the given string buffer ."}}
{"translation": {"code": "public String getQueryString ( ) { if ( sqlTemplate == null ) { return toString ( ) ; } if ( parameterValues == null ) { return sqlTemplate ; } final StringBuilder sb = new StringBuilder ( ) ; int qMarkCount = 0 ; final StringTokenizer tok = new StringTokenizer ( sqlTemplate + ' ' , \"?\" ) ; while ( tok . hasMoreTokens ( ) ) { final String oneChunk = tok . nextToken ( ) ; sb . append ( oneChunk ) ; try { Object value = null ; if ( parameterValues . size ( ) > 1 + qMarkCount ) { value = parameterValues . get ( 1 + qMarkCount ) ; qMarkCount ++ ; } else { if ( ! tok . hasMoreTokens ( ) ) { value = \"\" ; } } if ( value == null ) { value = \"?\" ; } sb . append ( value ) ; } catch ( Throwable th ) { sb . append ( \"--- Building query failed: \" ) . append ( th . toString ( ) ) ; } } return sb . toString ( ) . trim ( ) ; }", "nl": "Returns the query string ."}}
{"translation": {"code": "public static Socket connect ( final String hostname , final int port , final int connectionTimeout ) throws IOException { final Socket socket = new Socket ( ) ; if ( connectionTimeout <= 0 ) { socket . connect ( new InetSocketAddress ( hostname , port ) ) ; } else { socket . connect ( new InetSocketAddress ( hostname , port ) , connectionTimeout ) ; } return socket ; }", "nl": "Creates a socket with a timeout ."}}
{"translation": {"code": "public static Socket connect ( final String hostname , final int port ) throws IOException { final Socket socket = new Socket ( ) ; socket . connect ( new InetSocketAddress ( hostname , port ) ) ; return socket ; }", "nl": "Creates a socket ."}}