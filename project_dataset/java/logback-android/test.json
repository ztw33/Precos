{"translation": {"code": "private Map < String , String > mergePropertyMaps ( ILoggingEvent event ) { Map < String , String > mergedMap = new HashMap < String , String > ( ) ; // we add the context properties first, then the event properties, since // we consider that event-specific properties should have priority over // context-wide properties. Map < String , String > loggerContextMap = event . getLoggerContextVO ( ) . getPropertyMap ( ) ; if ( loggerContextMap != null ) { mergedMap . putAll ( loggerContextMap ) ; } Map < String , String > mdcMap = event . getMDCPropertyMap ( ) ; if ( mdcMap != null ) { mergedMap . putAll ( mdcMap ) ; } return mergedMap ; }", "nl": "Merges a log event s properties with the properties of the logger context . The context properties are first in the map and then the event s properties are appended ."}}
{"translation": {"code": "private void bindLoggingEvent ( SQLiteStatement stmt , ILoggingEvent event ) throws SQLException { stmt . bindLong ( TIMESTMP_INDEX , event . getTimeStamp ( ) ) ; stmt . bindString ( FORMATTED_MESSAGE_INDEX , event . getFormattedMessage ( ) ) ; stmt . bindString ( LOGGER_NAME_INDEX , event . getLoggerName ( ) ) ; stmt . bindString ( LEVEL_STRING_INDEX , event . getLevel ( ) . toString ( ) ) ; stmt . bindString ( THREAD_NAME_INDEX , event . getThreadName ( ) ) ; stmt . bindLong ( REFERENCE_FLAG_INDEX , computeReferenceMask ( event ) ) ; }", "nl": "Binds the main details of a log event to a SQLite statement s parameters"}}
{"translation": {"code": "private KeyManager [ ] createKeyManagers ( ContextAware context ) throws NoSuchProviderException , NoSuchAlgorithmException , UnrecoverableKeyException , KeyStoreException { if ( getKeyStore ( ) == null ) return null ; KeyStore keyStore = getKeyStore ( ) . createKeyStore ( ) ; context . addInfo ( \"key store of type '\" + keyStore . getType ( ) + \"' provider '\" + keyStore . getProvider ( ) + \"': \" + getKeyStore ( ) . getLocation ( ) ) ; KeyManagerFactory kmf = getKeyManagerFactory ( ) . createKeyManagerFactory ( ) ; context . addInfo ( \"key manager algorithm '\" + kmf . getAlgorithm ( ) + \"' provider '\" + kmf . getProvider ( ) + \"'\" ) ; char [ ] passphrase = getKeyStore ( ) . getPassword ( ) . toCharArray ( ) ; kmf . init ( keyStore , passphrase ) ; return kmf . getKeyManagers ( ) ; }", "nl": "Creates key managers using the receiver s key store configuration ."}}
{"translation": {"code": "private String [ ] enabledProtocols ( String [ ] supportedProtocols , String [ ] defaultProtocols ) { if ( enabledProtocols == null ) { // we're assuming that the same engine is used for all configurables // so once we determine the enabled set, we won't do it again if ( OptionHelper . isEmpty ( getIncludedProtocols ( ) ) && OptionHelper . isEmpty ( getExcludedProtocols ( ) ) ) { enabledProtocols = Arrays . copyOf ( defaultProtocols , defaultProtocols . length ) ; } else { enabledProtocols = includedStrings ( supportedProtocols , getIncludedProtocols ( ) , getExcludedProtocols ( ) ) ; } for ( String protocol : enabledProtocols ) { addInfo ( \"enabled protocol: \" + protocol ) ; } } return enabledProtocols ; }", "nl": "Gets the set of enabled protocols based on the configuration ."}}
{"translation": {"code": "private String [ ] includedStrings ( String [ ] defaults , String included , String excluded ) { List < String > values = new ArrayList < String > ( defaults . length ) ; values . addAll ( Arrays . asList ( defaults ) ) ; if ( included != null ) { StringCollectionUtil . retainMatching ( values , stringToArray ( included ) ) ; } if ( excluded != null ) { StringCollectionUtil . removeMatching ( values , stringToArray ( excluded ) ) ; } return values . toArray ( new String [ values . size ( ) ] ) ; }", "nl": "Applies include and exclude patterns to an array of default string values to produce an array of strings included by the patterns ."}}
{"translation": {"code": "public void endOfLife ( String key ) { Entry < C > entry = liveMap . remove ( key ) ; if ( entry == null ) return ; lingerersMap . put ( key , entry ) ; }", "nl": "Mark component identified by key as having reached its end - of - life ."}}
{"translation": {"code": "private Entry < C > getFromEitherMap ( String key ) { Entry < C > entry = liveMap . get ( key ) ; if ( entry != null ) return entry ; else { return lingerersMap . get ( key ) ; } }", "nl": "Get an entry from the liveMap if not found search the lingerersMap ."}}
{"translation": {"code": "public long timeOfLastReset ( ) { List < Status > statusList = sm . getCopyOfStatusList ( ) ; if ( statusList == null ) return - 1 ; int len = statusList . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { Status s = statusList . get ( i ) ; if ( CoreConstants . RESET_MSG_PREFIX . equals ( s . getMessage ( ) ) ) { return s . getDate ( ) ; } } return - 1 ; }", "nl": "Return the time of last reset . - 1 if last reset time could not be found"}}
{"translation": {"code": "private Collection < T > copyClients ( ) { clientsLock . lock ( ) ; try { Collection < T > copy = new ArrayList < T > ( clients ) ; return copy ; } finally { clientsLock . unlock ( ) ; } }", "nl": "Creates a copy of the collection of all clients that are presently being tracked by the server ."}}
{"translation": {"code": "private void clearExpiredLogs ( SQLiteDatabase db ) { if ( lastCheckExpired ( this . maxHistory , this . lastCleanupTime ) ) { this . lastCleanupTime = this . clock . currentTimeMillis ( ) ; this . getLogCleaner ( ) . performLogCleanup ( db , this . maxHistory ) ; } }", "nl": "Removes expired logs from the database"}}
{"translation": {"code": "public String getMountedExternalStorageDirectoryPath ( ) { String path = null ; String state = Environment . getExternalStorageState ( ) ; if ( state . equals ( Environment . MEDIA_MOUNTED ) || state . equals ( Environment . MEDIA_MOUNTED_READ_ONLY ) ) { path = absPath ( Environment . getExternalStorageDirectory ( ) ) ; } return path ; }", "nl": "Gets the path to the external storage directory only if mounted ."}}
{"translation": {"code": "public String getDatabaseDirectoryPath ( ) { return this . context != null && this . context . getDatabasePath ( \"x\" ) != null ? this . context . getDatabasePath ( \"x\" ) . getParent ( ) : \"\" ; }", "nl": "Returns the absolute path to the directory on the Android filesystem where databases are stored for the current application ."}}
{"translation": {"code": "public void setupProperties ( LoggerContext context ) { // legacy properties Properties props = new Properties ( ) ; props . setProperty ( CoreConstants . DATA_DIR_KEY , getFilesDirectoryPath ( ) ) ; final String extDir = getMountedExternalStorageDirectoryPath ( ) ; if ( extDir != null ) { props . setProperty ( CoreConstants . EXT_DIR_KEY , extDir ) ; } props . setProperty ( CoreConstants . PACKAGE_NAME_KEY , getPackageName ( ) ) ; props . setProperty ( CoreConstants . VERSION_CODE_KEY , getVersionCode ( ) ) ; props . setProperty ( CoreConstants . VERSION_NAME_KEY , getVersionName ( ) ) ; context . putProperties ( props ) ; }", "nl": "Sets properties for use in configs"}}
{"translation": {"code": "@ Override public void end ( InterpretationContext ic , String name ) throws ActionException { if ( inError ) { return ; } Object o = ic . peekObject ( ) ; if ( o != hook ) { addWarn ( \"The object at the of the stack is not the hook pushed earlier.\" ) ; } else { ic . popObject ( ) ; Thread hookThread = new Thread ( hook , \"Logback shutdown hook [\" + context . getName ( ) + \"]\" ) ; addInfo ( \"Registering shutdown hook with JVM runtime\" ) ; context . putObject ( CoreConstants . SHUTDOWN_HOOK_THREAD , hookThread ) ; Runtime . getRuntime ( ) . addShutdownHook ( hookThread ) ; } }", "nl": "Once the children elements are also parsed now is the time to activate the shutdown hook options ."}}
{"translation": {"code": "@ Override public void begin ( InterpretationContext ic , String name , Attributes attributes ) throws ActionException { hook = null ; inError = false ; String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; if ( OptionHelper . isEmpty ( className ) ) { className = DefaultShutdownHook . class . getName ( ) ; addInfo ( \"Assuming className [\" + className + \"]\" ) ; } try { addInfo ( \"About to instantiate shutdown hook of type [\" + className + \"]\" ) ; hook = ( ShutdownHookBase ) OptionHelper . instantiateByClassName ( className , ShutdownHookBase . class , context ) ; hook . setContext ( context ) ; ic . pushObject ( hook ) ; } catch ( Exception e ) { inError = true ; addError ( \"Could not create a shutdown hook of type [\" + className + \"].\" , e ) ; throw new ActionException ( e ) ; } }", "nl": "Instantiates a shutdown hook of the given class and sets its name ."}}
{"translation": {"code": "protected void stop ( ) { addInfo ( \"Logback context being closed via shutdown hook\" ) ; Context hookContext = getContext ( ) ; if ( hookContext instanceof ContextBase ) { ContextBase context = ( ContextBase ) hookContext ; context . stop ( ) ; } }", "nl": "Default method for stopping the Logback context"}}