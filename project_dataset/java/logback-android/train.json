{"translation": {"code": "protected String getClientThreadName ( Socket socket ) { return String . format ( Locale . US , \"Logback SocketNode (client: %s)\" , socket . getRemoteSocketAddress ( ) ) ; }", "nl": "Returns a name to identify each client thread ."}}
{"translation": {"code": "protected void subAppend ( CyclicBuffer < ILoggingEvent > cb , ILoggingEvent event ) { if ( includeCallerData ) { event . getCallerData ( ) ; } event . prepareForDeferredProcessing ( ) ; cb . add ( event ) ; }", "nl": "Perform SMTPAppender specific appending actions mainly adding the event to a cyclic buffer ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) DynamicConverter < E > createConverter ( SimpleKeywordNode kn ) { String keyword = ( String ) kn . getValue ( ) ; String converterClassStr = ( String ) converterMap . get ( keyword ) ; if ( converterClassStr != null ) { try { return ( DynamicConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , DynamicConverter . class , context ) ; } catch ( Exception e ) { addError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] for keyword [\" + keyword + \"]\" , e ) ; return null ; } } else { addError ( \"There is no conversion class registered for conversion word [\" + keyword + \"]\" ) ; return null ; } }", "nl": "Attempt to create a converter using the information found in converterMap ."}}
{"translation": {"code": "public void addMDCValueLevelPair ( MDCValueLevelPair mdcValueLevelPair ) { if ( valueLevelMap . containsKey ( mdcValueLevelPair . getValue ( ) ) ) { addError ( mdcValueLevelPair . getValue ( ) + \" has been already set\" ) ; } else { valueLevelMap . put ( mdcValueLevelPair . getValue ( ) , mdcValueLevelPair . getLevel ( ) ) ; } }", "nl": "Add a new MDCValuePair"}}
{"translation": {"code": "protected void sendBuffer ( CyclicBuffer < E > cb , E lastEventObject ) { // Note: this code already owns the monitor for this // appender. This frees us from needing to synchronize on 'cb'. try { MimeBodyPart part = new MimeBodyPart ( ) ; StringBuffer sbuf = new StringBuffer ( ) ; String header = layout . getFileHeader ( ) ; if ( header != null ) { sbuf . append ( header ) ; } String presentationHeader = layout . getPresentationHeader ( ) ; if ( presentationHeader != null ) { sbuf . append ( presentationHeader ) ; } fillBuffer ( cb , sbuf ) ; String presentationFooter = layout . getPresentationFooter ( ) ; if ( presentationFooter != null ) { sbuf . append ( presentationFooter ) ; } String footer = layout . getFileFooter ( ) ; if ( footer != null ) { sbuf . append ( footer ) ; } String subjectStr = \"Undefined subject\" ; if ( subjectLayout != null ) { subjectStr = subjectLayout . doLayout ( lastEventObject ) ; // The subject must not contain new-line characters, which cause // an SMTP error (LOGBACK-865). Truncate the string at the first // new-line character. int newLinePos = ( subjectStr != null ) ? subjectStr . indexOf ( ' ' ) : - 1 ; if ( newLinePos > - 1 ) { subjectStr = subjectStr . substring ( 0 , newLinePos ) ; } } MimeMessage mimeMsg = new MimeMessage ( session ) ; if ( from != null ) { mimeMsg . setFrom ( getAddress ( from ) ) ; } else { mimeMsg . setFrom ( ) ; } mimeMsg . setSubject ( subjectStr , charsetEncoding ) ; List < InternetAddress > destinationAddresses = parseAddress ( lastEventObject ) ; if ( destinationAddresses . isEmpty ( ) ) { addInfo ( \"Empty destination address. Aborting email transmission\" ) ; return ; } InternetAddress [ ] toAddressArray = destinationAddresses . toArray ( EMPTY_IA_ARRAY ) ; mimeMsg . setRecipients ( Message . RecipientType . TO , toAddressArray ) ; String contentType = layout . getContentType ( ) ; if ( ContentTypeUtil . isTextual ( contentType ) ) { part . setText ( sbuf . toString ( ) , charsetEncoding , ContentTypeUtil . getSubType ( contentType ) ) ; } else { part . setContent ( sbuf . toString ( ) , layout . getContentType ( ) ) ; } Multipart mp = new MimeMultipart ( ) ; mp . addBodyPart ( part ) ; mimeMsg . setContent ( mp ) ; updateMimeMsg ( mimeMsg , cb , lastEventObject ) ; mimeMsg . setSentDate ( new Date ( ) ) ; addInfo ( \"About to send out SMTP message \\\"\" + subjectStr + \"\\\" to \" + Arrays . toString ( toAddressArray ) ) ; Transport . send ( mimeMsg ) ; } catch ( Exception e ) { addError ( \"Error occurred while sending e-mail notification.\" , e ) ; } }", "nl": "Send the contents of the cyclic buffer as an e - mail message ."}}
{"translation": {"code": "protected void append ( E eventObject ) { if ( ! checkEntryConditions ( ) ) { return ; } String key = discriminator . getDiscriminatingValue ( eventObject ) ; long now = System . currentTimeMillis ( ) ; final CyclicBuffer < E > cb = cbTracker . getOrCreate ( key , now ) ; subAppend ( cb , eventObject ) ; try { if ( eventEvaluator . evaluate ( eventObject ) ) { // clone the CyclicBuffer before sending out asynchronously CyclicBuffer < E > cbClone = new CyclicBuffer < E > ( cb ) ; // see http://jira.qos.ch/browse/LBCLASSIC-221 cb . clear ( ) ; if ( asynchronousSending ) { // perform actual sending asynchronously SenderRunnable senderRunnable = new SenderRunnable ( cbClone , eventObject ) ; context . getScheduledExecutorService ( ) . execute ( senderRunnable ) ; } else { // synchronous sending sendBuffer ( cbClone , eventObject ) ; } } } catch ( EvaluationException ex ) { errorCount ++ ; if ( errorCount < CoreConstants . MAX_ERROR_COUNT ) { addError ( \"SMTPAppender's EventEvaluator threw an Exception-\" , ex ) ; } } // immediately remove the buffer if asked by the user if ( eventMarksEndOfLife ( eventObject ) ) { cbTracker . endOfLife ( key ) ; } cbTracker . removeStaleComponents ( now ) ; if ( lastTrackerStatusPrint + delayBetweenStatusMessages < now ) { addInfo ( \"SMTPAppender [\" + name + \"] is tracking [\" + cbTracker . getComponentCount ( ) + \"] buffers\" ) ; lastTrackerStatusPrint = now ; // quadruple 'delay' assuming less than max delay if ( delayBetweenStatusMessages < MAX_DELAY_BETWEEN_STATUS_MESSAGES ) { delayBetweenStatusMessages *= 4 ; } } }", "nl": "Perform SMTPAppender specific appending actions delegating some of them to a subclass and checking if the event triggers an e - mail to be sent ."}}
{"translation": {"code": "public void start ( ) { if ( cbTracker == null ) { cbTracker = new CyclicBufferTracker < E > ( ) ; } session = buildSessionFromProperties ( ) ; if ( session == null ) { addError ( \"Failed to obtain javax.mail.Session. Cannot start.\" ) ; return ; } subjectLayout = makeSubjectLayout ( subjectStr ) ; started = true ; }", "nl": "Start the appender"}}
{"translation": {"code": "public void begin ( InterpretationContext ec , String localName , Attributes attributes ) { if ( \"substitutionProperty\" . equals ( localName ) ) { addWarn ( \"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\" ) ; } String name = attributes . getValue ( NAME_ATTRIBUTE ) ; String value = attributes . getValue ( VALUE_ATTRIBUTE ) ; String scopeStr = attributes . getValue ( SCOPE_ATTRIBUTE ) ; Scope scope = ActionUtil . stringToScope ( scopeStr ) ; if ( checkFileAttributeSanity ( attributes ) ) { String file = attributes . getValue ( FILE_ATTRIBUTE ) ; file = ec . subst ( file ) ; try { FileInputStream istream = new FileInputStream ( file ) ; loadAndSetProperties ( ec , istream , scope ) ; } catch ( FileNotFoundException e ) { addError ( \"Could not find properties file [\" + file + \"].\" ) ; } catch ( IOException e1 ) { addError ( \"Could not read properties file [\" + file + \"].\" , e1 ) ; } } else if ( checkResourceAttributeSanity ( attributes ) ) { String resource = attributes . getValue ( RESOURCE_ATTRIBUTE ) ; resource = ec . subst ( resource ) ; URL resourceURL = Loader . getResourceBySelfClassLoader ( resource ) ; if ( resourceURL == null ) { addError ( \"Could not find resource [\" + resource + \"].\" ) ; } else { try { InputStream istream = resourceURL . openStream ( ) ; loadAndSetProperties ( ec , istream , scope ) ; } catch ( IOException e ) { addError ( \"Could not read resource file [\" + resource + \"].\" , e ) ; } } } else if ( checkValueNameAttributesSanity ( attributes ) ) { value = RegularEscapeUtil . basicEscape ( value ) ; // now remove both leading and trailing spaces value = value . trim ( ) ; value = ec . subst ( value ) ; ActionUtil . setProperty ( ec , name , value , scope ) ; } else { addError ( INVALID_ATTRIBUTES ) ; } }", "nl": "Set a new property for the execution context by name value pair or adds all the properties found in the given file ."}}
{"translation": {"code": "public static ClassLoader getClassLoaderOfClass ( final Class < ? > clazz ) { ClassLoader cl = clazz . getClassLoader ( ) ; if ( cl == null ) { return ClassLoader . getSystemClassLoader ( ) ; } else { return cl ; } }", "nl": "Return the class loader which loaded the class passed as argument . Return the system class loader if appropriate ."}}
{"translation": {"code": "public static ClassLoader getClassLoaderOfObject ( Object o ) { if ( o == null ) { throw new NullPointerException ( \"Argument cannot be null\" ) ; } return getClassLoaderOfClass ( o . getClass ( ) ) ; }", "nl": "Get the class loader of the object passed as argument . Return the system class loader if appropriate ."}}
{"translation": {"code": "public static URL getResource ( String resource , ClassLoader classLoader ) { try { return classLoader . getResource ( resource ) ; } catch ( Throwable t ) { return null ; } }", "nl": "Search for a resource using the classloader passed as parameter ."}}
{"translation": {"code": "public static Set < URL > getResourceOccurrenceCount ( String resource , ClassLoader classLoader ) throws IOException { // See LBCLASSIC-159 Set < URL > urlSet = new HashSet < URL > ( ) ; Enumeration < URL > urlEnum = classLoader . getResources ( resource ) ; while ( urlEnum . hasMoreElements ( ) ) { URL url = urlEnum . nextElement ( ) ; urlSet . add ( url ) ; } return urlSet ; }", "nl": "Compute the number of occurrences a resource can be found by a class loader ."}}
{"translation": {"code": "public static Level toLevel ( int val , Level defaultLevel ) { switch ( val ) { case ALL_INT : return ALL ; case TRACE_INT : return TRACE ; case DEBUG_INT : return DEBUG ; case INFO_INT : return INFO ; case WARN_INT : return WARN ; case ERROR_INT : return ERROR ; case OFF_INT : return OFF ; default : return defaultLevel ; } }", "nl": "Convert an integer passed as argument to a Level . If the conversion fails then this method returns the specified default ."}}
{"translation": {"code": "public Integer toInteger ( ) { switch ( levelInt ) { case ALL_INT : return ALL_INTEGER ; case TRACE_INT : return TRACE_INTEGER ; case DEBUG_INT : return DEBUG_INTEGER ; case INFO_INT : return INFO_INTEGER ; case WARN_INT : return WARN_INTEGER ; case ERROR_INT : return ERROR_INTEGER ; case OFF_INT : return OFF_INTEGER ; default : throw new IllegalStateException ( \"Level \" + levelStr + \", \" + levelInt + \" is unknown.\" ) ; } }", "nl": "Convert a Level to an Integer object ."}}
{"translation": {"code": "static public boolean createMissingParentDirectories ( File file ) { File parent = file . getParentFile ( ) ; if ( parent == null ) { // Parent directory not specified, therefore it's a request to // create nothing. Done! ;) return true ; } // File.mkdirs() creates the parent directories only if they don't // already exist; and it's okay if they do. parent . mkdirs ( ) ; return parent . exists ( ) ; }", "nl": "Creates the parent directories of a file . If parent directories not specified in file s path then nothing is done and this returns gracefully ."}}
{"translation": {"code": "private FilterReply callTurboFilters ( Marker marker , Level level ) { return loggerContext . getTurboFilterChainDecision_0_3OrMore ( marker , this , level , null , null , null ) ; }", "nl": "Method that calls the attached TurboFilter objects based on the logger and the level ."}}
{"translation": {"code": "Logger createChildByLastNamePart ( final String lastPart ) { int i_index = LoggerNameUtil . getFirstSeparatorIndexOf ( lastPart ) ; if ( i_index != - 1 ) { throw new IllegalArgumentException ( \"Child name [\" + lastPart + \" passed as parameter, may not include [\" + CoreConstants . DOT + \"]\" ) ; } if ( childrenList == null ) { childrenList = new CopyOnWriteArrayList < Logger > ( ) ; } Logger childLogger ; if ( this . isRootLogger ( ) ) { childLogger = new Logger ( lastPart , this , this . loggerContext ) ; } else { childLogger = new Logger ( name + CoreConstants . DOT + lastPart , this , this . loggerContext ) ; } childrenList . add ( childLogger ) ; childLogger . effectiveLevelInt = this . effectiveLevelInt ; return childLogger ; }", "nl": "Create a child of this logger by suffix that is the part of the name extending this logger . For example if this logger is named x . y and the lastPart is z then the created child logger will be named x . y . z ."}}
{"translation": {"code": "public boolean detachAppender ( Appender < ILoggingEvent > appender ) { if ( aai == null ) { return false ; } return aai . detachAppender ( appender ) ; }", "nl": "Remove the appender passed as parameter form the list of appenders ."}}
{"translation": {"code": "public void callAppenders ( ILoggingEvent event ) { int writes = 0 ; for ( Logger l = this ; l != null ; l = l . parent ) { writes += l . appendLoopOnAppenders ( event ) ; if ( ! l . additive ) { break ; } } // No appenders in hierarchy if ( writes == 0 ) { loggerContext . noAppenderDefinedWarning ( this ) ; } }", "nl": "Invoke all the appenders of this logger ."}}
{"translation": {"code": "private synchronized void handleParentLevelChange ( int newParentLevelInt ) { // changes in the parent levelInt affect children only if their levelInt is // null if ( level == null ) { effectiveLevelInt = newParentLevelInt ; // propagate the parent levelInt change to this logger's children if ( childrenList != null ) { int len = childrenList . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { Logger child = ( Logger ) childrenList . get ( i ) ; child . handleParentLevelChange ( newParentLevelInt ) ; } } } }", "nl": "This method is invoked by parent logger to let this logger know that the prent s levelInt changed ."}}
{"translation": {"code": "private void trimHeadAndTail ( SaxEventRecorder recorder ) { List < SaxEvent > saxEventList = recorder . getSaxEventList ( ) ; if ( saxEventList . size ( ) == 0 ) { return ; } boolean includedTagFound = false ; boolean configTagFound = false ; // find opening element SaxEvent first = saxEventList . get ( 0 ) ; if ( first != null ) { String elemName = getEventName ( first ) ; includedTagFound = INCLUDED_TAG . equalsIgnoreCase ( elemName ) ; configTagFound = CONFIG_TAG . equalsIgnoreCase ( elemName ) ; } // if opening element found, remove it, and then remove the closing element if ( includedTagFound || configTagFound ) { saxEventList . remove ( 0 ) ; final int listSize = saxEventList . size ( ) ; if ( listSize == 0 ) { return ; } final int lastIndex = listSize - 1 ; SaxEvent last = saxEventList . get ( lastIndex ) ; if ( last != null ) { String elemName = getEventName ( last ) ; if ( ( includedTagFound && INCLUDED_TAG . equalsIgnoreCase ( elemName ) ) || ( configTagFound && CONFIG_TAG . equalsIgnoreCase ( elemName ) ) ) { saxEventList . remove ( lastIndex ) ; } } } }", "nl": "Removes the head tag and tail tag if they are named either included or configuration"}}
{"translation": {"code": "public boolean detachAppender ( Appender < E > appender ) { if ( appender == null ) { return false ; } boolean result ; result = appenderList . remove ( appender ) ; return result ; }", "nl": "Remove the appender passed as parameter form the list of attached appenders ."}}
{"translation": {"code": "public void addAppender ( Appender < E > newAppender ) { if ( newAppender == null ) { throw new IllegalArgumentException ( \"Null argument disallowed\" ) ; } appenderList . addIfAbsent ( newAppender ) ; }", "nl": "Attach an appender . If the appender is already in the list in won t be added again ."}}
{"translation": {"code": "public String getDiscriminatingValue ( ILoggingEvent event ) { String contextName = event . getLoggerContextVO ( ) . getName ( ) ; if ( contextName == null ) { return defaultValue ; } else { return contextName ; } }", "nl": "Return the name of the current context name as found in the logging event ."}}
{"translation": {"code": "protected void determineCompressionMode ( ) { if ( fileNamePatternStr . endsWith ( \".gz\" ) ) { addInfo ( \"Will use gz compression\" ) ; compressionMode = CompressionMode . GZ ; } else if ( fileNamePatternStr . endsWith ( \".zip\" ) ) { addInfo ( \"Will use zip compression\" ) ; compressionMode = CompressionMode . ZIP ; } else { addInfo ( \"No compression will be used\" ) ; compressionMode = CompressionMode . NONE ; } }", "nl": "Given the FileNamePattern string this method determines the compression mode depending on last letters of the fileNamePatternStr . Patterns ending with . gz imply GZIP compression endings with . zip imply ZIP compression . Otherwise and by default there is no compression ."}}
{"translation": {"code": "public void start ( ) { int errors = 0 ; if ( this . encoder == null ) { addStatus ( new ErrorStatus ( \"No encoder set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; errors ++ ; } if ( this . outputStream == null ) { addStatus ( new ErrorStatus ( \"No output stream set for the appender named \\\"\" + name + \"\\\".\" , this ) ) ; errors ++ ; } // only error free appenders should be activated if ( errors == 0 ) { super . start ( ) ; } }", "nl": "Checks that requires parameters are set and if everything is in order activates this appender ."}}
{"translation": {"code": "public final void doConfigure ( URL url ) throws JoranException { InputStream in = null ; try { informContextOfURLUsedForConfiguration ( getContext ( ) , url ) ; URLConnection urlConnection = url . openConnection ( ) ; // per http://jira.qos.ch/browse/LBCORE-105 // per http://jira.qos.ch/browse/LBCORE-127 urlConnection . setUseCaches ( false ) ; // this closes the stream for us in = urlConnection . getInputStream ( ) ; doConfigure ( in , url . toExternalForm ( ) ) ; } catch ( IOException ioe ) { String errMsg = \"Could not open URL [\" + url + \"].\" ; addError ( errMsg , ioe ) ; throw new JoranException ( errMsg , ioe ) ; } finally { CloseUtil . closeQuietly ( in ) ; } }", "nl": "Configures logback with the configuration XML read from a file located at the given URL"}}
{"translation": {"code": "public final void doConfigure ( InputStream inputStream ) throws JoranException { try { doConfigure ( new InputSource ( inputStream ) ) ; } finally { try { inputStream . close ( ) ; } catch ( IOException ioe ) { String errMsg = \"Could not close the stream\" ; addError ( errMsg , ioe ) ; throw new JoranException ( errMsg , ioe ) ; } } }", "nl": "Configures logback with the configuraiton XML read from an input stream and then closes the stream"}}
{"translation": {"code": "private InputStream openURL ( URL url ) { try { return url . openStream ( ) ; } catch ( IOException e ) { optionalWarning ( \"Failed to open [\" + url . toString ( ) + \"]\" , e ) ; return null ; } }", "nl": "Opens the given URL logging any exceptions"}}
{"translation": {"code": "@ Override protected void processInclude ( InterpretationContext ic , URL url ) throws JoranException { InputStream in = openURL ( url ) ; try { if ( in != null ) { // add URL to watch list in case the \"scan\" flag is true, in // which case this URL is periodically checked for changes ConfigurationWatchListUtil . addToWatchList ( getContext ( ) , url ) ; // parse the include SaxEventRecorder recorder = createRecorder ( in , url ) ; recorder . setContext ( getContext ( ) ) ; recorder . recordEvents ( in ) ; // remove the leading/trailing tags (<included> or <configuration>) trimHeadAndTail ( recorder ) ; ic . getJoranInterpreter ( ) . getEventPlayer ( ) . addEventsDynamically ( recorder . getSaxEventList ( ) , this . eventOffset ) ; } } catch ( JoranException e ) { optionalWarning ( \"Failed processing [\" + url . toString ( ) + \"]\" , e ) ; } finally { close ( in ) ; } }", "nl": "Processes an include"}}
{"translation": {"code": "@ Override protected HashMap < String , String > childValue ( HashMap < String , String > parentValue ) { if ( parentValue == null ) { return null ; } else { return new HashMap < String , String > ( parentValue ) ; } }", "nl": "Child threads should get a copy of the parent s hashmap ."}}
{"translation": {"code": "private boolean isUnequivocallyInstantiable ( Class < ? > clazz ) { if ( clazz . isInterface ( ) ) { return false ; } // checking for constructors would be more elegant, but in // classes without any declared constructors, Class.getConstructor() // returns null. Object o ; try { o = clazz . getDeclaredConstructor ( ) . newInstance ( ) ; if ( o != null ) { return true ; } else { return false ; } } catch ( InstantiationException e ) { return false ; } catch ( IllegalAccessException e ) { return false ; } catch ( NoSuchMethodException e ) { return false ; } catch ( InvocationTargetException e ) { return false ; } }", "nl": "Can the given clazz instantiable with certainty?"}}
{"translation": {"code": "public void setProperty ( String name , String value ) { if ( value == null ) { return ; } name = Introspector . decapitalize ( name ) ; PropertyDescriptor prop = getPropertyDescriptor ( name ) ; if ( prop == null ) { addWarn ( \"No such property [\" + name + \"] in \" + objClass . getName ( ) + \".\" ) ; } else { try { setProperty ( prop , name , value ) ; } catch ( PropertySetterException ex ) { addWarn ( \"Failed to set property [\" + name + \"] to value \\\"\" + value + \"\\\". \" , ex ) ; } } }", "nl": "Set a property on this PropertySetter s Object . If successful this method will invoke a setter method on the underlying Object . The setter is the one for the specified property name and the value is determined partly from the setter argument type and partly from the value specified in the call to this method ."}}
{"translation": {"code": "public synchronized int getEffectiveLevel ( ) { int result = level ; int effLevel ; Iterator it = iterator ( ) ; Status s ; while ( it . hasNext ( ) ) { s = ( Status ) it . next ( ) ; effLevel = s . getEffectiveLevel ( ) ; if ( effLevel > result ) { result = effLevel ; } } return result ; }", "nl": "different status objects lying on the same cycle"}}
{"translation": {"code": "public int getPrefixMatchLength ( ElementPath p ) { if ( p == null ) { return 0 ; } int lSize = this . partList . size ( ) ; int rSize = p . partList . size ( ) ; // no match possible for empty sets if ( ( lSize == 0 ) || ( rSize == 0 ) ) { return 0 ; } int minLen = ( lSize <= rSize ) ? lSize : rSize ; int match = 0 ; for ( int i = 0 ; i < minLen ; i ++ ) { String l = this . partList . get ( i ) ; String r = p . partList . get ( i ) ; if ( equalityCheck ( l , r ) ) { match ++ ; } else { break ; } } return match ; }", "nl": "Returns the number of prefix components that this pattern has in common with the pattern p passed as parameter . By prefix components we mean the components at the beginning of the pattern ."}}
{"translation": {"code": "static public int facilityStringToint ( String facilityStr ) { if ( \"KERN\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_KERN ; } else if ( \"USER\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_USER ; } else if ( \"MAIL\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_MAIL ; } else if ( \"DAEMON\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_DAEMON ; } else if ( \"AUTH\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_AUTH ; } else if ( \"SYSLOG\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_SYSLOG ; } else if ( \"LPR\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LPR ; } else if ( \"NEWS\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_NEWS ; } else if ( \"UUCP\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_UUCP ; } else if ( \"CRON\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_CRON ; } else if ( \"AUTHPRIV\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_AUTHPRIV ; } else if ( \"FTP\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_FTP ; } else if ( \"NTP\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_NTP ; } else if ( \"AUDIT\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_AUDIT ; } else if ( \"ALERT\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_ALERT ; } else if ( \"CLOCK\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_CLOCK ; } else if ( \"LOCAL0\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL0 ; } else if ( \"LOCAL1\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL1 ; } else if ( \"LOCAL2\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL2 ; } else if ( \"LOCAL3\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL3 ; } else if ( \"LOCAL4\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL4 ; } else if ( \"LOCAL5\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL5 ; } else if ( \"LOCAL6\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL6 ; } else if ( \"LOCAL7\" . equalsIgnoreCase ( facilityStr ) ) { return SyslogConstants . LOG_LOCAL7 ; } else { throw new IllegalArgumentException ( facilityStr + \" is not a valid syslog facility string\" ) ; } }", "nl": "Returns the integer value corresponding to the named syslog facility ."}}
{"translation": {"code": "public static File [ ] filesInFolderMatchingStemRegex ( File file , final String stemRegex ) { if ( file == null ) { return new File [ 0 ] ; } if ( ! file . exists ( ) || ! file . isDirectory ( ) ) { return new File [ 0 ] ; } return file . listFiles ( new FilenameFilter ( ) { public boolean accept ( File dir , String name ) { return name . matches ( stemRegex ) ; } } ) ; }", "nl": "Return the set of files matching the stemRegex as found in directory . A stemRegex does not contain any slash characters or any folder separators ."}}
{"translation": {"code": "void init ( ) { try { try { new ContextInitializer ( defaultLoggerContext ) . autoConfig ( ) ; } catch ( JoranException je ) { Util . report ( \"Failed to auto configure default logger context\" , je ) ; } // logback-292 if ( ! StatusUtil . contextHasStatusListener ( defaultLoggerContext ) ) { StatusPrinter . printInCaseOfErrorsOrWarnings ( defaultLoggerContext ) ; } contextSelectorBinder . init ( defaultLoggerContext , KEY ) ; initialized = true ; } catch ( Exception t ) { // see LOGBACK-1159 Util . report ( \"Failed to instantiate [\" + LoggerContext . class . getName ( ) + \"]\" , t ) ; } }", "nl": "Package access for testing purposes ."}}
{"translation": {"code": "public FilterReply getTurboFilterChainDecision ( final Marker marker , final Logger logger , final Level level , final String format , final Object [ ] params , final Throwable t ) { final int size = size ( ) ; //    if (size == 0) { //      return FilterReply.NEUTRAL; //    } if ( size == 1 ) { try { TurboFilter tf = get ( 0 ) ; return tf . decide ( marker , logger , level , format , params , t ) ; } catch ( IndexOutOfBoundsException iobe ) { return FilterReply . NEUTRAL ; } } Object [ ] tfa = toArray ( ) ; final int len = tfa . length ; for ( int i = 0 ; i < len ; i ++ ) { //for (TurboFilter tf : this) { final TurboFilter tf = ( TurboFilter ) tfa [ i ] ; final FilterReply r = tf . decide ( marker , logger , level , format , params , t ) ; if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { return r ; } } return FilterReply . NEUTRAL ; }", "nl": "Loop through the filters in the chain . As soon as a filter decides on ACCEPT or DENY then that value is returned . If all of the filters return NEUTRAL then NEUTRAL is returned ."}}
{"translation": {"code": "public Map < String , String > getCopyOfContextMap ( ) { Map < String , String > hashMap = copyOnThreadLocal . get ( ) ; if ( hashMap == null ) { return null ; } else { return new HashMap < String , String > ( hashMap ) ; } }", "nl": "Return a copy of the current thread s context map . Returned value may be null ."}}
{"translation": {"code": "public void end ( InterpretationContext ec , String name ) { if ( inError ) { return ; } if ( appender instanceof LifeCycle ) { ( ( LifeCycle ) appender ) . start ( ) ; } Object o = ec . peekObject ( ) ; if ( o != appender ) { addWarn ( \"The object at the of the stack is not the appender named [\" + appender . getName ( ) + \"] pushed earlier.\" ) ; } else { ec . popObject ( ) ; } }", "nl": "Once the children elements are also parsed now is the time to activate the appender options ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public void begin ( InterpretationContext ec , String localName , Attributes attributes ) throws ActionException { // We are just beginning, reset variables appender = null ; inError = false ; String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; if ( OptionHelper . isEmpty ( className ) ) { addError ( \"Missing class name for appender. Near [\" + localName + \"] line \" + getLineNumber ( ec ) ) ; inError = true ; return ; } try { addInfo ( \"About to instantiate appender of type [\" + className + \"]\" ) ; warnDeprecated ( className ) ; appender = ( Appender < E > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . Appender . class , context ) ; appender . setContext ( context ) ; String appenderName = ec . subst ( attributes . getValue ( NAME_ATTRIBUTE ) ) ; if ( OptionHelper . isEmpty ( appenderName ) ) { addWarn ( \"No appender name given for appender of type \" + className + \"].\" ) ; } else { appender . setName ( appenderName ) ; addInfo ( \"Naming appender as [\" + appenderName + \"]\" ) ; } // The execution context contains a bag which contains the appenders // created thus far. HashMap < String , Appender < E > > appenderBag = ( HashMap < String , Appender < E > > ) ec . getObjectMap ( ) . get ( ActionConst . APPENDER_BAG ) ; // add the appender just created to the appender bag. appenderBag . put ( appenderName , appender ) ; ec . pushObject ( appender ) ; } catch ( Exception oops ) { inError = true ; addError ( \"Could not create an Appender of type [\" + className + \"].\" , oops ) ; throw new ActionException ( oops ) ; } }", "nl": "Instantiates an appender of the given class and sets its name ."}}
{"translation": {"code": "@ Override public String getFileFooter ( ) { StringBuilder sbuf = new StringBuilder ( ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"</body></html>\" ) ; return sbuf . toString ( ) ; }", "nl": "Returns the appropriate HTML footers ."}}
{"translation": {"code": "@ Override public String getFileHeader ( ) { StringBuilder sbuf = new StringBuilder ( ) ; sbuf . append ( \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\"\" ) ; sbuf . append ( \" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\" ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"<html>\" ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"  <head>\" ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"    <title>\" ) ; sbuf . append ( title ) ; sbuf . append ( \"</title>\" ) ; sbuf . append ( LINE_SEPARATOR ) ; cssBuilder . addCss ( sbuf ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"  </head>\" ) ; sbuf . append ( LINE_SEPARATOR ) ; sbuf . append ( \"<body>\" ) ; sbuf . append ( LINE_SEPARATOR ) ; return sbuf . toString ( ) ; }", "nl": "Returns appropriate HTML headers ."}}
{"translation": {"code": "public Map < String , String > getEffectiveConverterMap ( ) { Map < String , String > effectiveMap = new HashMap < String , String > ( ) ; // add the least specific map fist Map < String , String > defaultMap = getDefaultConverterMap ( ) ; if ( defaultMap != null ) { effectiveMap . putAll ( defaultMap ) ; } // contextMap is more specific than the default map Context context = getContext ( ) ; if ( context != null ) { @ SuppressWarnings ( \"unchecked\" ) Map < String , String > contextMap = ( Map < String , String > ) context . getObject ( CoreConstants . PATTERN_RULE_REGISTRY ) ; if ( contextMap != null ) { effectiveMap . putAll ( contextMap ) ; } } return effectiveMap ; }", "nl": "Returns a map where the default converter map is merged with the map contained in the context ."}}
{"translation": {"code": "@ Override public void start ( ) { int errorCount = 0 ; try { Parser < E > p = new Parser < E > ( pattern ) ; p . setContext ( getContext ( ) ) ; Node t = p . parse ( ) ; this . head = p . compile ( t , getEffectiveConverterMap ( ) ) ; ConverterUtil . startConverters ( this . head ) ; } catch ( ScanException ex ) { addError ( \"Incorrect pattern found\" , ex ) ; errorCount ++ ; } if ( errorCount == 0 ) { super . started = true ; } }", "nl": "Parses the pattern and creates the Converter linked list ."}}
{"translation": {"code": "public void setName ( String name ) throws IllegalStateException { if ( name != null && name . equals ( this . name ) ) { return ; // idempotent naming } if ( this . name == null || CoreConstants . DEFAULT_CONTEXT_NAME . equals ( this . name ) ) { this . name = name ; } else { throw new IllegalStateException ( \"Context has been already given a name\" ) ; } }", "nl": "The context name can be set only if it is not already set or if the current name is the default context name namely default or if the current name and the old name are the same ."}}
{"translation": {"code": "public String getProperty ( String key ) { if ( CONTEXT_NAME_KEY . equals ( key ) ) return getName ( ) ; return ( String ) this . propertyMap . get ( key ) ; }", "nl": "Given a key return the corresponding property value . If invoked with the special key CONTEXT_NAME the name of the context is returned ."}}
{"translation": {"code": "public void doConfigure ( final List < SaxEvent > eventList ) throws JoranException { buildInterpreter ( ) ; // disallow simultaneous configurations of the same context synchronized ( context . getConfigurationLock ( ) ) { interpreter . getEventPlayer ( ) . play ( eventList ) ; } }", "nl": "Configures logback with SAX events of configuration XML"}}
{"translation": {"code": "private final void doConfigure ( final InputSource inputSource ) throws JoranException { long threshold = System . currentTimeMillis ( ) ; //    if (!ConfigurationWatchListUtil.wasConfigurationWatchListReset(context)) { //      informContextOfURLUsedForConfiguration(getContext(), null); //    } SaxEventRecorder recorder = new SaxEventRecorder ( context ) ; recorder . recordEvents ( inputSource ) ; doConfigure ( recorder . getSaxEventList ( ) ) ; // no exceptions a this level StatusUtil statusUtil = new StatusUtil ( context ) ; if ( statusUtil . noXMLParsingErrorsOccurred ( threshold ) ) { addInfo ( \"Registering current configuration as safe fallback point\" ) ; registerSafeConfiguration ( recorder . getSaxEventList ( ) ) ; } }", "nl": "Configures logback with the configuration XML read from an input source ."}}
{"translation": {"code": "protected void buildInterpreter ( ) { RuleStore rs = new SimpleRuleStore ( context ) ; addInstanceRules ( rs ) ; this . interpreter = new Interpreter ( context , rs , initialElementPath ( ) ) ; InterpretationContext interpretationContext = interpreter . getInterpretationContext ( ) ; interpretationContext . setContext ( context ) ; addImplicitRules ( interpreter ) ; addDefaultNestedComponentRegistryRules ( interpretationContext . getDefaultNestedComponentRegistry ( ) ) ; }", "nl": "Builds a generic configuration - XML interpreter"}}
{"translation": {"code": "public final void doConfigure ( File file ) throws JoranException { FileInputStream fis = null ; try { URL url = file . toURI ( ) . toURL ( ) ; informContextOfURLUsedForConfiguration ( getContext ( ) , url ) ; fis = new FileInputStream ( file ) ; // this closes the stream for us doConfigure ( fis , url . toExternalForm ( ) ) ; } catch ( IOException ioe ) { String errMsg = \"Could not open [\" + file . getPath ( ) + \"].\" ; addError ( errMsg , ioe ) ; throw new JoranException ( errMsg , ioe ) ; } finally { CloseUtil . closeQuietly ( fis ) ; } }", "nl": "Configures logback with the configuration XML read from a given file"}}
{"translation": {"code": "List < Action > getApplicableActionList ( ElementPath elementPath , Attributes attributes ) { List < Action > applicableActionList = ruleStore . matchActions ( elementPath ) ; // logger.debug(\"set of applicable patterns: \" + applicableActionList); if ( applicableActionList == null ) { applicableActionList = lookupImplicitAction ( elementPath , attributes , interpretationContext ) ; } return applicableActionList ; }", "nl": "Return the list of applicable patterns for this"}}
{"translation": {"code": "public boolean detachAppender ( String name ) { if ( name == null ) { return false ; } boolean removed = false ; for ( Appender < E > a : appenderList ) { if ( name . equals ( ( a ) . getName ( ) ) ) { removed = appenderList . remove ( a ) ; break ; } } return removed ; }", "nl": "Remove the appender with the name passed as parameter form the list of appenders ."}}
{"translation": {"code": "public static void printInCaseOfErrorsOrWarnings ( Context context , long threshold ) { if ( context == null ) { throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; } StatusManager sm = context . getStatusManager ( ) ; if ( sm == null ) { ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; } else { StatusUtil statusUtil = new StatusUtil ( context ) ; if ( statusUtil . getHighestLevel ( threshold ) >= ErrorStatus . WARN ) { print ( sm , threshold ) ; } } }", "nl": "Print the contents of the context status but only if they contain warnings or errors occurring later then the threshold ."}}
{"translation": {"code": "public static < E > void startConverters ( Converter < E > head ) { Converter < E > c = head ; while ( c != null ) { // CompositeConverter is a subclass of  DynamicConverter if ( c instanceof CompositeConverter ) { CompositeConverter < E > cc = ( CompositeConverter < E > ) c ; Converter < E > childConverter = cc . childConverter ; startConverters ( childConverter ) ; cc . start ( ) ; } else if ( c instanceof DynamicConverter ) { DynamicConverter < E > dc = ( DynamicConverter < E > ) c ; dc . start ( ) ; } c = c . getNext ( ) ; } }", "nl": "Start converters in the chain of converters ."}}
{"translation": {"code": "public static FormatInfo valueOf ( String str ) throws IllegalArgumentException { if ( str == null ) { throw new NullPointerException ( \"Argument cannot be null\" ) ; } FormatInfo fi = new FormatInfo ( ) ; int indexOfDot = str . indexOf ( ' ' ) ; String minPart = null ; String maxPart = null ; if ( indexOfDot != - 1 ) { minPart = str . substring ( 0 , indexOfDot ) ; if ( indexOfDot + 1 == str . length ( ) ) { throw new IllegalArgumentException ( \"Formatting string [\" + str + \"] should not end with '.'\" ) ; } else { maxPart = str . substring ( indexOfDot + 1 ) ; } } else { minPart = str ; } if ( minPart != null && minPart . length ( ) > 0 ) { int min = Integer . parseInt ( minPart ) ; if ( min >= 0 ) { fi . min = min ; } else { fi . min = - min ; fi . leftPad = false ; } } if ( maxPart != null && maxPart . length ( ) > 0 ) { int max = Integer . parseInt ( maxPart ) ; if ( max >= 0 ) { fi . max = max ; } else { fi . max = - max ; fi . leftTruncate = false ; } } return fi ; }", "nl": "This method is used to parse a string such as 5 . 7 5 . 7 or - 5 . 7 into a FormatInfo ."}}
{"translation": {"code": "public static void printIfErrorsOccured ( Context context ) { if ( context == null ) { throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; } StatusManager sm = context . getStatusManager ( ) ; if ( sm == null ) { ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; } else { StatusUtil statusUtil = new StatusUtil ( context ) ; if ( statusUtil . getHighestLevel ( 0 ) == ErrorStatus . ERROR ) { print ( sm ) ; } } }", "nl": "Print the contents of the context statuses but only if they contain errors ."}}
{"translation": {"code": "public boolean chainHandlesThrowable ( Converter < ILoggingEvent > head ) { Converter < ILoggingEvent > c = head ; while ( c != null ) { if ( c instanceof ThrowableHandlingConverter ) { return true ; } c = c . getNext ( ) ; } return false ; }", "nl": "This method computes whether a chain of converters handles exceptions or not ."}}
{"translation": {"code": "List < Action > lookupImplicitAction ( ElementPath elementPath , Attributes attributes , InterpretationContext ec ) { int len = implicitActions . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { ImplicitAction ia = ( ImplicitAction ) implicitActions . get ( i ) ; if ( ia . isApplicable ( elementPath , attributes , ec ) ) { List < Action > actionList = new ArrayList < Action > ( 1 ) ; actionList . add ( ia ) ; return actionList ; } } return null ; }", "nl": "Check if any implicit actions are applicable . As soon as an applicable action is found it is returned . Thus the returned list will have at most one element ."}}
{"translation": {"code": "public FilterReply getFilterChainDecision ( E event ) { final Filter < E > [ ] filterArrray = filterList . asTypedArray ( ) ; final int len = filterArrray . length ; for ( int i = 0 ; i < len ; i ++ ) { final FilterReply r = filterArrray [ i ] . decide ( event ) ; if ( r == FilterReply . DENY || r == FilterReply . ACCEPT ) { return r ; } } // no decision return FilterReply . NEUTRAL ; }", "nl": "Loop through the filters in the list . As soon as a filter decides on ACCEPT or DENY then that value is returned . If all of the filters return NEUTRAL then NEUTRAL is returned ."}}
{"translation": {"code": "public String getDiscriminatingValue ( ILoggingEvent event ) { // http://jira.qos.ch/browse/LBCLASSIC-213 Map < String , String > mdcMap = event . getMDCPropertyMap ( ) ; if ( mdcMap == null ) { return defaultValue ; } String mdcValue = mdcMap . get ( key ) ; if ( mdcValue == null ) { return defaultValue ; } else { return mdcValue ; } }", "nl": "Return the value associated with an MDC entry designated by the Key property . If that value is null then return the value assigned to the DefaultValue property ."}}
{"translation": {"code": "public boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { return event . getLevel ( ) . levelInt >= Level . ERROR_INT ; }", "nl": "Return true if event passed as parameter has level ERROR or higher returns false otherwise ."}}
{"translation": {"code": "@ Override protected void subAppend ( E event ) { // The roll-over check must precede actual writing. This is the // only correct behavior for time driven triggers. // We need to synchronize on triggeringPolicy so that only one rollover // occurs at a time synchronized ( triggeringPolicy ) { if ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) { rollover ( ) ; } } super . subAppend ( event ) ; }", "nl": "This method differentiates RollingFileAppender from its super class ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public void end ( InterpretationContext ec , String e ) { if ( inError ) { return ; } if ( evaluator instanceof LifeCycle ) { ( ( LifeCycle ) evaluator ) . start ( ) ; addInfo ( \"Starting evaluator named [\" + evaluator . getName ( ) + \"]\" ) ; } Object o = ec . peekObject ( ) ; if ( o != evaluator ) { addWarn ( \"The object on the top the of the stack is not the evaluator pushed earlier.\" ) ; } else { ec . popObject ( ) ; try { Map < String , EventEvaluator < ? > > evaluatorMap = ( Map < String , EventEvaluator < ? > > ) context . getObject ( CoreConstants . EVALUATOR_MAP ) ; if ( evaluatorMap == null ) { addError ( \"Could not find EvaluatorMap\" ) ; } else { evaluatorMap . put ( evaluator . getName ( ) , evaluator ) ; } } catch ( Exception ex ) { addError ( \"Could not set evaluator named [\" + evaluator + \"].\" , ex ) ; } } }", "nl": "Once the children elements are also parsed now is the time to activate the evaluator options ."}}
{"translation": {"code": "public void begin ( InterpretationContext ec , String name , Attributes attributes ) { // Let us forget about previous errors (in this instance) inError = false ; evaluator = null ; String className = attributes . getValue ( CLASS_ATTRIBUTE ) ; if ( OptionHelper . isEmpty ( className ) ) { className = defaultClassName ( ) ; addInfo ( \"Assuming default evaluator class [\" + className + \"]\" ) ; } if ( OptionHelper . isEmpty ( className ) ) { className = defaultClassName ( ) ; inError = true ; addError ( \"Mandatory \\\"\" + CLASS_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\" ) ; return ; } String evaluatorName = attributes . getValue ( Action . NAME_ATTRIBUTE ) ; if ( OptionHelper . isEmpty ( evaluatorName ) ) { inError = true ; addError ( \"Mandatory \\\"\" + NAME_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\" ) ; return ; } try { evaluator = ( EventEvaluator < ? > ) OptionHelper . instantiateByClassName ( className , ch . qos . logback . core . boolex . EventEvaluator . class , context ) ; evaluator . setContext ( this . context ) ; evaluator . setName ( evaluatorName ) ; ec . pushObject ( evaluator ) ; addInfo ( \"Adding evaluator named [\" + evaluatorName + \"] to the object stack\" ) ; } catch ( Exception oops ) { inError = true ; addError ( \"Could not create evaluator of type \" + className + \"].\" , oops ) ; } }", "nl": "Instantiates an evaluator of the given class and sets its name ."}}
{"translation": {"code": "public String toRegexForFixedDate ( Date date ) { StringBuilder buf = new StringBuilder ( ) ; Converter < Object > p = headTokenConverter ; while ( p != null ) { if ( p instanceof LiteralConverter ) { buf . append ( p . convert ( null ) ) ; } else if ( p instanceof IntegerTokenConverter ) { buf . append ( FileFinder . regexEscapePath ( \"(\\\\d+)\" ) ) ; } else if ( p instanceof DateTokenConverter ) { DateTokenConverter < Object > dtc = ( DateTokenConverter < Object > ) p ; if ( dtc . isPrimary ( ) ) { buf . append ( p . convert ( date ) ) ; } else { buf . append ( FileFinder . regexEscapePath ( dtc . toRegex ( ) ) ) ; } } p = p . getNext ( ) ; } return buf . toString ( ) ; }", "nl": "Given date convert this instance to a regular expression ."}}
{"translation": {"code": "public void escape ( String escapeChars , StringBuffer buf , char next , int pointer ) { super . escape ( \"\" + CoreConstants . PERCENT_CHAR + CoreConstants . RIGHT_PARENTHESIS_CHAR , buf , next , pointer ) ; }", "nl": "Do not perform any character escaping except for % and ) ."}}
{"translation": {"code": "Node T ( ) throws ScanException { Token t = getCurentToken ( ) ; expectNotNull ( t , \"a LITERAL or '%'\" ) ; switch ( t . getType ( ) ) { case Token . LITERAL : advanceTokenPointer ( ) ; return new Node ( Node . LITERAL , t . getValue ( ) ) ; case Token . PERCENT : advanceTokenPointer ( ) ; // System.out.println(\"% token found\"); FormatInfo fi ; Token u = getCurentToken ( ) ; FormattingNode c ; expectNotNull ( u , \"a FORMAT_MODIFIER, SIMPLE_KEYWORD or COMPOUND_KEYWORD\" ) ; if ( u . getType ( ) == Token . FORMAT_MODIFIER ) { fi = FormatInfo . valueOf ( ( String ) u . getValue ( ) ) ; advanceTokenPointer ( ) ; c = C ( ) ; c . setFormatInfo ( fi ) ; } else { c = C ( ) ; } return c ; default : return null ; } }", "nl": "T = LITERAL | % C | % FORMAT_MODIFIER C"}}
{"translation": {"code": "public void addSubstitutionProperty ( String key , String value ) { if ( key == null || value == null ) { return ; } // values with leading or trailing spaces are bad. We remove them now. value = value . trim ( ) ; propertiesMap . put ( key , value ) ; }", "nl": "Add a property to the properties of this execution context . If the property exists already it is overwritten ."}}
{"translation": {"code": "public String getProperty ( String key ) { String v = propertiesMap . get ( key ) ; if ( v != null ) { return v ; } else { return context . getProperty ( key ) ; } }", "nl": "If a key is found in propertiesMap then return it . Otherwise delegate to the context ."}}
{"translation": {"code": "Node E ( ) throws ScanException { Node t = T ( ) ; if ( t == null ) { return null ; } Node eOpt = Eopt ( ) ; if ( eOpt != null ) { t . setNext ( eOpt ) ; } return t ; }", "nl": "E = TEopt"}}
{"translation": {"code": "public void rename ( String src , String target ) throws RolloverFailure { if ( src . equals ( target ) ) { addWarn ( \"Source and target files are the same [\" + src + \"]. Skipping.\" ) ; return ; } File srcFile = new File ( src ) ; if ( srcFile . exists ( ) ) { File targetFile = new File ( target ) ; createMissingTargetDirsIfNecessary ( targetFile ) ; addInfo ( \"Renaming file [\" + srcFile + \"] to [\" + targetFile + \"]\" ) ; boolean result = srcFile . renameTo ( targetFile ) ; if ( ! result ) { addWarn ( \"Failed to rename file [\" + srcFile + \"] as [\" + targetFile + \"].\" ) ; Boolean areOnDifferentVolumes = areOnDifferentVolumes ( srcFile , targetFile ) ; if ( Boolean . TRUE . equals ( areOnDifferentVolumes ) ) { addWarn ( \"Detected different file systems for source [\" + src + \"] and target [\" + target + \"]. Attempting rename by copying.\" ) ; renameByCopying ( src , target ) ; return ; } else { addWarn ( \"Please consider leaving the [file] option of \" + RollingFileAppender . class . getSimpleName ( ) + \" empty.\" ) ; addWarn ( \"See also \" + RENAMING_ERROR_URL ) ; } } } else { throw new RolloverFailure ( \"File [\" + src + \"] does not exist.\" ) ; } }", "nl": "A relatively robust file renaming method which in case of failure due to src and target being on different volumes falls back onto renaming by copying ."}}
{"translation": {"code": "Boolean areOnDifferentVolumes ( File srcFile , File targetFile ) throws RolloverFailure { if ( ! EnvUtil . isJDK7OrHigher ( ) ) { return false ; } // target file is not certain to exist but its parent has to exist given the call hierarchy of this method File parentOfTarget = targetFile . getAbsoluteFile ( ) . getParentFile ( ) ; if ( parentOfTarget == null ) { addWarn ( \"Parent of target file [\" + targetFile + \"] is null\" ) ; return null ; } if ( ! parentOfTarget . exists ( ) ) { addWarn ( \"Parent of target file [\" + targetFile + \"] does not exist\" ) ; return null ; } try { boolean onSameFileStore = FileStoreUtil . areOnSameFileStore ( srcFile , parentOfTarget ) ; return ! onSameFileStore ; } catch ( RolloverFailure rf ) { addWarn ( \"Error while checking file store equality\" , rf ) ; return null ; } }", "nl": "Attempts tp determine whether both files are on different volumes . Returns true if we could determine that the files are on different volumes . Returns false otherwise or if an error occurred while doing the check ."}}
{"translation": {"code": "public Converter < E > compile ( final Node top , Map < String , String > converterMap ) { Compiler < E > compiler = new Compiler < E > ( top , converterMap ) ; compiler . setContext ( context ) ; //compiler.setStatusManager(statusManager); return compiler . compile ( ) ; }", "nl": "When the parsing step is done the Node list can be transformed into a converter chain ."}}
{"translation": {"code": "private URL findConfigFileFromSystemProperties ( boolean updateStatus ) { String logbackConfigFile = OptionHelper . getSystemProperty ( CONFIG_FILE_PROPERTY ) ; if ( logbackConfigFile != null ) { URL result = null ; try { File file = new File ( logbackConfigFile ) ; if ( file . exists ( ) && file . isFile ( ) ) { if ( updateStatus ) { statusOnResourceSearch ( logbackConfigFile , this . classLoader , logbackConfigFile ) ; } result = file . toURI ( ) . toURL ( ) ; } else { result = new URL ( logbackConfigFile ) ; } return result ; } catch ( MalformedURLException e ) { // so, resource is not a URL: // attempt to get the resource from the class path result = Loader . getResource ( logbackConfigFile , this . classLoader ) ; if ( result != null ) { return result ; } } finally { if ( updateStatus ) { statusOnResourceSearch ( logbackConfigFile , this . classLoader , result != null ? result . toString ( ) : null ) ; } } } return null ; }", "nl": "Finds a configuration file by system property"}}
{"translation": {"code": "public void autoConfig ( ) throws JoranException { StatusListenerConfigHelper . installIfAsked ( loggerContext ) ; new AndroidContextUtil ( ) . setupProperties ( loggerContext ) ; boolean verbose = true ; boolean configured = false ; JoranConfigurator configurator = new JoranConfigurator ( ) ; configurator . setContext ( loggerContext ) ; // search system property if ( ! configured ) { URL url = findConfigFileFromSystemProperties ( verbose ) ; if ( url != null ) { configurator . doConfigure ( url ) ; configured = true ; } } // search assets if ( ! configured ) { URL assetsConfigUrl = findConfigFileURLFromAssets ( verbose ) ; if ( assetsConfigUrl != null ) { configurator . doConfigure ( assetsConfigUrl ) ; configured = true ; } } }", "nl": "Configures logback with the first configuration found in the following search path . If no configuration found nothing is done and logging is disabled ."}}
{"translation": {"code": "private void statusOnResourceSearch ( String resourceName , ClassLoader classLoader , String path ) { StatusManager sm = loggerContext . getStatusManager ( ) ; if ( path == null ) { sm . add ( new InfoStatus ( \"Could NOT find resource [\" + resourceName + \"]\" , loggerContext ) ) ; } else { sm . add ( new InfoStatus ( \"Found resource [\" + resourceName + \"] at [\" + path + \"]\" , loggerContext ) ) ; } }", "nl": "Adds a status message for the result of the resource search"}}
{"translation": {"code": "private String outputMDCForAllKeys ( Map < String , String > mdcPropertyMap ) { StringBuilder buf = new StringBuilder ( ) ; boolean first = true ; for ( Map . Entry < String , String > entry : mdcPropertyMap . entrySet ( ) ) { if ( first ) { first = false ; } else { buf . append ( \", \" ) ; } //format: key0=value0, key1=value1 buf . append ( entry . getKey ( ) ) . append ( ' ' ) . append ( entry . getValue ( ) ) ; } return buf . toString ( ) ; }", "nl": "if no key is specified return all the values present in the MDC in the format k1 = v1 k2 = v2 ..."}}
{"translation": {"code": "public void add ( Status newStatus ) { // LBCORE-72: fire event before the count check fireStatusAddEvent ( newStatus ) ; count ++ ; if ( newStatus . getLevel ( ) > level ) { level = newStatus . getLevel ( ) ; } synchronized ( statusListLock ) { if ( statusList . size ( ) < MAX_HEADER_COUNT ) { statusList . add ( newStatus ) ; } else { tailBuffer . add ( newStatus ) ; } } }", "nl": "Add a new status object ."}}
{"translation": {"code": "public boolean add ( StatusListener listener ) { synchronized ( statusListenerListLock ) { if ( listener instanceof OnConsoleStatusListener ) { boolean alreadyPresent = checkForPresence ( statusListenerList , listener . getClass ( ) ) ; if ( alreadyPresent ) { return false ; } } statusListenerList . add ( listener ) ; } return true ; }", "nl": "This implementation does not allow duplicate installations of OnConsoleStatusListener"}}
{"translation": {"code": "private URL getResource ( String filename , ClassLoader myClassLoader , boolean updateStatus ) { URL url = myClassLoader . getResource ( filename ) ; if ( updateStatus ) { String resourcePath = null ; if ( url != null ) { resourcePath = filename ; } statusOnResourceSearch ( filename , myClassLoader , resourcePath ) ; } return url ; }", "nl": "Uses the given classloader to search for a resource"}}
{"translation": {"code": "public static StackTraceElement [ ] extract ( Throwable t , String fqnOfInvokingClass , final int maxDepth , List < String > frameworkPackageList ) { if ( t == null ) { return null ; } StackTraceElement [ ] steArray = t . getStackTrace ( ) ; StackTraceElement [ ] callerDataArray ; int found = LINE_NA ; for ( int i = 0 ; i < steArray . length ; i ++ ) { if ( isInFrameworkSpace ( steArray [ i ] . getClassName ( ) , fqnOfInvokingClass , frameworkPackageList ) ) { // the caller is assumed to be the next stack frame, hence the +1. found = i + 1 ; } else { if ( found != LINE_NA ) { break ; } } } // we failed to extract caller data if ( found == LINE_NA ) { return EMPTY_CALLER_DATA_ARRAY ; } int availableDepth = steArray . length - found ; int desiredDepth = maxDepth < ( availableDepth ) ? maxDepth : availableDepth ; callerDataArray = new StackTraceElement [ desiredDepth ] ; for ( int i = 0 ; i < desiredDepth ; i ++ ) { callerDataArray [ i ] = steArray [ found + i ] ; } return callerDataArray ; }", "nl": "Extract caller data information as an array based on a Throwable passed as parameter"}}
{"translation": {"code": "public boolean evaluate ( ILoggingEvent event ) throws NullPointerException , EvaluationException { Marker eventsMarker = event . getMarker ( ) ; if ( eventsMarker == null ) { return false ; } for ( String markerStr : markerList ) { if ( eventsMarker . contains ( markerStr ) ) { return true ; } } return false ; }", "nl": "Return true if event passed as parameter contains one of the specified user - markers ."}}
{"translation": {"code": "public static Method getValueOfMethod ( Class < ? > type ) { try { return type . getMethod ( CoreConstants . VALUE_OF , STING_CLASS_PARAMETER ) ; } catch ( NoSuchMethodException e ) { return null ; } catch ( SecurityException e ) { return null ; } }", "nl": "returned value may be null and in most cases it is null ."}}
{"translation": {"code": "static ContextSelector dynamicalContextSelector ( LoggerContext defaultLoggerContext , String contextSelectorStr ) throws ClassNotFoundException , SecurityException , NoSuchMethodException , IllegalArgumentException , InstantiationException , IllegalAccessException , InvocationTargetException { Class < ? > contextSelectorClass = Loader . loadClass ( contextSelectorStr ) ; Constructor cons = contextSelectorClass . getConstructor ( new Class [ ] { LoggerContext . class } ) ; return ( ContextSelector ) cons . newInstance ( defaultLoggerContext ) ; }", "nl": "Instantiate the context selector class designated by the user . The selector must have a constructor taking a LoggerContext instance as an argument ."}}
{"translation": {"code": "public void init ( LoggerContext defaultLoggerContext , Object key ) throws ClassNotFoundException , NoSuchMethodException , InstantiationException , IllegalAccessException , InvocationTargetException { if ( this . key == null ) { this . key = key ; } else if ( this . key != key ) { throw new IllegalAccessException ( \"Only certain classes can access this method.\" ) ; } String contextSelectorStr = OptionHelper . getSystemProperty ( ClassicConstants . LOGBACK_CONTEXT_SELECTOR ) ; if ( contextSelectorStr == null ) { contextSelector = new DefaultContextSelector ( defaultLoggerContext ) ; } else if ( contextSelectorStr . equals ( \"JNDI\" ) ) { throw new RuntimeException ( \"JNDI not supported\" ) ; } else { contextSelector = dynamicalContextSelector ( defaultLoggerContext , contextSelectorStr ) ; } }", "nl": "FOR INTERNAL USE . This method is intended for use by StaticLoggerBinder ."}}
{"translation": {"code": "public void end ( InterpretationContext ec , String name ) { if ( inError ) { return ; } Object o = ec . peekObject ( ) ; if ( o != definer ) { addWarn ( \"The object at the of the stack is not the property definer for property named [\" + propertyName + \"] pushed earlier.\" ) ; } else { addInfo ( \"Popping property definer for property named [\" + propertyName + \"] from the object stack\" ) ; ec . popObject ( ) ; // let's put defined property and value to context but only if it is // not null String propertyValue = definer . getPropertyValue ( ) ; if ( propertyValue != null ) { ActionUtil . setProperty ( ec , propertyName , propertyValue , scope ) ; } } }", "nl": "Now property definer is initialized by all properties and we can put property value to context"}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) CompositeConverter < E > createCompositeConverter ( CompositeNode cn ) { String keyword = ( String ) cn . getValue ( ) ; String converterClassStr = ( String ) converterMap . get ( keyword ) ; if ( converterClassStr != null ) { try { return ( CompositeConverter < E > ) OptionHelper . instantiateByClassName ( converterClassStr , CompositeConverter . class , context ) ; } catch ( Exception e ) { addError ( \"Failed to instantiate converter class [\" + converterClassStr + \"] as a composite converter for keyword [\" + keyword + \"]\" , e ) ; return null ; } } else { addError ( \"There is no conversion class registered for composite conversion word [\" + keyword + \"]\" ) ; return null ; } }", "nl": "Attempt to create a converter using the information found in compositeConverterMap ."}}
{"translation": {"code": "public static void print ( Context context , long threshold ) { if ( context == null ) { throw new IllegalArgumentException ( \"Context argument cannot be null\" ) ; } StatusManager sm = context . getStatusManager ( ) ; if ( sm == null ) { ps . println ( \"WARN: Context named \\\"\" + context . getName ( ) + \"\\\" has no status manager\" ) ; } else { print ( sm , threshold ) ; } }", "nl": "Print context s status data with a timestamp higher than the threshold ."}}
{"translation": {"code": "static public MethodDescriptor [ ] getMethodDescriptors ( Class < ? > clazz ) { ArrayList < MethodDescriptor > methods = new ArrayList < MethodDescriptor > ( ) ; for ( Method m : clazz . getMethods ( ) ) { methods . add ( new MethodDescriptor ( m . getName ( ) , m ) ) ; } return methods . toArray ( new MethodDescriptor [ 0 ] ) ; }", "nl": "Gets a class s method descriptors"}}
{"translation": {"code": "static public PropertyDescriptor [ ] getPropertyDescriptors ( Class < ? > clazz ) { final String SETTER_PREFIX = \"set\" ; final String GETTER_PREFIX = \"get\" ; final int LEN_PREFIX = SETTER_PREFIX . length ( ) ; Map < String , PropertyDescriptor > map = new HashMap < String , PropertyDescriptor > ( ) ; for ( Method m : clazz . getMethods ( ) ) { PropertyDescriptor pd = null ; String mName = m . getName ( ) ; boolean isGet = mName . startsWith ( GETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; boolean isSet = mName . startsWith ( SETTER_PREFIX ) && ( mName . length ( ) > LEN_PREFIX ) ; if ( isGet || isSet ) { String propName = decapitalize ( mName . substring ( LEN_PREFIX ) ) ; pd = map . get ( propName ) ; if ( pd == null ) { pd = new PropertyDescriptor ( propName ) ; map . put ( propName , pd ) ; } Class < ? > [ ] parmTypes = m . getParameterTypes ( ) ; if ( isSet ) { if ( parmTypes . length == 1 ) { // we only want the single-parm setter pd . setWriteMethod ( m ) ; pd . setPropertyType ( parmTypes [ 0 ] ) ; } } else if ( isGet ) { if ( parmTypes . length == 0 ) { // we only want the zero-parm getter pd . setReadMethod ( m ) ; // let setter's type take priority if ( pd . getPropertyType ( ) == null ) { pd . setPropertyType ( m . getReturnType ( ) ) ; } } } } } return map . values ( ) . toArray ( new PropertyDescriptor [ 0 ] ) ; }", "nl": "Gets a class s property descriptors . All properties have methods whose name begins with set or get . The setters must have a single parameter and getters must have none ."}}
{"translation": {"code": "static public String decapitalize ( String name ) { if ( name == null || name . length ( ) == 0 ) { return name ; } else { String nm = name . substring ( 0 , 1 ) . toLowerCase ( Locale . US ) ; if ( name . length ( ) > 1 ) { nm += name . substring ( 1 ) ; } return nm ; } }", "nl": "Converts a name string s first letter to lowercase"}}
{"translation": {"code": "public static ClassLoader getClassLoaderAsPrivileged ( final Class < ? > clazz ) { if ( ! HAS_GET_CLASS_LOADER_PERMISSION ) return null ; else return AccessController . doPrivileged ( new PrivilegedAction < ClassLoader > ( ) { public ClassLoader run ( ) { return clazz . getClassLoader ( ) ; } } ) ; }", "nl": "Returns the class loader of clazz in an access privileged section ."}}
{"translation": {"code": "public static String getEnv ( String key ) { try { return System . getenv ( key ) ; } catch ( SecurityException e ) { return null ; } }", "nl": "Lookup a key from the environment ."}}
{"translation": {"code": "private void updateMaskIfNecessary ( long now ) { final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; lastMaskCheck = now ; if ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { mask = ( mask << 1 ) | 1 ; } else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { mask = mask >>> 2 ; } }", "nl": "update the mask so as to execute change detection code about once every 100 to 8000 milliseconds ."}}
{"translation": {"code": "protected boolean isDiscardable ( ILoggingEvent event ) { Level level = event . getLevel ( ) ; return level . toInt ( ) <= Level . INFO_INT ; }", "nl": "Events of level TRACE DEBUG and INFO are deemed to be discardable ."}}
{"translation": {"code": "static public void setProperties ( InterpretationContext ic , Properties props , Scope scope ) { switch ( scope ) { case LOCAL : ic . addSubstitutionProperties ( props ) ; break ; case CONTEXT : ContextUtil cu = new ContextUtil ( ic . getContext ( ) ) ; cu . addProperties ( props ) ; break ; case SYSTEM : OptionHelper . setSystemProperties ( ic , props ) ; } }", "nl": "Add all the properties found in the argument named props to an InterpretationContext ."}}
{"translation": {"code": "static public Scope stringToScope ( String scopeStr ) { if ( Scope . SYSTEM . toString ( ) . equalsIgnoreCase ( scopeStr ) ) return Scope . SYSTEM ; if ( Scope . CONTEXT . toString ( ) . equalsIgnoreCase ( scopeStr ) ) return Scope . CONTEXT ; return Scope . LOCAL ; }", "nl": "Convert a string into a scope . Scope . LOCAL is returned by default ."}}
{"translation": {"code": "public static int getSeparatorIndexOf ( String name , int fromIndex ) { int dotIndex = name . indexOf ( CoreConstants . DOT , fromIndex ) ; int dollarIndex = name . indexOf ( CoreConstants . DOLLAR , fromIndex ) ; if ( dotIndex == - 1 && dollarIndex == - 1 ) return - 1 ; if ( dotIndex == - 1 ) return dollarIndex ; if ( dollarIndex == - 1 ) return dotIndex ; return dotIndex < dollarIndex ? dotIndex : dollarIndex ; }", "nl": "Get the position of the separator character if any starting at position fromIndex ."}}
{"translation": {"code": "public void setMDCPropertyMap ( Map < String , String > map ) { if ( mdcPropertyMap != null ) { throw new IllegalStateException ( \"The MDCPropertyMap has been already set for this event.\" ) ; } this . mdcPropertyMap = map ; }", "nl": "Set the MDC map for this event ."}}
{"translation": {"code": "private void retrospectivePrint ( ) { if ( context == null ) return ; long now = System . currentTimeMillis ( ) ; StatusManager sm = context . getStatusManager ( ) ; List < Status > statusList = sm . getCopyOfStatusList ( ) ; for ( Status status : statusList ) { long timestampOfStatusMesage = status . getDate ( ) ; if ( isElapsedTimeLongerThanThreshold ( now , timestampOfStatusMesage ) ) { print ( status ) ; } } }", "nl": "Print status messages retrospectively"}}
{"translation": {"code": "static public boolean contextHasStatusListener ( Context context ) { StatusManager sm = context . getStatusManager ( ) ; if ( sm == null ) return false ; List < StatusListener > listeners = sm . getCopyOfStatusListenerList ( ) ; if ( listeners == null || listeners . size ( ) == 0 ) return false ; else return true ; }", "nl": "Returns true if the StatusManager associated with the context passed as parameter has one or more StatusListener instances registered . Returns false otherwise ."}}
{"translation": {"code": "private void handleThrowableFirstLine ( OutputStream sw , IThrowableProxy tp , String stackTracePrefix , boolean isRootException ) throws IOException { StringBuilder sb = new StringBuilder ( ) . append ( stackTracePrefix ) ; if ( ! isRootException ) { sb . append ( CoreConstants . CAUSED_BY ) ; } sb . append ( tp . getClassName ( ) ) . append ( \": \" ) . append ( tp . getMessage ( ) ) ; sw . write ( sb . toString ( ) . getBytes ( ) ) ; sw . flush ( ) ; }", "nl": "LOGBACK - 411 and LOGBACK - 750"}}
{"translation": {"code": "public String get ( String key , String def ) throws IllegalArgumentException { if ( SystemProperties == null || getString == null ) return null ; String ret = null ; try { ret = ( String ) getString . invoke ( SystemProperties , new Object [ ] { key , def } ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( Exception e ) { } // if return value is null or empty, use the default // since neither of those are valid values if ( ret == null || ret . length ( ) == 0 ) { ret = def ; } return ret ; }", "nl": "Get the value for the given key in the Android system properties"}}
{"translation": {"code": "public Boolean getBoolean ( String key , boolean def ) throws IllegalArgumentException { if ( SystemProperties == null || getBoolean == null ) return def ; Boolean ret = def ; try { ret = ( Boolean ) getBoolean . invoke ( SystemProperties , new Object [ ] { key , def } ) ; } catch ( IllegalArgumentException e ) { throw e ; } catch ( Exception e ) { } return ret ; }", "nl": "Get the value for the given key in the Android system properties returned as a boolean ."}}
{"translation": {"code": "public void setClassLoader ( ClassLoader cl ) throws ClassNotFoundException , SecurityException , NoSuchMethodException { if ( cl == null ) cl = this . getClass ( ) . getClassLoader ( ) ; SystemProperties = cl . loadClass ( \"android.os.SystemProperties\" ) ; getString = SystemProperties . getMethod ( \"get\" , new Class [ ] { String . class , String . class } ) ; getBoolean = SystemProperties . getMethod ( \"getBoolean\" , new Class [ ] { String . class , boolean . class } ) ; }", "nl": "Sets the classloader to lookup the class for android . os . SystemProperties"}}
{"translation": {"code": "public static String getAndroidSystemProperty ( String key ) { try { return SystemPropertiesProxy . getInstance ( ) . get ( key , null ) ; } catch ( IllegalArgumentException e ) { return null ; } }", "nl": "Gets an Android system property"}}
{"translation": {"code": "private String getAbsoluteFilePath ( String filename ) { // In Android, relative paths created with File() are relative // to root, so fix it by prefixing the path to the app's \"files\" // directory. // This transformation is rather expensive, since it involves loading the // Android manifest from the APK (which is a ZIP file), and parsing it to // retrieve the application package name. This should be avoided if // possible as it may perceptibly delay the app launch time. if ( EnvUtil . isAndroidOS ( ) && ! new File ( filename ) . isAbsolute ( ) ) { String dataDir = context . getProperty ( CoreConstants . DATA_DIR_KEY ) ; filename = FileUtil . prefixRelativePath ( dataDir , filename ) ; } return filename ; }", "nl": "Gets the absolute path to the filename starting from the app s files directory if it is not already an absolute path"}}
{"translation": {"code": "private static boolean isInFrameworkSpaceList ( String currentClass , List < String > frameworkPackageList ) { if ( frameworkPackageList == null ) return false ; for ( String s : frameworkPackageList ) { if ( currentClass . startsWith ( s ) ) return true ; } return false ; }", "nl": "Is currentClass present in the list of packages considered part of the logging framework?"}}
{"translation": {"code": "static public boolean areOnSameFileStore ( File a , File b ) throws RolloverFailure { if ( ! a . exists ( ) ) { throw new IllegalArgumentException ( \"File [\" + a + \"] does not exist.\" ) ; } if ( ! b . exists ( ) ) { throw new IllegalArgumentException ( \"File [\" + b + \"] does not exist.\" ) ; } // Implements the following by reflection //    Path pathA = a.toPath(); //    Path pathB = b.toPath(); // //    FileStore fileStoreA = Files.getFileStore(pathA); //    FileStore fileStoreB = Files.getFileStore(pathB); // //    return fileStoreA.equals(fileStoreB); try { Class < ? > pathClass = Class . forName ( PATH_CLASS_STR ) ; Class < ? > filesClass = Class . forName ( FILES_CLASS_STR ) ; Method toPath = File . class . getMethod ( \"toPath\" ) ; Method getFileStoreMethod = filesClass . getMethod ( \"getFileStore\" , pathClass ) ; Object pathA = toPath . invoke ( a ) ; Object pathB = toPath . invoke ( b ) ; Object fileStoreA = getFileStoreMethod . invoke ( null , pathA ) ; Object fileStoreB = getFileStoreMethod . invoke ( null , pathB ) ; return fileStoreA . equals ( fileStoreB ) ; } catch ( Exception e ) { throw new RolloverFailure ( \"Failed to check file store equality for [\" + a + \"] and [\" + b + \"]\" , e ) ; } }", "nl": "This method assumes that both files a and b exists ."}}
{"translation": {"code": "private String locationFromSystemProperty ( String name ) { String location = System . getProperty ( name ) ; if ( location != null && ! location . startsWith ( \"file:\" ) ) { location = \"file:\" + location ; } return location ; }", "nl": "Constructs a resource location from a JSSE system property ."}}
{"translation": {"code": "private KeyStoreFactoryBean keyStoreFromSystemProperties ( String property ) { if ( System . getProperty ( property ) == null ) return null ; KeyStoreFactoryBean keyStore = new KeyStoreFactoryBean ( ) ; keyStore . setLocation ( locationFromSystemProperty ( property ) ) ; keyStore . setProvider ( System . getProperty ( property + \"Provider\" ) ) ; keyStore . setPassword ( System . getProperty ( property + \"Password\" ) ) ; keyStore . setType ( System . getProperty ( property + \"Type\" ) ) ; return keyStore ; }", "nl": "Constructs a key store factory bean using JSSE system properties ."}}
{"translation": {"code": "static public ExecutorService newExecutorService ( ) { return new ThreadPoolExecutor ( CoreConstants . CORE_POOL_SIZE , CoreConstants . MAX_POOL_SIZE , 0L , TimeUnit . MILLISECONDS , new SynchronousQueue < Runnable > ( ) , THREAD_FACTORY ) ; }", "nl": "Creates an executor service suitable for use by logback components ."}}
{"translation": {"code": "public Socket call ( ) throws InterruptedException { useDefaultsForMissingFields ( ) ; Socket socket = createSocket ( ) ; while ( socket == null && ! Thread . currentThread ( ) . isInterrupted ( ) ) { Thread . sleep ( delayStrategy . nextDelay ( ) ) ; socket = createSocket ( ) ; } return socket ; }", "nl": "Loops until the desired connection is established and returns the resulting connector ."}}
{"translation": {"code": "@ Override public void start ( ) { if ( ( this . encoder == null ) || ( this . encoder . getLayout ( ) == null ) ) { addError ( \"No layout set for the appender named [\" + name + \"].\" ) ; return ; } // tag encoder is optional but needs a layout if ( this . tagEncoder != null ) { final Layout < ? > layout = this . tagEncoder . getLayout ( ) ; if ( layout == null ) { addError ( \"No tag layout set for the appender named [\" + name + \"].\" ) ; return ; } // prevent stack traces from showing up in the tag // (which could lead to very confusing error messages) if ( layout instanceof PatternLayout ) { String pattern = this . tagEncoder . getPattern ( ) ; if ( ! pattern . contains ( \"%nopex\" ) ) { this . tagEncoder . stop ( ) ; this . tagEncoder . setPattern ( pattern + \"%nopex\" ) ; this . tagEncoder . start ( ) ; } PatternLayout tagLayout = ( PatternLayout ) layout ; tagLayout . setPostCompileProcessor ( null ) ; } } super . start ( ) ; }", "nl": "Checks that required parameters are set and if everything is in order activates this appender ."}}
{"translation": {"code": "protected String getTag ( ILoggingEvent event ) { // format tag based on encoder layout; truncate if max length // exceeded (only necessary for isLoggable(), which throws // IllegalArgumentException) String tag = ( this . tagEncoder != null ) ? this . tagEncoder . getLayout ( ) . doLayout ( event ) : event . getLoggerName ( ) ; if ( checkLoggable && ( tag . length ( ) > MAX_TAG_LENGTH ) ) { tag = tag . substring ( 0 , MAX_TAG_LENGTH - 1 ) + \"*\" ; } return tag ; }", "nl": "Gets the logcat tag string of a logging event"}}
{"translation": {"code": "static public boolean isAndroidOS ( ) { String osname = OptionHelper . getSystemProperty ( \"os.name\" ) ; String root = OptionHelper . getEnv ( \"ANDROID_ROOT\" ) ; String data = OptionHelper . getEnv ( \"ANDROID_DATA\" ) ; return osname != null && osname . contains ( \"Linux\" ) && root != null && root . contains ( \"/system\" ) && data != null && data . contains ( \"/data\" ) ; }", "nl": "Heuristically determines whether the current OS is Android"}}