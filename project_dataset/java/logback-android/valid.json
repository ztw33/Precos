{"translation": {"code": "private static short computeReferenceMask ( ILoggingEvent event ) { short mask = 0 ; int mdcPropSize = 0 ; if ( event . getMDCPropertyMap ( ) != null ) { mdcPropSize = event . getMDCPropertyMap ( ) . keySet ( ) . size ( ) ; } int contextPropSize = 0 ; if ( event . getLoggerContextVO ( ) . getPropertyMap ( ) != null ) { contextPropSize = event . getLoggerContextVO ( ) . getPropertyMap ( ) . size ( ) ; } if ( mdcPropSize > 0 || contextPropSize > 0 ) { mask = PROPERTIES_EXIST ; } if ( event . getThrowableProxy ( ) != null ) { mask |= EXCEPTION_EXISTS ; } return mask ; }", "nl": "Computes the reference mask for a logging event including flags to indicate whether MDC properties or exception info is available for the event ."}}
{"translation": {"code": "private void insertException ( SQLiteStatement stmt , String txt , short i , long eventId ) throws SQLException { stmt . bindLong ( 1 , eventId ) ; stmt . bindLong ( 2 , i ) ; stmt . bindString ( 3 , txt ) ; stmt . executeInsert ( ) ; }", "nl": "Inserts an exception into the logging_exceptions table"}}
{"translation": {"code": "private String asStringTruncatedTo254 ( Object o ) { String s = null ; if ( o != null ) { s = o . toString ( ) ; } if ( s != null && s . length ( ) > 254 ) { s = s . substring ( 0 , 254 ) ; } return s == null ? \"\" : s ; }", "nl": "Gets the first 254 characters of an object s string representation . This is used to truncate a logging event s argument binding if necessary ."}}
{"translation": {"code": "private long subAppend ( ILoggingEvent event , SQLiteStatement insertStatement ) throws SQLException { bindLoggingEvent ( insertStatement , event ) ; bindLoggingEventArguments ( insertStatement , event . getArgumentArray ( ) ) ; // This is expensive... should we do it every time? bindCallerData ( insertStatement , event . getCallerData ( ) ) ; long insertId = - 1 ; try { insertId = insertStatement . executeInsert ( ) ; } catch ( SQLiteException e ) { addWarn ( \"Failed to insert loggingEvent\" , e ) ; } return insertId ; }", "nl": "Inserts the main details of a log event into the database"}}
{"translation": {"code": "private void secondarySubAppend ( ILoggingEvent event , long eventId ) throws SQLException { Map < String , String > mergedMap = mergePropertyMaps ( event ) ; insertProperties ( mergedMap , eventId ) ; if ( event . getThrowableProxy ( ) != null ) { insertThrowable ( event . getThrowableProxy ( ) , eventId ) ; } }", "nl": "Updates an existing row of an event with the secondary details of the event . This includes MDC properties and any exception information ."}}
{"translation": {"code": "private String socketAddressToString ( SocketAddress address ) { String addr = address . toString ( ) ; int i = addr . indexOf ( \"/\" ) ; if ( i >= 0 ) { addr = addr . substring ( i + 1 ) ; } return addr ; }", "nl": "Converts a socket address to a reasonable display string ."}}
{"translation": {"code": "private void addClient ( T client ) { clientsLock . lock ( ) ; try { clients . add ( client ) ; } finally { clientsLock . unlock ( ) ; } }", "nl": "Adds a client to the collection of those being tracked by the server ."}}
{"translation": {"code": "private String [ ] enabledCipherSuites ( String [ ] supportedCipherSuites , String [ ] defaultCipherSuites ) { if ( enabledCipherSuites == null ) { // we're assuming that the same engine is used for all configurables // so once we determine the enabled set, we won't do it again if ( OptionHelper . isEmpty ( getIncludedCipherSuites ( ) ) && OptionHelper . isEmpty ( getExcludedCipherSuites ( ) ) ) { enabledCipherSuites = Arrays . copyOf ( defaultCipherSuites , defaultCipherSuites . length ) ; } else { enabledCipherSuites = includedStrings ( supportedCipherSuites , getIncludedCipherSuites ( ) , getExcludedCipherSuites ( ) ) ; } for ( String cipherSuite : enabledCipherSuites ) { addInfo ( \"enabled cipher suite: \" + cipherSuite ) ; } } return enabledCipherSuites ; }", "nl": "Gets the set of enabled cipher suites based on the configuration ."}}
{"translation": {"code": "private void removeClient ( T client ) { clientsLock . lock ( ) ; try { clients . remove ( client ) ; } finally { clientsLock . unlock ( ) ; } }", "nl": "Removes a client from the collection of those being tracked by the server ."}}
{"translation": {"code": "public static URL urlForResource ( String location ) throws MalformedURLException , FileNotFoundException { if ( location == null ) { throw new NullPointerException ( \"location is required\" ) ; } URL url = null ; if ( ! location . matches ( SCHEME_PATTERN ) ) { url = Loader . getResourceBySelfClassLoader ( location ) ; } else if ( location . startsWith ( CLASSPATH_SCHEME ) ) { String path = location . substring ( CLASSPATH_SCHEME . length ( ) ) ; if ( path . startsWith ( \"/\" ) ) { path = path . substring ( 1 ) ; } if ( path . length ( ) == 0 ) { throw new MalformedURLException ( \"path is required\" ) ; } url = Loader . getResourceBySelfClassLoader ( path ) ; } else { url = new URL ( location ) ; } if ( url == null ) { throw new FileNotFoundException ( location ) ; } return url ; }", "nl": "Converts a string describing the location of a resource into a URL object ."}}
{"translation": {"code": "private TrustManager [ ] createTrustManagers ( ContextAware context ) throws NoSuchProviderException , NoSuchAlgorithmException , KeyStoreException { if ( getTrustStore ( ) == null ) return null ; KeyStore trustStore = getTrustStore ( ) . createKeyStore ( ) ; context . addInfo ( \"trust store of type '\" + trustStore . getType ( ) + \"' provider '\" + trustStore . getProvider ( ) + \"': \" + getTrustStore ( ) . getLocation ( ) ) ; TrustManagerFactory tmf = getTrustManagerFactory ( ) . createTrustManagerFactory ( ) ; context . addInfo ( \"trust manager algorithm '\" + tmf . getAlgorithm ( ) + \"' provider '\" + tmf . getProvider ( ) + \"'\" ) ; tmf . init ( trustStore ) ; return tmf . getTrustManagers ( ) ; }", "nl": "Creates trust managers using the receiver s trust store configuration ."}}
{"translation": {"code": "protected boolean shouldStart ( ) { ServerSocket serverSocket = null ; try { serverSocket = getServerSocketFactory ( ) . createServerSocket ( getPort ( ) , getBacklog ( ) , getInetAddress ( ) ) ; ServerListener < RemoteAppenderClient > listener = createServerListener ( serverSocket ) ; runner = createServerRunner ( listener , getContext ( ) . getScheduledExecutorService ( ) ) ; runner . setContext ( getContext ( ) ) ; return true ; } catch ( Exception ex ) { addError ( \"server startup error: \" + ex , ex ) ; CloseUtil . closeQuietly ( serverSocket ) ; return false ; } }", "nl": "Starts the server ."}}
{"translation": {"code": "private boolean lastCheckExpired ( Duration expiry , long lastCleanupTime ) { boolean isExpired = false ; if ( expiry != null && expiry . getMilliseconds ( ) > 0 ) { final long now = this . clock . currentTimeMillis ( ) ; final long timeDiff = now - lastCleanupTime ; isExpired = ( lastCleanupTime <= 0 ) || ( timeDiff >= expiry . getMilliseconds ( ) ) ; } return isExpired ; }", "nl": "Determines whether it s time to clear expired logs"}}
{"translation": {"code": "public File getDatabaseFile ( String filename ) { File dbFile = null ; if ( filename != null && filename . trim ( ) . length ( ) > 0 ) { dbFile = new File ( filename ) ; } if ( dbFile == null || dbFile . isDirectory ( ) ) { dbFile = new File ( new AndroidContextUtil ( ) . getDatabasePath ( \"logback.db\" ) ) ; } return dbFile ; }", "nl": "Gets a file object from a file path to a SQLite database"}}
{"translation": {"code": "public void log ( org . slf4j . event . LoggingEvent slf4jEvent ) { Level level = Level . fromLocationAwareLoggerInteger ( slf4jEvent . getLevel ( ) . toInt ( ) ) ; filterAndLog_0_Or3Plus ( FQCN , slf4jEvent . getMarker ( ) , level , slf4jEvent . getMessage ( ) , slf4jEvent . getArgumentArray ( ) , slf4jEvent . getThrowable ( ) ) ; }", "nl": "Support SLF4J interception during initialization as introduced in SLF4J version 1 . 7 . 15"}}
{"translation": {"code": "static public void addOnConsoleListenerInstance ( Context context , OnConsoleStatusListener onConsoleStatusListener ) { onConsoleStatusListener . setContext ( context ) ; boolean effectivelyAdded = context . getStatusManager ( ) . add ( onConsoleStatusListener ) ; if ( effectivelyAdded ) { onConsoleStatusListener . start ( ) ; } }", "nl": "This utility method adds a new OnConsoleStatusListener to the context passed as parameter ."}}