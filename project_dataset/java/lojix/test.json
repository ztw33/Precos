{"translation": {"code": "private SizeableList < WAMInstruction > optimize ( List < WAMInstruction > instructions ) { StateMachine optimizeConstants = new OptimizeInstructions ( symbolTable , interner ) ; Iterable < WAMInstruction > matcher = new Matcher < WAMInstruction , WAMInstruction > ( instructions . iterator ( ) , optimizeConstants ) ; SizeableList < WAMInstruction > result = new SizeableLinkedList < WAMInstruction > ( ) ; for ( WAMInstruction instruction : matcher ) { result . add ( instruction ) ; } return result ; }", "nl": "Performs an optimization pass for specialized instructions ."}}
{"translation": {"code": "private boolean isVoidVariable ( WAMInstruction instruction ) { SymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; if ( symbolKey != null ) { Integer count = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_OCCURRENCE_COUNT ) ; Boolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_VAR_NON_ARG ) ; Integer allocation = ( Integer ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_ALLOCATION ) ; boolean singleton = ( count != null ) && count . equals ( 1 ) ; boolean nonArgPosition = ( nonArgPositionOnly != null ) && TRUE . equals ( nonArgPositionOnly ) ; boolean permanent = ( allocation != null ) && ( ( byte ) ( ( allocation & 0xff00 ) >> 8 ) == WAMInstruction . STACK_ADDR ) ; if ( singleton && nonArgPosition && ! permanent ) { return true ; } } return false ; }", "nl": "Checks if the term argument to an instruction was a singleton non - argument position variable . The variable must also be non - permanent to ensure that singleton variables in queries are created ."}}
{"translation": {"code": "public boolean isConstant ( WAMInstruction instruction ) { Integer name = instruction . getFunctorNameReg1 ( ) ; if ( name != null ) { FunctorName functorName = interner . getDeinternedFunctorName ( name ) ; if ( functorName . getArity ( ) == 0 ) { return true ; } } return false ; }", "nl": "Checks if the term argument to an instruction was a constant ."}}
{"translation": {"code": "private void tidyTrail ( ) { int i ; // Check that there is a current choice point to tidy down to, otherwise tidy down to the root of the trail. if ( bp == 0 ) { i = TRAIL_BASE ; } else { i = data . get ( bp + data . get ( bp ) + 5 ) ; } while ( i < trp ) { int addr = data . get ( i ) ; if ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { i ++ ; } else { data . put ( i , data . get ( trp - 1 ) ) ; trp -- ; } } }", "nl": "Tidies trail when a choice point is being discarded and a previous choice point it being made the current one ."}}
{"translation": {"code": "private void displayCompiledQuery ( Term query ) { // Pretty print the clause. StringBuffer result = new StringBuffer ( ) ; PositionalTermVisitor displayVisitor = new WAMCompiledQueryPrintingVisitor ( interner , symbolTable , result ) ; TermWalkers . positionalWalker ( displayVisitor ) . walk ( query ) ; /*log.fine(result.toString());*/ }", "nl": "Pretty prints a compiled query ."}}
{"translation": {"code": "private void gatherPositionAndOccurrenceInfo ( Term clause ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; PositionAndOccurrenceVisitor positionAndOccurrenceVisitor = new PositionAndOccurrenceVisitor ( interner , symbolTable , positionalTraverser ) ; positionalTraverser . setContextChangeVisitor ( positionAndOccurrenceVisitor ) ; TermWalker walker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , positionAndOccurrenceVisitor ) ; walker . walk ( clause ) ; }", "nl": "Gather information about variable counts and positions of occurrence of constants and variable within a clause ."}}
{"translation": {"code": "private int findMaxArgumentsInClause ( Clause clause ) { int result = 0 ; Functor head = clause . getHead ( ) ; if ( head != null ) { result = head . getArity ( ) ; } Functor [ ] body = clause . getBody ( ) ; if ( body != null ) { for ( int i = 0 ; i < body . length ; i ++ ) { int arity = body [ i ] . getArity ( ) ; result = ( arity > result ) ? arity : result ; } } return result ; }", "nl": "Examines all top - level functors within a clause including any head and body and determines which functor has the highest number of arguments ."}}
{"translation": {"code": "protected void allocateArgumentRegisters ( Functor expression ) { // Assign argument registers to functors appearing directly in the argument of the outermost functor. // Variables are never assigned directly to argument registers. int reg = 0 ; for ( ; reg < expression . getArity ( ) ; reg ++ ) { Term term = expression . getArgument ( reg ) ; if ( term instanceof Functor ) { /*log.fine(\"X\" + lastAllocatedTempReg + \" = \" + interner.getFunctorFunctorName((Functor) term));*/ int allocation = ( reg & 0xff ) | ( REG_ADDR << 8 ) ; symbolTable . put ( term . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_ALLOCATION , allocation ) ; } } }", "nl": "For a predicate of arity n the first n registers are used to receive its arguments in ."}}
{"translation": {"code": "public static TermWalker goalWalker ( UnaryPredicate < Term > unaryPredicate , TermVisitor visitor ) { TermWalker walker = simpleWalker ( visitor ) ; walker . setGoalPredicate ( unaryPredicate ) ; return walker ; }", "nl": "Provides a depth first walk over a term visiting only when a goal predicate matches ."}}
{"translation": {"code": "public static TermWalker positionalGoalWalker ( UnaryPredicate < Term > unaryPredicate , PositionalTermVisitor visitor ) { TermWalker walker = positionalWalker ( visitor ) ; walker . setGoalPredicate ( unaryPredicate ) ; return walker ; }", "nl": "Provides a positional depth first walk over a term visiting only when a goal predicate matches ."}}
{"translation": {"code": "public static TermWalker positionalWalker ( PositionalTermVisitor visitor ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; positionalTraverser . setContextChangeVisitor ( visitor ) ; visitor . setPositionalTraverser ( positionalTraverser ) ; return new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , visitor ) ; }", "nl": "Provides a positional depth first walk over a term ."}}
{"translation": {"code": "public static TermWalker positionalPostfixWalker ( PositionalTermVisitor visitor ) { PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; positionalTraverser . setContextChangeVisitor ( visitor ) ; visitor . setPositionalTraverser ( positionalTraverser ) ; return new TermWalker ( new PostFixSearch < Term , Term > ( ) , positionalTraverser , visitor ) ; }", "nl": "Provides a positional postfix walk over a term ."}}
{"translation": {"code": "private boolean inTopLevelFunctor ( PositionalContext context ) { PositionalContext parentContext = context . getParentContext ( ) ; return parentContext . isTopLevel ( ) || isTopLevel ( parentContext ) ; }", "nl": "Checks if the current position is immediately within a top - level functor ."}}
{"translation": {"code": "private void gatherDisjunctions ( Disjunction disjunction , List < Term > expressions ) { // Left argument. gatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 0 ] , expressions ) ; // Right argument. gatherDisjunctionsExploreArgument ( disjunction . getArguments ( ) [ 1 ] , expressions ) ; }", "nl": "Gathers the functors to compile as a sequence of choice points . These exist as the arguments to disjunctions recursively below the supplied disjunction . They are flattened into a list by performing a left - to - right depth first traversal over the disjunctions and adding their arguments into a list ."}}
{"translation": {"code": "protected void leaveFunctor ( Functor functor ) { int pos = traverser . getPosition ( ) ; if ( ! traverser . isInHead ( ) && ( pos >= 0 ) ) { Functor transformed = builtInTransform . apply ( functor ) ; if ( functor != transformed ) { /*log.fine(\"Transformed: \" + functor + \" to \" + transformed.getClass());*/ BuiltInFunctor builtInFunctor = ( BuiltInFunctor ) transformed ; Term parentTerm = traverser . getParentContext ( ) . getTerm ( ) ; if ( parentTerm instanceof Clause ) { Clause parentClause = ( Clause ) parentTerm ; parentClause . getBody ( ) [ pos ] = builtInFunctor ; } else if ( parentTerm instanceof Functor ) { Functor parentFunctor = ( Functor ) parentTerm ; parentFunctor . getArguments ( ) [ pos ] = builtInFunctor ; } } } }", "nl": "Applies the built - in transform during a post - fix visit of a term ."}}
{"translation": {"code": "private void topLevelCheck ( Term clause ) { TermWalker walk = TermWalkers . positionalWalker ( new TopLevelCheckVisitor ( interner , symbolTable , null ) ) ; walk . walk ( clause ) ; }", "nl": "Finds and marks all functors within the clause that are considered to be top - level ."}}
{"translation": {"code": "private void notifyChanges ( Iterable < PropertyChangeEvent > changes ) { List < PropertyChangeListener > activeListeners = listeners . getActiveListeners ( ) ; if ( activeListeners != null ) { for ( PropertyChangeListener listener : activeListeners ) { for ( PropertyChangeEvent event : changes ) { listener . propertyChange ( event ) ; } } } }", "nl": "Fires off a list of property change events to any interested listeners ."}}
{"translation": {"code": "public void terminated ( ) { try { stateLock . writeLock ( ) . lock ( ) ; if ( ( state == State . Shutdown ) || ( state == State . Running ) ) { state = State . Terminated ; stateChange . signalAll ( ) ; } } finally { stateLock . writeLock ( ) . unlock ( ) ; } }", "nl": "Makes a transaction from the Running or Shutdown state to the Terminated state or no transition if the current state is not Running or Shutdown ."}}
{"translation": {"code": "public void running ( ) { try { stateLock . writeLock ( ) . lock ( ) ; if ( state == State . Initial ) { state = State . Running ; stateChange . signalAll ( ) ; } } finally { stateLock . writeLock ( ) . unlock ( ) ; } }", "nl": "Makes a transaction from the Initial state to the Running state or no transition if the current state is not Initial ."}}
{"translation": {"code": "public static void main ( String [ ] args ) { try { Main main = new Main ( ) ; main . start ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( main . getShutdownHook ( ) ) ; main . awaitTermination ( 1 , TimeUnit . DAYS ) ; } catch ( InterruptedException e ) { e = null ; Thread . currentThread ( ) . interrupt ( ) ; } }", "nl": "Launches the debugger as a stand - alone Swing application ."}}
{"translation": {"code": "private void showHorizontalBar ( ) { // Left vertical bar. Component bar = factory . createGripPanel ( layout . getConsoleHeightResizer ( ) , false ) ; frame . getContentPane ( ) . add ( bar , DesktopAppLayout . STATUS_BAR ) ; }", "nl": "Creates a horizontal grip - able bar for adjusting the console height ."}}
{"translation": {"code": "private void showLeftBar ( ) { // Left vertical bar. Component bar = factory . createGripPanel ( layout . getLeftPaneWidthResizer ( ) , true ) ; frame . getContentPane ( ) . add ( bar , DesktopAppLayout . LEFT_VERTICAL_BAR ) ; }", "nl": "Creates a vertical grip - able bar for adjusting the left panel width ."}}
{"translation": {"code": "public void updateRegisters ( WAMMemoryLayout layout ) { List < PropertyChangeEvent > changes = delta ( this , layout ) ; regBase = layout . regBase ; regSize = layout . regSize ; heapBase = layout . heapBase ; heapSize = layout . heapSize ; stackBase = layout . stackBase ; stackSize = layout . stackSize ; trailBase = layout . trailBase ; trailSize = layout . trailSize ; pdlBase = layout . pdlBase ; pdlSize = layout . pdlSize ; notifyChanges ( changes ) ; }", "nl": "Updates the layout register file with a new set of layout registers ."}}
{"translation": {"code": "private void setRowAttribute ( AttributeSet attributes , int r ) { if ( r >= rowAttributes . size ( ) ) { for ( int i = rowAttributes . size ( ) ; i <= r ; i ++ ) { rowAttributes . add ( null ) ; } } rowAttributes . set ( r , attributes ) ; }", "nl": "Sets a row attribute adding padding to the underlying array as necessary to ensure it is large enough to hold the attribute at the requested position ."}}
{"translation": {"code": "private void copyAndResizeCodeBuffer ( ByteBuffer codeBuffer , int start , int length ) { // Check the internal code buffer is large enough or resize it, then copy in the new instructions. int max = start + length ; if ( this . codeBuffer . limit ( ) <= max ) { ByteBuffer newCodeBuffer = ByteBuffer . allocate ( max * 2 ) ; newCodeBuffer . put ( this . codeBuffer . array ( ) , 0 , this . codeBuffer . limit ( ) ) ; log . fine ( \"Re-sized code buffer to \" + ( max * 2 ) ) ; } codeBuffer . position ( start ) ; codeBuffer . get ( this . codeBuffer . array ( ) , start , length ) ; }", "nl": "Copies code from the specified code buffer into the internal one resizing the internal code buffer if necessary to make enough room ."}}
{"translation": {"code": "protected Dimension computeGridSize ( ) { int cols = model . getWidth ( ) ; int rows = model . getHeight ( ) ; int horizSeparatorSize = 0 ; for ( int size : model . getHorizontalSeparators ( ) . values ( ) ) { horizSeparatorSize += size ; } int vertSeparatorSize = 0 ; for ( int size : model . getVerticalSeparators ( ) . values ( ) ) { vertSeparatorSize += size ; } return new Dimension ( vertSeparatorSize + colToX ( cols ) , horizSeparatorSize + rowToY ( rows ) ) ; }", "nl": "Computes the rendered dimensions of the text grid model on screen . Used for sizing this component ."}}
{"translation": {"code": "private String modifiersToString ( int modifiers ) { String result = \"\" ; if ( ( modifiers & InputEvent . SHIFT_MASK ) != 0 ) { result += \"shift \" ; } if ( ( modifiers & InputEvent . CTRL_MASK ) != 0 ) { result += \"ctrl \" ; } if ( ( modifiers & InputEvent . META_MASK ) != 0 ) { result += \"meta \" ; } if ( ( modifiers & InputEvent . ALT_MASK ) != 0 ) { result += \"alt \" ; } if ( ( modifiers & InputEvent . ALT_GRAPH_MASK ) != 0 ) { result += \"altGraph \" ; } return result ; }", "nl": "Converts the modifiers to a specification string for KeyStroke ."}}
{"translation": {"code": "private void read ( Term term ) { if ( term . isNumber ( ) ) { NumericType numericType = ( NumericType ) term ; if ( numericType . isInteger ( ) ) { IntLiteral jplInteger = ( IntLiteral ) term ; getContentHandler ( ) . startIntegerTerm ( jplInteger . longValue ( ) ) ; } else if ( numericType . isFloat ( ) ) { FloatLiteral jplFloat = ( FloatLiteral ) term ; getContentHandler ( ) . startFloatTerm ( jplFloat . doubleValue ( ) ) ; } } else if ( term . isVar ( ) ) { Variable var = ( Variable ) term ; getContentHandler ( ) . startVariable ( interner . getVariableName ( var . getName ( ) ) ) ; } else if ( term . isAtom ( ) ) { Functor atom = ( Functor ) term ; getContentHandler ( ) . startAtom ( interner . getFunctorName ( atom . getName ( ) ) ) ; } else if ( term . isCompound ( ) ) { Functor functor = ( Functor ) term ; getContentHandler ( ) . startCompound ( ) ; getContentHandler ( ) . startAtom ( interner . getFunctorName ( functor . getName ( ) ) ) ; for ( com . thesett . aima . logic . fol . Term child : functor . getArguments ( ) ) { read ( child ) ; } getContentHandler ( ) . endCompound ( ) ; } else { throw new IllegalStateException ( \"Unrecognized Lojix term: \" + term ) ; } }", "nl": "Reads a Lojix term and invoked appropriate methods on the content handler to describe its structure and contents to it ."}}
{"translation": {"code": "public Functor functor ( String name , Term ... args ) { int internedName = interner . internFunctorName ( name , args . length ) ; return new Functor ( internedName , args ) ; }", "nl": "Creates a functor ."}}
{"translation": {"code": "public Variable var ( String name ) { boolean isAnonymous = name . startsWith ( \"_\" ) ; int internedName = interner . internVariableName ( name ) ; return new Variable ( internedName , null , isAnonymous ) ; }", "nl": "Creates a variable . If the variable name begins with an underscore _ it will be anonymous otherwise it will be named ."}}
{"translation": {"code": "public int doStartTag ( ) throws JspException { log . fine ( \"doStartTag: called\" ) ; try { // Write out the beggining of the debug table pageContext . getResponse ( ) . getWriter ( ) . write ( \"<table class=\\\"debug\\\" width=\\\"100%\\\" border=\\\"1\\\">\" ) ; // Write out the debugging info for all categories pageContext . getResponse ( ) . getWriter ( ) . write ( getRequestInfo ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getHeaders ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getCookies ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getParameters ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getRequestScope ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getPageScope ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getSessionScope ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getApplicationScope ( ) ) ; pageContext . getResponse ( ) . getWriter ( ) . write ( getUserPrincipal ( ) ) ; // Write out the closing of the debug table pageContext . getResponse ( ) . getWriter ( ) . write ( \"</table>\" ) ; } catch ( IOException e ) { throw new JspException ( \"Got an IOException whilst writing the debug tag to the page.\" , e ) ; } // Continue processing the page return ( EVAL_BODY_INCLUDE ) ; }", "nl": "Renders the debugging message ."}}
{"translation": {"code": "public ActionForward execute ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { log . fine ( \"ActionForward perform(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse): called\" ) ; // Build an ActionErrors object to hold any errors that occurr ActionErrors errors = new ActionErrors ( ) ; // Create reference to the session HttpSession session = request . getSession ( ) ; // Use a try block to catch any errors that may occur try { return executeWithErrorHandling ( mapping , form , request , response , errors ) ; } // Catch all exceptions here. This will forward to the error page in the event of // any exception that falls through to this top level handler. // Don't catch Throwable here as Errors should fall through to the JVM top level and will result in // termination of the application. catch ( Exception t ) { log . log ( Level . WARNING , \"Caught a Throwable\" , t ) ; // Don't Forward the error to the error handler to interpret it as a Struts error as the exception will // automatically be translated by the error page. // @todo Could add code here to check if there is a 'error' forward page defined. If there is then call // the error handler to translate the throwable into Struts errors and then forward to the 'error' page. // This would mean that the error page defined in web.xml would be the default unless an action explicitly // defined an alternative 'error' forward. // handleErrors(t, errors); // Save all the error messages in the request so that they will be displayed // request.setAttribute(Action.ERROR_KEY, errors); // Rethrow the error as a ServletException here to cause forwarding to error page defined in web.xml throw new WrappedStrutsServletException ( t ) ; } }", "nl": "Processes the action providing default error handling . Implementation should override this method to provide their own error handling if the default is not to be used ."}}
{"translation": {"code": "public static void handleErrors ( Throwable exception , ActionErrors errors ) { // Log the error. log . log ( Level . SEVERE , exception . getMessage ( ) , exception ) ; if ( exception . getCause ( ) == null ) { log . fine ( \"Exception.getCause() is null\" ) ; } // Unwrap the exception if it is a WrappedStrutsServletException, which is a place holder for returning // other throwables from struts actions. // See BaseAction and WrappedStrutsServletException for more information. if ( ( exception instanceof WrappedStrutsServletException ) && ( exception . getCause ( ) != null ) ) { exception = exception . getCause ( ) ; log . fine ( \"Unwrapped WrappedStrutsServletException\" ) ; } // Create an error called 'exception' in the Struts errors for debugging purposes // Debugging code can print this piece of html containing the exception stack trace at the bottom // of the page for convenience. Writer stackTrace = new StringWriter ( ) ; exception . printStackTrace ( new PrintWriter ( new HTMLFilter ( stackTrace ) ) ) ; errors . add ( \"exception\" , new ActionError ( \"error.general\" , stackTrace ) ) ; // Check if the exception is a user readable exception if ( exception instanceof UserReadableError ) { UserReadableError userError = ( UserReadableError ) exception ; // Check that it contains a user readable message if ( userError . isUserReadable ( ) ) { // Check if there is an error message key to use if ( userError . getUserMessageKey ( ) != null ) { errors . add ( \"generalerror\" , new ActionError ( userError . getUserMessageKey ( ) , userError . getUserMessageKey ( ) ) ) ; } // There is no error message key to use so default to error.general and pass the error message as an // argument so that it will be displayed else { errors . add ( \"generalerror\" , new ActionError ( \"error.general\" , userError . getUserMessage ( ) ) ) ; } return ; } } // Not a user reable exception so print a standard error message errors . add ( \"generalerror\" , new ActionError ( \"error.internalerror\" ) ) ; }", "nl": "Converts an exception into struts action errors . The exception stack trace is stored under the exception message key . The message resource error . internalerror is stored under the message key generalerror . The stack trace is pretty printed in HTML ."}}
{"translation": {"code": "public String getApplicationScope ( ) { Map info = new TreeMap ( ) ; ServletContext context = pageContext . getServletContext ( ) ; Enumeration names = context . getAttributeNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = context . getAttribute ( name ) ; info . put ( name , toStringValue ( value ) ) ; } return toHTMLTable ( \"application scope\" , info ) ; }", "nl": "Returns a String with all application scope variables ."}}
{"translation": {"code": "public void put ( String name , Object value ) { pageContext . setAttribute ( name , value , scope ) ; }", "nl": "Inserts an object into the scope ."}}
{"translation": {"code": "public ActionForward executeWithErrorHandling ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response , ActionErrors errors ) { log . fine ( \"public ActionForward performWithErrorHandling(ActionMapping mapping, ActionForm form,\" + \"HttpServletRequest request, HttpServletResponse response, \" + \"ActionErrors errors): called\" ) ; HttpSession session = request . getSession ( ) ; DynaBean dynaForm = ( DynaActionForm ) form ; // Redirect to the specified location String redirect = ( String ) dynaForm . get ( REDIRECT ) ; log . fine ( \"redirect = \" + redirect ) ; return new ActionForward ( redirect , true ) ; }", "nl": "Handles an HTTP request sent to this action by struts . This simply forwards to the location specified by the redirect request parameter ."}}
{"translation": {"code": "public String getSessionScope ( ) { Map info = new TreeMap ( ) ; HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; HttpSession session = req . getSession ( ) ; Enumeration names = session . getAttributeNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = session . getAttribute ( name ) ; info . put ( name , toStringValue ( value ) ) ; } return toHTMLTable ( \"session scope\" , info ) ; }", "nl": "Returns a String with all session scope variables ."}}
{"translation": {"code": "public String getPageScope ( ) { Map info = new TreeMap ( ) ; Enumeration names = pageContext . getAttributeNamesInScope ( PageContext . PAGE_SCOPE ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = pageContext . getAttribute ( name ) ; info . put ( name , toStringValue ( value ) ) ; } return toHTMLTable ( \"page scope\" , info ) ; }", "nl": "Returns a String with all page scope variables ."}}
{"translation": {"code": "public String getCookies ( ) { Map info = new TreeMap ( ) ; HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; Cookie [ ] cookies = req . getCookies ( ) ; // check that cookies is not null which it may be if there are no cookies if ( cookies != null ) { for ( int i = 0 ; i < cookies . length ; i ++ ) { Cookie cooky = cookies [ i ] ; info . put ( cooky . getName ( ) , cooky . getValue ( ) ) ; } } return toHTMLTable ( \"cookies\" , info ) ; }", "nl": "Returns a String with all cookie information as an HTML table ."}}
{"translation": {"code": "public int doStartTag ( ) throws JspException { log . fine ( \"public int doStartTag(): called\" ) ; TagUtils tagUtils = TagUtils . getInstance ( ) ; // Get a reference to the PagedList. PagedList list = ( PagedList ) tagUtils . lookup ( pageContext , name , property , scope ) ; log . fine ( \"list = \" + list ) ; // Work out what the URL of the action to handle the paging events is. String url ; try { url = tagUtils . computeURL ( pageContext , null , null , null , action , null , null , null , false ) ; } catch ( MalformedURLException e ) { throw new JspException ( \"Got malformed URL exception: \" , e ) ; } // Optionally render the first page button. renderButton ( renderFirst , 0 , 0 , openDelimFirst , url , firstText , list . getCurrentPage ( ) != 0 ) ; // Optionally render the back button. renderButton ( renderBack , list . getCurrentPage ( ) - 1 , ( ( list . getCurrentPage ( ) - 1 ) < list . getCurrentIndex ( ) ) ? ( list . getCurrentIndex ( ) - maxPages ) : list . getCurrentIndex ( ) , openDelimBack , url , backText , ( list . getCurrentPage ( ) - 1 ) >= 0 ) ; // Render links for pages from the current index to the current index plus the maximum number of pages. int from = list . getCurrentIndex ( ) ; int to = list . getCurrentIndex ( ) + maxPages ; for ( int i = from ; ( i < list . size ( ) ) && ( i < to ) ; i ++ ) { renderButton ( true , i , list . getCurrentIndex ( ) , ( i == list . getCurrentPage ( ) ) ? openDelimCurrent : openDelimNumber , url , \"\" + ( i + 1 ) , i != list . getCurrentPage ( ) ) ; } // Optionally render a more button. The more button should only be rendered if the current index plus // the maximum number of pages is less than the total number of pages so there are pages beyond those that // have numeric link to them already. renderButton ( ( list . getCurrentIndex ( ) + maxPages ) < list . size ( ) , list . getCurrentPage ( ) + maxPages , list . getCurrentPage ( ) + maxPages , openDelimMore , url , moreText , true ) ; // Optionally render a forward button. renderButton ( renderForward , list . getCurrentPage ( ) + 1 , ( ( list . getCurrentPage ( ) + 1 ) >= ( list . getCurrentIndex ( ) + maxPages ) ) ? ( list . getCurrentIndex ( ) + maxPages ) : list . getCurrentIndex ( ) , openDelimForward , url , forwardText , ( list . getCurrentPage ( ) + 1 ) < list . size ( ) ) ; // Optionally render a last page button. renderButton ( renderLast , list . size ( ) - 1 , ( list . size ( ) / maxPages ) * maxPages , openDelimLast , url , lastText , list . getCurrentPage ( ) != ( list . size ( ) - 1 ) ) ; return SKIP_BODY ; }", "nl": "Renders the paging control ."}}
{"translation": {"code": "private boolean callInternal ( int function , int arity , int numPerms ) { switch ( function ) { case CALL_1_ID : return internalCall_1 ( numPerms ) ; case EXECUTE_1_ID : return internalExecute_1 ( ) ; default : throw new IllegalStateException ( \"Unknown internal function id: \" + function ) ; } }", "nl": "Invokes an internal function ."}}
{"translation": {"code": "public static String convertCase ( String value , String separator , boolean firstLetterUpper , boolean firstLetterOfWordUpper ) { final StringBuffer result = new StringBuffer ( ) ; boolean firstWord = true ; boolean firstLetter = true ; boolean upper = false ; WordMachineState state = WordMachineState . Initial ; Function2 < Character , Boolean , StringBuffer > writeChar = new Function2 < Character , Boolean , StringBuffer > ( ) { public StringBuffer apply ( Character nextChar , Boolean upper ) { if ( upper ) result . append ( Character . toUpperCase ( nextChar ) ) ; else result . append ( Character . toLowerCase ( nextChar ) ) ; return result ; } } ; for ( int i = 0 ; i < value . length ( ) ; i ++ ) { char nextChar = value . charAt ( i ) ; if ( Character . isUpperCase ( nextChar ) ) { switch ( state ) { case Initial : state = WordMachineState . StartWord ; upper = firstLetterOfWordUpper ; if ( ! firstWord ) { result . append ( separator ) ; } firstWord = false ; break ; case StartWord : case ContinueWordCaps : state = WordMachineState . ContinueWordCaps ; upper = false ; break ; case ContinueWordLower : state = WordMachineState . StartWord ; upper = firstLetterOfWordUpper ; result . append ( separator ) ; break ; } writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; firstLetter = false ; } else if ( Character . isLetterOrDigit ( nextChar ) ) { switch ( state ) { case Initial : state = WordMachineState . StartWord ; upper = firstLetterOfWordUpper ; if ( ! firstWord ) { result . append ( separator ) ; } firstWord = false ; break ; case StartWord : case ContinueWordLower : case ContinueWordCaps : state = WordMachineState . ContinueWordLower ; upper = false ; break ; } writeChar . apply ( nextChar , ( ! firstLetter && upper ) || ( firstLetter & firstLetterUpper ) ) ; firstLetter = false ; } else { switch ( state ) { case Initial : state = WordMachineState . Initial ; break ; case StartWord : case ContinueWordCaps : case ContinueWordLower : state = WordMachineState . Initial ; break ; } upper = false ; } } return result . toString ( ) ; }", "nl": "Converts string between various case forms such as camel case snake case or kebab case ."}}