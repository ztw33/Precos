{"translation": {"code": "private int mod ( long c , int bucketSize ) { return ( int ) ( ( c < 0 ) ? ( ( bucketSize + ( c % bucketSize ) ) % bucketSize ) : ( c % bucketSize ) ) ; }", "nl": "Calculates the modulo of a coordinate with the bucket size . Correctly calculates this module for negative coordinates such the the first negative bucket is - 1 with element 0 corresponding to - 100 running to 99 corresponding to - 1 ."}}
{"translation": {"code": "protected void backtrack ( SearchNode checkNode ) { while ( ( checkNode != null ) && ( checkNode . unexaminedSuccessorCount == 0 ) ) { Reversable undoState = ( ReTraversable ) checkNode . getState ( ) ; undoState . undoOperator ( ) ; checkNode = checkNode . getParent ( ) ; } }", "nl": "Back - tracks from the specified node moving succesively upwards through the chain of parent nodes until a node is encountered that has unexamined successors . This method implements the backtracking searches reverse direction . By checking for the presence of unexamined successors this method only backtracks where necessary ."}}
{"translation": {"code": "public Long getPropertyAsLong ( String propName ) { String prop = getProperty ( propName ) ; return ( prop != null ) ? Long . valueOf ( prop ) : null ; }", "nl": "Parses a property as a long ."}}
{"translation": {"code": "public Integer getPropertyAsInteger ( String propName ) { String prop = getProperty ( propName ) ; return ( prop != null ) ? Integer . valueOf ( prop ) : null ; }", "nl": "Parses a property as an integer ."}}
{"translation": {"code": "public boolean getPropertyAsBoolean ( String propName ) { String prop = getProperty ( propName ) ; return ( prop != null ) && Boolean . parseBoolean ( prop ) ; }", "nl": "Parses a property as a boolean ."}}
{"translation": {"code": "public Object next ( ) { try { Object ob = source . next ( ) ; return ob ; } catch ( RemoteException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Fetches the next element from this iterator ."}}
{"translation": {"code": "protected boolean insert ( E element , boolean unlockAndBlock ) { // Create a new record for the data item. SynchRecordImpl < E > record = new SynchRecordImpl < E > ( element ) ; boolean result = buffer . offer ( record ) ; if ( result ) { count ++ ; // Tell any waiting consumers that the queue is not empty. notEmpty . signal ( ) ; if ( unlockAndBlock ) { // Allow other threads to read/write the queue. lock . unlock ( ) ; // Wait until a consumer takes this data item. record . waitForConsumer ( ) ; } return true ; } else { return false ; } }", "nl": "Insert element into the queue then possibly signal that the queue is not empty and block the producer on the element until permission to procede is given ."}}
{"translation": {"code": "public void put ( E e ) throws InterruptedException { try { tryPut ( e ) ; } catch ( SynchException ex ) { // This exception is deliberately ignored. See the method comment for information about this. ex = null ; } }", "nl": "Adds the specified element to this queue waiting if necessary for space to become available ."}}
{"translation": {"code": "public E poll ( long timeout , TimeUnit unit ) throws InterruptedException { ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; try { long nanos = unit . toNanos ( timeout ) ; do { if ( count != 0 ) { return extract ( true , true ) . getElement ( ) ; } try { nanos = notEmpty . awaitNanos ( nanos ) ; } catch ( InterruptedException ie ) { notEmpty . signal ( ) ; // propagate to non-interrupted thread throw ie ; } } while ( nanos > 0 ) ; return null ; } finally { lock . unlock ( ) ; } }", "nl": "Retrieves and removes the head of this queue waiting if necessary up to the specified wait time if no elements are present on this queue ."}}
{"translation": {"code": "public boolean offer ( E e , long timeout , TimeUnit unit ) throws InterruptedException { if ( e == null ) { throw new IllegalArgumentException ( \"The 'e' parameter may not be null.\" ) ; } ReentrantLock lock = this . lock ; lock . lockInterruptibly ( ) ; long nanos = unit . toNanos ( timeout ) ; try { do { if ( insert ( e , false ) ) { return true ; } try { nanos = notFull . awaitNanos ( nanos ) ; } catch ( InterruptedException ie ) { // Wake up another thread waiting on notFull, as the condition may be true, but this thread // was interrupted so cannot make use of it. notFull . signal ( ) ; throw ie ; } } while ( nanos > 0 ) ; return false ; } finally { lock . unlock ( ) ; } }", "nl": "Inserts the specified element into this queue waiting if necessary up to the specified wait time for space to become available ."}}
{"translation": {"code": "private void enlistWithSession ( ) { TxSession session = TxSessionImpl . getCurrentSession ( ) ; // Ensure that this resource is being used within a session. if ( session == null ) { throw new IllegalStateException ( \"Cannot access transactional resource outside of a session.\" ) ; } // Ensure that this resource is enlisted with the session. session . enlist ( this ) ; }", "nl": "Enlists this transactional resource with the current session . If no session exists this will fail ."}}
{"translation": {"code": "private void releaseGlobalWriteLock ( ) { // Get the global write lock to ensure only one thread at a time can execute this code. globalLock . writeLock ( ) . lock ( ) ; // Use a try block so that the corresponding finally block guarantees release of the thread lock. try { // Release the global write lock, assigning it to no transaction. globalWriteLockTxId = null ; // Signal that the write lock is now free. globalWriteLockFree . signal ( ) ; } // Ensure that the thread lock is released once assignment of the write lock to the transaction is complete. finally { globalLock . writeLock ( ) . unlock ( ) ; } }", "nl": "Releases the global write lock from being assigned to a transaction ."}}
{"translation": {"code": "private void acquireGlobalWriteLock ( TxId txId ) throws InterruptedException { // Get the global write lock to ensure only one thread at a time can execute this code. globalLock . writeLock ( ) . lock ( ) ; // Use a try block so that the corresponding finally block guarantees release of the thread lock. try { // Check that this transaction does not already own the lock. if ( ! txId . equals ( globalWriteLockTxId ) ) { // Wait until the write lock becomes free. while ( globalWriteLockTxId != null ) { globalWriteLockFree . await ( ) ; } // Assign the global write lock to this transaction. globalWriteLockTxId = txId ; } } finally { // Ensure that the thread lock is released once assignment of the write lock to the transaction is complete. globalLock . writeLock ( ) . unlock ( ) ; } }", "nl": "Waits until the global write lock can be acquired by the specified transaction ."}}
{"translation": {"code": "private void addCachedOperation ( TxId txId , TxOperation cachedWriteOperation ) { List < TxOperation > writeCache = txWrites . get ( txId ) ; if ( writeCache == null ) { writeCache = new ArrayList < TxOperation > ( ) ; txWrites . put ( txId , writeCache ) ; } writeCache . add ( cachedWriteOperation ) ; }", "nl": "Adds a transactional operation to the transactional write - behind cache for the specified transaction . If no cache exists for the specified transaction id a new one is created ."}}
{"translation": {"code": "public void requestWriteOperation ( TxOperation op ) { // Check if in a higher transactional mode than none and capture the transaction id if so. TxId txId = null ; if ( getIsolationLevel ( ) . compareTo ( IsolationLevel . None ) > 0 ) { // Extract the current transaction id. txId = TxManager . getTxIdFromThread ( ) ; // Ensure that this resource is enlisted with the current session. enlistWithSession ( ) ; } // For non-transactional isolation levels, apply the requested operation immediately. if ( getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { op . execute ( ) ; } // Add the operation to the transaction write-behind cache for the transaction id, if using transactional // isolation, to defer the operation untill commit time. else { addCachedOperation ( txId , op ) ; } }", "nl": "Requests an operation that alters the transactional resource . This may be blocked until an appropriate lock can be acquired delayed until commit time or actioned upon a copy of the data structure private to a transaction branch ."}}
{"translation": {"code": "public void rollback ( ) { TxId txId = null ; // Check if in a higher transactional mode than none, otherwise commit does nothing. if ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { // Extract the current transaction id. txId = TxManager . getTxIdFromThread ( ) ; // Check that this transaction has made changes to be rolled back. List < TxOperation > alterations = txWrites . get ( txId ) ; if ( alterations != null ) { // Loop through all the writes that the transaction wants to apply to the resource. for ( TxOperation nextAlteration : alterations ) { // Cancel the operation. nextAlteration . cancel ( false ) ; } } // Discard all the changes that the transaction was going to make. txWrites . remove ( txId ) ; } }", "nl": "When operation in transactional mode causes any changes since the last commit to be dropped and never made visible to the search method ."}}
{"translation": {"code": "public void commit ( ) { TxId txId = null ; // Check if in a higher transactional mode than none, otherwise commit does nothing. if ( ! getIsolationLevel ( ) . equals ( IsolationLevel . None ) ) { // Extract the current transaction id. txId = TxManager . getTxIdFromThread ( ) ; // Wait until the global write lock can be acquired by this transaction. try { acquireGlobalWriteLock ( txId ) ; } catch ( InterruptedException e ) { // The commit was interrupted, so cannot succeed. throw new IllegalStateException ( \"Interrupted whilst commit is waiting for global write lock.\" , e ) ; } // Check that this transaction has made changes to be committed. List < TxOperation > alterations = txWrites . get ( txId ) ; try { if ( alterations != null ) { // Loop through all the writes that the transaction wants to apply to the resource. for ( TxOperation nextAlteration : alterations ) { // Apply the change and update the term resource. nextAlteration . execute ( ) ; } // Clear the write behind cache for this transaction as its work has been completed. txWrites . remove ( txId ) ; } } finally { // Release the global write lock. releaseGlobalWriteLock ( ) ; } } }", "nl": "When operating in transactional mode causes any changes since the last commit to be made visible to the search method ."}}
{"translation": {"code": "protected void initializePrinters ( ) { int maxColumns = 0 ; printers . add ( new SourceClausePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; printers . add ( new PositionPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; printers . add ( new UnoptimizedLabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; printers . add ( new UnoptimizedByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; printers . add ( new LabelPrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; printers . add ( new ByteCodePrinter ( interner , symbolTable , traverser , maxColumns ++ , printTable ) ) ; }", "nl": "Sets up the stack of column printers ."}}
{"translation": {"code": "void fireConnector ( ) { if ( connector == null ) { LogLog . debug ( \"Starting a new connector thread.\" ) ; connector = new Connector ( ) ; connector . setDaemon ( true ) ; connector . setPriority ( Thread . MIN_PRIORITY ) ; connector . start ( ) ; } }", "nl": "Starts a new connector thread to do?"}}
{"translation": {"code": "public void append ( LoggingEvent event ) { if ( event == null ) { return ; } if ( address == null ) { errorHandler . error ( \"No remote host is set for SocketAppender named \\\"\" + this . name + \"\\\".\" ) ; return ; } if ( oos != null ) { try { if ( locationInfo ) { event . getLocationInformation ( ) ; } oos . writeObject ( event ) ; // LogLog.debug(\"=========Flushing.\"); oos . flush ( ) ; if ( ++ counter >= RESET_FREQUENCY ) { counter = 0 ; // Failing to reset the object output stream every now and // then creates a serious memory leak. // System.err.println(\"Doing oos.reset()\"); oos . reset ( ) ; } } catch ( IOException e ) { oos = null ; LogLog . warn ( \"Detected problem with connection: \" + e ) ; if ( reconnectionDelay > 0 ) { fireConnector ( ) ; } } } }", "nl": "Appends a logging event to the remote event reciever ."}}
{"translation": {"code": "protected Set < Variable > executeAndExtractBindings ( WAMCompiledQuery query ) { // Execute the query and program. The starting point for the execution is the first functor in the query // body, this will follow on to the subsequent functors and make calls to functors in the compiled programs. boolean success = execute ( query . getCallPoint ( ) ) ; // Used to collect the results in. Set < Variable > results = null ; // Collect the results only if the resolution was successfull. if ( success ) { results = new HashSet < Variable > ( ) ; // The same variable context is used accross all of the results, for common use of variables in the // results. Map < Integer , Variable > varContext = new HashMap < Integer , Variable > ( ) ; // For each of the free variables in the query, extract its value from the location on the heap pointed to // by the register that holds the variable. /*log.fine(\"query.getVarNames().size() =  \" + query.getVarNames().size());*/ for ( byte reg : query . getVarNames ( ) . keySet ( ) ) { int varName = query . getVarNames ( ) . get ( reg ) ; if ( query . getNonAnonymousFreeVariables ( ) . contains ( varName ) ) { int addr = derefStack ( reg ) ; Term term = decodeHeap ( addr , varContext ) ; results . add ( new Variable ( varName , term , false ) ) ; } } } return results ; }", "nl": "Runs a query and for every non - anonymous variable in the query decodes its binding value from the heap and returns it in a set of variable bindings ."}}
{"translation": {"code": "protected Term decodeHeap ( int start , Map < Integer , Variable > variableContext ) { /*log.fine(\"private Term decodeHeap(int start = \" + start + \", Map<Integer, Variable> variableContext = \" +\n            variableContext + \"): called\");*/ // Used to hold the decoded argument in. Term result = null ; // Dereference the initial heap pointer. int addr = deref ( start ) ; byte tag = getDerefTag ( ) ; int val = getDerefVal ( ) ; /*log.fine(\"addr = \" + addr);*/ /*log.fine(\"tag = \" + tag);*/ /*log.fine(\"val = \" + val);*/ switch ( tag ) { case REF : { // Check if a variable for the address has already been created in this context, and use it if so. Variable var = variableContext . get ( val ) ; if ( var == null ) { var = new Variable ( varNameId . decrementAndGet ( ) , null , false ) ; variableContext . put ( val , var ) ; } result = var ; break ; } case STR : { // Decode f/n from the STR data. int fn = getHeap ( val ) ; int f = fn & 0x00ffffff ; /*log.fine(\"fn = \" + fn);*/ /*log.fine(\"f = \" + f);*/ // Look up and initialize this functor name from the symbol table. FunctorName functorName = getDeinternedFunctorName ( f ) ; // Fill in this functors name and arity and allocate storage space for its arguments. int arity = functorName . getArity ( ) ; Term [ ] arguments = new Term [ arity ] ; // Loop over all of the functors arguments, recursively decoding them. for ( int i = 0 ; i < arity ; i ++ ) { arguments [ i ] = decodeHeap ( val + 1 + i , variableContext ) ; } // Create a new functor to hold the decoded data. result = new Functor ( f , arguments ) ; break ; } case WAMInstruction . CON : { //Decode f/n from the CON data. int f = val & 0x3fffffff ; /*log.fine(\"f = \" + f);*/ // Create a new functor to hold the decoded data. result = new Functor ( f , null ) ; break ; } case WAMInstruction . LIS : { FunctorName functorName = new FunctorName ( \"cons\" , 2 ) ; int f = internFunctorName ( functorName ) ; // Fill in this functors name and arity and allocate storage space for its arguments. int arity = functorName . getArity ( ) ; Term [ ] arguments = new Term [ arity ] ; // Loop over all of the functors arguments, recursively decoding them. for ( int i = 0 ; i < arity ; i ++ ) { arguments [ i ] = decodeHeap ( val + i , variableContext ) ; } // Create a new functor to hold the decoded data. result = new Functor ( f , arguments ) ; break ; } default : throw new IllegalStateException ( \"Encountered unknown tag type on the heap.\" ) ; } return result ; }", "nl": "Decodes a term from the raw byte representation on the machines heap into an abstract syntax tree ."}}
{"translation": {"code": "public void capture ( ) { // Get the class of the object to build a memento for. Class cls = ob . getClass ( ) ; // Iterate through the classes whole inheritence chain. while ( ! cls . equals ( Object . class ) ) { // Get the classes fields. Field [ ] attrs = cls . getDeclaredFields ( ) ; // Build a new map to put the fields in for the current class. HashMap map = new HashMap ( ) ; // Cache the field values by the class name. values . put ( cls , map ) ; // Loop over all the fields in the current class. for ( Field attr : attrs ) { // Make the field accessible (it may be protected or private). attr . setAccessible ( true ) ; // Check that the field should be captured. if ( shouldBeSaved ( attr ) ) { // Use a try block as access to the field may fail, although this should not happen because // even private, protected and package fields have been made accessible. try { // Cache the field by its name. map . put ( attr . getName ( ) , attr . get ( ob ) ) ; } catch ( IllegalAccessException e ) { // The field could not be accessed but all fields have been made accessible so this should // not happen. throw new IllegalStateException ( \"Field '\" + attr . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; } } } // Get the superclass for the next step of the iteration over the whole inheritence chain. cls = cls . getSuperclass ( ) ; } }", "nl": "Captures an objects state in this memento ."}}
{"translation": {"code": "public void restore ( Object ob ) throws NoSuchFieldException { /*log.fine(\"public void map(Object ob): called\");*/ /*log.fine(\"class is \" + ob.getClass());*/ // Iterate over the whole inheritence chain. for ( Object key : values . keySet ( ) ) { // Get the next class from the cache. Class cls = ( Class ) key ; // Get the cache of field values for the class. Map vals = ( HashMap ) values . get ( cls ) ; // Loop over all fields in the class. for ( Object o : vals . keySet ( ) ) { // Get the next field name. String attr = ( String ) o ; // Get the next field value. Object val = vals . get ( attr ) ; // Get a reference to the field in the object. Field f = cls . getDeclaredField ( attr ) ; // Make the field accessible (it may be protected, package or private). f . setAccessible ( true ) ; // Use a try block as writing to the field may fail. try { // Write to the field. f . set ( ob , val ) ; } catch ( IllegalAccessException e ) { // The field could not be written to but all fields have been made accessible so this should // not happen. throw new IllegalStateException ( \"Field '\" + f . getName ( ) + \"' could not be accessed but the 'setAccessible(true)' method was invoked on it.\" , e ) ; } } } }", "nl": "Restores the values currently in this memento to the specified object ."}}
{"translation": {"code": "public void execute ( ) throws MojoExecutionException , MojoFailureException { //log.debug(\"public void execute() throws MojoExecutionException: called\"); // Turn each of the test runner command lines into a script. for ( String commandName : commands . keySet ( ) ) { if ( scriptOutDirectory != null ) { writeUnixScript ( commandName , scriptOutDirectory ) ; writeWindowsScript ( commandName , scriptOutDirectory ) ; } } }", "nl": "Implementation of the script goal ."}}
{"translation": {"code": "public boolean await ( T t , long timeout , TimeUnit unit ) throws InterruptedException { synchronized ( monitor ) { // Holds the absolute time when the timeout expires. long expiryTimeNanos = System . nanoTime ( ) + unit . toNanos ( timeout ) ; // Used to hold the estimated wait time until the condition may pass. long waitNanos = evaluateWithWaitTimeNanos ( t ) ; // Loop forever until all conditions pass, the timeout expires, or the thread is interrupted. while ( waitNanos > 0 ) { // Check how much time remains until the timeout expires. long remainingTimeNanos = expiryTimeNanos - System . nanoTime ( ) ; // Check if the timeout has expired. if ( remainingTimeNanos <= 0 ) { return false ; } // If some conditions failed, then wait for the shortest of the wait time or the remaining time until the // timout expires, or until the thread is woken up by a signal, before re-evaluating conditions. long timeToPauseNanos = ( waitNanos < remainingTimeNanos ) ? waitNanos : remainingTimeNanos ; long milliPause = timeToPauseNanos / 1000000 ; int nanoPause = ( int ) ( timeToPauseNanos % 1000000 ) ; monitor . wait ( milliPause , nanoPause ) ; // Re-evelaute the condition and obtain a new estimate of how long until it may pass. waitNanos = evaluateWithWaitTimeNanos ( t ) ; } } // All conditions have passed when the above loop terminates. return true ; }", "nl": "Wait for up to a timeout limit for the predicate to become true on the specified object ."}}
{"translation": {"code": "public void await ( T t ) throws InterruptedException { synchronized ( monitor ) { long waitNanos = evaluateWithWaitTimeNanos ( t ) ; // Loop forever until all conditions pass or the thread is interrupted. while ( waitNanos > 0 ) { // If some conditions failed, then wait for the shortest wait time, or until the thread is woken up by // a signal, before re-evaluating conditions. long milliPause = waitNanos / 1000000 ; int nanoPause = ( int ) ( waitNanos % 1000000 ) ; monitor . wait ( milliPause , nanoPause ) ; waitNanos = evaluateWithWaitTimeNanos ( t ) ; } } }", "nl": "Wait for the predicate to become true on the specified object ."}}
{"translation": {"code": "public static Type createInstance ( String name , double min , double max ) { // Ensure that min is less than or equal to max. if ( min > max ) { throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; } synchronized ( DOUBLE_RANGE_TYPES ) { // Add the newly created type to the map of all types. DoubleRangeType newType = new DoubleRangeType ( name , min , max ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. DoubleRangeType oldType = DOUBLE_RANGE_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { DOUBLE_RANGE_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new double range type with the specified name if it does not already exist ."}}
{"translation": {"code": "protected void firePropertyChange ( PropertyChangeEvent evt ) { /*log.fine(\"firePropertyChange: called\");*/ // Take a copy of the event as a final variable so that it can be used in an inner class final PropertyChangeEvent finalEvent = evt ; Iterator it ; // Check if the list of listeners is empty if ( listeners == null ) { // There are no listeners so simply return without doing anything return ; } // synchronize on the list of listeners to prevent comodification synchronized ( listeners ) { // Cycle through all listeners and notify them it = listeners . iterator ( ) ; while ( it . hasNext ( ) ) { // Get the next listener from the list final PropertyChangeListener l = ( PropertyChangeListener ) it . next ( ) ; // Notify the listener of the property change event Runnable r = new Runnable ( ) { public void run ( ) { // Fire a property change event l . propertyChange ( finalEvent ) ; } } ; // Run the property change event in the Swing event queue SwingUtilities . invokeLater ( r ) ; } } }", "nl": "Notifies all property change listeners of the given PropertyChangeEvent ."}}
{"translation": {"code": "public void removePropertyChangeListener ( String p , PropertyChangeListener l ) { if ( listeners == null ) { return ; } synchronized ( listeners ) { listeners . remove ( l ) ; } }", "nl": "Removes the specified property change listener from the list of active listeners ."}}
{"translation": {"code": "public void addPropertyChangeListener ( String p , PropertyChangeListener l ) { // Check if the listeneres list has been initialized if ( listeners == null ) { // Listeneres list not initialized so create a new list listeners = new ArrayList ( ) ; } synchronized ( listeners ) { // Add the new listener to the list listeners . add ( l ) ; } }", "nl": "Adds a property changed listener to be notified of changes to the named property ."}}
{"translation": {"code": "public void addPropertyChangeListener ( PropertyChangeListener l ) { // Check if the listneres list has been initialized if ( listeners == null ) { // Listeneres list not intialized so create a new list listeners = new ArrayList ( ) ; } synchronized ( listeners ) { // Add the new listener to the list listeners . add ( l ) ; } }", "nl": "Adds a property changed listener to be notified of changes to the application state ."}}
{"translation": {"code": "public static Properties getProperties ( String pathname ) throws IOException { /*log.fine(\"getProperties(String): called\");*/ // Check that the path is not null if ( pathname == null ) { return null ; } // Check if the path is a URL if ( isURL ( pathname ) ) { // The path is a URL return getProperties ( new URL ( pathname ) ) ; } else { // Assume the path is a file name return getProperties ( new File ( pathname ) ) ; } }", "nl": "Get properties from a path name . The path name may refer to either a file or a URL ."}}
{"translation": {"code": "public void cleanUp ( ) { if ( oos != null ) { try { oos . close ( ) ; } catch ( IOException e ) { LogLog . error ( \"Could not close oos.\" , e ) ; } oos = null ; } if ( connector != null ) { // LogLog.debug(\"Interrupting the connector.\"); connector . interrupted = true ; connector = null ; // allow gc } }", "nl": "Drop the connection to the remote host and release the underlying connector thread if it has been created ."}}
{"translation": {"code": "public static Properties getProperties ( URL url ) throws IOException { /*log.fine(\"getProperties(URL): called\");*/ // Open the URL as an input stream InputStream is = url . openStream ( ) ; // Create properties object loaded from the stream Properties properties = getProperties ( is ) ; // Close the url is . close ( ) ; return properties ; }", "nl": "Get properties from a url ."}}
{"translation": {"code": "public static Properties getProperties ( InputStream is ) throws IOException { /*log.fine(\"getProperties(InputStream): called\");*/ // Create properties object laoded from input stream Properties properties = new Properties ( ) ; properties . load ( is ) ; return properties ; }", "nl": "Get properties from an input stream ."}}
{"translation": {"code": "public Queue < SearchNode < O , T > > createQueue ( ) { return new PriorityQueue < SearchNode < O , T > > ( 11 , new UniformCostComparator ( ) ) ; }", "nl": "Creates the correct type of queue for this search . This search uses a priority queue ordered by path cost ."}}
{"translation": {"code": "public SearchNode < O , T > createSearchNode ( T state ) { return new SearchNode < O , T > ( state ) ; }", "nl": "Creates the correct type of search nodes for this search . This search uses ordinary search nodes ."}}
{"translation": {"code": "public E poll ( ) { /*log.fine(\"public E poll(): called\");*/ // This is used to keep track of the level of the list that is found to have data in it. int currentLevel = 0 ; while ( true ) { // This is used to locate the marker head of a list that contains data. Marker < E > h = null ; // This is used to locate the potential data node of a list with data in it. Another thread may already // have taken this data. Node < E > first = null ; // Second data item, may also be tail marker, first data item of next list, or null at end of last list. Node < E > second = null ; // Loop down any empty lists at the front of the queue until a list with data in it is found. for ( ; currentLevel < n ; currentLevel ++ ) { h = markers [ currentLevel ] ; first = h . getNext ( ) ; second = first . getNext ( ) ; // Check if the list at the current level is not empty and should be tried for data. if ( ! h . isEmpty ( markers [ currentLevel + 1 ] ) ) { break ; } // Check if the current level is empty and is the last level, in which case return null. else if ( currentLevel == ( n - 1 ) ) { // log.info(\"returning null from level loop.\"); return null ; } // Else if the current level is empty loop to the next one to see if it has data. } /*log.fine(\"current poll level = \" + currentLevel);*/ // This is used to locate the tail of the list that has been found with data in it. Node < E > t = markers [ currentLevel + 1 ] . getTail ( ) ; // Check that the first data item has not yet been taken. Another thread may already have taken it, // in which case performing a relatively expensive cas on the head will fail. If first is still intact // then second will be intact too. if ( first == h . getNext ( ) ) { // Check if the queue has become empty. if ( h . isEmpty ( markers [ currentLevel + 1 ] ) ) { // Another thread has managed to take data from the queue, leaving it empty. // First won't be null. It may point to tail though... if ( first == null ) { // Don't want to return here, want to try the next list. The list loop has a return null // once it gets to the end to take care of that. // log.info(\"returning null as first == null\"); return null ; } else { // Not sure yet why castail here? Does this repair a broken tail ref left after the last item // was taken? markers [ currentLevel + 1 ] . casTail ( t , first ) ; } } // The queue contains data, so try to move its head marker reference from the first data item, onto the // second item (which may be data, or the tail marker). If this succeeds, then the first data node // has been atomically extracted from the head of the queue. else if ( h . casNext ( first , second ) ) { // h Does not refer to an empty queue, so first must be a data node. DataNode < E > firstDataNode = ( ( DataNode < E > ) first ) ; E item = firstDataNode . getItem ( ) ; // Even though the empty test did not indicate that the list was empty, it may contain null // data items, because the remove method doesn't extract nodes on a remove. These need to be skipped // over. Could they be removed here? if ( item != null ) { firstDataNode . setItem ( null ) ; /*log.fine(\"returing item = \" + item);*/ // Decrement the queue size count. count . decrementAndGet ( ) ; return item ; } // else skip over deleted item, continue trying at this level. Go back an retry starting from same // level. List at this level may now be empty, or may get the next item from it. // else skip over marker element. just make markers return null for item to skip them? No, because // need to advance currentLevel and get head and tail markers for the next level. but then, next // level advance will occur when this level is retried and found to be empty won't it? } } } }", "nl": "Retrieves and removes the head of this queue or null if this queue is empty ."}}
{"translation": {"code": "public boolean offer ( E o ) { /*log.fine(\"public boolean offer(E o): called\");*/ /*log.fine(\"o = \" + o);*/ // Ensure that the item to add is not null. if ( o == null ) { throw new IllegalArgumentException ( \"The 'o' parameter may not be null.\" ) ; } // Derive the integer priority of the element using the priority function, shift it into this queues range if // necessary and adjust it to any offset caused by lowest priority not equal to zero. int level = priorityToLevel ( p . apply ( o ) ) ; /*log.fine(\"offer level = \" + level);*/ // Create a new node to hold the new data element. Node < E > newNode = new DataNode < E > ( o , markers [ level + 1 ] ) ; // Add the element to the tail of the queue with matching level, looping until this can complete as an atomic // operation. while ( true ) { // Get tail and next ref. Would expect next ref to be null, but other thread may update it. Node < E > t = markers [ level + 1 ] . getTail ( ) ; Node < E > s = t . getNext ( ) ; /*log.fine(\"t = \" + t);*/ /*log.fine(\"s = \" + s);*/ // Recheck the tail ref, to ensure other thread has not already moved it. This can potentially prevent // a relatively expensive compare and set from failing later on, if another thread has already shited // the tail. if ( t == markers [ level + 1 ] . getTail ( ) ) { /*log.fine(\"t is still the tail.\");*/ // Check that the next element reference on the tail is the tail marker, to confirm that another thread // has not updated it. Again, this may prevent a cas from failing later. if ( s == markers [ level + 1 ] ) { /*log.fine(\"s is  the tail marker.\");*/ // Try to join the new tail onto the old one. if ( t . casNext ( s , newNode ) ) { // The tail join was succesfull, so now update the queues tail reference. No conflict should // occurr here as the tail join was succesfull, so its just a question of updating the tail // reference. A compare and set is still used because ... markers [ level + 1 ] . casTail ( t , newNode ) ; // Increment the queue size count. count . incrementAndGet ( ) ; return true ; } } // Update the tail reference, other thread may also be doing the same. else { // Why bother doing this at all? I suppose, because another thread may be stalled and doing this // will enable this one to keep running. // Update the tail reference for the queue because another thread has already added a new tail // but not yet managed to update the tail reference. markers [ level + 1 ] . casTail ( t , s ) ; } } } }", "nl": "Inserts the specified element onto the tail of this queue ."}}
{"translation": {"code": "public void execute ( ) throws MojoExecutionException , MojoFailureException { //log.debug(\"public void execute() throws MojoExecutionException: called\"); // Turn each of the test runner command lines into a script. for ( String commandName : commands . keySet ( ) ) { if ( prodScriptOutDirectory != null ) { writeUnixScript ( commandName , prodScriptOutDirectory ) ; writeWindowsScript ( commandName , prodScriptOutDirectory ) ; } } }", "nl": "Implementation of the prod - script goal ."}}
{"translation": {"code": "public Collection getAllFieldNames ( Class cls ) { /*log.fine(\"public Collection getAllFieldNames(Class cls): called\");*/ // See if the class exists in the cache if ( ! values . containsKey ( cls ) ) { // Class not in cache so return null return null ; } // Get the cache of fields for the class Map map = ( HashMap ) values . get ( cls ) ; // Return all the keys from cache of fields return map . keySet ( ) ; }", "nl": "Generates a list of all the fields of the object that this memento maps for a given class ."}}
{"translation": {"code": "public void put ( Class cls , String attr , Object val ) { /*log.fine(\"public void put(Class cls, String attr, Object val): called\");*/ /*log.fine(\"class name is \" + cls.getName());*/ /*log.fine(\"attribute is \" + attr);*/ /*log.fine(\"value to set is \" + val);*/ HashMap map ; // Check that the cache for the class exists in the cache. if ( values . containsKey ( cls ) ) { // Get the cache of field for the class. map = ( HashMap ) values . get ( cls ) ; } else { // The class does not already exist in the cache to create a new cache for its fields. map = new HashMap ( ) ; // Cache the new field cache against the class. values . put ( cls , map ) ; } // Store the attribute in the field cache for the class. map . put ( attr , val ) ; }", "nl": "Places the specified value into the memento based on the field s declaring class and name ."}}
{"translation": {"code": "public Object get ( Class cls , String attr ) { HashMap map ; // See if the class exists in the cache. if ( ! values . containsKey ( cls ) ) { // Class not in cache so return null. return null ; } // Get the cache of field values for the class. map = ( HashMap ) values . get ( cls ) ; // Extract the specified field from the cache. return map . get ( attr ) ; }", "nl": "Gets the value of the named field of the specified class ."}}
{"translation": {"code": "public static Properties getProperties ( File file ) throws IOException { /*log.fine(\"getProperties(File): called\");*/ // Open the file as an input stream InputStream is = new FileInputStream ( file ) ; // Create properties object loaded from the stream Properties properties = getProperties ( is ) ; // Close the file is . close ( ) ; return properties ; }", "nl": "Get properties from a file ."}}
{"translation": {"code": "public Queue < SearchNode < O , T > > createQueue ( ) { return new PriorityQueue < SearchNode < O , T > > ( 11 , new GreedyComparator ( ) ) ; }", "nl": "Creates the correct type of queue for this search . This search uses a priority queue ordered by heuristic value ."}}
{"translation": {"code": "public void setSubstitution ( Term term ) { Term termToBindTo = term ; // When binding against a variable, always bind to its storage cell and not the variable itself. if ( termToBindTo instanceof Variable ) { Variable variableToBindTo = ( Variable ) term ; termToBindTo = variableToBindTo . getStorageCell ( variableToBindTo ) ; } substitution = termToBindTo ; }", "nl": "Binds this variable to the specified value ."}}
{"translation": {"code": "public Term getValue ( ) { Term result = this ; Term assignment = this . substitution ; // If the variable is assigned, loops down the chain of assignments until no more can be found. Whatever term // is found at the end of the chain of assignments is the value of this variable. while ( assignment != null ) { result = assignment ; if ( ! assignment . isVar ( ) ) { break ; } else { assignment = ( ( Variable ) assignment ) . substitution ; } } return result ; }", "nl": "Gets the actual value of a term which is either the term itself or in the case of variables the value that is currently assigned to the variable . When the variable is free the variable term itself is returned ."}}
{"translation": {"code": "public int compare ( T a , T b ) { boolean aRb = partialOrdering . evaluate ( a , b ) ; if ( ! aRb ) { return - 1 ; } boolean bRa = partialOrdering . evaluate ( b , a ) ; return ( aRb && bRa ) ? 0 : 1 ; }", "nl": "Translates the partial order into the + 1 0 - 1 convention needed by Comparators ."}}
{"translation": {"code": "public Map < String , OrdinalAttribute > classify ( State state ) throws ClassifyingFailureException { // Start at the root of the decision tree. DecisionTree currentNode = dt ; // Loop down the decision tree until a leaf node is found. while ( true ) // !currentNode.isLeaf()) { DecisionTreeElement element = currentNode . getElement ( ) ; // Check that the current element really is a decision. if ( element instanceof Decision ) { Decision decision = ( Decision ) element ; // Apply the decision at the current node to the state to be classified to get a new tree. currentNode = decision . decide ( state ) ; // , currentNode); } else if ( element instanceof Assignment ) { // Cast the element to an Assignment as this is the only type of leaf that is possible. Assignment assignment = ( Assignment ) element ; // Return the assignment in a map. Map < String , OrdinalAttribute > assignmentMap = new HashMap < String , OrdinalAttribute > ( ) ; assignmentMap . put ( assignment . getPropertyName ( ) , assignment . getAttribute ( ) ) ; return assignmentMap ; } // It is possible that a node may be of type Pending if an incomplete tree has been used to // run this classification on. else { // Throw a classification exception due to an incomplete decision tree. throw new ClassifyingFailureException ( \"A node which is not a decision was encountered.\" , null ) ; } // What happens if the decision could not operate on the state, either because of a missing property or // because its property was not of the type that the decision was expecting? Can either throw an exception, // return an empty assignment, or implement an algorithm for coping with missing properties. } }", "nl": "Classifies a state using the decision tree ."}}
{"translation": {"code": "public void addErrorMessage ( String key , String userMessage ) { /*log.fine(\"addErrorMessage(String key, String userMessage): called\");*/ /*log.fine(\"userMessage = \" + userMessage);*/ errors . add ( new UserReadableErrorImpl ( key , userMessage ) ) ; }", "nl": "Adds another user readable error message to this exception ."}}
{"translation": {"code": "public String printVariableBinding ( Term var ) { return var . toString ( getInterner ( ) , true , false ) + \" = \" + var . getValue ( ) . toString ( getInterner ( ) , false , true ) ; }", "nl": "Prints a variable binding in the form Var = value ."}}
{"translation": {"code": "public float computeH ( EightPuzzleState state , HeuristicSearchNode searchNode ) { // Get the parent heuristic search node. HeuristicSearchNode parentNode = ( HeuristicSearchNode ) searchNode . getParent ( ) ; // Check if there is no parent, in which case this is the start state so the complete heuristic needs // to be calculated. if ( parentNode == null ) { // Used to hold the running total. int h = 0 ; // Loop over the whole board. for ( int j = 0 ; j < 3 ; j ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { char nextTile = state . getTileAt ( i , j ) ; // Look up the board position of the tile in the solution. int goalX = state . getGoalXForTile ( nextTile ) ; int goalY = state . getGoalYForTile ( nextTile ) ; // Compute the manhattan distance and add it to the total. int diffX = goalX - i ; diffX = ( diffX < 0 ) ? - diffX : diffX ; int diffY = goalY - j ; diffY = ( diffY < 0 ) ? - diffY : diffY ; h += diffX + diffY ; } } // Convert the result to a float and return it return ( float ) h ; } // There is a parent node so calculate the heuristic incrementally from it. else { // Get the parent board state. EightPuzzleState parentState = ( EightPuzzleState ) parentNode . getState ( ) ; // Get the parent heurstic value. float h = parentNode . getH ( ) ; // Get the move that was played. char playedMove = ( ( String ) searchNode . getAppliedOp ( ) . getOp ( ) ) . charAt ( 0 ) ; // Get the position of the empty tile on the parent board. int emptyX = parentState . getEmptyX ( ) ; int emptyY = parentState . getEmptyY ( ) ; // Work out which tile has been moved, this is the tile that now sits where the empty tile was. char movedTile = state . getTileAt ( emptyX , emptyY ) ; // The tile has either moved one step closer to its goal location or one step further away, decide which it // is. Calculate the X or Y position that the tile moved from. int oldX = 0 ; int oldY = 0 ; switch ( playedMove ) { case ' ' : { oldX = emptyX - 1 ; break ; } case ' ' : { oldX = emptyX + 1 ; break ; } case ' ' : { oldY = emptyY - 1 ; break ; } case ' ' : { oldY = emptyY + 1 ; break ; } default : { throw new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; } } // Calculate the change in heuristic. int change = 0 ; switch ( playedMove ) { // Catch the case where a horizontal move was made. case ' ' : case ' ' : { // Get the X position of the tile in the goal state and current state int goalX = state . getGoalXForTile ( movedTile ) ; int newX = emptyX ; // Calculate the change in the heuristic int oldDiffX = oldX - goalX ; oldDiffX = ( oldDiffX < 0 ) ? - oldDiffX : oldDiffX ; int newDiffX = newX - goalX ; newDiffX = ( newDiffX < 0 ) ? - newDiffX : newDiffX ; change = newDiffX - oldDiffX ; break ; } // Catch the case where a vertical move was made. case ' ' : case ' ' : { // Get the Y position of the tile in the goal state and current state int goalY = state . getGoalYForTile ( movedTile ) ; int newY = emptyY ; // Calculate the change in the heuristic int oldDiffY = oldY - goalY ; oldDiffY = ( oldDiffY < 0 ) ? - oldDiffY : oldDiffY ; int newDiffY = newY - goalY ; newDiffY = ( newDiffY < 0 ) ? - newDiffY : newDiffY ; change = newDiffY - oldDiffY ; break ; } default : { throw new IllegalStateException ( \"Unkown operator: \" + playedMove + \".\" ) ; } } // Return the parent heuristic plus or minus one. return ( change > 0 ) ? ( h + 1.0f ) : ( h - 1.0f ) ; } }", "nl": "Returns heuristic evaluation of an eight puzzle board position as the manhattan distance of all tiles from their correct positions ."}}
{"translation": {"code": "private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { // Perform default de-serialization. // in.defaultReadObject(); // Deserialize the attribute by value, from its attribute class and full path. String [ ] pathArrayValue = ( String [ ] ) in . readObject ( ) ; String attributeClassName = ( String ) in . readObject ( ) ; // Re-create the attribute from its value representation. HierarchyAttribute attr = getFactoryForClass ( attributeClassName ) . createHierarchyAttribute ( pathArrayValue ) ; // Copy the fields from the freshly constructed attribute into this one. value = attr . value ; attributeClass = attr . attributeClass ; // Print out some information about the deserialized object. /*log.fine(\"Deserialized hierarchy attribute = \" + this);*/ /*log.fine(\"Deserialized hierarchy attribute class = \" + attributeClass);*/ /*log.fine(\"Deserialized attribute classes in static class map are: \");*/ for ( HierarchyClassImpl attributeClass : attributeClasses . values ( ) ) { /*log.fine(attributeClass.toString());*/ } }", "nl": "Deserializes a hierarchy attribute ."}}
{"translation": {"code": "private void writeObject ( ObjectOutputStream out ) throws IOException { // Print out some information about the serialized object. /*log.fine(\"Serialized hierarchy attribute = \" + this);*/ /*log.fine(\"Serialized hierarchy attribute class = \" + attributeClass);*/ /*log.fine(\"Serialized attribute classes in static class map are: \");*/ for ( HierarchyClassImpl attributeClass : attributeClasses . values ( ) ) { /*log.fine(attributeClass.toString());*/ } // Perform default serialization. // out.defaultWriteObject(); // Serialized the attribute by value, that is, its full path and the name of its attribute class. List < String > pathValue = getPathValue ( ) ; String [ ] pathArrayValue = pathValue . toArray ( new String [ pathValue . size ( ) ] ) ; out . writeObject ( pathArrayValue ) ; out . writeObject ( attributeClass . getName ( ) ) ; }", "nl": "Serialized a hierarchy attribute ."}}
{"translation": {"code": "public String getLastValue ( ) { List < String > pathValue = getPathValue ( ) ; return pathValue . get ( pathValue . size ( ) - 1 ) ; }", "nl": "Gets the label value at the last level of the hierarchy ."}}
{"translation": {"code": "public String getValueAtLevel ( String level ) { /*log.fine(\"public String getValueAtLevel(String level): called\");*/ /*log.fine(\"level = \" + level);*/ int index = attributeClass . levels . indexOf ( level ) ; /*log.fine(\"index = \" + index);*/ if ( index == - 1 ) { throw new IllegalArgumentException ( \"Level name \" + level + \" is not known to this hierarchy attribute type.\" ) ; } return getValueAtLevel ( index ) ; }", "nl": "Gets the label value at the named level of the hierarchy ."}}
{"translation": {"code": "public Iterator iterator ( ) { try { DistributedIteratorImpl di ; di = new DistributedIteratorImpl ( super . iterator ( ) ) ; return new ClientIterator ( di ) ; } catch ( RemoteException e ) { // Rethrow the RemoteException as a RuntimeException so as not to conflict with the interface of ArrayList throw new IllegalStateException ( \"There was a RemoteExcpetion.\" , e ) ; } }", "nl": "Returns a distriubuted iterator that can provide elements of the list on demand over a remote connection ."}}
{"translation": {"code": "public long getId ( ) { // Find the category for this hierarchy attribute value. Tree < CategoryNode > category = attributeClass . lookup . get ( value ) ; // Extract and return the id. return category . getElement ( ) . id ; }", "nl": "Returns the long id of the attribute ."}}
{"translation": {"code": "protected WAMCallPoint setCodeAddress ( int functorName , int offset , int length ) { WAMCallPoint entry = new WAMCallPoint ( offset , length , functorName ) ; symbolTable . put ( functorName , SYMKEY_CALLPOINTS , entry ) ; // Keep a reverse lookup from address to functor name. reverseTable . put ( offset , functorName ) ; return entry ; }", "nl": "Records the offset of the start of the code for the named functor ."}}
{"translation": {"code": "public WAMCallPoint resolveCallPoint ( int functorName ) { /*log.fine(\"public WAMCallPoint resolveCallPoint(int functorName): called\");*/ WAMCallPoint result = ( WAMCallPoint ) symbolTable . get ( functorName , SYMKEY_CALLPOINTS ) ; if ( result == null ) { result = new WAMCallPoint ( - 1 , 0 , functorName ) ; } return result ; }", "nl": "Looks up the offset of the start of the code for the named functor ."}}
{"translation": {"code": "private static StringBuffer listHandlers ( Handler [ ] handlers , StringBuffer buffer ) { for ( Handler handler : handlers ) { Class < ? extends Handler > handlerClass = handler . getClass ( ) ; Formatter formatter = handler . getFormatter ( ) ; buffer . append ( \"Handler:\" ) . append ( handlerClass . getName ( ) ) . append ( \"\\n\" ) ; buffer . append ( \"Level:\" ) . append ( handler . getLevel ( ) . toString ( ) ) . append ( \"\\n\" ) ; if ( formatter != null ) { buffer . append ( \"Formatter:\" ) . append ( formatter . getClass ( ) . getName ( ) ) . append ( \"\\n\" ) ; } } return buffer ; }", "nl": "Lists information about logging handlers ."}}
{"translation": {"code": "public static String currentConfiguration ( ) { StringBuffer rtn = new StringBuffer ( 1024 ) ; String loggingConfigClass = System . getProperty ( \"java.util.logging.config.class\" ) ; String loggingConfigFile = System . getProperty ( \"java.util.logging.config.file\" ) ; boolean configClassOK = false ; if ( loggingConfigClass == null ) { rtn . append ( \"No java.util.logging.config.class class is set.\\n\" ) ; } else { rtn . append ( \"java.util.logging.config.class is set to '\" ) . append ( loggingConfigClass ) . append ( \"'\\n\" ) ; try { Class c = Class . forName ( loggingConfigClass ) ; c . newInstance ( ) ; rtn . append ( \"This class was loaded and a new instance was sucessfully created.\\n\" ) ; configClassOK = true ; } catch ( ClassNotFoundException e ) { e = null ; rtn . append ( loggingConfigClass ) . append ( \" could not be found.\" ) ; } catch ( InstantiationException e ) { e = null ; rtn . append ( loggingConfigClass ) . append ( \" could not be instantiated.\" ) ; } catch ( IllegalAccessException e ) { e = null ; rtn . append ( loggingConfigClass ) . append ( \" could not be accessed.\" ) ; } } if ( loggingConfigFile == null ) { rtn . append ( \"No java.util.logging.config.file file is set.\\n\" ) ; } else { rtn . append ( \"java.util.logging.config.file is set to '\" ) . append ( loggingConfigFile ) . append ( \"'\\n\" ) ; File loggingFile = new File ( loggingConfigFile ) ; rtn . append ( loggingFile . getAbsolutePath ( ) ) . append ( \"\\n\" ) ; if ( ! loggingFile . exists ( ) || ! loggingFile . isFile ( ) ) { rtn . append ( \"This file does NOT EXIST.\\n\" ) ; } if ( loggingConfigClass != null ) { if ( configClassOK ) { rtn . append ( \"This file is ignored because java.util.logging.config.class is set.\\n\" ) ; } } } Handler [ ] handlers = Logger . getLogger ( \"\" ) . getHandlers ( ) ; listHandlers ( handlers , rtn ) ; return rtn . toString ( ) ; }", "nl": "Provides a string containing information about the configured logging set up ."}}
{"translation": {"code": "public static String toCamelCase ( String name ) { String [ ] parts = name . split ( \"_\" ) ; String result = parts [ 0 ] ; for ( int i = 1 ; i < parts . length ; i ++ ) { if ( parts [ i ] . length ( ) > 0 ) { result += upperFirstChar ( parts [ i ] ) ; } } return result ; }", "nl": "Converts a string to camel case ."}}
{"translation": {"code": "public static String arrayToList ( String [ ] array , String delim ) { String result = \"\" ; for ( int i = 0 ; i < array . length ; i ++ ) { result += array [ i ] + ( ( i == ( array . length - 1 ) ) ? \"\" : delim ) ; } return result ; }", "nl": "Converts an array of strings into a delimeter seperated string ."}}
{"translation": {"code": "public static String [ ] listToArray ( String value , String delim ) { List < String > result = new ArrayList < String > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( value , delim ) ; while ( tokenizer . hasMoreTokens ( ) ) { result . add ( tokenizer . nextToken ( ) ) ; } return result . toArray ( new String [ result . size ( ) ] ) ; }", "nl": "Converts a string listing sub - strings seperated by a delimeter into an array of strings ."}}
{"translation": {"code": "public void setValue ( T value ) throws IllegalArgumentException { Integer b = attributeClass . lookupInt . get ( value ) ; // Check if the value is not already a memeber of the attribute class. if ( b == null ) { // Check if the attribute class has been finalized yet. if ( attributeClass . finalized ) { throw new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized IdType, \" + attributeClass . attributeClassName + \".\" ) ; } else { // Add the new value to the attribute class. Delegate to the factory to do this so that strings are // interned and so on. IdAttribute newAttribute = attributeClass . createIdAttribute ( value ) ; b = newAttribute . value ; } } // Set the new value as the value of this attribute. this . value = b ; }", "nl": "Sets the specified object as the value of this attribute . The value to set must be a legitimate member of this attributes type when the type has been finalized . If the type has yet to be finalized then the new value is added to the set of possible values for the type ."}}
{"translation": {"code": "public T getValue ( ) { // Check if the attribute class has been finalized yet. if ( attributeClass . finalized ) { // Fetch the object value from the attribute class. return attributeClass . lookupValue [ value ] . label ; } else { return attributeClass . lookupValueList . get ( value ) . label ; } }", "nl": "Gets the object value of a object attribute ."}}
{"translation": {"code": "public boolean isSubCategory ( HierarchyAttribute comp ) { // Check that the comparator is of the same type class as this one. if ( ! comp . attributeClass . attributeClassName . equals ( attributeClass . attributeClassName ) ) { return false ; } // Extract the path labels from this and the comparator. List < String > otherPath = comp . getPathValue ( ) ; List < String > path = getPathValue ( ) ; // Check that the path length of the comparator is the same as this plus one or longer. if ( otherPath . size ( ) <= path . size ( ) ) { return false ; } // Start by assuming that the paths prefixes are the same, then walk down both paths checking they are // the same. boolean subcat = true ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { // Check that the labels really are equal. if ( ! otherPath . get ( i ) . equals ( path . get ( i ) ) ) { subcat = false ; break ; } } return subcat ; }", "nl": "Tests if another hierarchy attribute is strict a sub - category of this one . It is a sub - category if it has the same sequence of path labels as this one as a prefix of its whole path label ."}}
{"translation": {"code": "protected String appendClasspath ( String commandLine , boolean unix ) { String pathSeperator ; String seperator ; if ( unix ) { pathSeperator = \"/\" ; seperator = \":\" ; } else { pathSeperator = \"\\\\\" ; seperator = \";\" ; } for ( Iterator i = classpathElements . iterator ( ) ; i . hasNext ( ) ; ) { String cpPath = ( String ) i . next ( ) ; cpPath = cpPath . replace ( \"/\" , pathSeperator ) ; commandLine += cpPath + ( i . hasNext ( ) ? seperator : \"\" ) ; } return commandLine ; }", "nl": "Appends the classpath onto the command line ."}}
{"translation": {"code": "public static int intLogBase2 ( int value ) { int temp1 ; int temp2 = value >> 16 ; if ( temp2 > 0 ) { temp1 = temp2 >> 8 ; return ( temp1 > 0 ) ? ( 24 + LOG_TABLE_256 [ temp1 ] ) : ( 16 + LOG_TABLE_256 [ temp2 ] ) ; } else { temp1 = value >> 8 ; return ( temp1 > 0 ) ? ( 8 + LOG_TABLE_256 [ temp1 ] ) : LOG_TABLE_256 [ value ] ; } }", "nl": "Calcalates the log base 2 of an integer . This code is tuned to uniformly distributed output values longer numbers are slightly favoured ."}}
{"translation": {"code": "public static int intLogBase10v2 ( int value ) { return ( value >= 1000000000 ) ? 9 : ( ( value >= 100000000 ) ? 8 : ( ( value >= 10000000 ) ? 7 : ( ( value >= 1000000 ) ? 6 : ( ( value >= 100000 ) ? 5 : ( ( value >= 10000 ) ? 4 : ( ( value >= 1000 ) ? 3 : ( ( value >= 100 ) ? 2 : ( ( value >= 10 ) ? 1 : 0 ) ) ) ) ) ) ) ) ; }", "nl": "Calcalates the log base 10 of an integer . This produces results faster for longer numbers ."}}
{"translation": {"code": "protected Properties getPropertiesUsingCWD ( ) { /*log.fine(\"getPropertiesUsingCWD: called\");*/ // Use PropertiesHelper to try to load the properties from a file or URl try { return PropertiesHelper . getProperties ( getPropertiesResourceName ( ) ) ; } catch ( IOException e ) { /*log.fine(\"Could not load properties from file or URL \" + getPropertiesResourceName());*/ // Failure of this method is noted, so exception is ignored. e = null ; } return null ; }", "nl": "Tries to load the properties as a file or URL matching the properties resource name . File names will be taken relative to the current working directory ."}}
{"translation": {"code": "protected Properties getPropertiesUsingClasspath ( ) { /*log.fine(\"getPropertiesUsingClasspath: called\");*/ // Try to open the properties resource name as an input stream from the classpath InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( getPropertiesResourceName ( ) ) ; // Use PropertiesHelper to try to load the properties from the input stream if one was succesfully created if ( is != null ) { try { return PropertiesHelper . getProperties ( is ) ; } catch ( IOException e ) { /*log.fine(\"Could not load properties from classpath\");*/ // Failure of this method is noted, so exception is ignored. e = null ; } } return null ; }", "nl": "Tries to load the properties from the classpath using the classloader for this class ."}}
{"translation": {"code": "protected Properties getPropertiesUsingSystemProperty ( ) { /*log.fine(\"getPropertiesUsingSystemProperty: called\");*/ // Get the path to the file from the system properties /*log.fine(\"getPropertiesResourceName() = \" + getPropertiesResourceName());*/ String path = System . getProperty ( getPropertiesResourceName ( ) ) ; /*log.fine(\"properties resource name = \" + getPropertiesResourceName());*/ /*log.fine(\"path = \" + path);*/ // Use PropertiesHelper to try to load the properties from the path try { return PropertiesHelper . getProperties ( path ) ; } catch ( IOException e ) { /*log.fine(\"Could not load properties from path \" + path);*/ // Failure of this method is noted, so exception is ignored. e = null ; } return null ; }", "nl": "Tries to load the properties from the file or URL named by the system property with name mathching the properties resource name ."}}
{"translation": {"code": "protected void findProperties ( ) { /*log.fine(\"findProperties: called\");*/ // Try to load the properties from a file referenced by the system property matching // the properties file name. properties = getPropertiesUsingSystemProperty ( ) ; if ( properties != null ) { /*log.fine(\"loaded properties using the system property\");*/ // The properties were succesfully located and loaded return ; } /*log.fine(\"failed to get properties from the system properties\");*/ // Try to load the properties from a resource on the classpath using the current // class loader properties = getPropertiesUsingClasspath ( ) ; if ( properties != null ) { /*log.fine(\"loaded properties from the class path\");*/ // The properties were succesfully located and loaded return ; } /*log.fine(\"failed to get properties from the classpath\");*/ // Try to load the properties from a file relative to the current working directory properties = getPropertiesUsingCWD ( ) ; if ( properties != null ) { /*log.fine(\"loaded properties from the current working directory\");*/ // The properties were succesfully located and loaded return ; } /*log.fine(\"failed to get properties from the current working directory\");*/ }", "nl": "This methods attempts to load the properties from a file or URL referenced by the system property with the same name as the properties resource name from a resource on the classpath with the same name as the properties resource name or from a properties file name relative to the current working directory . It tries these methods sequentially one after the other until one succeeds ."}}
{"translation": {"code": "protected NumericType evaluate ( NumericType firstNumber ) { // If the argument is a real number, then use real number arithmetic, otherwise use integer arithmetic. if ( firstNumber . isInteger ( ) ) { return new IntLiteral ( - firstNumber . intValue ( ) ) ; } else { return new DoubleLiteral ( - firstNumber . doubleValue ( ) ) ; } }", "nl": "Evaluates the arithmetic operator on its numeric argument ."}}
{"translation": {"code": "public void setRate ( float hertz ) { // Check that the argument is above zero. if ( hertz <= 0.0f ) { throw new IllegalArgumentException ( \"The throttle rate must be above zero.\" ) ; } // Calculate the cycle time. cycleTimeNanos = ( long ) ( 1000000000f / hertz ) ; // Reset the first pass flag. firstCall = false ; firstCheckCall = false ; }", "nl": "Specifies the throttling rate in operations per second . This must be called with with a value the inverse of which is a measurement in nano seconds such that the number of nano seconds do not overflow a long integer . The value must also be larger than zero ."}}
{"translation": {"code": "protected void createArrayProperties ( ) { // Scan through all defined properties. for ( Object o : keySet ( ) ) { String key = ( String ) o ; String value = super . getProperty ( key ) ; // Split the property key into everything before the last '.' and after it. int lastDotIndex = key . lastIndexOf ( ' ' ) ; String keyEnding = key . substring ( lastDotIndex + 1 , key . length ( ) ) ; String keyStart = key . substring ( 0 , ( lastDotIndex == - 1 ) ? 0 : lastDotIndex ) ; // Check if the property key ends in an integer, in which case it is an array property. int index = 0 ; try { index = Integer . parseInt ( keyEnding ) ; } catch ( NumberFormatException e ) { // The ending is not an integer so its not an array. // Exception can be ignored as it means this property is not an array. e = null ; continue ; } // Check if an array property already exists for this base name and create one if not. ArrayList propArray = ( ArrayList ) arrayProperties . get ( keyStart ) ; if ( propArray == null ) { propArray = new ArrayList ( ) ; arrayProperties . put ( keyStart , propArray ) ; } // Add the new property value to the array property for the index. propArray . set ( index , value ) ; } }", "nl": "Scans all the properties in the parent Properties object and creates arrays for any array property definitions ."}}
{"translation": {"code": "protected Iterator getKeyIterator ( final String base , final String modifier , final String key ) { return new Iterator ( ) { // The key ordering count always begins at the start of the ORDER array. private int i ; public boolean hasNext ( ) { return ( useDefaults ? ( ( i < ORDER . length ) && ( ORDER [ i ] > ENVIRONMENT_DEFAULTS_CUTOFF ) ) : ( i < ORDER . length ) ) ; } public Object next ( ) { // Check that there is a next element and return null if not. if ( ! hasNext ( ) ) { return null ; } // Get the next ordering count. int o = ORDER [ i ] ; // Do bit matching on the count to choose which elements to include in the key. String result = ( ( ( o & E ) != 0 ) ? ( environment + \".\" ) : \"\" ) + ( ( ( o & B ) != 0 ) ? ( base + \".\" ) : \"\" ) + ( ( ( o & M ) != 0 ) ? ( modifier + \".\" ) : \"\" ) + key ; // Increment the iterator to get the next key on the next call. i ++ ; return result ; } public void remove ( ) { // This method is not supported. throw new UnsupportedOperationException ( \"remove() is not supported on this key order iterator as \" + \"the ordering cannot be changed\" ) ; } } ; }", "nl": "For a given environment base modifier and key and setting of the use of default environments feature this generates an iterator that walks over the order in which to try and access properties ."}}
{"translation": {"code": "public String [ ] getProperties ( String key ) { // Try to get the callers class name and method name by throwing an exception an searching the stack frames. String className = null ; String methodName = null ; /* Java 1.4 onwards only.\n           try {\n             throw new Exception();\n           } catch (Exception e) {\n             StackTraceElement[] stack = e.getStackTrace();\n             // Check that the stack trace contains at least two elements, one for this method and one for the caller.\n             if (stack.length >= 2) {\n               className = stack[1].getClassName();\n               methodName = stack[1].getMethodName();\n             }\n           }*/ return getProperties ( className , methodName , key ) ; }", "nl": "Looks up an array property value relative to the environment callers class and method . The default environment will be checked for a matching array property if defaults are being used . In order to work out the callers class and method this method throws an exception and then searches one level up its stack frames ."}}
{"translation": {"code": "public static int intLogBase2v2 ( int value ) { int temp ; if ( ( temp = value >> 24 ) > 0 ) { return 24 + LOG_TABLE_256 [ temp ] ; } else if ( ( temp = value >> 16 ) > 0 ) { return 16 + LOG_TABLE_256 [ temp ] ; } else if ( ( temp = value >> 8 ) > 0 ) { return 8 + LOG_TABLE_256 [ temp ] ; } else { return LOG_TABLE_256 [ value ] ; } }", "nl": "Calcalates the log base 2 of an integer . This code is tuned to uniformly distributed input values longer numbers are favoured ."}}
{"translation": {"code": "public String getProperty ( String key ) { // Try to get the callers class name and method name by examing the stack. String className = null ; String methodName = null ; // Java 1.4 onwards only. /*try\n        {\n            throw new Exception();\n        }\n        catch (Exception e)\n        {\n            StackTraceElement[] stack = e.getStackTrace();\n\n            // Check that the stack trace contains at least two elements, one for this method and one for the caller.\n            if (stack.length >= 2)\n            {\n                className = stack[1].getClassName();\n                methodName = stack[1].getMethodName();\n            }\n        }*/ // Java 1.5 onwards only. StackTraceElement [ ] stack = Thread . currentThread ( ) . getStackTrace ( ) ; // Check that the stack trace contains at least two elements, one for this method and one for the caller. if ( stack . length >= 2 ) { className = stack [ 1 ] . getClassName ( ) ; methodName = stack [ 1 ] . getMethodName ( ) ; } // Java 1.3 and before? Not sure, some horrible thing that parses the text spat out by printStackTrace? return getProperty ( className , methodName , key ) ; }", "nl": "Looks up a property value relative to the environment callers class and method . The default environment will be checked for a matching property if defaults are being used . In order to work out the callers class and method this method throws an exception and then searches one level up its stack frames ."}}
{"translation": {"code": "protected void setCurrentScreen ( WorkFlowScreenPanel screen ) { // Remove any existing screen from the panel panel . removeAll ( ) ; // Place the new screen into the panel panel . add ( screen ) ; // Check if the screen is not already in the stack of accessed screens. It may be if this is the second time // the screen is visited foir example if the back button is used. if ( ! accessedScreens . contains ( screen ) ) { // Add the screen to the stack of accessed screens accessedScreens . push ( screen ) ; } // Update the work flow state to reflect the change to a new screen state state . setCurrentScreenState ( screen . getState ( ) ) ; // Keep track of the current screen in a local member variable currentScreen = screen ; // Initialize the new screen screen . initialize ( ) ; // Force the panel to redraw panel . validate ( ) ; }", "nl": "This is a helper method that controller implementations may find useful for moving to a new screen . It places the screen into the panel that this controller was built with replacing any existing screen changes the underlying state to reflect the change to a new current screen and calls the new screens initialize method ."}}
{"translation": {"code": "public void emmitCode ( ByteBuffer buffer , WAMMachine machine , WAMCallPoint callPoint ) throws LinkageException { // Ensure that the size of the instruction listing does not exceed max int (highly unlikely). if ( sizeof ( ) > Integer . MAX_VALUE ) { throw new IllegalStateException ( \"The instruction listing size exceeds Integer.MAX_VALUE.\" ) ; } // Used to keep track of the size of the emitted code, in bytes, as it is written. int length = 0 ; // Insert the compiled code into the byte code machine's code area. for ( WAMInstruction instruction : instructions ) { instruction . emmitCode ( buffer , machine ) ; length += instruction . sizeof ( ) ; } // Keep record of the machine that the code is hosted in, and the call point of the functor within the machine. this . machine = machine ; this . callPoint = callPoint ; // Record the fact that the code is now linked into a machine. this . status = LinkStatus . Linked ; }", "nl": "Emmits the binary byte code for the clause into a machine writing into the specified byte array . The state of this clause is changed to Linked to indicate that it has been linked into a binary machine ."}}
{"translation": {"code": "public void setHead ( Functor head , SizeableList < WAMInstruction > instructions ) { this . head = head ; addInstructions ( instructions ) ; }", "nl": "Sets a compiled head functor to this clause ."}}
{"translation": {"code": "public static int getCharacterCountDecimal ( long integerValue , int scale ) { boolean isNeg = integerValue < 0 ; // Work out how many digits will be needed for the number, adding space for the minus sign, the decimal // point and leading zeros if needed. int totalDigits = BitHackUtils . getCharacterCountInt64 ( integerValue ) ; int totalLength = totalDigits ; if ( isNeg ) { totalDigits -- ; // Minus sign already accounted for. } if ( scale > 0 ) { totalLength ++ ; // For the decimal point. if ( scale >= totalDigits ) { // For the leading zeros (+ 1 for the zero before decimal point). totalLength += ( scale - totalDigits ) + 1 ; } } else { // Add a zero for each negative point in scale totalLength -= scale ; } return totalLength ; }", "nl": "Calculates the number of ASCII characters that will be needed to represent a specified signed decimal number ."}}
{"translation": {"code": "public static int getCharacterCountInt64 ( long value ) { if ( value >= 0 ) { return getCharacterCountUInt64 ( value ) ; } else if ( value == Long . MIN_VALUE ) { return getCharacterCountUInt64 ( Long . MAX_VALUE ) + 1 ; } else { return getCharacterCountUInt64 ( - value ) + 1 ; } }", "nl": "Calculates the number of ASCII characters that will be needed to represent a specifed signed 64 - bit integer ."}}
{"translation": {"code": "public static int getCharacterCountInt32 ( int value ) { if ( value >= 0 ) { return getCharacterCountUInt32 ( value ) ; } else if ( value == Integer . MIN_VALUE ) { return getCharacterCountUInt32 ( Integer . MAX_VALUE ) + 1 ; } else { return getCharacterCountUInt32 ( - value ) + 1 ; } }", "nl": "Calculates the number of ASCII characters that will be needed to represent a specifed signed 32 - bit integer ."}}
{"translation": {"code": "public static int intLogBase10v2 ( long value ) { return ( value < 10 ) ? 0 : ( ( value < 100 ) ? 1 : ( ( value < 1000 ) ? 2 : ( ( value < 10000 ) ? 3 : ( ( value < 100000 ) ? 4 : ( ( value < 1000000 ) ? 5 : ( ( value < 10000000 ) ? 6 : ( ( value < 100000000 ) ? 7 : ( ( value < 1000000000L ) ? 8 : ( ( value < 10000000000L ) ? 9 : ( ( value < 100000000000L ) ? 10 : ( ( value < 1000000000000L ) ? 11 : ( ( value < 10000000000000L ) ? 12 : ( ( value < 100000000000000L ) ? 13 : ( ( value < 1000000000000000L ) ? 14 : ( ( value < 10000000000000000L ) ? 15 : ( ( value < 100000000000000000L ) ? 16 : ( ( value < 1000000000000000000L ) ? 17 : 18 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }", "nl": "Calcalates the log base 10 of an integer . This method favours longer numbers or evenly distributed input ."}}
{"translation": {"code": "public static int intLogBase10 ( long value ) { return ( value >= 1000000000000000000L ) ? 18 : ( ( value >= 100000000000000000L ) ? 17 : ( ( value >= 10000000000000000L ) ? 16 : ( ( value >= 1000000000000000L ) ? 15 : ( ( value >= 100000000000000L ) ? 14 : ( ( value >= 10000000000000L ) ? 13 : ( ( value >= 1000000000000L ) ? 12 : ( ( value >= 100000000000L ) ? 11 : ( ( value >= 10000000000L ) ? 10 : ( ( value >= 1000000000L ) ? 9 : ( ( value >= 100000000L ) ? 8 : ( ( value >= 10000000L ) ? 7 : ( ( value >= 1000000L ) ? 6 : ( ( value >= 100000L ) ? 5 : ( ( value >= 10000L ) ? 4 : ( ( value >= 1000L ) ? 3 : ( ( value >= 100L ) ? 2 : ( ( value >= 10L ) ? 1 : 0 ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ) ; }", "nl": "Calcalates the log base 10 of an integer . This method favours shorter numbers ."}}
{"translation": {"code": "public static int intLogBase10v3 ( int value ) { return ( value < 10 ) ? 0 : ( ( value < 100 ) ? 1 : ( ( value < 1000 ) ? 2 : ( ( value < 10000 ) ? 3 : ( ( value < 100000 ) ? 4 : ( ( value < 1000000 ) ? 5 : ( ( value < 10000000 ) ? 6 : ( ( value < 100000000 ) ? 7 : ( ( value < 1000000000 ) ? 8 : 9 ) ) ) ) ) ) ) ) ; }", "nl": "Calcalates the log base 10 of an integer . This produces results faster for shorter numbers ."}}
{"translation": {"code": "public boolean evaluate ( T t ) { // Start by assuming that the candidate will be a member of the predicate. boolean passed = true ; // Loop through all predicates and fail if any one of them does. for ( UnaryPredicate < T > predicate : chain ) { if ( ! predicate . evaluate ( t ) ) { passed = false ; break ; } } return passed ; }", "nl": "Evaluates a logical predicate ."}}
{"translation": {"code": "public static Type createInstance ( String name , DateOnly from , DateOnly to ) { // Ensure that min is less than or equal to max. if ( ( from != null ) && ( to != null ) && ( from . compareTo ( to ) > 0 ) ) { throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; } synchronized ( DATE_RANGE_TYPES ) { // Add the newly created type to the map of all types. DateRangeType newType = new DateRangeType ( name , from , to ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. DateRangeType oldType = DATE_RANGE_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { DATE_RANGE_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new date range type with the specified name if it does not already exist ."}}
{"translation": {"code": "private void evaluate ( Sentence < Clause > sentence ) throws SourceCodeException { Clause clause = sentence . getT ( ) ; if ( clause . isQuery ( ) ) { engine . endScope ( ) ; engine . compile ( sentence ) ; evaluateQuery ( ) ; } else { // Check if the program clause is new, or a continuation of the current predicate. int name = clause . getHead ( ) . getName ( ) ; if ( ( currentPredicateName == null ) || ( currentPredicateName != name ) ) { engine . endScope ( ) ; currentPredicateName = name ; } addProgramClause ( sentence ) ; } }", "nl": "Evaluates a query against the resolver or adds a clause to the resolvers domain ."}}
{"translation": {"code": "private void evaluateQuery ( ) { /*log.fine(\"Read query from input.\");*/ // Create an iterator to generate all solutions on demand with. Iteration will stop if the request to // the parser for the more ';' token fails. Iterator < Set < Variable >> i = engine . iterator ( ) ; if ( ! i . hasNext ( ) ) { System . out . println ( \"false. \" ) ; return ; } for ( ; i . hasNext ( ) ; ) { Set < Variable > solution = i . next ( ) ; if ( solution . isEmpty ( ) ) { System . out . print ( \"true\" ) ; } else { for ( Iterator < Variable > j = solution . iterator ( ) ; j . hasNext ( ) ; ) { Variable nextVar = j . next ( ) ; String varName = engine . getVariableName ( nextVar . getName ( ) ) ; System . out . print ( varName + \" = \" + nextVar . getValue ( ) . toString ( engine , true , false ) ) ; if ( j . hasNext ( ) ) { System . out . println ( ) ; } } } // Finish automatically if there are no more solutions. if ( ! i . hasNext ( ) ) { System . out . println ( \".\" ) ; break ; } // Check if the user wants more solutions. try { int key = consoleReader . readVirtualKey ( ) ; if ( key == SEMICOLON ) { System . out . println ( \" ;\" ) ; } else { System . out . println ( ) ; break ; } } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } } }", "nl": "Evaluates a query . In the case of queries the interner is used to recover textual names for the resulting variable bindings . The user is queried through the parser to if more than one solution is required ."}}
{"translation": {"code": "public void restart ( ) { // Clear the sweep thread kill flag. sweepThreadKillFlag = false ; // Start the sweep thread running with low priority. cacheSweepThread = new Thread ( ) { public void run ( ) { sweep ( ) ; } } ; cacheSweepThread . setPriority ( Thread . MIN_PRIORITY ) ; cacheSweepThread . start ( ) ; }", "nl": "Restarts the sweep alogirithm . Useful after a kill has stopped it ."}}
{"translation": {"code": "private void insertNodes ( Node node , Node newNode ) { // Keep a reference to the next node in the node's chain as this will be overwritten when attaching the node // or chain into the root list. Node oldNodeNext = newNode . next ; // Break open the node's chain and attach it into the root list. newNode . next . prev = node ; newNode . next = node . next ; // Break open the root list chain and attach it to the new node or chain. node . next . prev = newNode ; node . next = oldNodeNext ; }", "nl": "Inserts a single node or a circular doubly linked list of nodes into a list next to the specified node . I does not matter if the specified nodes are singletons or part of a chain as they will be correctly linked in in either case so long as their prev and next references form a loop with themselves ."}}
{"translation": {"code": "private int compare ( Node node1 , Node node2 ) { // Check if a comparator was set. if ( entryComparator != null ) { // Use the comparator to compare. return entryComparator . compare ( node1 . element , node2 . element ) ; } // No comparator was set so use the natural ordering. else { // Cast one of the elements into a Comparable and compare it with the other. return ( ( Comparable ) node1 . element ) . compareTo ( node2 . element ) ; } }", "nl": "Compares two heap nodes . The comparison performed is dependant on whether a comparator has been set or the natural ordering is to be used ."}}
{"translation": {"code": "private void updateMinimum ( Node node ) { // Check if a comparator was set. if ( entryComparator != null ) { // Use the comparator to compare the candidate new minimum with the current one and check if the new one // should be set. if ( entryComparator . compare ( node . element , minNode . element ) < 0 ) { // Update the minimum node. minNode = node ; } } // No comparator was set so use the natural ordering. else { // Cast the candidate new minimum element into a Comparable and compare it with the existing minimum // to check if the new one should be set. if ( ( ( Comparable ) node . element ) . compareTo ( minNode . element ) < 0 ) { // Update the minimum node. minNode = node ; } } }", "nl": "Compares the specified node with the minimum and updates the minimum if neccessary . If a comparator was used to create this heap then this comparator is used to perform the comparison . If no comparator was set then the natural ordering of the element type is used . The element must implement the Comparable interface to support a natural ordering . If it does not there will be a class cast exception thrown ."}}
{"translation": {"code": "private static int ceilingLog2 ( int n ) { int oa ; int i ; int b ; oa = n ; b = 32 / 2 ; i = 0 ; while ( b != 0 ) { i = ( i << 1 ) ; if ( n >= ( 1 << b ) ) { n /= ( 1 << b ) ; i = i | 1 ; } else { n &= ( 1 << b ) - 1 ; } b /= 2 ; } if ( ( 1 << i ) == oa ) { return i ; } else { return i + 1 ; } }", "nl": "Calculates the smallest integer value m such that m^2 > = n . The ceiling log2 of n ."}}
{"translation": {"code": "public boolean offer ( E o ) { // Make a new node out of the new data element. Node newNode = new Node ( o ) ; // Check if there is already a minimum element. if ( minNode != null ) { // There is already a minimum element, so add this new element to its right. newNode . next = minNode . next ; newNode . prev = minNode ; minNode . next . prev = newNode ; minNode . next = newNode ; // Compare the new element with the minimum and update the minimum if neccessary. updateMinimum ( newNode ) ; } // There is not already a minimum element. else { // Update the new element previous and next references to refer to itself so that it forms a doubly linked // list with only one element. This leaves the data structure in a suitable condition for adding more // elements. newNode . next = newNode ; newNode . prev = newNode ; // Set the minimum element to be the new data element. minNode = newNode ; } // Increment the count of data elements in this collection. size ++ ; // Return true to indicate that the new data element was accepted into the heap. return true ; }", "nl": "Inserts the specified element into this heap ."}}
{"translation": {"code": "protected boolean evaluate ( NumericType firstNumber , NumericType secondNumber ) { // If either of the arguments is a real number, then use real number arithmetic, otherwise use integer arithmetic. if ( firstNumber . isInteger ( ) && secondNumber . isInteger ( ) ) { return firstNumber . intValue ( ) < secondNumber . intValue ( ) ; } else { return firstNumber . doubleValue ( ) < secondNumber . doubleValue ( ) ; } }", "nl": "Evaluates the arithmetic comparison on its two numeric arguments ."}}
{"translation": {"code": "private String listToString ( VariableAndFunctorInterner interner , boolean isFirst , boolean printVarName , boolean printBindings ) { String result = \"\" ; if ( isFirst ) { result += \"[\" ; } result += arguments [ 0 ] . toString ( interner , printVarName , printBindings ) ; Term consArgument = arguments [ 1 ] . getValue ( ) ; if ( consArgument instanceof Cons ) { result += \", \" + ( ( Cons ) consArgument ) . listToString ( interner , false , printVarName , printBindings ) ; } if ( isFirst ) { result += \"]\" ; } return result ; }", "nl": "Pretty prints a term relative to the symbol namings provided by the specified interner ."}}
{"translation": {"code": "public HeuristicSearchNode < O , T > makeNode ( Successor successor ) throws SearchNotExhaustiveException { HeuristicSearchNode < O , T > node = ( HeuristicSearchNode < O , T > ) super . makeNode ( successor ) ; // Make sure the new node has a reference to the heuristic evaluator node . heuristic = this . heuristic ; // Compute h for the new node node . computeH ( ) ; return node ; }", "nl": "Returns a new node based on a successor of this node . This new node will also be a HeuristicSearchNode ."}}
{"translation": {"code": "public static < T > Set < T > setOf ( SearchMethod < T > method ) { Set < T > result = new HashSet < T > ( ) ; findAll ( result , method ) ; return result ; }", "nl": "Finds the set of all goals of a search ."}}
{"translation": {"code": "private static void runGCTillStable ( ) { // Possibly add another iteration in here to run this whole method 3 or 4 times. long usedMem1 = usedMemory ( ) ; long usedMem2 = Long . MAX_VALUE ; // Repeatedly garbage collection until the used memory count becomes stable, or 500 iterations occur. for ( int i = 0 ; ( usedMem1 < usedMem2 ) && ( i < 500 ) ; i ++ ) { // Force finalisation of all object pending finalisation. RUNTIME . runFinalization ( ) ; // Return unused memory to the heap. RUNTIME . gc ( ) ; // Allow other threads to run. Thread . currentThread ( ) . yield ( ) ; // Keep the old used memory count from the last iteration and get a fresh reading. usedMem2 = usedMem1 ; usedMem1 = usedMemory ( ) ; } }", "nl": "Repeatedly runs the garbage collector and finalization method of the JVM runtime system until the used memory count becomes stable or 500 iterations occur whichever happens soonest . If other threads are active then this method is not likely to work as the used memory count will continually be changing ."}}
{"translation": {"code": "public Object addToEnvironment ( String propName , Object propVal ) { if ( myEnv == null ) { myEnv = new Hashtable ( 5 , 0.75f ) ; } return myEnv . put ( propName , propVal ) ; }", "nl": "Adds a new environment property to the environment of this context . If the property already exists its value is overwritten . See class description for more details on environment properties ."}}
{"translation": {"code": "public NamingEnumeration listBindings ( String name ) throws NamingException { if ( \"\" . equals ( name ) ) { // listing this context return new FlatBindings ( bindings . keys ( ) ) ; } // Perhaps `name' names a context Object target = lookup ( name ) ; if ( target instanceof Context ) { return ( ( Context ) target ) . listBindings ( \"\" ) ; } throw new NotContextException ( name + \" cannot be listed\" ) ; }", "nl": "Enumerates the names bound in the named context along with the objects bound to them . The contents of any subcontexts are not included ."}}
{"translation": {"code": "public NamingEnumeration list ( String name ) throws NamingException { if ( \"\" . equals ( name ) ) { // listing this context return new FlatNames ( bindings . keys ( ) ) ; } // Perhaps `name' names a context Object target = lookup ( name ) ; if ( target instanceof Context ) { return ( ( Context ) target ) . list ( \"\" ) ; } throw new NotContextException ( name + \" cannot be listed\" ) ; }", "nl": "Enumerates the names bound in the named context along with the class names of objects bound to them . The contents of any subcontexts are not included . If a binding is added to or removed from this context its effect on an enumeration previously returned is undefined ."}}
{"translation": {"code": "private void signalOnSizeThresholdCrossing ( long oldSize , long newSize ) { if ( signalable != null ) { if ( ( oldSize >= lowWaterSizeThreshold ) && ( newSize < lowWaterSizeThreshold ) ) { signalable . signalAll ( ) ; } else if ( ( oldSize >= highWaterSizeThreshold ) && ( newSize < highWaterSizeThreshold ) ) { signalable . signal ( ) ; } } }", "nl": "Signals the signallable resource if the size crosses a threshold boundary in a downward direction ."}}
{"translation": {"code": "private void decrementSizeAndCount ( E record ) { // Update the count for atomically counted queues. if ( atomicallyCounted ) { count . decrementAndGet ( ) ; } // Update the size for sizeable elements and sizeable queues. if ( sizeable && ( record instanceof Sizeable ) ) { long recordSize = - ( ( Sizeable ) record ) . sizeof ( ) ; long oldSize = dataSize . getAndAdd ( recordSize ) ; long newSize = oldSize + recordSize ; signalOnSizeThresholdCrossing ( oldSize , newSize ) ; } else if ( sizeable ) { long oldSize = dataSize . getAndDecrement ( ) ; long newSize = oldSize - 1 ; signalOnSizeThresholdCrossing ( oldSize , newSize ) ; } }", "nl": "Atomically subtracts from the size and count if the queue is running in atomic counting mode or sizeable mode and the element is sizeable ."}}
{"translation": {"code": "private void incrementSizeAndCount ( E record ) { // Update the count for atomically counted queues. if ( atomicallyCounted ) { count . incrementAndGet ( ) ; } // Update the size for sizeable elements and sizeable queues. if ( sizeable && ( record instanceof Sizeable ) ) { dataSize . addAndGet ( ( ( Sizeable ) record ) . sizeof ( ) ) ; } else if ( sizeable ) { dataSize . incrementAndGet ( ) ; } }", "nl": "Atomically adds to the size and count if the queue is running in atomic counting mode or sizeable mode and the element is sizeable ."}}
{"translation": {"code": "private RequeueElementWrapper < E > requeue ( E element , Object owner , AcquireState acquired ) { RequeueElementWrapper < E > record = new RequeueElementWrapper < E > ( element ) ; record . state = acquired ; record . owner = owner ; requeue . add ( record ) ; requeuedElementMap . put ( element , record ) ; return record ; }", "nl": "Places an element onto the requeue buffer in the acquired state by the specified owner ."}}
{"translation": {"code": "private void requeue ( E element ) { RequeueElementWrapper < E > record = new RequeueElementWrapper < E > ( element ) ; requeue . add ( record ) ; requeuedElementMap . put ( element , record ) ; }", "nl": "Places an element onto the requeue buffer ."}}
{"translation": {"code": "private org . apache . log4j . Level toLog4j ( Level level ) { if ( Level . SEVERE == level ) { return org . apache . log4j . Level . ERROR ; } else if ( Level . WARNING == level ) { return org . apache . log4j . Level . WARN ; } else if ( Level . INFO == level ) { return org . apache . log4j . Level . INFO ; } else if ( Level . FINE == level ) { return org . apache . log4j . Level . DEBUG ; } else if ( Level . FINER == level ) { return org . apache . log4j . Level . TRACE ; } else if ( Level . OFF == level ) { return org . apache . log4j . Level . OFF ; } return org . apache . log4j . Level . OFF ; }", "nl": "Converts java . util . logging levels to Log4J logging levels ."}}
{"translation": {"code": "public Object removeFromEnvironment ( String propName ) { if ( myEnv == null ) { return null ; } return myEnv . remove ( propName ) ; }", "nl": "Removes an environment property from the environment of this context . See class description for more details on environment properties ."}}
{"translation": {"code": "private String toLog4jMessage ( LogRecord record ) { String message = record . getMessage ( ) ; // Format message Object [ ] parameters = record . getParameters ( ) ; if ( ( parameters != null ) && ( parameters . length != 0 ) ) { // Check for the first few parameters ? if ( ( message . indexOf ( \"{0}\" ) >= 0 ) || ( message . indexOf ( \"{1}\" ) >= 0 ) || ( message . indexOf ( \"{2}\" ) >= 0 ) || ( message . indexOf ( \"{3}\" ) >= 0 ) ) { message = MessageFormat . format ( message , parameters ) ; } } return message ; }", "nl": "Transforms a java . util . logging . LogRecord to a message printable on Log4J ."}}
{"translation": {"code": "public static < T > Collection < T > bagOf ( SearchMethod < T > method ) { Collection < T > result = new ArrayList < T > ( ) ; findAll ( result , method ) ; return result ; }", "nl": "Finds a bag of all goals of a search ."}}
{"translation": {"code": "public T nextInSequence ( ) { T result = null ; // Loop until a filtered element is found, or the source iterator is exhausted. while ( source . hasNext ( ) ) { S next = source . next ( ) ; result = mapping . apply ( next ) ; if ( result != null ) { break ; } } return result ; }", "nl": "Generates the next element in the sequence ."}}
{"translation": {"code": "public void consultInputStream ( InputStream stream ) throws SourceCodeException { // Create a token source to read from the specified input stream. Source < Token > tokenSource = TokenSource . getTokenSourceForInputStream ( stream ) ; getParser ( ) . setTokenSource ( tokenSource ) ; // Consult the type checking rules and add them to the knowledge base. while ( true ) { Sentence < S > sentence = getParser ( ) . parse ( ) ; if ( sentence == null ) { break ; } getCompiler ( ) . compile ( sentence ) ; } }", "nl": "Consults an input stream reading first order logic clauses from it and inserting them into the resolvers knowledge base ."}}
{"translation": {"code": "private void setBasicType ( Class c ) { if ( Boolean . class . equals ( c ) ) { type = BasicTypes . BOOLEAN ; } else if ( Character . class . equals ( c ) ) { type = BasicTypes . CHARACTER ; } else if ( Byte . class . equals ( c ) ) { type = BasicTypes . BYTE ; } else if ( Short . class . equals ( c ) ) { type = BasicTypes . SHORT ; } else if ( Integer . class . equals ( c ) ) { type = BasicTypes . INTEGER ; } else if ( Long . class . equals ( c ) ) { type = BasicTypes . LONG ; } else if ( Float . class . equals ( c ) ) { type = BasicTypes . FLOAT ; } else if ( Double . class . equals ( c ) ) { type = BasicTypes . DOUBLE ; } else { type = BasicTypes . OTHER ; } }", "nl": "Sets the basic type of this type depending on the class ."}}
{"translation": {"code": "public void emmitCode ( ByteBuffer codeBuffer , WAMMachine machine ) throws LinkageException { mnemonic . emmitCode ( this , codeBuffer , machine ) ; }", "nl": "Writes out the instruction plus arguments in the byte code format to the specified location within a code buffer ."}}
{"translation": {"code": "protected String toStringArguments ( ) { String result = \"\" ; if ( arity > 0 ) { result += \"[ \" ; for ( int i = 0 ; i < arity ; i ++ ) { Term nextArg = arguments [ i ] ; result += ( ( nextArg != null ) ? nextArg . toString ( ) : \"<null>\" ) + ( ( i < ( arity - 1 ) ) ? \", \" : \" \" ) ; } result += \" ]\" ; } return result ; }", "nl": "Creates a string representation of this functors arguments mostly used for debugging purposes ."}}
{"translation": {"code": "public Iterator < Operator < Term > > getChildren ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof FunctorTraverser ) ) { return ( ( FunctorTraverser ) traverser ) . traverse ( this , reverse ) ; } else { if ( arguments == null ) { return new LinkedList < Operator < Term > > ( ) . iterator ( ) ; } else if ( ! reverse ) { return Arrays . asList ( ( Operator < Term > [ ] ) arguments ) . iterator ( ) ; } else { List < Operator < Term >> argList = new LinkedList < Operator < Term > > ( ) ; for ( int i = arity - 1 ; i >= 0 ; i -- ) { argList . add ( arguments [ i ] ) ; } return argList . iterator ( ) ; } } }", "nl": "Provides an iterator over the child terms if there are any . Only functors are compound and built across a list of child arguments ."}}
{"translation": {"code": "public Term getArgument ( int index ) { if ( ( arguments == null ) || ( index > ( arguments . length - 1 ) ) ) { return null ; } else { return arguments [ index ] ; } }", "nl": "Gets the argument within the functor with the specified index ."}}
{"translation": {"code": "public Iterator < Operator < Term > > getChildren ( boolean reverse ) { if ( ( traverser != null ) && ( traverser instanceof ClauseTraverser ) ) { return ( ( ClauseTraverser ) traverser ) . traverse ( this , reverse ) ; } else { LinkedList < Operator < Term >> resultList = null ; if ( ! reverse ) { resultList = new LinkedList < Operator < Term > > ( ) ; } else { resultList = new StackQueue < Operator < Term > > ( ) ; } if ( head != null ) { resultList . add ( head ) ; } if ( body != null ) { for ( Term bodyTerm : body ) { resultList . add ( bodyTerm ) ; } } return resultList . iterator ( ) ; } }", "nl": "Provides an iterator over the child terms if there are any . Only functors and clauses are compound and build across a list of child arguments ."}}
{"translation": {"code": "public static Source getTokenSourceForInputStream ( InputStream in ) { SimpleCharStream inputStream = new SimpleCharStream ( in , 1 , 1 ) ; PrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; return new TokenSource ( tokenManager ) ; }", "nl": "Creates a token source on an input stream ."}}
{"translation": {"code": "public static TokenSource getTokenSourceForFile ( File file ) throws FileNotFoundException { // Create a token source to load the model rules from. Reader ins = new FileReader ( file ) ; SimpleCharStream inputStream = new SimpleCharStream ( ins , 1 , 1 ) ; PrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; return new TokenSource ( tokenManager ) ; }", "nl": "Creates a token source on a file ."}}
{"translation": {"code": "private static < T > void findAll ( Collection < T > result , SearchMethod < T > method ) { for ( Iterator < T > i = allSolutions ( method ) ; i . hasNext ( ) ; ) { T nextSoltn = i . next ( ) ; result . add ( nextSoltn ) ; } }", "nl": "Finals all solutions to a search and inserts them into the specified collection ."}}
{"translation": {"code": "public static TokenSource getTokenSourceForString ( String stringToTokenize ) { SimpleCharStream inputStream = new SimpleCharStream ( new StringReader ( stringToTokenize ) , 1 , 1 ) ; PrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; return new TokenSource ( tokenManager ) ; }", "nl": "Creates a token source on a string ."}}
{"translation": {"code": "public static boolean isTime ( String s ) { // Build a time formatter using the format specified by timeFormat DateFormat dateFormatter = new SimpleDateFormat ( timeFormat ) ; try { dateFormatter . parse ( s ) ; return true ; } catch ( ParseException e ) { // Exception noted so can be ignored. e = null ; return false ; } }", "nl": "Checks that a string is a time in the format specified by timeFormat ."}}
{"translation": {"code": "public static boolean isDate ( String s ) { // Build a date formatter using the format specified by dateFormat DateFormat dateFormatter = new SimpleDateFormat ( dateFormat ) ; try { dateFormatter . parse ( s ) ; return true ; } catch ( ParseException e ) { // Exception noted so can be ignored. e = null ; return false ; } }", "nl": "Check that a string is a date in the format specified by dateFormat ."}}
{"translation": {"code": "public static Date toDate ( String s ) { // Build a date formatter using the format specified by dateFormat DateFormat dateFormatter = new SimpleDateFormat ( dateFormat ) ; try { return dateFormatter . parse ( s ) ; } catch ( ParseException e ) { // Exception noted so can be ignored. e = null ; return null ; } }", "nl": "Converts a string to a date . The string must be a date in the correct format or this method will return null ."}}
{"translation": {"code": "public static int toInteger ( String s ) { try { return Integer . parseInt ( s ) ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; return 0 ; } }", "nl": "Converts a string to an integer . The string must be a valid integer or the result will be zero ."}}
{"translation": {"code": "public E pop ( ) { E ob ; if ( size ( ) == 0 ) { return null ; } ob = get ( 0 ) ; remove ( 0 ) ; return ob ; }", "nl": "Pops the first object placed on the stack off of it and returns it ."}}
{"translation": {"code": "public void put ( Class cls , String property , Object value ) { // Store the new data under the specified property name. values . put ( property , value ) ; }", "nl": "Places the specified value into the memento based on the property s declaring class and name ."}}
{"translation": {"code": "public void put ( Class cls , String property , TypeConverter . MultiTypeData value ) { /*log.fine(\"public void put(String property, TypeConverter.MultiTypeData value): called\");*/ /*log.fine(\"property  = \" + property);*/ /*log.fine(\"value = \" + value);*/ // Store the multi typed data under the specified property name. values . put ( property , value ) ; }", "nl": "Sets the value of the named property as a multi type object ."}}
{"translation": {"code": "public Object get ( Class cls , String property ) throws NoSuchFieldException { // Check that the field exists. if ( ! values . containsKey ( property ) ) { throw new NoSuchFieldException ( \"The property, \" + property + \", does not exist on the underlying class.\" ) ; } // Try to find a matching property cached in this memento. return values . get ( property ) ; }", "nl": "Gets the value of the named property of the specified class ."}}
{"translation": {"code": "public static void restoreValues ( Object ob , Map < String , Object > values ) throws NoSuchFieldException { /*log.fine(\"public void restore(Object ob): called\");*/ /*log.fine(\"Object to restore to has the type: \" + ob.getClass());*/ // Get the class of th object to restore to. Class obClass = ob . getClass ( ) ; // Loop over all the stored properties. for ( String propName : values . keySet ( ) ) { // Get the cached property from this mementos store. Object nextValue = values . get ( propName ) ; /*log.fine(\"Next property to restore is: \" + propName);*/ /*log.fine(\"Next value to restore is: \" + nextValue);*/ // Used to hold the value to set. Object paramValue ; // Used to hold the type of the value to set. Class paramType ; // Check if the value store is a null. if ( nextValue == null ) { paramValue = null ; paramType = null ; } // Check if the value to store is a multi type data object. else if ( nextValue instanceof TypeConverter . MultiTypeData ) { /*log.fine(\"The value to restore is a multi typed data object.\");*/ TypeConverter . MultiTypeData multiValue = ( TypeConverter . MultiTypeData ) nextValue ; // Get the types (classes) of all the possible 'setter' methods for the property. Set < Class > setterTypes = ReflectionUtils . findMatchingSetters ( ob . getClass ( ) , propName ) ; /*log.fine(\"setterTypes = \" + setterTypes);*/ // Use the type converter to get the best matching type with the multi data. paramType = TypeConverter . bestMatchingConversion ( multiValue , setterTypes ) ; // Convert the multi data to an object of the appropriate type. paramValue = TypeConverter . convert ( multiValue , paramType ) ; } // The value to store is not a multi type. else { /*log.fine(\"The value to restore is a simply typed data object.\");*/ // Get the type and value of the plain type to set. paramValue = nextValue ; paramType = nextValue . getClass ( ) ; } /*log.fine(\"paramValue = \" + paramValue);*/ /*log.fine(\"paramType = \" + paramType);*/ // Call the setter method with the new property value, checking first that the property has a matching // 'setter' method. Method setterMethod ; try { // Convert the first letter of the property name to upper case to match against the upper case version // of it that will be in the setter method name. For example the property test will have a setter method // called setTest. String upperPropertyName = Character . toUpperCase ( propName . charAt ( 0 ) ) + propName . substring ( 1 ) ; // Try to find an appropriate setter method on the object to call. setterMethod = obClass . getMethod ( \"set\" + upperPropertyName , paramType ) ; // Call the setter method with the new property value. Object [ ] params = new Object [ ] { paramValue } ; setterMethod . invoke ( ob , params ) ; } catch ( NoSuchMethodException e ) { // Do nothing as properties may have getters but no setter for read only properties. /*log.log(java.util.logging.Level.FINE, \"A setter method could not be found for \" + propName + \".\", e);*/ /*\n                // The object does not have a matching setter method for the type.\n                NoSuchFieldException nsfe = new NoSuchFieldException(\"The object does not have a matching setter \" +\n                                                                     \"method 'set\" + propName + \"'.\");\n                nsfe.initCause(e);\n                throw nsfe;\n                */ } catch ( IllegalAccessException e ) { /*log.log(java.util.logging.Level.FINE, \"IllegalAccessException during call to setter method.\", e);*/ } catch ( InvocationTargetException e ) { /*log.log(java.util.logging.Level.FINE, \"InvocationTargetException during call to setter method.\", e);*/ } } }", "nl": "Restores the properties currently in this memento to the specified object ."}}
{"translation": {"code": "public static boolean isDateTime ( String s ) { DateFormat dateFormatter = new SimpleDateFormat ( dateTimeFormat ) ; try { dateFormatter . parse ( s ) ; return true ; } catch ( ParseException e ) { // Exception noted so can be ignored. e = null ; return false ; } }", "nl": "Checks that a string is a datetime in the format specified by dateTimeFormat ."}}
{"translation": {"code": "public long getId ( ) { // Check if the attribute class has been finalized yet. if ( attributeClass . finalized ) { // Fetch the object value from the attribute class array of finalized values. return attributeClass . lookupValue [ value ] . id ; } // The attribute class has not been finalized yet. else { // Fetch the object value from the attribute class list of unfinalized values. return attributeClass . lookupValueList . get ( value ) . id ; } }", "nl": "Returns the integer id of the attribute ."}}
{"translation": {"code": "private static EightPuzzleState charListToState ( List < Character > charList ) { // Create a new empty puzzle state EightPuzzleState newState = new EightPuzzleState ( ) ; // Loop over the board inserting the characters into it from the character list Iterator < Character > k = charList . iterator ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { char nextChar = k . next ( ) ; // Check if this is the empty tile and if so then take note of its position if ( nextChar == ' ' ) { newState . emptyX = i ; newState . emptyY = j ; } newState . board [ j ] [ i ] = nextChar ; } } return newState ; }", "nl": "Turns a list of characters representation of the board into a proper state ."}}
{"translation": {"code": "protected boolean swapTiles ( int x1 , int y1 , int x2 , int y2 ) { // Used to indicate that one of the swapped tiles was the empty tile boolean swappedEmpty = false ; // Get the tile at the first position char tile1 = board [ y1 ] [ x1 ] ; // Store the tile from the second position at the first position char tile2 = board [ y2 ] [ x2 ] ; board [ y1 ] [ x1 ] = tile2 ; // Store the first tile in the second position board [ y2 ] [ x2 ] = tile1 ; // Check if the first tile was the empty tile and update the empty tile coordinates if so if ( tile1 == ' ' ) { emptyX = x2 ; emptyY = y2 ; swappedEmpty = true ; } // Else check if the second tile was the empty tile and update the empty tile coordinates if so else if ( tile2 == ' ' ) { emptyX = x1 ; emptyY = y1 ; swappedEmpty = true ; } return ! swappedEmpty ; }", "nl": "Swaps the two tiles at the specified coordinates . One of the tiles may be the empty tile and the empty tile position will be correctly updated . If neither of the tiles is empty then this is an illegal swap in which case the method returns true ."}}
{"translation": {"code": "public String getErrors ( ) { // Return the empty string if there are no errors. if ( parsingErrors . isEmpty ( ) ) { return \"\" ; } // Concatenate all the parsing errors together. String result = \"\" ; for ( String s : parsingErrors ) { result += s ; } return result ; }", "nl": "Lists all the parsing errors from the most recent parsing in a string ."}}
{"translation": {"code": "public static String rightPad ( String stringToPad , String padder , int size ) { if ( padder . length ( ) == 0 ) { return stringToPad ; } StringBuffer strb = new StringBuffer ( stringToPad ) ; CharacterIterator sci = new StringCharacterIterator ( padder ) ; while ( strb . length ( ) < size ) { for ( char ch = sci . first ( ) ; ch != CharacterIterator . DONE ; ch = sci . next ( ) ) { if ( strb . length ( ) < size ) { strb . append ( String . valueOf ( ch ) ) ; } } } return strb . toString ( ) ; }", "nl": "Right pads a string with a given string to a given size . This method will repeat the padder string as many times as is necessary until the exact specified size is reached . If the specified size is less than the size of the original string then the original string is returned unchanged ."}}
{"translation": {"code": "public SearchNode < O , T > makeNode ( Successor successor ) throws SearchNotExhaustiveException { SearchNode newNode ; try { // Create a new instance of this class newNode = getClass ( ) . newInstance ( ) ; // Set the state, operation, parent, depth and cost for the new search node newNode . state = successor . getState ( ) ; newNode . parent = this ; newNode . appliedOp = successor . getOperator ( ) ; newNode . depth = depth + 1 ; newNode . pathCost = pathCost + successor . getCost ( ) ; // Check if there is a repeated state filter and copy the reference to it into the new node if so if ( repeatedStateFilter != null ) { newNode . setRepeatedStateFilter ( repeatedStateFilter ) ; } return newNode ; } catch ( InstantiationException e ) { // In practice this should never happen but may if the nodes if some class loader error were to occur whilst // using a custom node implementation. Rethrow this as a RuntimeException. throw new IllegalStateException ( \"InstantiationException during creation of new search node.\" , e ) ; } catch ( IllegalAccessException e ) { // In practice this should never happen but may if the nodes to use are not public whilst using a custom node // implementation. Rethrow this as a RuntimeException. throw new IllegalStateException ( \"IllegalAccessException during creation of new search node.\" , e ) ; } }", "nl": "Makes a new node of the same type as this one from a Successor state ."}}
{"translation": {"code": "protected static OpSymbol checkAndResolveToFixity ( CandidateOpSymbol candidate , OpSymbol . Fixity ... fixities ) throws SourceCodeException { OpSymbol result = null ; for ( OpSymbol . Fixity fixity : fixities ) { result = candidate . getPossibleOperators ( ) . get ( fixity ) ; if ( result != null ) { break ; } } if ( result == null ) { throw new SourceCodeException ( \"Operator \" + candidate + \" must be one of \" + Arrays . toString ( fixities ) + \", but does not have the required form.\" , null , null , null , candidate . getSourceCodePosition ( ) ) ; } return result ; }", "nl": "Checks if a candidate operator symbol can have one of the specified fixities and resolve it to an oeprator with that fixity if so . If it cannot be resolved an exception is raised ."}}
{"translation": {"code": "public EnumMap < OpSymbol . Fixity , OpSymbol > getOperatorsMatchingNameByFixity ( String name ) { return operators . get ( name ) ; }", "nl": "Checks the operator table for all possible operators matching a given name ."}}
{"translation": {"code": "public Term parseOperators ( Term [ ] terms ) throws SourceCodeException { // Initialize the parsers state. stack . offer ( 0 ) ; state = 0 ; position = 0 ; nextTerm = null ; // Consume the terms from left to right. for ( position = 0 ; position <= terms . length ; ) { Symbol nextSymbol ; // Decide what the next symbol to parse is; candidate op, term or final. if ( position < terms . length ) { nextTerm = terms [ position ] ; if ( nextTerm instanceof CandidateOpSymbol ) { nextSymbol = Symbol . Op ; } else { nextSymbol = Symbol . Term ; } } else { nextSymbol = Symbol . Final ; } // Look in the action table to find the action associated with the current symbol and state. Action action = actionTable [ state ] [ nextSymbol . ordinal ( ) ] ; // Apply the action. action . apply ( ) ; } return ( Functor ) outputStack . poll ( ) ; }", "nl": "Parses a flat list of terms which are literals variables functors or operators into a tree in such a way that the operators associativity and precendence is obeyed ."}}
{"translation": {"code": "public int compare ( SearchNode object1 , SearchNode object2 ) { float cost1 = object1 . getPathCost ( ) ; float cost2 = object2 . getPathCost ( ) ; return ( cost1 > cost2 ) ? 1 : ( ( cost1 < cost2 ) ? - 1 : 0 ) ; }", "nl": "Compares two search nodes by their path cost ."}}
{"translation": {"code": "private void expand ( int key ) { // Set the new size to whichever is the larger of 1.5 times the old size, or an array large enough to hold // the proposed key that caused the expansion. int newFactorSize = ( ( length * 3 ) / 2 ) + 1 ; int newSpaceSize = spaceRequired ( key ) ; int newSize = ( newSpaceSize > newFactorSize ) ? newSpaceSize : newFactorSize ; Object [ ] oldData = data ; data = new Object [ newSize ] ; // The valid data in the old array runs from offset(start) to offset(end) when offset(start) < offset(end), and // from offset(start) to length - 1 and 0 to offset(end) when offset(start) >= offset(end). int offsetStart = offset ( start ) ; int offsetEnd = offset ( end ) ; if ( offsetStart < offsetEnd ) { System . arraycopy ( oldData , offsetStart , data , 0 , end - start ) ; } else { System . arraycopy ( oldData , offsetStart , data , 0 , length - offsetStart ) ; System . arraycopy ( oldData , 0 , data , length - offsetStart , offsetEnd ) ; } offset = - start ; length = newSize ; }", "nl": "Expands the size of the storage to whichever is the larger of 1 . 5 times the old size or an array large enough to hold the proposed key that caused the expansion copying the old data into a new array ."}}
{"translation": {"code": "public void clearUpTo ( int key ) { if ( ( ( start <= key ) && ( key < ( end - 1 ) ) ) ) { // Loop from the start of the data, up to the key to clear up to, clearing all data encountered in-between. int newStart ; for ( newStart = start ; ( newStart <= end ) && ( newStart <= key ) ; newStart ++ ) { int offset = offset ( newStart ) ; if ( data [ offset ] != null ) { data [ offset ] = null ; count -- ; } } // Continue on after the clear up to point, until the first non-null entry or end of array is encountered, // and make that the new start. for ( ; newStart <= end ; newStart ++ ) { if ( data [ offset ( newStart ) ] != null ) { break ; } } start = newStart ; } else { // The key does not lie between the start and end markers, so clear the entire map up to the end int newStart ; for ( newStart = start ; ( newStart <= end ) ; newStart ++ ) { int offset = offset ( newStart ) ; if ( data [ offset ] != null ) { data [ offset ] = null ; count -- ; } } start = newStart ; offset = - start ; } }", "nl": "Clears entries up to and including the specified key from the map . This is a simple garbage collection operation to clear consumed data from the circular buffer ."}}
{"translation": {"code": "public String getOptionsInForce ( ) { // Check if there are no properties to report and return and empty string if so. if ( parsedProperties == null ) { return \"\" ; } // List all the properties. String result = \"Options in force:\\n\" ; for ( Map . Entry < Object , Object > property : parsedProperties . entrySet ( ) ) { result += property . getKey ( ) + \" = \" + property . getValue ( ) + \"\\n\" ; } return result ; }", "nl": "Lists the properties set from the most recent parsing or an empty string if no parsing has been done yet ."}}
{"translation": {"code": "public static Object convert ( MultiTypeData d , Class c ) { // Check if it is an boolean convertion. if ( ( ( d . typeFlags & BOOLEAN ) != 0 ) && ( Boolean . TYPE . equals ( c ) || Boolean . class . equals ( c ) ) ) { return d . booleanValue ; } // Check if it is an int convertion. else if ( ( ( d . typeFlags & INT ) != 0 ) && ( Integer . TYPE . equals ( c ) || Integer . class . equals ( c ) ) ) { return d . intValue ; } // Check if it is an char convertion. else if ( ( ( d . typeFlags & CHAR ) != 0 ) && ( Character . TYPE . equals ( c ) || Character . class . equals ( c ) ) ) { return d . charValue ; } // Check if it is an byte convertion. else if ( ( ( d . typeFlags & BYTE ) != 0 ) && ( Byte . TYPE . equals ( c ) || Byte . class . equals ( c ) ) ) { return d . byteValue ; } // Check if it is an short convertion. else if ( ( ( d . typeFlags & SHORT ) != 0 ) && ( Short . TYPE . equals ( c ) || Short . class . equals ( c ) ) ) { return d . shortValue ; } // Check if it is an long convertion. else if ( ( ( d . typeFlags & LONG ) != 0 ) && ( Long . TYPE . equals ( c ) || Long . class . equals ( c ) ) ) { return d . longValue ; } // Check if it is an float convertion. else if ( ( ( d . typeFlags & FLOAT ) != 0 ) && ( Float . TYPE . equals ( c ) || Float . class . equals ( c ) ) ) { return d . floatValue ; } // Check if it is an double convertion. else if ( ( ( d . typeFlags & DOUBLE ) != 0 ) && ( Double . TYPE . equals ( c ) || Double . class . equals ( c ) ) ) { return d . doubleValue ; } // Check if it is a string convertion. else if ( ( ( d . typeFlags & STRING ) != 0 ) && String . class . equals ( c ) ) { return d . stringValue ; } // Check if it is an object convertion and th object types match. else if ( ( ( d . typeFlags & OBJECT ) != 0 ) && d . objectValue . getClass ( ) . equals ( c ) ) { return d . objectValue ; } // Throw a class cast exception if the multi data type cannot be converted to the specified class. else { throw new ClassCastException ( \"The multi data type, \" + d + \", cannot be converted to the class, \" + c + \".\" ) ; } }", "nl": "Given a multi type data object and a class representing a type this method attemps to return an object of that class created from the multi type data . The exception to this rule is if the specified data type is a primtive type such as int . clas then the returned object will be of the equivalent wrapper class type Integer . class in this case . This is because a primitive cannot be returned under an Object return type ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( String s ) { MultiTypeData result = new MultiTypeData ( ) ; // Start by assuming that the String can only be converted to a String. result . typeFlags = STRING ; result . stringValue = s ; // Assume that the native type is String. It is up to methods that call this one to override this if this is // not the case. result . nativeType = STRING ; // Check if the string can be converted to a boolean. if ( \"true\" . equals ( s ) ) { result . booleanValue = true ; result . typeFlags |= BOOLEAN ; } else if ( \"false\" . equals ( s ) ) { result . booleanValue = false ; result . typeFlags |= BOOLEAN ; } // Check if the string can be converted to an int. try { result . intValue = Integer . parseInt ( s ) ; result . typeFlags |= INT ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags &= ( Integer . MAX_VALUE - INT ) ; } // Check if the string can be converted to a byte. try { result . byteValue = Byte . parseByte ( s ) ; result . typeFlags |= BYTE ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags = ( Integer . MAX_VALUE - BYTE ) ; } // Check if the string can be converted to a char. if ( s . length ( ) == 1 ) { result . charValue = s . charAt ( 0 ) ; result . typeFlags |= CHAR ; } // Check if the string can be converted to a short. try { result . shortValue = Short . parseShort ( s ) ; result . typeFlags |= SHORT ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags = ( Integer . MAX_VALUE - SHORT ) ; } // Check if the string can be converted to a long. try { result . longValue = Long . parseLong ( s ) ; result . typeFlags |= LONG ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags = ( Integer . MAX_VALUE - LONG ) ; } // Check if the string can be converted to a float. try { result . floatValue = Float . parseFloat ( s ) ; result . typeFlags |= FLOAT ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags = ( Integer . MAX_VALUE - FLOAT ) ; } // Check if the string can be converted to a double. try { result . doubleValue = Double . parseDouble ( s ) ; result . typeFlags |= DOUBLE ; } catch ( NumberFormatException e ) { // Exception noted so can be ignored. e = null ; result . typeFlags = ( Integer . MAX_VALUE - DOUBLE ) ; } // Assume the string can never be converted to an object. return result ; }", "nl": "Converts a String into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( double d ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Double . toString ( d ) ) ; result . nativeType = DOUBLE ; return result ; }", "nl": "Converts a double into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( float f ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Float . toString ( f ) ) ; result . nativeType = FLOAT ; return result ; }", "nl": "Converts a float into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( long l ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Long . toString ( l ) ) ; result . nativeType = LONG ; return result ; }", "nl": "Converts a long into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( int i ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Integer . toString ( i ) ) ; result . nativeType = INT ; return result ; }", "nl": "Converts a int into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( short s ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Short . toString ( s ) ) ; result . nativeType = SHORT ; return result ; }", "nl": "Converts a short into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( char c ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Character . toString ( c ) ) ; result . nativeType = CHAR ; return result ; }", "nl": "Converts a char into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( byte b ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Byte . toString ( b ) ) ; result . nativeType = BYTE ; return result ; }", "nl": "Converts a byte into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( boolean b ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( Boolean . toString ( b ) ) ; result . nativeType = BOOLEAN ; return result ; }", "nl": "Converts a boolean into a multi type data object ."}}
{"translation": {"code": "public static MultiTypeData getMultiTypeData ( Object o ) { // Convert the value to a String and return the set of types that that String can be converted to. MultiTypeData result = getMultiTypeData ( o . toString ( ) ) ; result . nativeType = OBJECT ; return result ; }", "nl": "Converts a Object into a multi type data object ."}}
{"translation": {"code": "private static List < Character > stringToCharList ( String boardString ) { // Turn the goal state into a list of characters char [ ] chars = new char [ 9 ] ; boardString . getChars ( 0 , 9 , chars , 0 ) ; List < Character > charList = new ArrayList < Character > ( ) ; for ( int l = 0 ; l < 9 ; l ++ ) { charList . add ( chars [ l ] ) ; } return charList ; }", "nl": "Turns a string representation of the board into a list of characters ."}}
{"translation": {"code": "public String getUsage ( ) { String result = \"Options:\\n\" ; int optionWidth = 0 ; int argumentWidth = 0 ; // Calculate the column widths required for aligned layout. for ( CommandLineOption optionInfo : optionMap . values ( ) ) { int oWidth = optionInfo . option . length ( ) ; int aWidth = ( optionInfo . argument != null ) ? ( optionInfo . argument . length ( ) ) : 0 ; optionWidth = ( oWidth > optionWidth ) ? oWidth : optionWidth ; argumentWidth = ( aWidth > argumentWidth ) ? aWidth : argumentWidth ; } // Print usage on each of the command line options. for ( CommandLineOption optionInfo : optionMap . values ( ) ) { String argString = ( ( optionInfo . argument != null ) ? ( optionInfo . argument ) : \"\" ) ; String optionString = optionInfo . option ; argString = rightPad ( argString , \" \" , argumentWidth ) ; optionString = rightPad ( optionString , \" \" , optionWidth ) ; result += \"-\" + optionString + \" \" + argString + \" \" + optionInfo . comment + \"\\n\" ; } return result ; }", "nl": "Generates a usage string consisting of the name of each option and each options argument description and comment ."}}
{"translation": {"code": "public void addOptionsToProperties ( Properties properties ) { if ( parsedProperties != null ) { for ( Object propKey : parsedProperties . keySet ( ) ) { String name = ( String ) propKey ; String value = parsedProperties . getProperty ( name ) ; // This filters out all trailing items. if ( ! name . matches ( \"^[0-9]+$\" ) ) { properties . setProperty ( name , value ) ; } } } }", "nl": "If a command line has been parsed calling this method sets all of its options that were set to the specified properties ."}}
{"translation": {"code": "protected int swapTileToLocationCountingIllegal ( char t , int x , int y ) { // Used to hold the count of illegal swaps int illegal = 0 ; // Find out where the tile to move is int tileX = getXForTile ( t ) ; int tileY = getYForTile ( t ) ; // Shift the tile into the correct column by repeatedly moving it left or right. while ( tileX != x ) { if ( ( tileX - x ) > 0 ) { if ( swapTiles ( tileX , tileY , tileX - 1 , tileY ) ) { illegal ++ ; } tileX -- ; } else { if ( swapTiles ( tileX , tileY , tileX + 1 , tileY ) ) { illegal ++ ; } tileX ++ ; } } // Shift the tile into the correct row by repeatedly moving it up or down. while ( tileY != y ) { // Commented out because tiles never swap down the board during the solvability test because tiles are // swapped into place left to right, top to bottom. The top row is always filled first so tiles cannot be // swapped down into it. Then the next row is filled but ones from the row above are never swapped down // into it because they are alrady in place and never move again and so on. /* if (tileY - y > 0)\n             *{*/ if ( swapTiles ( tileX , tileY , tileX , tileY - 1 ) ) { illegal ++ ; } tileY -- ; /*}\n             * else { if (swapTiles(tileX, tileY, tileX, tileY + 1)) illegal++; tileY++;}*/ } return illegal ; }", "nl": "Repeatedly swaps a tile with its neighbours until it reaches the specified location . If the tile is swapped with the empty tile then this is a legal move . If the tile is swapped with another non - empty tile then this is an illegal move and the total number of illegal moves is counted ."}}
{"translation": {"code": "public String prettyPrint ( ) { String result = \"\" ; for ( int j = 0 ; j < 3 ; j ++ ) { result += new String ( board [ j ] ) + \"\\n\" ; } result = result . replace ( ' ' , ' ' ) ; return result ; }", "nl": "Pretty prints the board as 3 lines of characters with a space for the empty square ."}}
{"translation": {"code": "public Iterator < Operator < String > > validOperators ( boolean reverse ) { // Used to hold a list of valid moves List < Operator < String >> moves = new ArrayList < Operator < String > > ( 4 ) ; // Check if the up move is valid if ( emptyY != 0 ) { moves . add ( new OperatorImpl < String > ( \"U\" ) ) ; } // Check if the down move is valid if ( emptyY != 2 ) { moves . add ( new OperatorImpl < String > ( \"D\" ) ) ; } // Check if the left move is valid if ( emptyX != 0 ) { moves . add ( new OperatorImpl < String > ( \"L\" ) ) ; } // Check if the right move is valid if ( emptyX != 2 ) { moves . add ( new OperatorImpl < String > ( \"R\" ) ) ; } return moves . iterator ( ) ; }", "nl": "Supplies the valid moves for a board position ."}}
{"translation": {"code": "public EightPuzzleState getChildStateForOperator ( Operator op ) { // Create a copy of the existing board state EightPuzzleState newState ; try { newState = ( EightPuzzleState ) clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; } // Update the new board state using the in-place operator application newState . updateWithOperator ( op ) ; return newState ; }", "nl": "Applies a move to generate a new board position . This creates a new state object and updates its board position . The board position in this object is not changed ."}}
{"translation": {"code": "public static boolean isSolvable ( EightPuzzleState state ) { // Take a copy of the puzzle to check. This is done because this puzzle will be updated in-place and the // original is to be preserved. EightPuzzleState checkState ; try { checkState = ( EightPuzzleState ) state . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new IllegalStateException ( \"Puzzle state could not be cloned.\" , e ) ; } // Create the goal state to check against when swapping tiles into position. EightPuzzleState goalState = getGoalState ( ) ; // Count the number of illegal swaps needed to put the puzzle in order. int illegalSwaps = 0 ; // Loop over the whole board, left to right, to to bottom for ( int j = 0 ; j < 3 ; j ++ ) { for ( int i = 0 ; i < 3 ; i ++ ) { // Find out from the goal state what tile should be at this position. char t = goalState . getTileAt ( i , j ) ; // Swap the tile into its goal position keeping count of the total number of illegal swaps. illegalSwaps += checkState . swapTileToLocationCountingIllegal ( t , i , j ) ; } } // Check if the number of illegal swaps is even in which case the puzzle is solvable, or odd in which case it // is not solvable. return ( illegalSwaps % 2 ) == 0 ; }", "nl": "To check for solvability the empty tile is moved to its goal position and then the number of swaps needed to put the other tiles in position is counted . For an odd number of rows on a square puzzle there must be an even number of swaps for an even number of rows an odd number of swaps ."}}
{"translation": {"code": "public static EightPuzzleState getRandomStartState ( ) { EightPuzzleState newState ; // Turn the goal string into a list of characters. List < Character > charList = stringToCharList ( GOAL_STRING ) ; // Generate random puzzles until a solvable one is found. do { // Shuffle the list. Collections . shuffle ( charList ) ; // Turn the shuffled list into a proper eight puzzle state object. newState = charListToState ( charList ) ; // Check that the puzzle is solvable and if not then repeat the shuffling process. } while ( ! isSolvable ( newState ) ) ; return newState ; }", "nl": "Generates a random starting position ."}}
{"translation": {"code": "private String printSlot ( int xi , int mode ) { return ( ( mode == STACK_ADDR ) ? \"Y\" : \"X\" ) + ( ( mode == STACK_ADDR ) ? ( xi - ep - 3 ) : xi ) ; }", "nl": "Pretty prints a variable allocation slot for tracing purposes ."}}
{"translation": {"code": "private boolean unify ( int a1 , int a2 ) { // pdl.push(a1) // pdl.push(a2) uPush ( a1 ) ; uPush ( a2 ) ; // fail <- false boolean fail = false ; // while !empty(PDL) and not failed while ( ! uEmpty ( ) && ! fail ) { // d1 <- deref(pdl.pop()) // d2 <- deref(pdl.pop()) // t1, v1 <- STORE[d1] // t2, v2 <- STORE[d2] int d1 = deref ( uPop ( ) ) ; int t1 = derefTag ; int v1 = derefVal ; int d2 = deref ( uPop ( ) ) ; int t2 = derefTag ; int v2 = derefVal ; // if (d1 != d2) if ( d1 != d2 ) { // if (t1 = REF or t2 = REF) // bind(d1, d2) if ( ( t1 == WAMInstruction . REF ) ) { bind ( d1 , d2 ) ; } else if ( t2 == WAMInstruction . REF ) { bind ( d1 , d2 ) ; } else if ( t2 == WAMInstruction . STR ) { // f1/n1 <- STORE[v1] // f2/n2 <- STORE[v2] int fn1 = data . get ( v1 ) ; int fn2 = data . get ( v2 ) ; byte n1 = ( byte ) ( fn1 >>> 24 ) ; // if f1 = f2 and n1 = n2 if ( fn1 == fn2 ) { // for i <- 1 to n1 for ( int i = 1 ; i <= n1 ; i ++ ) { // pdl.push(v1 + i) // pdl.push(v2 + i) uPush ( v1 + i ) ; uPush ( v2 + i ) ; } } else { // fail <- true fail = true ; } } else if ( t2 == WAMInstruction . CON ) { if ( ( t1 != WAMInstruction . CON ) || ( v1 != v2 ) ) { fail = true ; } } else if ( t2 == WAMInstruction . LIS ) { if ( t1 != WAMInstruction . LIS ) { fail = true ; } else { uPush ( v1 ) ; uPush ( v2 ) ; uPush ( v1 + 1 ) ; uPush ( v2 + 1 ) ; } } } } return ! fail ; }", "nl": "Attempts to unify structures or references on the heap given two references to them . Structures are matched element by element free references become bound ."}}
{"translation": {"code": "private void unwindTrail ( int a1 , int a2 ) { // for i <- a1 to a2 - 1 do for ( int addr = a1 ; addr < a2 ; addr ++ ) { //  STORE[TRAIL[i]] <- <REF, TRAIL[i]> int tmp = data . get ( addr ) ; data . put ( tmp , refTo ( tmp ) ) ; } }", "nl": "Undoes variable bindings that have been recorded on the trail . Addresses recorded on the trail are reset to REF to self ."}}
{"translation": {"code": "public void addTrailingPairsToProperties ( Properties properties ) { if ( trailingProperties != null ) { for ( Object propKey : trailingProperties . keySet ( ) ) { String name = ( String ) propKey ; String value = trailingProperties . getProperty ( name ) ; properties . setProperty ( name , value ) ; } } }", "nl": "If a command line has been parsed calling this method sets all of its free arguments that were name = value pairs on the specified properties ."}}
{"translation": {"code": "private void trail ( int addr ) { // if (a < HB) \\/ ((H < a) /\\ (a < B)) if ( ( addr < hbp ) || ( ( hp < addr ) && ( addr < bp ) ) ) { //  TRAIL[TR] <- a data . put ( trp , addr ) ; //  TR <- TR + 1 trp ++ ; } }", "nl": "Records the address of a binding onto the trail . The trail pointer is advanced by one as part of this operation ."}}
{"translation": {"code": "private int nextStackFrame ( ) { // if E > B // then newB <- E + STACK[E + 2] + 3 // else newB <- B + STACK[B] + 7 if ( ep == bp ) { return STACK_BASE ; } else if ( ep > bp ) { return ep + data . get ( ep + 2 ) + 3 ; } else { return bp + data . get ( bp ) + 8 ; } }", "nl": "Computes the start of the next stack frame . This depends on whether the most recent stack frame is an environment frame or a choice point frame as these have different sizes . The size of the most recent type of frame is computed and added to the current frame pointer to give the start of the next frame ."}}
{"translation": {"code": "protected String traceChoiceFrame ( ) { if ( bp == 0 ) { return \"\" ; } int n = data . get ( bp ) ; return \"choice: [ n = \" + data . get ( bp ) + \", ep = \" + data . get ( bp + n + 1 ) + \", cp = \" + data . get ( bp + n + 2 ) + \", bp = \" + data . get ( bp + n + 3 ) + \", l = \" + data . get ( bp + n + 4 ) + \", trp = \" + data . get ( bp + n + 5 ) + \", hp = \" + data . get ( bp + n + 6 ) + \", b0 = \" + data . get ( bp + n + 7 ) ; }", "nl": "Pretty prints the current choice point frame for debugging purposes ."}}
{"translation": {"code": "protected String traceEnvFrame ( ) { return \"env: [ ep = \" + data . get ( ep ) + \", cp = \" + data . get ( ep + 1 ) + \", n = \" + data . get ( ep + 2 ) + \"]\" ; }", "nl": "Pretty prints the current environment frame for debugging purposes ."}}
{"translation": {"code": "public void reset ( ) { // Create fresh heaps, code areas and stacks. data = ByteBuffer . allocateDirect ( TOP << 2 ) . order ( ByteOrder . LITTLE_ENDIAN ) . asIntBuffer ( ) ; codeBuffer = ByteBuffer . allocateDirect ( CODE_SIZE ) ; codeBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; // Registers are on the top of the data area, the heap comes next. hp = HEAP_BASE ; hbp = HEAP_BASE ; sp = HEAP_BASE ; // The stack comes after the heap. Pointers are zero initially, since no stack frames exist yet. ep = 0 ; bp = 0 ; b0 = 0 ; // The trail comes after the stack. trp = TRAIL_BASE ; // The unification stack (PDL) is a push down stack at the end of the data area. up = TOP ; // Turn off write mode. writeMode = false ; // Reset the instruction pointer to that start of the code area, ready for fresh code to be loaded there. ip = 0 ; // Could probably not bother resetting these, but will do it anyway just to be sure. derefTag = 0 ; derefVal = 0 ; // The machine is initially not suspended. suspended = false ; // Ensure that the overridden reset method of WAMBaseMachine is run too, to clear the call table. super . reset ( ) ; // Put the internal functions in the call table. setInternalCodeAddress ( internFunctorName ( \"call\" , 1 ) , CALL_1_ID ) ; setInternalCodeAddress ( internFunctorName ( \"execute\" , 1 ) , EXECUTE_1_ID ) ; // Notify any debug monitor that the machine has been reset. if ( monitor != null ) { monitor . onReset ( this ) ; } }", "nl": "Resets the machine to its initial state . This clears any programs from the machine and clears all of its stacks and heaps ."}}
{"translation": {"code": "public static Type createInstance ( String name , float min , float max ) { // Ensure that min is less than or equal to max. if ( min > max ) { throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; } synchronized ( FLOAT_RANGE_TYPES ) { // Add the newly created type to the map of all types. FloatRangeType newType = new FloatRangeType ( name , min , max ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. FloatRangeType oldType = FLOAT_RANGE_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { FLOAT_RANGE_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new float range type with the specified name if it does not already exist ."}}
{"translation": {"code": "public static < T , U > String compareIterators ( Iterator < U > iterator , Iterator < T > expectedIterator , Function < U , T > mapping ) { String errorMessage = \"\" ; while ( iterator . hasNext ( ) ) { U next = iterator . next ( ) ; T nextMapped = mapping . apply ( next ) ; T nextExpected = expectedIterator . next ( ) ; if ( ! nextMapped . equals ( nextExpected ) ) { errorMessage += \"Expecting \" + nextExpected + \" but got \" + nextMapped ; } } return errorMessage ; }", "nl": "Walks down two iterators comparing them element by element using the equals method ."}}
{"translation": {"code": "private void checkArgumentFormat ( CommandLineOption optionInfo , CharSequence matchedArg ) { // Check if this option enforces a format for its argument. if ( optionInfo . argumentFormatRegexp != null ) { Pattern pattern = Pattern . compile ( optionInfo . argumentFormatRegexp ) ; Matcher argumentMatcher = pattern . matcher ( matchedArg ) ; // Check if the argument does not meet its required format. if ( ! argumentMatcher . matches ( ) ) { // Create an error for this badly formed argument. parsingErrors . add ( \"The argument to option \" + optionInfo . option + \" does not meet its required format.\\n\" ) ; } } }", "nl": "Checks the format of an argument to an option against its specified regular expression format if one has been set . Any errors are added to the list of parsing errors ."}}
{"translation": {"code": "private Properties takeFreeArgsAsProperties ( Properties properties , int from ) { Properties result = new Properties ( ) ; for ( int i = from ; true ; i ++ ) { String nextFreeArg = properties . getProperty ( Integer . toString ( i ) ) ; // Terminate the loop once all free arguments have been consumed. if ( nextFreeArg == null ) { break ; } // Split it on the =, strip any whitespace and set it as a system property. String [ ] nameValuePair = nextFreeArg . split ( \"=\" ) ; if ( nameValuePair . length == 2 ) { result . setProperty ( nameValuePair [ 0 ] , nameValuePair [ 1 ] ) ; } } return result ; }", "nl": "Converts the free arguments into property declarations . After parsing the command line the free arguments are numbered from 1 such that the parsed properties contain values for the keys 1 2 ... This method converts any free arguments declared using the name = value syntax into properties with key name value value ."}}
{"translation": {"code": "protected void addOption ( String option , String comment , String argument , boolean mandatory , String formatRegexp ) { // Check if usage text has been set in which case this option is expecting arguments. boolean expectsArgs = ( ! ( ( argument == null ) || \"\" . equals ( argument ) ) ) ; // Add the option to the map of command line options. CommandLineOption opt = new CommandLineOption ( option , expectsArgs , comment , argument , mandatory , formatRegexp ) ; optionMap . put ( option , opt ) ; }", "nl": "Adds the option to list of available command line options ."}}
{"translation": {"code": "private boolean backtrack ( ) { // if B = bottom_of_stack if ( bp == 0 ) { //  then fail_and_exit_program return true ; } else { // B0 <- STACK[B + STACK[B} + 7] b0 = data . get ( bp + data . get ( bp ) + 7 ) ; // P <- STACK[B + STACK[B] + 4] ip = data . get ( bp + data . get ( bp ) + 4 ) ; return false ; } }", "nl": "Backtracks to the continuation label stored in the current choice point frame if there is one . Otherwise returns a fail to indicate that there are no more choice points so no backtracking can be done ."}}
{"translation": {"code": "public Iterator < Operator < Tree < E > > > validOperators ( boolean reverse ) { /*log.fine(\"public Iterator<Operator> validOperators(): called\");*/ // Check if the tree is a leaf and return an empty iterator if so. if ( tree . isLeaf ( ) ) { /*log.fine(\"is leaf\");*/ return new ArrayList < Operator < Tree < E > > > ( ) . iterator ( ) ; } // Generate an iterator over the child trees of the current node, encapsulating them as operators. else { /*log.fine(\"is node\");*/ Tree . Node < E > node = tree . getAsNode ( ) ; return new TreeSearchOperatorIterator < E > ( node . getChildIterator ( ) ) ; } }", "nl": "Gets all operators valid from this state . If the current tree to search has any children these are encoded as operators to access those child trees as tree search states . If the current tree is a leaf then an empty iterator is returned ."}}
{"translation": {"code": "public Iterable < Map < String , Variable > > expandResultSetToMap ( Iterator < Set < Variable > > solutions ) { return new Filterator < Set < Variable > , Map < String , Variable > > ( solutions , new Function < Set < Variable > , Map < String , Variable > > ( ) { public Map < String , Variable > apply ( Set < Variable > variables ) { Map < String , Variable > results = new HashMap < String , Variable > ( ) ; for ( Variable var : variables ) { String varName = getInterner ( ) . getVariableName ( var . getName ( ) ) ; results . put ( varName , var ) ; } return results ; } } ) ; }", "nl": "Transforms an iterator over sets of variable bindings resulting from a query to an iterator over a map from the string name of variables to their bindings for the same sequence of query solutions ."}}
{"translation": {"code": "public static void writeShortToByteArray ( byte [ ] buf , int offset , short value ) { buf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; buf [ offset ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; }", "nl": "Outputs a short into a byte array ."}}
{"translation": {"code": "public void setTexture ( Paint obj ) { if ( obj instanceof GradientPaint ) { texture = new GradientPaint ( 0 , 0 , Color . white , getSize ( ) . width * 2 , 0 , Color . green ) ; } else { texture = obj ; } }", "nl": "Sets the kind of paint to use . For the image background?"}}
{"translation": {"code": "public List < E > get ( int index ) { /*log.fine(\"public List<E> get(int index): called\");*/ // Check that the index is not to large. int originalSize = original . size ( ) ; int size = ( originalSize / pageSize ) + ( ( ( originalSize % pageSize ) == 0 ) ? 0 : 1 ) ; /*log.fine(\"originalSize = \" + originalSize);*/ /*log.fine(\"size = \" + size);*/ // Check if the size of the underlying list is zero, in which case return an empty list, so long as page zero // was requested. if ( ( index == 0 ) && ( originalSize == 0 ) ) { return new ArrayList < E > ( ) ; } // Check if the requested index exceeds the number of pages, or is an illegal negative value. if ( ( index >= size ) || ( index < 0 ) ) { /*log.fine(\"(index >= size) || (index < 0), throwing out of bounds exception.\");*/ throw new IndexOutOfBoundsException ( \"Index \" + index + \" is less than zero or more than the number of pages: \" + size ) ; } // Extract the appropriate sub-list. // Note that if this is the last page it may not be a full page. Just up to the last page will be returned. /*log.fine(\"Requesting sublist from, \" + (pageSize * index) + \", to ,\" +\n            (((pageSize * (index + 1)) >= originalSize) ? originalSize : (pageSize * (index + 1))) + \".\");*/ List < E > result = original . subList ( pageSize * index , ( ( pageSize * ( index + 1 ) ) >= originalSize ) ? originalSize : ( pageSize * ( index + 1 ) ) ) ; return result ; }", "nl": "Extracts the sub - list at the specified page index . The returned list will have size equal to the page size unless it is the last page in which case it may not be a full page ."}}
{"translation": {"code": "private String chooseBestPropertyToDecideOn ( String outputProperty , Iterable < State > examples , Iterable < String > inputProperties ) { /*log.fine(\"private String chooseBestPropertyToDecideOn(String outputProperty, Collection<State> examples, \" +\n         \"Collection<String> inputProperties): called\");*/ // for (State e : examples) /*log.fine(e);*/ // Determine how many possible values (symbols) the output property can have. int numOutputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( outputProperty ) . getNumPossibleValues ( ) ; // Used to hold the largest information gain found so far. double largestGain = 0.0d ; // Used to hold the input property that gives the largest gain found so far. String largestGainProperty = null ; // Loop over all the input properties. for ( String inputProperty : inputProperties ) { // let G = the set of goal property values. // let A = the set of property values that the input property can have. // Determine how many possible values (symbols) the input property can have. int numInputValues = examples . iterator ( ) . next ( ) . getComponentType ( ) . getPropertyType ( inputProperty ) . getNumPossibleValues ( ) ; // Create an array to hold the counts of the output symbols. int [ ] outputCounts = new int [ numOutputValues ] ; // Create arrays to hold the counts of the input symbols and the joint input/output counts. int [ ] inputCounts = new int [ numInputValues ] ; int [ ] [ ] jointCounts = new int [ numInputValues ] [ numOutputValues ] ; // Loop over all the examples. for ( State example : examples ) { // Extract the output property attribute value. OrdinalAttribute outputAttribute = ( OrdinalAttribute ) example . getProperty ( outputProperty ) ; // Extract the input property attribute value. OrdinalAttribute inputAttribute = ( OrdinalAttribute ) example . getProperty ( inputProperty ) ; // Increment the count for the occurence of this value of the output property. outputCounts [ outputAttribute . ordinal ( ) ] ++ ; // Increment the count for the occurence of this value of the input property. inputCounts [ inputAttribute . ordinal ( ) ] ++ ; // Increment the count for the joint occurrence of this input/output value pair. jointCounts [ inputAttribute . ordinal ( ) ] [ outputAttribute . ordinal ( ) ] ++ ; } // Calculate the estimated probability distribution of G from the occurrence counts over the examples. double [ ] pForG = InformationTheory . pForDistribution ( outputCounts ) ; // Calculate the estimated probability distribution of A from the occurrence counts over the examples. double [ ] pForA = InformationTheory . pForDistribution ( inputCounts ) ; // Calculate the estimated probability distribution p(g|a) from the joint occurrence counts over the // examples. double [ ] [ ] pForGGivenA = InformationTheory . pForJointDistribution ( jointCounts ) ; // Calculate the information gain on G by knowing A. double gain = InformationTheory . gain ( pForG , pForA , pForGGivenA ) ; // Check if the gain is larger than the best found so far and update the best if so. if ( gain > largestGain ) { largestGain = gain ; largestGainProperty = inputProperty ; } } return largestGainProperty ; }", "nl": "For a given set of examples input properties and an output property this method chooses the input property that provides the largest information gain on the value of the output property ."}}
{"translation": {"code": "private boolean allHaveSameClassification ( String property , Iterable < State > examples ) { // Used to hold the value of the first attribute seen. OrdinalAttribute firstAttribute = null ; // Flag used to indicate that the test passed successfully. boolean success = true ; // Loop over all the examples. for ( State example : examples ) { OrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; // If this is the first example just store its attribute value. if ( firstAttribute == null ) { firstAttribute = nextAttribute ; } // Otherwise check if the attribute value does not match the first one in which case the test fails. else if ( ! nextAttribute . equals ( firstAttribute ) ) { success = false ; break ; } } // If the test passed then store the matching classification that all the examples have in a memeber variable // from where it can be accessed. if ( success ) { allClassification = firstAttribute ; } return success ; }", "nl": "Tests if a property of a set of examples has the same value for all the examples . This algorithm works by iterating through the examples until two different values are found or the end of the collection is reached having found only one value ."}}
{"translation": {"code": "private OrdinalAttribute getMajorityClassification ( String property , Iterable < State > examples ) throws LearningFailureException { /*log.fine(\"private OrdinalAttribute getMajorityClassification(String property, Collection<State> examples): called\");*/ /*log.fine(\"property = \" + property);*/ // Flag used to indicate that the map to hold the value counts in has been initialized. Map < OrdinalAttribute , Integer > countMap = null ; // Used to hold the biggest count found so far. int biggestCount = 0 ; // Used to hold the value with the biggest count found so far. OrdinalAttribute biggestAttribute = null ; // Loop over all the examples counting the number of occurences of each possible classification by the // named property. for ( State example : examples ) { OrdinalAttribute nextAttribute = ( OrdinalAttribute ) example . getProperty ( property ) ; /*log.fine(\"nextAttribute = \" + nextAttribute);*/ // If this is the first attribute then find out how many possible values it can take on. if ( countMap == null ) { // A check has already been performed at the start of the learning method to ensure that the output // property only takes on a finite number of values. countMap = new HashMap < OrdinalAttribute , Integer > ( ) ; } int count ; // Increment the count for the number of occurences of this classification. if ( ! countMap . containsKey ( nextAttribute ) ) { count = 1 ; countMap . put ( nextAttribute , count ) ; } else { count = countMap . get ( nextAttribute ) ; countMap . put ( nextAttribute , count ++ ) ; } // Compare it to the biggest score found so far to see if it is bigger. if ( count > biggestCount ) { // Update the biggest score. biggestCount = count ; // Update the value of the majority classification. biggestAttribute = nextAttribute ; } } // Return the majority classification found. return biggestAttribute ; }", "nl": "This helper method works out how the majority of the specified examples are classified by the named property . The property should always be the goal property that the algorithm is learning and must always take on a finite number of different values ."}}
{"translation": {"code": "public String generateTraceIndent ( int delta ) { if ( ! useIndent ) { return \"\" ; } else { if ( delta >= 1 ) { indentStack . push ( delta ) ; } else if ( delta < 0 ) { indentStack . pop ( ) ; } StringBuffer result = new StringBuffer ( ) ; traceIndent += ( delta < 0 ) ? delta : 0 ; for ( int i = 0 ; i < traceIndent ; i ++ ) { result . append ( \" \" ) ; } traceIndent += ( delta > 0 ) ? delta : 0 ; return result . toString ( ) ; } }", "nl": "Generates a sequence of spaces to indent debugging output with ."}}
{"translation": {"code": "public SearchNode < O , T > createSearchNode ( T state ) { return new HeuristicSearchNode < O , T > ( state , heuristic ) ; }", "nl": "Creates the correct type of search nodes for this search . This search uses heuristic search nodes ."}}
{"translation": {"code": "private static String readStreamAsString ( BufferedInputStream is ) { try { byte [ ] data = new byte [ 4096 ] ; StringBuffer inBuffer = new StringBuffer ( ) ; int read ; while ( ( read = is . read ( data ) ) != - 1 ) { String s = new String ( data , 0 , read ) ; inBuffer . append ( s ) ; } return inBuffer . toString ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Reads the contents of a reader one line at a time until the end of stream is encountered and returns all together as a string ."}}
{"translation": {"code": "public static void writeObjectToFile ( String outputFileName , Object toWrite , boolean append ) { // Open the output file. Writer resultWriter ; try { resultWriter = new FileWriter ( outputFileName , append ) ; } catch ( IOException e ) { throw new IllegalStateException ( \"Unable to open the output file '\" + outputFileName + \"' for writing.\" , e ) ; } // Write the object into the output file. try { resultWriter . write ( toWrite . toString ( ) ) ; resultWriter . flush ( ) ; resultWriter . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( \"There was an error whilst writing to the output file '\" + outputFileName + \"'.\" , e ) ; } }", "nl": "Writes an object using its toString method to the named file . The object may optionally be appended to the file or may overwrite it ."}}
{"translation": {"code": "public int compare ( SearchNode object1 , SearchNode object2 ) { float h1 = ( ( HeuristicSearchNode ) object1 ) . getH ( ) ; float h2 = ( ( HeuristicSearchNode ) object2 ) . getH ( ) ; return ( h1 > h2 ) ? 1 : ( ( h1 < h2 ) ? - 1 : 0 ) ; }", "nl": "Compares two heuristic search nodes by their heuristic values ."}}
{"translation": {"code": "public static Set < Variable > findFreeNonAnonymousVariables ( Term query ) { QueueBasedSearchMethod < Term , Term > freeVarSearch = new DepthFirstSearch < Term , Term > ( ) ; freeVarSearch . reset ( ) ; freeVarSearch . addStartState ( query ) ; freeVarSearch . setGoalPredicate ( new FreeNonAnonymousVariablePredicate ( ) ) ; return ( Set < Variable > ) ( Set ) Searches . setOf ( freeVarSearch ) ; }", "nl": "Calculates the set of free and non - anonymous variables in a term . This is the set of variables that a user query usually wants to be made aware of ."}}
{"translation": {"code": "public static Set < Variable > findFreeVariables ( Term query ) { QueueBasedSearchMethod < Term , Term > freeVarSearch = new DepthFirstSearch < Term , Term > ( ) ; freeVarSearch . reset ( ) ; freeVarSearch . addStartState ( query ) ; freeVarSearch . setGoalPredicate ( new FreeVariablePredicate ( ) ) ; return ( Set < Variable > ) ( Set ) Searches . setOf ( freeVarSearch ) ; }", "nl": "Calculates the set of free variables in a term ."}}
{"translation": {"code": "public static Type createInstance ( String name , int min , int max ) { // Ensure that min is less than or equal to max. if ( min > max ) { throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; } synchronized ( INT_RANGE_TYPES ) { // Add the newly created type to the map of all types. IntRangeType newType = new IntRangeType ( name , min , max ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. IntRangeType oldType = INT_RANGE_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { INT_RANGE_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new int range type with the specified name if it does not already exist ."}}
{"translation": {"code": "public T search ( ) throws SearchNotExhaustiveException { SearchNode < O , T > path = findGoalPath ( ) ; if ( path != null ) { return path . getState ( ) ; } else { return null ; } }", "nl": "Perform the search . This can be called multiple times to get successive results where more than one goal can be found if the algorithm supports this . In this case it should return null once no more goals can be found ."}}
{"translation": {"code": "public void reset ( ) { // Clear out the start states. startStates . clear ( ) ; enqueuedOnce = false ; // Reset the queue to a fresh empty queue. queue = createQueue ( ) ; // Clear the goal predicate. goalPredicate = null ; // Reset the maximum steps limit maxSteps = 0 ; // Reset the number of steps taken searchSteps = 0 ; // Reset the repeated state filter if there is one. if ( repeatedStateFilter != null ) { repeatedStateFilter . reset ( ) ; } // Reset the search alogorithm if it requires resettting. searchAlgorithm . reset ( ) ; }", "nl": "Resets the search clearing out the queue and setting it to contain just the start state node ."}}
{"translation": {"code": "public static Type getTypeFromObject ( Object o ) { // Check if the object is null, in which case its type cannot be derived. if ( o == null ) { return new UnknownType ( ) ; } // Check if the object is an attribute a and get its type that way if possible. if ( o instanceof Attribute ) { return ( ( Attribute ) o ) . getType ( ) ; } // Return an approproate Type for the java primitive, wrapper or class type of the argument. return new JavaType ( o ) ; }", "nl": "Gets the type of a specified object ."}}
{"translation": {"code": "public static < E > Queue < E > getTransactionalReQueue ( java . util . Queue < E > queue , Collection < E > requeue ) { return new WrapperQueue < E > ( queue , requeue , true , false , false ) ; }", "nl": "Provides a transactional requeue that delays all queue manipulation operations until the transaction is committed or erases them if it is rolled back . As this is a requeue the requeue buffer may be examined directly and the queue fully supports browsing with iterators ."}}
{"translation": {"code": "public void paintImmediately ( int x , int y , int w , int h ) { RepaintManager repaintManager = null ; boolean save = true ; if ( ! isDoubleBuffered ( ) ) { repaintManager = RepaintManager . currentManager ( this ) ; save = repaintManager . isDoubleBufferingEnabled ( ) ; repaintManager . setDoubleBufferingEnabled ( false ) ; } super . paintImmediately ( x , y , w , h ) ; if ( repaintManager != null ) { repaintManager . setDoubleBufferingEnabled ( save ) ; } }", "nl": "Immediately repaints the surface ."}}
{"translation": {"code": "protected BufferedImage createBufferedImage ( int w , int h , int imgType ) { BufferedImage bi = null ; if ( imgType == 0 ) { bi = ( BufferedImage ) createImage ( w , h ) ; } else if ( ( imgType > 0 ) && ( imgType < 14 ) ) { bi = new BufferedImage ( w , h , imgType ) ; } else if ( imgType == 14 ) { bi = createBinaryImage ( w , h , 2 ) ; } else if ( imgType == 15 ) { bi = createBinaryImage ( w , h , 4 ) ; } else if ( imgType == 16 ) { bi = createSGISurface ( w , h , 32 ) ; } else if ( imgType == 17 ) { bi = createSGISurface ( w , h , 16 ) ; } // Store the buffered image size biw = w ; bih = h ; return bi ; }", "nl": "Generates a fresh buffered image of the appropriate type ."}}
{"translation": {"code": "protected Graphics2D createGraphics2D ( int width , int height , BufferedImage bi , Graphics g ) { Graphics2D g2 = null ; // Check if the buffered image is null if ( bi != null ) { // Create Graphics2D context for the buffered image g2 = bi . createGraphics ( ) ; } else { // The buffered image is null so create Graphics2D context for the Graphics context g2 = ( Graphics2D ) g ; } // @todo what is this for? g2 . setBackground ( getBackground ( ) ) ; // Set the rendering properties of the graphics context g2 . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , antiAlias ) ; g2 . setRenderingHint ( RenderingHints . KEY_RENDERING , rendering ) ; // Check the clear flags to see if the graphics context should be cleared if ( clearSurface || clearOnce ) { // Clear the image g2 . clearRect ( 0 , 0 , width , height ) ; // Reset the clear once flag to show that clearing has been done clearOnce = false ; } // Check if a background fill texture is to be used if ( texture != null ) { // set composite to opaque for texture fills g2 . setComposite ( AlphaComposite . SrcOver ) ; g2 . setPaint ( texture ) ; g2 . fillRect ( 0 , 0 , width , height ) ; } // Check if alpha compositing is to be used if ( composite != null ) { // Set the alpha compositing algorithm g2 . setComposite ( composite ) ; } return g2 ; }", "nl": "Creates a Graphics2D drawing context from a BufferedImage or Graphics context . The graphics context is built using the properties defined for the surface . This method is used to generate the Graphics2D context that subclasses will render in . IF the buffered image is null then the passed in Graphics context will be used to generate the Graphics2D context . This is the case when no buffered image is used and the subclass renders straight to the screen ."}}
{"translation": {"code": "private BufferedImage createBinaryImage ( int w , int h , int pixelBits ) { int bytesPerRow = w * pixelBits / 8 ; if ( ( w * pixelBits % 8 ) != 0 ) { bytesPerRow ++ ; } byte [ ] imageData = new byte [ h * bytesPerRow ] ; IndexColorModel cm = null ; switch ( pixelBits ) { case 1 : { cm = new IndexColorModel ( pixelBits , lut1Arr . length , lut1Arr , lut1Arr , lut1Arr ) ; break ; } case 2 : { cm = new IndexColorModel ( pixelBits , lut2Arr . length , lut2Arr , lut2Arr , lut2Arr ) ; break ; } case 4 : { cm = new IndexColorModel ( pixelBits , lut4Arr . length , lut4Arr , lut4Arr , lut4Arr ) ; break ; } default : { new Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; } } DataBuffer db = new DataBufferByte ( imageData , imageData . length ) ; WritableRaster r = Raster . createPackedRaster ( db , w , h , pixelBits , null ) ; return new BufferedImage ( cm , r , false , null ) ; }", "nl": "Creates a custom grey - scale binary image format ."}}
{"translation": {"code": "public void bind ( ) { // If necessary create a fresh transaction id. if ( ( txId == null ) || ! txId . isValid ( ) ) { txId = TxManager . createTxId ( ) ; } // Bind the transaction to the current thread. TxManager . assignTxIdToThread ( txId ) ; // Bind this session to the current thread. threadSession . set ( this ) ; }", "nl": "Binds the session as a transactional context to the current thread if it is not already bound ."}}
{"translation": {"code": "protected Token consumeToken ( int kind ) throws SourceCodeException { Token nextToken = tokenSource . peek ( ) ; if ( nextToken . kind != kind ) { throw new SourceCodeException ( \"Was expecting \" + tokenImage [ kind ] + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; } else { nextToken = tokenSource . poll ( ) ; return nextToken ; } }", "nl": "Consumes a token of the expected kind from the token sequence . If the next token in the sequence is not of the expected kind an error will be raised ."}}
{"translation": {"code": "protected void initializeBuiltIns ( ) { // Initializes the operator table with the standard ISO prolog built-in operators. internOperator ( \":-\" , 1200 , XFX ) ; internOperator ( \":-\" , 1200 , FX ) ; internOperator ( \"-->\" , 1200 , XFX ) ; internOperator ( \"?-\" , 1200 , FX ) ; internOperator ( \";\" , 1100 , XFY ) ; internOperator ( \"->\" , 1050 , XFY ) ; internOperator ( \",\" , 1000 , XFY ) ; internOperator ( \"\\\\+\" , 900 , FY ) ; internOperator ( \"=\" , 700 , XFX ) ; internOperator ( \"\\\\=\" , 700 , XFX ) ; internOperator ( \"==\" , 700 , XFX ) ; internOperator ( \"\\\\==\" , 700 , XFX ) ; internOperator ( \"@<\" , 700 , XFX ) ; internOperator ( \"@=<\" , 700 , XFX ) ; internOperator ( \"@>\" , 700 , XFX ) ; internOperator ( \"@>=\" , 700 , XFX ) ; internOperator ( \"=..\" , 700 , XFX ) ; internOperator ( \"is\" , 700 , XFX ) ; internOperator ( \"=:=\" , 700 , XFX ) ; internOperator ( \"=\\\\=\" , 700 , XFX ) ; internOperator ( \"<\" , 700 , XFX ) ; internOperator ( \"=<\" , 700 , XFX ) ; internOperator ( \">\" , 700 , XFX ) ; internOperator ( \">=\" , 700 , XFX ) ; internOperator ( \"+\" , 500 , YFX ) ; internOperator ( \"-\" , 500 , YFX ) ; internOperator ( \"\\\\/\" , 500 , YFX ) ; internOperator ( \"/\\\\\" , 500 , YFX ) ; internOperator ( \"/\" , 400 , YFX ) ; internOperator ( \"//\" , 400 , YFX ) ; internOperator ( \"*\" , 400 , YFX ) ; internOperator ( \">>\" , 400 , YFX ) ; internOperator ( \"<<\" , 400 , YFX ) ; internOperator ( \"rem\" , 400 , YFX ) ; internOperator ( \"mod\" , 400 , YFX ) ; internOperator ( \"-\" , 200 , FY ) ; internOperator ( \"^\" , 200 , YFX ) ; internOperator ( \"**\" , 200 , YFX ) ; internOperator ( \"\\\\\" , 200 , FY ) ; // Intern all built in functors. interner . internFunctorName ( \"nil\" , 0 ) ; interner . internFunctorName ( \"cons\" , 2 ) ; interner . internFunctorName ( \"true\" , 0 ) ; interner . internFunctorName ( \"fail\" , 0 ) ; interner . internFunctorName ( \"!\" , 0 ) ; }", "nl": "Interns and inserts into the operator table all of the built in operators and functors in Prolog ."}}
{"translation": {"code": "public void internOperator ( String operatorName , int priority , OpSymbol . Associativity associativity ) { int arity ; if ( ( associativity == XFY ) | ( associativity == YFX ) | ( associativity == XFX ) ) { arity = 2 ; } else { arity = 1 ; } int name = interner . internFunctorName ( operatorName , arity ) ; operatorTable . setOperator ( name , operatorName , priority , associativity ) ; }", "nl": "Interns an operators name as a functor of appropriate arity for the operators fixity and sets the operator in the operator table ."}}
{"translation": {"code": "public Term stringLiteral ( ) throws SourceCodeException { Token valToken = consumeToken ( STRING_LITERAL ) ; String valWithQuotes = valToken . image ; StringLiteral result = new StringLiteral ( valWithQuotes . substring ( 1 , valWithQuotes . length ( ) - 1 ) ) ; // Set the position that the literal was parsed from. SourceCodePosition position = new SourceCodePositionImpl ( valToken . beginLine , valToken . beginColumn , valToken . endLine , valToken . endColumn ) ; result . setSourceCodePosition ( position ) ; return result ; }", "nl": "Parses a string literal ."}}
{"translation": {"code": "public Term doubleLiteral ( ) throws SourceCodeException { Token valToken = consumeToken ( FLOATING_POINT_LITERAL ) ; NumericType result = new DoubleLiteral ( Double . parseDouble ( valToken . image ) ) ; // Set the position that the literal was parsed from. SourceCodePosition position = new SourceCodePositionImpl ( valToken . beginLine , valToken . beginColumn , valToken . endLine , valToken . endColumn ) ; result . setSourceCodePosition ( position ) ; return result ; }", "nl": "Parses a real number literal ."}}
{"translation": {"code": "public Term intLiteral ( ) throws SourceCodeException { Token valToken = consumeToken ( INTEGER_LITERAL ) ; NumericType result = new IntLiteral ( Integer . parseInt ( valToken . image ) ) ; // Set the position that the literal was parsed from. SourceCodePosition position = new SourceCodePositionImpl ( valToken . beginLine , valToken . beginColumn , valToken . endLine , valToken . endColumn ) ; result . setSourceCodePosition ( position ) ; return result ; }", "nl": "Parses an integer literal ."}}
{"translation": {"code": "public Term variable ( ) throws SourceCodeException { Token name = consumeToken ( VAR ) ; // Intern the variables name. int nameId = interner . internVariableName ( name . image ) ; // Check if the variable already exists in this scope, or create a new one if it does not. // If the variable is the unidentified anonymous variable '_', a fresh one will always be created. Variable var = null ; if ( ! \"_\" . equals ( name . image ) ) { var = variableContext . get ( nameId ) ; } if ( var != null ) { return var ; } else { var = new Variable ( nameId , null , name . image . equals ( \"_\" ) ) ; variableContext . put ( nameId , var ) ; return var ; } }", "nl": "Parses a variable in first order logic . Variables are scoped within the current sentence being parsed so if the variable has been seen previously in the sentence it is returned rather than a new one being created ."}}
{"translation": {"code": "public static < E > Queue < E > getTransactionalQueue ( java . util . Queue < E > queue ) { return new WrapperQueue < E > ( queue , new LinkedList < E > ( ) , true , false , false ) ; }", "nl": "Provides a transactional queue that delays all queue manipulation operations until the transaction is committed or erases them if it is rolled back ."}}
{"translation": {"code": "public Term [ ] arglist ( ) throws SourceCodeException { Term term = term ( ) ; List < Term > result = TermUtils . flattenTerm ( term , Term . class , \",\" , interner ) ; return result . toArray ( new Term [ result . size ( ) ] ) ; }", "nl": "Parses a sequence of terms as a comma seperated argument list . The operator in prolog can be used as an operator when it behaves as a functor of arity 2 or it can be used to separate a sequence of terms that are arguments to a functor or list . The sequence of functors must first be parsed as a term using the operator precedence of to form the term . This method takes such a term and flattens it back into a list of terms breaking it only on a sequence of commas . Terms that have been parsed as a bracketed expression will not be broken up ."}}
{"translation": {"code": "public Term functor ( ) throws SourceCodeException { Token name = consumeToken ( FUNCTOR ) ; Term [ ] args = arglist ( ) ; consumeToken ( RPAREN ) ; int nameId = interner . internFunctorName ( ( args == null ) ? name . image : name . image . substring ( 0 , name . image . length ( ) - 1 ) , ( args == null ) ? 0 : args . length ) ; Functor result = new Functor ( nameId , args ) ; SourceCodePosition position = new SourceCodePositionImpl ( name . beginLine , name . beginColumn , name . endLine , name . endColumn ) ; result . setSourceCodePosition ( position ) ; return result ; }", "nl": "Parses a single functor in first order logic with its arguments ."}}
{"translation": {"code": "public TreeSearchState < E > getChildStateForOperator ( Operator < Tree < E > > op ) { /*log.fine(\"public Traversable getChildStateForOperator(Operator op): called\");*/ // Extract the child tree from the operator and create a new tree search state from it. return new TreeSearchState < E > ( op . getOp ( ) ) ; }", "nl": "Returns the state obtained by applying the specified operation . If the operation is not valid then this should return null ."}}
{"translation": {"code": "public Clause clause ( ) throws SourceCodeException { // Each new sentence provides a new scope in which to make variables unique. variableContext . clear ( ) ; Term term = term ( ) ; Clause clause = TermUtils . convertToClause ( term , interner ) ; if ( clause == null ) { throw new SourceCodeException ( \"Only queries and clauses are valid sentences in Prolog, not \" + term + \".\" , null , null , null , term . getSourceCodePosition ( ) ) ; } return clause ; }", "nl": "Parses a single sentence in first order logic . A sentence consists of a term followed by a full stop ."}}
{"translation": {"code": "public static void main ( String [ ] args ) { try { SimpleCharStream inputStream = new SimpleCharStream ( System . in , null , 1 , 1 ) ; PrologParserTokenManager tokenManager = new PrologParserTokenManager ( inputStream ) ; Source < Token > tokenSource = new TokenSource ( tokenManager ) ; PrologParser parser = new PrologParser ( tokenSource , new VariableAndFunctorInternerImpl ( \"Prolog_Variable_Namespace\" , \"Prolog_Functor_Namespace\" ) ) ; while ( true ) { // Parse the next sentence or directive. Object nextParsing = parser . clause ( ) ; console . info ( nextParsing . toString ( ) ) ; } } catch ( Exception e ) { console . log ( Level . SEVERE , e . getMessage ( ) , e ) ; System . exit ( 1 ) ; } }", "nl": "Parses statements and print the parse tree to the console for quick interactive testing of the parser ."}}
{"translation": {"code": "public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { // Initialize the queue with the start states set up in search nodes if this has not already been done. // This will only be done on the first call to this method, as enqueueStartStates sets a flag when it is // done. Subsequent searches continue from where the previous search left off. Have to call reset on // the search method to really start the search again from the start states. Queue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; // Get the goal predicate configured as part of the enqueueing start states process. UnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; // Keep running until the queue becomes empty or a goal state is found. while ( ! queue . isEmpty ( ) ) { // Extract or peek at the head element from the queue. SearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; // Expand the successors into the queue whether the current node is a goal state or not. // This prepares the queue for subsequent searches, ensuring that goal states do not block // subsequent goal states that exist beyond them. if ( ! headNode . isExpanded ( ) ) { headNode . expandSuccessors ( queue , reverseEnqueue ) ; } // Get the node to be goal checked, either the head node or the new top of queue, depending on the // peek at head flag. Again this is only a peek, the node is only to be removed if it is to be // goal checked. SearchNode < O , T > currentNode = peekAtHead ? queue . peek ( ) : headNode ; // Only goal check leaves, or nodes already expanded. (The expanded flag will be set on leaves anyway). if ( currentNode . isExpanded ( ) ) { // If required, remove the node to goal check from the queue. currentNode = peekAtHead ? queue . remove ( ) : headNode ; // Check if the current node is a goal state. if ( goalPredicate . evaluate ( currentNode . getState ( ) ) ) { return currentNode ; } } // Check if there is a maximum number of steps limit and increase the step count and check the limit if so. if ( maxSteps > 0 ) { searchSteps ++ ; // Update the search state with the number of steps taken so far. initSearch . setStepsTaken ( searchSteps ) ; if ( searchSteps >= maxSteps ) { // The maximum number of steps has been reached, however if the queue is now empty then the search // has just completed within the maximum. Check if the queue is empty and return null if so. if ( queue . isEmpty ( ) ) { return null ; } // Quit without a solution as the max number of steps has been reached but because there are still // more states in the queue then raise a search failure exception. else { throw new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; } } } } // No goal state was found so return null return null ; }", "nl": "Search until a goal state is found or the maximum allowed number of steps is reached ."}}
{"translation": {"code": "public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { // Iteratively increase the bound until a search succeeds. for ( float bound = startBound ; ; ) { // Set up the maximum bound for this iteration. maxBound = bound ; // Use a try block as the depth bounded search will throw a MaxBoundException if it fails but there // are successors states known to exist beyond the current max depth fringe. try { // Get the number of search steps taken so far and pass this into the underlying depth bounded search // so that the step count limit carries over between successive iterations. int numStepsSoFar = initSearch . getStepsTaken ( ) ; // Call the super class search method to perform a depth bounded search on this maximum bound starting // from the initial search state. initSearch . resetEnqueuedOnceFlag ( ) ; SearchNode node = super . search ( initSearch , startStates , maxSteps , numStepsSoFar ) ; // Check if the current depth found a goal node if ( node != null ) { return node ; } // The depth bounded search returned null, so it has exhausted the search space. Return with null. else { return null ; } } // The depth bounded search failed but it knows that there are more successor states at deeper levels. catch ( MaxBoundException e ) { // Do nothing, no node found at this depth so continue at the next depth level e = null ; } // Check if the bound should be increased by epsilon or to the next smallest bound property value // beyond the fringe and update the bound for the next iteration. if ( useEpsilon ) { bound = bound + epsilon ; } else { bound = getMinBeyondBound ( ) ; } } }", "nl": "Search iteratively on increasing maximum bound limits until the search space is exhausted or a goal state is found ."}}
{"translation": {"code": "protected void setQueueSearchAlgorithm ( QueueSearchAlgorithm < O , T > algorithm ) { algorithm . setPeekAtHead ( true ) ; algorithm . setReverseEnqueueOrder ( true ) ; super . setQueueSearchAlgorithm ( algorithm ) ; }", "nl": "Allows different queue search algorithms to replace the default one . This overidden method ensures that the peek at head flag is always set on the search algorithm and that it expands it successor nodes in reverse as for depth first searches ."}}
{"translation": {"code": "private BufferedImage createSGISurface ( int w , int h , int pixelBits ) { int rMask32 = 0xFF000000 ; int rMask16 = 0xF800 ; int gMask32 = 0x00FF0000 ; int gMask16 = 0x07C0 ; int bMask32 = 0x0000FF00 ; int bMask16 = 0x003E ; DirectColorModel dcm = null ; DataBuffer db = null ; WritableRaster wr = null ; switch ( pixelBits ) { case 16 : { short [ ] imageDataUShort = new short [ w * h ] ; dcm = new DirectColorModel ( 16 , rMask16 , gMask16 , bMask16 ) ; db = new DataBufferUShort ( imageDataUShort , imageDataUShort . length ) ; wr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { rMask16 , gMask16 , bMask16 } , null ) ; break ; } case 32 : { int [ ] imageDataInt = new int [ w * h ] ; dcm = new DirectColorModel ( 32 , rMask32 , gMask32 , bMask32 ) ; db = new DataBufferInt ( imageDataInt , imageDataInt . length ) ; wr = Raster . createPackedRaster ( db , w , h , w , new int [ ] { rMask32 , gMask32 , bMask32 } , null ) ; break ; } default : { new Exception ( \"Invalid # of bit per pixel\" ) . printStackTrace ( ) ; } } return new BufferedImage ( dcm , wr , false , null ) ; }", "nl": "Creates a custom colour image format ."}}
{"translation": {"code": "public Term listFunctor ( ) throws SourceCodeException { // Get the interned names of the nil and cons functors. int nilId = interner . internFunctorName ( \"nil\" , 0 ) ; int consId = interner . internFunctorName ( \"cons\" , 2 ) ; // A list always starts with a '['. Token leftDelim = consumeToken ( LSQPAREN ) ; // Check if the list contains any arguments and parse them if so. Term [ ] args = null ; Token nextToken = tokenSource . peek ( ) ; switch ( nextToken . kind ) { case LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : args = arglist ( ) ; break ; default : } // Work out what the terminal element in the list is. It will be 'nil' unless an explicit cons '|' has // been used to specify a different terminal element. In the case where cons is used explciitly, the // list prior to the cons must not be empty. Term accumulator ; if ( tokenSource . peek ( ) . kind == CONS ) { if ( args == null ) { throw new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; } consumeToken ( CONS ) ; accumulator = term ( ) ; } else { accumulator = new Nil ( nilId , null ) ; } // A list is always terminated with a ']'. Token rightDelim = consumeToken ( RSQPAREN ) ; // Walk down all of the lists arguments joining them together with cons/2 functors. if ( args != null ) // 'args' will contain one or more elements if not null. { for ( int i = args . length - 1 ; i >= 0 ; i -- ) { Term previousAccumulator = accumulator ; //accumulator = new Functor(consId.ordinal(), new Term[] { args[i], previousAccumulator }); accumulator = new Cons ( consId , new Term [ ] { args [ i ] , previousAccumulator } ) ; } } // Set the position that the list was parsed from, as being the region between the '[' and ']' brackets. SourceCodePosition position = new SourceCodePositionImpl ( leftDelim . beginLine , leftDelim . beginColumn , rightDelim . endLine , rightDelim . endColumn ) ; accumulator . setSourceCodePosition ( position ) ; // The cast must succeed because arglist must return at least one argument, therefore the cons generating // loop must have been run at least once. If arglist is not called at all because an empty list was // encountered, then the accumulator will contain the 'nil' constant which is a functor of arity zero. return ( Functor ) accumulator ; }", "nl": "Parses a list expressed as a sequence of functors in first order logic . The empty list consists of the atom nil and a non - empty list consists of the functor cons with arguments the head of the list and the remainder of the list ."}}
{"translation": {"code": "public static Set < Class > findMatchingSetters ( Class obClass , String propertyName ) { /*log.fine(\"private Set<Class> findMatchingSetters(Object ob, String propertyName): called\");*/ Set < Class > types = new HashSet < Class > ( ) ; // Convert the first letter of the property name to upper case to match against the upper case version of // it that will be in the setter method name. For example the property test will have a setter method called // setTest. String upperPropertyName = Character . toUpperCase ( propertyName . charAt ( 0 ) ) + propertyName . substring ( 1 ) ; // Scan through all the objects methods. Method [ ] methods = obClass . getMethods ( ) ; for ( Method nextMethod : methods ) { // Get the next method. /*log.fine(\"nextMethod = \" + nextMethod.getName());*/ // Check if a method has the correct name, accessibility and the correct number of arguments to be a setter // method for the property. String methodName = nextMethod . getName ( ) ; if ( methodName . equals ( \"set\" + upperPropertyName ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { /*log.fine(methodName + \" is a valid setter method for the property \" + propertyName +\n                        \" with argument of type \" + nextMethod.getParameterTypes()[0]);*/ // Add its argument type to the array of setter types. types . add ( nextMethod . getParameterTypes ( ) [ 0 ] ) ; } } return types ; }", "nl": "Finds the argument types of all setter methods on a bean for a given property name . For a method to be a setter method it must have a void return type be public and accept only a single argument . Its name must be set followed by the property name ."}}
{"translation": {"code": "public static < T > Constructor < T > getConstructor ( Class < T > cls , Class [ ] args ) { try { return cls . getConstructor ( args ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Gets the constructor of a class that takes the specified set of arguments if any matches . If no matching constructor is found then a runtime exception is raised ."}}
{"translation": {"code": "public static Object callStaticMethod ( Method method , Object [ ] params ) { try { return method . invoke ( null , params ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Calls a named static method on a class with a specified set of parameters ."}}
{"translation": {"code": "public boolean hasProperty ( String property ) { // Check if a getter method exists for the property. Method getterMethod = getters . get ( property ) ; return getterMethod != null ; }", "nl": "Checks if the bean has a named property . Note that if the property value is set to null on the bean this method will still return true it tests for the existance of a named property including null ones ."}}
{"translation": {"code": "public V remove ( int index ) throws IndexOutOfBoundsException { // Check that the index is not too large if ( index >= data . size ( ) ) { throw new IndexOutOfBoundsException ( ) ; } // Get the key for the index by scanning through the key to index mapping for ( K nextKey : keyToIndex . keySet ( ) ) { int nextIndex = keyToIndex . get ( nextKey ) ; // Found the key for the index, now remove it if ( index == nextIndex ) { return remove ( nextKey ) ; } } // No matching index was found throw new IndexOutOfBoundsException ( ) ; }", "nl": "Removes the specified index from the data structure . This only works if the index already exists ."}}
{"translation": {"code": "public V remove ( Object key ) { // Check if the key is in the map Integer index = keyToIndex . get ( key ) ; if ( index == null ) { return null ; } // Leave the data in the array but remove its key keyToIndex . remove ( key ) ; keySet . remove ( key ) ; // Remove the data from the array V removedValue = data . remove ( index . intValue ( ) ) ; // Go through the whole key to index map reducing by one the value of any indexes greater that the removed index for ( K nextKey : keyToIndex . keySet ( ) ) { Integer nextIndex = keyToIndex . get ( nextKey ) ; if ( nextIndex > index ) { keyToIndex . put ( nextKey , nextIndex - 1 ) ; } } // Return the removed object return removedValue ; }", "nl": "Removes the mapping for the specified key from this map if present ."}}
{"translation": {"code": "public V set ( int index , V value ) throws IndexOutOfBoundsException { // Check if the index does not already exist if ( index >= data . size ( ) ) { throw new IndexOutOfBoundsException ( ) ; } return data . set ( index , value ) ; }", "nl": "Inserts the element at the specified index . This only works if this index already exists ."}}
{"translation": {"code": "public int getIndexOf ( Object key ) { // Get the index from the map Integer index = keyToIndex . get ( key ) ; // Check that the key is in the map and return -1 if it is not. if ( index == null ) { return - 1 ; } return index ; }", "nl": "Returns the index to which this map maps the specified key ."}}
{"translation": {"code": "public V get ( Object key ) { // Get the index from the map Integer index = keyToIndex . get ( key ) ; // Check that the key is in the map if ( index == null ) { return null ; } // Get the data from the array return data . get ( index . intValue ( ) ) ; }", "nl": "Returns the value to which this map maps the specified key ."}}
{"translation": {"code": "protected void initialize ( ) throws LearningFailureException { // Check that at least one training example has been set. if ( inputExamples . isEmpty ( ) ) { throw new LearningFailureException ( \"No training examples to learn from.\" , null ) ; } // Check if an output property set to override the default was not set. if ( ! outputPropertiesSet ) { // Set the 'goal' property as the default. addGoalProperty ( \"goal\" ) ; } // Check if an input property set to override the default was not set. if ( ! inputPropertiesSet ) { // Extract all properties from the first example in the training data set as the input property set, // automatically excluding any properties which are in the output set. State example = inputExamples . iterator ( ) . next ( ) ; Set < String > allProperties = example . getComponentType ( ) . getAllPropertyNames ( ) ; inputProperties = new HashSet < String > ( allProperties ) ; inputProperties . removeAll ( outputProperties ) ; inputPropertiesSet = true ; } // Check all the training examples have all the required input and output properties. for ( State example : inputExamples ) { Set < String > properties = example . getComponentType ( ) . getAllPropertyNames ( ) ; String errorMessage = \"\" ; for ( String inputProperty : inputProperties ) { if ( ! properties . contains ( inputProperty ) ) { errorMessage += \"The training example, \" + example + \" does not contain the specified input property, \" + inputProperty + \"\\n\" ; } } for ( String outputProperty : outputProperties ) { if ( ! properties . contains ( outputProperty ) ) { errorMessage += \"The training example, \" + example + \" does not contain the specified output property, \" + outputProperty + \"\\n\" ; } } if ( ! \"\" . equals ( errorMessage ) ) { throw new LearningFailureException ( errorMessage , null ) ; } } }", "nl": "This should be called at the start of the learn method to initialize the input and output property sets ."}}
{"translation": {"code": "public void reset ( ) { maxSteps = 0 ; machineToTrain = null ; inputExamples = new ArrayList < State > ( ) ; inputProperties = new HashSet < String > ( ) ; outputProperties = new HashSet < String > ( ) ; inputPropertiesSet = false ; outputPropertiesSet = false ; }", "nl": "Resets the learning method . This should clear all the examples properties to learn from and for and the input machine to train ."}}
{"translation": {"code": "protected void setProperty ( Object callee , String property , Object value ) { // Initialize this meta bean if it has not already been initialized. if ( ! initialized ) { initialize ( callee ) ; } // Check that at least one setter method exists for the property. Method [ ] setterMethods = setters . get ( property ) ; if ( ( setterMethods == null ) || ( setterMethods . length == 0 ) ) { throw new IllegalArgumentException ( \"No setter method for the property \" + property + \" exists.\" ) ; } // Choose which setter method to call based on the type of the value argument. If the value argument is null // then call the first available one. Method setterMethod = null ; Class valueType = ( value == null ) ? null : value . getClass ( ) ; // Check if the value is null and use the first available setter if so, as type cannot be extracted. if ( value == null ) { setterMethod = setterMethods [ 0 ] ; } // Loop through the available setter methods for one that matches the arguments type. else { for ( Method method : setterMethods ) { Class argType = method . getParameterTypes ( ) [ 0 ] ; if ( argType . isAssignableFrom ( valueType ) ) { setterMethod = method ; break ; } // Check if the arg type is primitive but the value type is a wrapper type that matches it. else if ( argType . isPrimitive ( ) && ! valueType . isPrimitive ( ) && isAssignableFromPrimitive ( valueType , argType ) ) { setterMethod = method ; break ; } // Check if the arg type is a wrapper but the value type is a primitive type that matches it. else if ( valueType . isPrimitive ( ) && ! argType . isPrimitive ( ) && isAssignableFromPrimitive ( argType , valueType ) ) { setterMethod = method ; break ; } } // Check if this point has been reached but no matching setter method could be found, in which case raise // an exception. if ( setterMethod == null ) { Class calleeType = ( callee == null ) ? null : callee . getClass ( ) ; throw new IllegalArgumentException ( \"No setter method for property \" + property + \", of type, \" + calleeType + \" will accept the type of value specified, \" + valueType + \".\" ) ; } } // Call the setter method with the value. try { Object [ ] args = new Object [ ] { value } ; setterMethod . invoke ( callee , args ) ; } catch ( InvocationTargetException e ) { throw new IllegalArgumentException ( \"The setter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; } // This should never happen as the initiliazed method should already have checked this. catch ( IllegalAccessException e ) { throw new IllegalStateException ( \"The setter method for the property \" + property + \" cannot be accessed.\" , e ) ; } }", "nl": "Sets the value of a property of the bean by name ."}}
{"translation": {"code": "public int compare ( Collection < T > c1 , Collection < T > c2 ) { // Simultaneously iterator over both collections until one runs out. Iterator < T > i1 = c1 . iterator ( ) ; Iterator < T > i2 = c2 . iterator ( ) ; while ( i1 . hasNext ( ) && i2 . hasNext ( ) ) { T t1 = i1 . next ( ) ; T t2 = i2 . next ( ) ; // Compare t1 and t2. int comp = comparator . compare ( t1 , t2 ) ; // Check if t1 < t2 in which case c1 < c2. if ( comp < 0 ) { return - 1 ; } // Check if t2 < t1 in which case c2 < c1. else if ( comp > 0 ) { return 1 ; } // Otherwise t1 = t2 in which case further elements must be examined in order to determine the ordering. } // If this point is reached then one of the collections ran out of elements before the ordering was determined. // Check if c1 ran out and c2 still has elements, in which case c1 < c2. if ( ! i1 . hasNext ( ) && i2 . hasNext ( ) ) { return - 1 ; } // Check if c2 ran out and c1 still has elements, in which case c2 < c1. if ( i1 . hasNext ( ) && ! i2 . hasNext ( ) ) { return 1 ; } // Otherwise both ran out in which case c1 = c2. return 0 ; }", "nl": "Compares two collections using lexicographic ordering based on a comparator of their elements ."}}
{"translation": {"code": "public static Type createInstance ( String name , int precision , int scale , String min , String max ) { synchronized ( DECIMAL_TYPES ) { // Add the newly created type to the map of all types. BigDecimalTypeImpl newType = new BigDecimalTypeImpl ( name , precision , scale , min , max ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. BigDecimalTypeImpl oldType = DECIMAL_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { DECIMAL_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new decimal type with the specified name if it does not already exist ."}}
{"translation": {"code": "public void registerWorkPanel ( WorkPanel panel ) { // Set the work panel to listen for actions generated by the buttons okButton . addActionListener ( panel ) ; cancelButton . addActionListener ( panel ) ; applyButton . addActionListener ( panel ) ; // Register this to listen for changes to the work panels state panel . getWorkPanelState ( ) . addPropertyChangeListener ( this ) ; }", "nl": "Sets the specified work panel to listen to the button press events for all of the OK Cancel and Apply buttons . Regisers this object to listen for changes to the work panels state ."}}
{"translation": {"code": "public void propertyChange ( PropertyChangeEvent event ) { /*log.fine(\"void propertyChange(PropertyChangeEvent): called\");*/ // Check that the property change was sent by a WorkPanelState if ( event . getSource ( ) instanceof WorkPanelState ) { // Get the state String state = ( ( WorkPanelState ) event . getSource ( ) ) . getState ( ) ; // Check what the state to set is if ( state . equals ( WorkPanelState . NOT_SAVED ) ) { // Set the Cancel and Apply buttons to enabled cancelButton . setEnabled ( true ) ; applyButton . setEnabled ( true ) ; } else if ( state . equals ( WorkPanelState . READY ) ) { // Set the Cancel and Apply buttons to disabled cancelButton . setEnabled ( false ) ; applyButton . setEnabled ( false ) ; } else if ( state . equals ( WorkPanelState . NOT_INITIALIZED ) ) { // Disable all the buttons okButton . setEnabled ( false ) ; cancelButton . setEnabled ( false ) ; applyButton . setEnabled ( false ) ; } } }", "nl": "Called when a property in the WorkPanelState is changed . This method calls initPanels to rebuild the user interface to reflect the current application state ."}}
{"translation": {"code": "private void addInstructionsAndThisToParent ( SizeableList < WAMInstruction > instructions ) { if ( ! addedToParent ) { parent . addInstructions ( this , instructions ) ; addedToParent = true ; } else { parent . addInstructions ( instructions ) ; } }", "nl": "Adds some instructions to the parent predicate and also adds this as a clause on the parent if it has not already been added ."}}
{"translation": {"code": "public void addInstructions ( Functor body , SizeableList < WAMInstruction > instructions ) { int oldLength ; if ( this . body == null ) { oldLength = 0 ; this . body = new Functor [ 1 ] ; } else { oldLength = this . body . length ; this . body = Arrays . copyOf ( this . body , oldLength + 1 ) ; } this . body [ oldLength ] = body ; addInstructionsAndThisToParent ( instructions ) ; }", "nl": "Adds a conjunctive body functor or head functor to this clause along with the instructions that implement it ."}}
{"translation": {"code": "private E nextInternal ( ) { // Check if the next soluation has already been cached, because of a call to hasNext. if ( nextSolution != null ) { return nextSolution ; } // Otherwise, generate the next solution, if possible. nextSolution = nextInSequence ( ) ; // Check if the solution was null, which indicates that the search space is exhausted. if ( nextSolution == null ) { exhausted = true ; } return nextSolution ; }", "nl": "Gets the next element from the sequence the cached one if one has already been generated or creating and caching a new one if not . If the cached element from a previous call has not been consumed then subsequent calls to this method will not advance the iterator ."}}
{"translation": {"code": "public void clearChildren ( ) { // Check that their are children to clear. if ( children != null ) { // Loop over all the children setting their parent to null. for ( Tree < E > child : children ) { child . setParent ( null ) ; } // Clear out the children collection. children . clear ( ) ; // Mark this as a leaf node. nodeOrLeaf = Type . Leaf ; } }", "nl": "Clears all the children of this point in the tree . If this point is a leaf it will have no children so this operation does nothing . If this point is a node it will be reduced to a leaf by this operation . This implementation supports turning nodes into leaves ."}}
{"translation": {"code": "public void addChild ( Tree < E > child ) { initChildren ( ) ; // Add the new child to the collection of children. children . add ( child ) ; // Set the type of this point in the tree to a node as it now has children. nodeOrLeaf = Type . Node ; // Set the new childs parent to this. child . setParent ( this ) ; }", "nl": "Adds a child tree to the children of this point in the tree . If this is already a node then it remains as a node . If this is a leaf then adding a child to it must promote it to become a node . This implementation supports turning leaves into nodes ."}}
{"translation": {"code": "public boolean evaluate ( Term term ) { if ( term . isVar ( ) && ( term instanceof Variable ) ) { Variable var = ( Variable ) term ; return ! var . isBound ( ) && ! var . isAnonymous ( ) ; } return false ; }", "nl": "Determine whether a term is a free variable ."}}
{"translation": {"code": "public void rollback ( ) { // Rollback all soft resources. for ( Transactional enlist : enlists ) { enlist . rollback ( ) ; } // Clear all of the rolled back resources. enlists . clear ( ) ; // Invalidate the transaction id, so that a fresh transaction is begun. txId = TxManager . removeTxIdFromThread ( ) ; TxManager . invalidateTxId ( txId ) ; bind ( ) ; }", "nl": "Forgets pending operations ."}}
{"translation": {"code": "protected Object getProperty ( Object callee , String property ) { // Initialize this meta bean if it has not already been initialized. if ( ! initialized ) { initialize ( callee ) ; } // Check if a getter method exists for the property being fetched. Method getterMethod = getters . get ( property ) ; if ( getterMethod == null ) { throw new IllegalArgumentException ( \"No getter method for the property \" + property + \" exists.\" ) ; } // Fetch the value by calling the getter method. Object result ; try { result = getterMethod . invoke ( callee ) ; } // This should never happen as the initiliazation method should already have checked this. catch ( InvocationTargetException e ) { throw new IllegalStateException ( \"The getter method for the property \" + property + \" threw an invocation target exception.\" , e ) ; } // This should never happen as the initiliazation method should already have checked this. catch ( IllegalAccessException e ) { throw new IllegalStateException ( \"The getter method for the property \" + property + \" cannot be accessed.\" , e ) ; } return result ; }", "nl": "Returns a single named property of the bean ."}}
{"translation": {"code": "private void initialize ( Object callee ) { // This is used to build up all the setter methods in. Map < String , List < Method > > settersTemp = new HashMap < String , List < Method > > ( ) ; // Get all the property getters and setters on this class. Method [ ] methods = callee . getClass ( ) . getMethods ( ) ; for ( Method nextMethod : methods ) { String methodName = nextMethod . getName ( ) ; // Check if it is a getter method. if ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { String propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; getters . put ( propertyName , nextMethod ) ; } // Check if it is a setter method. else if ( methodName . startsWith ( \"set\" ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 1 ) ) { /*log.fine(\"Found setter method.\");*/ String propertyName = methodName . substring ( 3 , 4 ) . toLowerCase ( ) + methodName . substring ( 4 ) ; /*log.fine(\"propertyName = \" + propertyName);*/ // Check the setter to see if any for this name already exist, and start a new list if not. List < Method > setterMethodsForName = settersTemp . get ( propertyName ) ; if ( setterMethodsForName == null ) { setterMethodsForName = new ArrayList < Method > ( ) ; settersTemp . put ( propertyName , setterMethodsForName ) ; } // Add the setter method to the list of setter methods for the named property. setterMethodsForName . add ( nextMethod ) ; } } // Convert all the lists of setter methods into arrays. for ( Map . Entry < String , List < Method > > entries : settersTemp . entrySet ( ) ) { String nextPropertyName = entries . getKey ( ) ; List < Method > nextMethodList = entries . getValue ( ) ; Method [ ] methodArray = nextMethodList . toArray ( new Method [ nextMethodList . size ( ) ] ) ; setters . put ( nextPropertyName , methodArray ) ; } // Initialization completed, set the initialized flag. initialized = true ; }", "nl": "Initialized this property introspector on a specified object building the caches of getter and setter methods ."}}
{"translation": {"code": "public static Object callMethod ( Object o , String method , Object [ ] params ) { // Get the objects class. Class cls = o . getClass ( ) ; // Get the classes of the parameters. Class [ ] paramClasses = new Class [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { paramClasses [ i ] = params [ i ] . getClass ( ) ; } try { // Try to find the matching method on the class. Method m = cls . getMethod ( method , paramClasses ) ; // Invoke it with the parameters. return m . invoke ( o , params ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( e ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Calls a named method on an object with a specified set of parameters ."}}
{"translation": {"code": "public static Object callMethodOverridingIllegalAccess ( Object o , String method , Object [ ] params , Class [ ] paramClasses ) { // Get the objects class. Class cls = o . getClass ( ) ; // Get the classes of the parameters. /*Class[] paramClasses = new Class[params.length];\n\n        for (int i = 0; i < params.length; i++)\n        {\n            paramClasses[i] = params[i].getClass();\n        }*/ try { // Try to find the matching method on the class. Method m = cls . getDeclaredMethod ( method , paramClasses ) ; // Make it accessible. m . setAccessible ( true ) ; // Invoke it with the parameters. return m . invoke ( o , params ) ; } catch ( NoSuchMethodException e ) { throw new IllegalStateException ( e ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Calls a named method on an object with a specified set of parameters any Java access modifier are overridden ."}}
{"translation": {"code": "public static < T > T newInstance ( Constructor < T > constructor , Object [ ] args ) { try { return constructor . newInstance ( args ) ; } catch ( InstantiationException e ) { throw new IllegalStateException ( e ) ; } catch ( IllegalAccessException e ) { throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { throw new IllegalStateException ( e ) ; } }", "nl": "Calls a constuctor with the specified arguments ."}}
{"translation": {"code": "public static < T > T newInstance ( Class < T > cls ) { try { return cls . newInstance ( ) ; } catch ( InstantiationException e ) { throw new ReflectionUtilsException ( \"InstantiationException whilst instantiating class.\" , e ) ; } catch ( IllegalAccessException e ) { throw new ReflectionUtilsException ( \"IllegalAccessException whilst instantiating class.\" , e ) ; } }", "nl": "Creates an instance of a Class instantiated through its no - args constructor ."}}
{"translation": {"code": "public static Class < ? > forName ( String className ) { try { return Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new ReflectionUtilsException ( \"ClassNotFoundException whilst finding class: \" + className + \".\" , e ) ; } }", "nl": "Gets the Class object for a named class ."}}
{"translation": {"code": "public static boolean isSubTypeOf ( Class parentClass , Class childClass ) { try { // Check that the child class can be cast as a sub-type of the parent. childClass . asSubclass ( parentClass ) ; return true ; } catch ( ClassCastException e ) { // Exception noted so can be ignored. e = null ; return false ; } }", "nl": "Checks that the child class is the same type or a sub - type of the parent class ."}}
{"translation": {"code": "public static boolean isSubTypeOf ( String parent , String child ) { try { return isSubTypeOf ( Class . forName ( parent ) , Class . forName ( child ) ) ; } catch ( ClassNotFoundException e ) { // Exception noted so can be ignored. e = null ; return false ; } }", "nl": "Checks that the named child class is the same type or a sub - type of the named parent class ."}}
{"translation": {"code": "public static boolean isSubTypeOf ( Class parent , String className ) { try { Class cls = Class . forName ( className ) ; return parent . isAssignableFrom ( cls ) ; } catch ( ClassNotFoundException e ) { // Exception noted and ignored. e = null ; return false ; } }", "nl": "Checks if the named class exists and is loadable and is a sub - type of the specified class ."}}
{"translation": {"code": "private boolean isAssignableFromPrimitive ( Class wrapperType , Class primitiveType ) { boolean result = false ; if ( primitiveType . equals ( boolean . class ) && wrapperType . equals ( Boolean . class ) ) { result = true ; } else if ( primitiveType . equals ( byte . class ) && wrapperType . equals ( Byte . class ) ) { result = true ; } else if ( primitiveType . equals ( char . class ) && wrapperType . equals ( Character . class ) ) { result = true ; } else if ( primitiveType . equals ( short . class ) && wrapperType . equals ( Short . class ) ) { result = true ; } else if ( primitiveType . equals ( int . class ) && wrapperType . equals ( Integer . class ) ) { result = true ; } else if ( primitiveType . equals ( long . class ) && wrapperType . equals ( Long . class ) ) { result = true ; } else if ( primitiveType . equals ( float . class ) && wrapperType . equals ( Float . class ) ) { result = true ; } else if ( primitiveType . equals ( double . class ) && wrapperType . equals ( Double . class ) ) { result = true ; } else { result = false ; } return result ; }", "nl": "Checks if a wrapper type is assignable from a primtive type ."}}
{"translation": {"code": "public static boolean classExistsAndIsLoadable ( String className ) { try { Class . forName ( className ) ; return true ; } catch ( ClassNotFoundException e ) { // Exception noted and ignored. e = null ; return false ; } }", "nl": "Checks if the named class exists and is loadable ."}}
{"translation": {"code": "public String getStringValue ( ) { // Check if the attribute class has been finalized yet. if ( attributeClass . finalized ) { // Fetch the string value from the attribute class. return attributeClass . lookupValue [ value ] . label ; } else { return attributeClass . lookupValueList . get ( value ) . label ; } }", "nl": "Gets the string value of a string attribute ."}}
{"translation": {"code": "public static String asString ( ByteBuffer buffer , int length ) { char [ ] chars = new char [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { chars [ i ] = ( char ) buffer . get ( i ) ; } return String . valueOf ( chars ) ; }", "nl": "Returns the contents of a buffer as a string converting ASCII characters in the buffer into unicode string characters ."}}
{"translation": {"code": "public static ByteBuffer putPaddedInt32AsString ( ByteBuffer buffer , int value , int length ) { // Ensure there is sufficient space in the buffer to hold the result. int charsRequired = BitHackUtils . getCharacterCountInt32 ( value ) ; length = ( charsRequired < length ) ? length : charsRequired ; // Take an explicit index into the buffer to start writing to, as the numbers will be written backwards. int index = buffer . position ( ) + length - 1 ; // Record the start position, to remember if a minus sign was written or not, so that it does not get // overwritten by the zero padding. int start = buffer . position ( ) ; // Advance the buffer position manually, as the characters will be written to specific indexes backwards. buffer . position ( buffer . position ( ) + length ) ; // Take care of the minus sign for negative numbers. if ( value < 0 ) { buffer . put ( MINUS_ASCII ) ; start ++ ; // Stop padding code overwriting minus sign. } else { value = - value ; } // Write the digits least significant to most significant into the buffer. As the number was converted to be // negative the remainders will be negative too. do { int remainder = value % 10 ; value = value / 10 ; buffer . put ( index -- , ( ( byte ) ( ZERO_ASCII - remainder ) ) ) ; } while ( value != 0 ) ; // Write out the padding zeros. while ( index >= start ) { buffer . put ( index -- , ZERO_ASCII ) ; } return buffer ; }", "nl": "Writes the specified integer value as an ASCII string into the specified byte buffer . If the integer value is shorted than the specified length the number will be padded with leading zeros so that it fills the required length . If there is insufficient space in the buffer to write the value into then the buffer size is increased using the supplied byte buffer pool ."}}
{"translation": {"code": "protected boolean unifyVar ( Variable leftVar , Term rightTerm , List < Variable > leftTrail , List < Variable > rightTrail ) { /*log.fine(\"protected boolean unifyVar(Variable var = \" + leftVar + \", Term term = \" + rightTerm +\n            \", List<Variable> trail = \" + leftTrail + \"): called\");*/ // Check if the variable is bound (in the trail, but no need to explicitly check the trail as the binding is // already held against the variable). if ( leftVar . isBound ( ) ) { /*log.fine(\"Variable is bound.\");*/ return unifyInternal ( leftVar . getValue ( ) , rightTerm , leftTrail , rightTrail ) ; } else if ( rightTerm . isVar ( ) && ( ( Variable ) rightTerm ) . isBound ( ) ) { // The variable is free, but the term itself is a bound variable, in which case unify againt the value // of the term. /*log.fine(\"Term is a bound variable.\");*/ return unifyInternal ( leftVar , rightTerm . getValue ( ) , leftTrail , rightTrail ) ; } else { // Otherwise, unify by binding the variable to the value of the term. /*log.fine(\"Variable is free, substituting in the term for it.\");*/ leftVar . setSubstitution ( rightTerm ) ; leftTrail . add ( leftVar . getStorageCell ( leftVar ) ) ; //leftTrail.add(leftVar); return true ; } // Occurs can go above if desired. /*else if (var occurs anywhere in x)\n        {\n            return false;\n        }*/ }", "nl": "Unifies a variable with a term . If the variable is bound then the bound value is unified with the term . If the term is a bound variable and the variable is free then the vairable is unified with the bound value of the term . Otherwise the variable is free and is bound to the value of the term ."}}
{"translation": {"code": "public boolean unifyInternal ( Term left , Term right , List < Variable > leftTrail , List < Variable > rightTrail ) { /*log.fine(\"public boolean unifyInternal(Term left = \" + left + \", Term right = \" + right +\n            \", List<Variable> trail = \" + leftTrail + \"): called\");*/ if ( left == right ) { /*log.fine(\"Terms are identical objects.\");*/ return true ; } if ( ! left . isVar ( ) && ! right . isVar ( ) && left . isConstant ( ) && right . isConstant ( ) && left . equals ( right ) ) { /*log.fine(\"Terms are equal atoms or literals.\");*/ return true ; } else if ( left . isVar ( ) ) { /*log.fine(\"Left is a variable.\");*/ return unifyVar ( ( Variable ) left , right , leftTrail , rightTrail ) ; } else if ( right . isVar ( ) ) { /*log.fine(\"Right is a variable.\");*/ return unifyVar ( ( Variable ) right , left , rightTrail , leftTrail ) ; } else if ( left . isFunctor ( ) && right . isFunctor ( ) ) { /*log.fine(\"Terms are functors, at least one of which is not an atom.\");*/ Functor leftFunctor = ( Functor ) left ; Functor rightFunctor = ( Functor ) right ; // Check if the functors may be not be equal (that is, they do not have the same name and arity), in // which case they cannot possibly be unified. if ( ! left . equals ( right ) ) { return false ; } /*log.fine(\"Terms are functors with same name and arity, both are compound.\");*/ // Pairwise unify all of the arguments of the functor. int arity = leftFunctor . getArity ( ) ; for ( int i = 0 ; i < arity ; i ++ ) { Term leftArgument = leftFunctor . getArgument ( i ) ; Term rightArgument = rightFunctor . getArgument ( i ) ; boolean result = unifyInternal ( leftArgument , rightArgument , leftTrail , rightTrail ) ; if ( ! result ) { /*log.fine(\"Non unifying arguments in functors encountered, left = \" + leftArgument + \", right = \" +\n                        rightArgument);*/ return false ; } } return true ; } else { return false ; } }", "nl": "Attempts to unify one term with another against a background of already unified variables in both terms . In the case where two terms are being unified from scratch the variable assignments will be empty ."}}
{"translation": {"code": "public List < Variable > unify ( Term query , Term statement ) { /*log.fine(\"unify(Term left = \" + query + \", Term right = \" + statement + \"): called\");*/ // Find all free variables in the query. Set < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( query ) ; // Build up all the variable bindings in both sides of the unification in these bindings. List < Variable > queryBindings = new LinkedList < Variable > ( ) ; List < Variable > statementBindings = new LinkedList < Variable > ( ) ; // Fund the most general unifier, if possible. boolean unified = unifyInternal ( query , statement , queryBindings , statementBindings ) ; List < Variable > results = null ; // If a unification was found, only retain the free variables in the query in the results returned. if ( unified ) { queryBindings . retainAll ( freeVars ) ; results = new ArrayList < Variable > ( queryBindings ) ; } return results ; }", "nl": "Unifies two terms and produces a list of bound variables that form the unification when it it possible ."}}
{"translation": {"code": "public void initializeLookups ( DecisionTree thisNode ) { // Scan over all the decision trees children at this point inserting them into the lookup table depending // on the ordinal of the attribute value that matches them. for ( Iterator < Tree < DecisionTreeElement > > i = thisNode . getChildIterator ( ) ; i . hasNext ( ) ; ) { DecisionTree nextChildTree = ( DecisionTree ) i . next ( ) ; // Get the matching attribute value from the childs decision tree element. OrdinalAttribute matchingValue = nextChildTree . getElement ( ) . getAttributeValue ( ) ; // Insert the matching sub-tree into the lookup table. decisions [ matchingValue . ordinal ( ) ] = nextChildTree ; } }", "nl": "Initializes the lookup table for this decision node . The specified decision tree that corresponds to this node is used to extract all the possible outcomes for this decision and these are stored in a lookup table so that future decisions made with this tree will run faster ."}}
{"translation": {"code": "public DecisionTree decide ( State state ) { // Extract the value of the property being decided from state to be classified. OrdinalAttribute attributeValue = ( OrdinalAttribute ) state . getProperty ( propertyName ) ; // Extract the child decision tree that matches the property value, using the attributes ordinal for a quick // look up. return decisions [ attributeValue . ordinal ( ) ] ; }", "nl": "Performs the actual decision based on a property of the state . If the quick lookup table has been initialized then the decision is taken straight from it . If not then the supplied reference to the decision tree at this point is used to find the outcome by scanning over its children ."}}
{"translation": {"code": "public void setStringValue ( String value ) throws IllegalArgumentException { Byte b = attributeClass . lookupByte . get ( value ) ; // Check if the value is not already a memeber of the attribute class. if ( b == null ) { // Check if the attribute class has been finalized yet. if ( attributeClass . finalized ) { throw new IllegalArgumentException ( \"The value to set, \" + value + \", is not already a member of the finalized EnumeratedStringType, \" + attributeClass . attributeClassName + \".\" ) ; } else { // Add the new value to the attribute class. Delegate to the factory to do this so that strings are // interned and so on. EnumeratedStringAttribute newAttribute = attributeClass . createStringAttribute ( value ) ; b = newAttribute . value ; } } // Set the new value as the value of this attribute. this . value = b ; }", "nl": "Sets the specified string as the value of this attribute . The value to set must be a legitimate member of this attributes type when the type has been finalized . If the type has yet to be finalized then the new value is added to the set of possible values for the type ."}}
{"translation": {"code": "public static < T > Collection < T > collectIterator ( Iterator < T > iterator , Collection < T > targetCollection ) { while ( iterator . hasNext ( ) ) { targetCollection . add ( iterator . next ( ) ) ; } return targetCollection ; }", "nl": "Extracts all elements from an iterator usually created from a filterator and adds them into the target collection returning that collection as the result ."}}
{"translation": {"code": "public List < Term > terms ( List < Term > terms ) throws SourceCodeException { Term term ; Token nextToken = tokenSource . peek ( ) ; switch ( nextToken . kind ) { case FUNCTOR : term = functor ( ) ; break ; case LSQPAREN : term = listFunctor ( ) ; break ; case VAR : term = variable ( ) ; break ; case INTEGER_LITERAL : term = intLiteral ( ) ; break ; case FLOATING_POINT_LITERAL : term = doubleLiteral ( ) ; break ; case STRING_LITERAL : term = stringLiteral ( ) ; break ; case ATOM : term = atom ( ) ; break ; case LPAREN : consumeToken ( LPAREN ) ; term = term ( ) ; // Mark the term as bracketed to ensure that this is its final parsed form. In particular the // #arglist method will not break it up if it contains commas. term . setBracketed ( true ) ; consumeToken ( RPAREN ) ; break ; default : throw new SourceCodeException ( \"Was expecting one of \" + BEGIN_TERM_TOKENS + \" but got \" + tokenImage [ nextToken . kind ] + \".\" , null , null , null , new SourceCodePositionImpl ( nextToken . beginLine , nextToken . beginColumn , nextToken . endLine , nextToken . endColumn ) ) ; } terms . add ( term ) ; switch ( tokenSource . peek ( ) . kind ) { case LPAREN : case LSQPAREN : case INTEGER_LITERAL : case FLOATING_POINT_LITERAL : case STRING_LITERAL : case VAR : case FUNCTOR : case ATOM : terms ( terms ) ; break ; default : } return terms ; }", "nl": "Recursively parses terms which may be functors atoms variables literals or operators into a flat list in the order in which they are encountered ."}}
{"translation": {"code": "public static int getIntFromBytes ( byte [ ] buf , int offset ) { int result = 0 ; result += buf [ offset ++ ] & 0xFF ; result += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; result += ( ( buf [ offset ++ ] & 0xFF ) << 16 ) ; result += ( ( buf [ offset ] ) << 24 ) ; return result ; }", "nl": "Extracts an int from an array of bytes ."}}
{"translation": {"code": "public static WAMResolvingNativeMachine getInstance ( SymbolTableImpl < Integer , String , Object > symbolTable ) throws ImplementationUnavailableException { try { if ( ! libraryLoadAttempted ) { libraryLoadAttempted = true ; System . loadLibrary ( \"aima_native\" ) ; libraryFound = true ; } if ( libraryFound ) { return new WAMResolvingNativeMachine ( symbolTable ) ; } else { throw new ImplementationUnavailableException ( \"The native library could not be found.\" , null , null , null ) ; } } catch ( UnsatisfiedLinkError e ) { libraryFound = false ; throw new ImplementationUnavailableException ( \"The native library could not be found.\" , e , null , null ) ; } }", "nl": "Creates an instance of this machine loading and checking for availability of the native implementation library as required ."}}
{"translation": {"code": "public Iterator < Set < Variable > > iterator ( ) { return new SequenceIterator < Set < Variable > > ( ) { public Set < Variable > nextInSequence ( ) { return resolve ( ) ; } } ; }", "nl": "Provides an iterator that generates all solutions on demand as a sequence of variable bindings ."}}
{"translation": {"code": "public static double expectedI ( double [ ] probabilities ) { double result = 0.0d ; // Loop over the probabilities for all the symbols calculating the contribution of each to the expected value. for ( double p : probabilities ) { // Calculate the information in each symbol. I(p) = - ln p and weight this by its probability of occurence // to get that symbols contribution to the expected value over all symbols. if ( p > 0.0d ) { result -= p * Math . log ( p ) ; } } // Convert the result from nats to bits by dividing by ln 2. return result / LN2 ; }", "nl": "For a given set of probabilities of the occurences of symbols this function calculates the expected information content of a set of symbols given its probability distribution . The answer is expressed as a positive number of bits ."}}
{"translation": {"code": "public static void writeIntToByteArray ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; buf [ offset ++ ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; buf [ offset ++ ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; buf [ offset ] = ( byte ) ( ( value & 0xff000000 ) >> 24 ) ; }", "nl": "Outputs an int into a byte array ."}}
{"translation": {"code": "public static double [ ] pForDistribution ( int [ ] counts ) { double [ ] probabilities = new double [ counts . length ] ; int total = 0 ; // Loop over the counts for all symbols adding up the total number. for ( int c : counts ) { total += c ; } // Loop over the counts for all symbols dividing by the total number to provide a probability estimate. for ( int i = 0 ; i < probabilities . length ; i ++ ) { if ( total > 0 ) { probabilities [ i ] = ( ( double ) counts [ i ] ) / total ; } else { probabilities [ i ] = 0.0d ; } } return probabilities ; }", "nl": "Estimates probabilities given a set of counts of occurrences of symbols ."}}
{"translation": {"code": "public static EnumAttributeFactory getFactoryForClass ( Class cls ) { // Check that the requested class is actually an enum. if ( ! cls . isEnum ( ) ) { throw new IllegalArgumentException ( \"Can only create enum attribute factories for classes that are enums.\" ) ; } return EnumClassImpl . getInstance ( cls ) ; }", "nl": "Generates a factory for building enum attributes of the specified enum class ."}}
{"translation": {"code": "public long skip ( long n ) throws IOException { try { return source . skip ( n ) ; } catch ( RemoteException e ) { throw new IOException ( \"There was a Remote Exception.\" , e ) ; } }", "nl": "Skips over and discards n bytes of data from this input stream ."}}
{"translation": {"code": "public int read ( byte [ ] b ) throws IOException { try { ByteBlock block = source . read ( b ) ; System . arraycopy ( block . data , 0 , b , 0 , block . count ) ; return block . count ; } catch ( RemoteException e ) { throw new IOException ( \"There was a Remote Exception.\" , e ) ; } }", "nl": "Reads some number of bytes from the input stream and stores them into the buffer array b ."}}
{"translation": {"code": "void setTicks ( long ticks ) { year = TimeUtils . ticksToYears ( ticks ) ; month = TimeUtils . ticksToMonths ( ticks ) ; day = TimeUtils . ticksToDate ( ticks ) ; }", "nl": "Sets this date from a milliseconds timestamp ."}}
{"translation": {"code": "public void setRate ( float hertz ) { // Pass the rate unaltered down to the base implementation, for the check method. super . setRate ( hertz ) ; // Log base 10 over 2 is used here to get a feel for what power of 100 the total rate is. // As the total rate goes up the powers of 100 the batch size goes up by powers of 100 to keep the // throttle rate in the range 1 to 100. int x = ( int ) ( Math . log10 ( hertz ) / 2 ) ; batchSize = ( int ) Math . pow ( 100 , x ) ; float throttleRate = hertz / batchSize ; // Reset the call count. callCount = 0 ; // Set the sleep throttle wrapped implementation at a rate within its abilities. batchRateThrottle . setRate ( throttleRate ) ; }", "nl": "Specifies the throttling rate in operations per second ."}}
{"translation": {"code": "public static synchronized Properties getProperties ( String resourceName ) { /*log.fine(\"public static synchronized Properties getProperties(String resourceName): called\");*/ /*log.fine(\"resourceName = \" + resourceName);*/ // Try to find an already created singleton property reader for the resource PropertyReaderBase propertyReader = ( PropertyReaderBase ) propertyReaders . get ( resourceName ) ; if ( propertyReader != null ) { /*log.fine(\"found property reader in the cache for resource: \" + resourceName);*/ return propertyReader . getProperties ( ) ; } /*log.fine(\"did not find property reader in the cache for resource: \" + resourceName);*/ // There is not already a singleton for the named resource so create a new one propertyReader = new DefaultPropertyReader ( resourceName ) ; // Keep the newly created singleton for next time propertyReaders . put ( resourceName , propertyReader ) ; return propertyReader . getProperties ( ) ; }", "nl": "Static factory method that locates an existing instance or creates a new property reader for a named resource ."}}
{"translation": {"code": "public List < T > cacheBlock ( int block ) { /*log.fine(\"public List<T> cacheBlock(int block): called\");*/ // Get the new block. List < T > blockList = getBlock ( block * blockSize , blockSize ) ; // Cache it. blockMap . put ( block , blockList ) ; /*log.fine(\"Cached block \" + block + \" with list of size \" + blockList.size());*/ return blockList ; }", "nl": "Fetches and caches the specified block ."}}
{"translation": {"code": "private SearchNode < O , T > joinBothPaths ( SearchNode < O , T > forwardPath , SearchNode < O , T > reversePath ) throws SearchNotExhaustiveException { // Check if an alternative path join algorithm has been set and delegate to it if so if ( pathJoiner != null ) { return pathJoiner . joinBothPaths ( forwardPath , reversePath ) ; } // No alternative path join algorithm has been supplied so use this default one else { // Used to hold the current position along the reverse path of search nodes SearchNode < O , T > currentReverseNode = reversePath ; // Used to hold the current position along the forward path of search nodes SearchNode < O , T > currentForwardNode = forwardPath ; // Loop over all nodes in the reverse path checking if the current reverse node is the // goal state to terminate on. while ( ! goalPredicate . evaluate ( currentReverseNode . getState ( ) ) ) { // Create a new forward node from the parent state of the current reverse node, the current reverse // nodes applied operation and cost, and an increment of one to the path depth SearchNode < O , T > reverseParentNode = currentReverseNode . getParent ( ) ; T state = currentReverseNode . getParent ( ) . getState ( ) ; Operator < O > operation = currentReverseNode . getAppliedOp ( ) ; float cost = currentReverseNode . getPathCost ( ) - reverseParentNode . getPathCost ( ) ; currentForwardNode = currentForwardNode . makeNode ( new Successor < O > ( state , operation , cost ) ) ; // Move one step up the reverse path currentReverseNode = reverseParentNode ; } // Return the last forward search node found return currentForwardNode ; } }", "nl": "Once a match has been found between the forward and reverse fringes of the search a path is known to exist from the start to the goal . The path is not complete at this stage because it remains to reverse all of the steps in the backward half of the path and add them to the forward half of the path to produce the complete forward path from start to the goal ."}}
{"translation": {"code": "public SearchNode < O , T > findGoalPath ( ) throws SearchNotExhaustiveException { // Keep running until the queue becomes empty or a goal state is found while ( ! forwardQueue . isEmpty ( ) || ! reverseQueue . isEmpty ( ) ) { // Only run the forward step of the search if the forward queue is not empty if ( ! forwardQueue . isEmpty ( ) ) { // Extract the next node from the forward queue SearchNode < O , T > currentForwardNode = forwardQueue . remove ( ) ; // Remove this node from the forward fringe map as it will soon be replaced by more fringe members forwardFringe . remove ( currentForwardNode . getState ( ) ) ; // Check the reverse fringe against the next forward node for a match. if ( reverseFringe . containsKey ( currentForwardNode . getState ( ) ) ) { // A path from start to the goal has been found. Walk backwards along the reverse path adding all // nodes encountered to the forward path until the goal is reached. return joinBothPaths ( currentForwardNode , reverseFringe . get ( currentForwardNode . getState ( ) ) ) ; } // There was no match so a path to the goal has not been found else { // Get all of the successor states to the current node Queue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; currentForwardNode . expandSuccessors ( newStates , false ) ; // Expand all the successors to the current forward node into the buffer to be searched. forwardQueue . addAll ( newStates ) ; // Also add all the successors to the current forward fringe map. for ( SearchNode < O , T > nextSearchNode : newStates ) { forwardFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; } } } // Only run the reverse step of the search if the reverse queue is not empty if ( ! reverseQueue . isEmpty ( ) ) { // Extract the next node from the reverse queue SearchNode < O , T > currentReverseNode = reverseQueue . remove ( ) ; // Remove this node from the reverse fringe set as it will soon be replaced by more fringe members reverseFringe . remove ( currentReverseNode . getState ( ) ) ; // Check the forward fringe against the next reverse node for a match. if ( forwardFringe . containsKey ( currentReverseNode . getState ( ) ) ) { // A path from start to goal has been found. // Walk backwards along the reverse path adding all nodes encountered to the foward path until the // goal is reached. return joinBothPaths ( forwardFringe . get ( currentReverseNode . getState ( ) ) , currentReverseNode ) ; } // There was no match so a path to the goal has not been found else { // Get all of the successor states to the current node (really predecessor state) Queue < SearchNode < O , T > > newStates = new LinkedList < SearchNode < O , T > > ( ) ; currentReverseNode . expandSuccessors ( newStates , false ) ; // Expand all the successors to the current reverse node into the reverse buffer to be searched. reverseQueue . addAll ( newStates ) ; // Add all the successors to the current reverse fringe set for ( SearchNode < O , T > nextSearchNode : newStates ) { reverseFringe . put ( nextSearchNode . getState ( ) , nextSearchNode ) ; } } } } // No goal state was found so return null return null ; }", "nl": "Implementation of the general bi - dircetional search . The search alternated between taking a forward and a reverse step ."}}
{"translation": {"code": "public void setFinished ( boolean avail ) { /*log.fine(\"void setFinished(boolean): called\");*/ // Check if the state has changed if ( finished != avail ) { // Keep the new state finished = avail ; // Notify any listeners fo the change in state firePropertyChange ( new PropertyChangeEvent ( this , \"finished\" , ! avail , avail ) ) ; /*log.fine(\"fired property change event\");*/ } }", "nl": "Sets the state of the finished and notifies any listeners of this change ."}}
{"translation": {"code": "private void createInitialContext ( Term term ) { if ( ! initialContextCreated ) { PositionalContextOperator initialContext = new PositionalContextOperator ( term , - 1 , false , false , false , null , contextStack . peek ( ) ) ; contextStack . offer ( initialContext ) ; term . setReversable ( initialContext ) ; initialContextCreated = true ; } }", "nl": "Sets up the initial context once at the start of a traversal ."}}
{"translation": {"code": "public static Type createInstance ( String name , int maxLength , String pattern ) { synchronized ( STRING_PATTERN_TYPES ) { StringPatternType newType = new StringPatternType ( name , maxLength , pattern ) ; // Ensure that the named type does not already exist. StringPatternType oldType = STRING_PATTERN_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { // Add the newly created type to the map of all types. STRING_PATTERN_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new string pattern type with the specified name if it does not already exist ."}}
{"translation": {"code": "public static Type createInstance ( String name , TimeOnly min , TimeOnly max ) { // Ensure that min is less than or equal to max. if ( ( min != null ) && ( max != null ) && ( min . compareTo ( max ) > 0 ) ) { throw new IllegalArgumentException ( \"'min' must be less than or equal to 'max'.\" ) ; } synchronized ( INT_RANGE_TYPES ) { // Add the newly created type to the map of all types. TimeRangeType newType = new TimeRangeType ( name , min , max ) ; // Ensure that the named type does not already exist, unless it has an identical definition already, in which // case the old definition can be re-used and the new one discarded. TimeRangeType oldType = INT_RANGE_TYPES . get ( name ) ; if ( ( oldType != null ) && ! oldType . equals ( newType ) ) { throw new IllegalArgumentException ( \"The type '\" + name + \"' already exists and cannot be redefined.\" ) ; } else if ( ( oldType != null ) && oldType . equals ( newType ) ) { return oldType ; } else { INT_RANGE_TYPES . put ( name , newType ) ; return newType ; } } }", "nl": "Creates a new time range type with the specified name if it does not already exist ."}}
{"translation": {"code": "public boolean isBound ( ) { VariableBindingContext < Variable > context = getBindingContext ( ) ; // The variable can only be bound if it has a binding context and is bound in that context. return ( context != null ) && context . getStorageCell ( this ) . isBound ( ) ; }", "nl": "Reports whether or not this variable is bound to a value ."}}
{"translation": {"code": "public SearchNode search ( QueueSearchState < O , T > initSearch , Collection < T > startStates , int maxSteps , int searchSteps ) throws SearchNotExhaustiveException { // Initialize the queue with the start states set up in search nodes. Queue < SearchNode < O , T > > queue = initSearch . enqueueStartStates ( startStates ) ; // Get the goal predicate configured as part of the enqueueing start states process. UnaryPredicate < T > goalPredicate = initSearch . getGoalPredicate ( ) ; // Flag used to indicate whether there are unexplored successor states known to exist beyond the max depth // fringe. boolean beyondFringe = false ; // Reset the minimum beyond the fringe boundary value. minBeyondBound = Float . POSITIVE_INFINITY ; // Keep running until the queue becomes empty or a goal state is found. while ( ! queue . isEmpty ( ) ) { // Extract the head element from the queue. SearchNode < O , T > headNode = peekAtHead ? queue . peek ( ) : queue . remove ( ) ; // Expand the successors into the queue whether the current node is a goal state or not. // This prepares the queue for subsequent searches, ensuring that goal states do not block // subsequent goal states that exist beyond them. // Add the successors to the queue provided that they are below or at the maximum bounded property. // Get all the successor states. Queue < SearchNode < O , T > > successors = new LinkedList < SearchNode < O , T > > ( ) ; headNode . expandSuccessors ( successors , reverseEnqueue ) ; // Loop over all the successor states checking how they stand with respect to the bounded property. for ( SearchNode < O , T > successor : successors ) { // Get the value of the bound property for the successor node. float boundProperty = boundPropertyExtractor . getBoundProperty ( successor ) ; // Check if the successor is below or on the bound. if ( boundProperty <= maxBound ) { // Add it to the queue to be searched. queue . offer ( successor ) ; } // The successor state is above the bound. else { // Set the flag to indicate that there is at least one search node known to exist beyond the // bound. beyondFringe = true ; // Compare to the best minimum beyond the bound property found so far to see if // this is a new minimum and update the minimum to the new minimum if so. minBeyondBound = ( boundProperty < minBeyondBound ) ? boundProperty : minBeyondBound ; } } // Get the node to be goal checked, either the head node or the new top of queue, depending on the // peek at head flag. SearchNode < O , T > currentNode = peekAtHead ? queue . remove ( ) : headNode ; // Check if the current node is a goal state. // Only goal check leaves, or nodes already expanded. (The expanded flag will be set on leaves anyway). if ( currentNode . isExpanded ( ) && goalPredicate . evaluate ( currentNode . getState ( ) ) ) { return currentNode ; } // Check if there is a maximum number of steps limit and increase the step count and check the limit if so. if ( maxSteps > 0 ) { // Increase the search step count because a goal test was performed. searchSteps ++ ; // Update the search state with the number of steps taken so far. initSearch . setStepsTaken ( searchSteps ) ; if ( searchSteps >= maxSteps ) { // The maximum number of steps has been reached, however if the queue is now empty then the search // has just completed within the maximum. Check if the queue is empty and return null if so. if ( queue . isEmpty ( ) ) { return null ; } // Quit without a solution as the max number of steps has been reached but because there are still // more states in the queue then raise a search failure exception. else { throw new SearchNotExhaustiveException ( \"Maximum number of steps reached.\" , null ) ; } } } } // No goal state was found. Check if there known successors beyond the max depth fringe and if so throw // a SearchNotExhaustiveException to indicate that the search failed rather than exhausted the search space. if ( beyondFringe ) { throw new MaxBoundException ( \"Max bound reached.\" , null ) ; } else { // The search space was exhausted so return null to indicate that no goal could be found. return null ; } }", "nl": "Searches all SearchNodes less than the maximum bound for some property of the nodes ."}}
{"translation": {"code": "public void setCurrentScreenState ( WorkFlowScreenState state ) { /*log.fine(\"void setCurrentScreenState(WorkFlowScreenState): called\");*/ WorkFlowScreenState oldState = currentScreenState ; // Keep the new state. currentScreenState = state ; // Notify all listeners of the change of current screen. firePropertyChange ( new PropertyChangeEvent ( this , \"currentScreenState\" , oldState , state ) ) ; }", "nl": "Sets the new current screen state and notifies all listeners of the change in screen state ."}}
{"translation": {"code": "public void walk ( Term term ) { // Set up the traverser on the term to walk over. term . setTermTraverser ( traverser ) ; // Create a fresh search starting from the term. search . reset ( ) ; if ( goalPredicate != null ) { search . setGoalPredicate ( goalPredicate ) ; } search . addStartState ( term ) ; Iterator < Term > treeWalker = Searches . allSolutions ( search ) ; // If the traverser is a term visitor, allow it to visit the top-level term in the walk to establish // an initial context. if ( traverser instanceof TermVisitor ) { term . accept ( ( TermVisitor ) traverser ) ; } // Visit every goal node discovered in the walk over the term. while ( treeWalker . hasNext ( ) ) { Term nextTerm = treeWalker . next ( ) ; nextTerm . accept ( visitor ) ; } // Remote the traverser on the term to walk over. term . setTermTraverser ( null ) ; }", "nl": "Walks over the supplied term ."}}
{"translation": {"code": "public int compare ( SearchNode object1 , SearchNode object2 ) { float f1 = ( ( HeuristicSearchNode ) object1 ) . getF ( ) ; float f2 = ( ( HeuristicSearchNode ) object2 ) . getF ( ) ; return ( f1 > f2 ) ? 1 : ( ( f1 < f2 ) ? - 1 : 0 ) ; }", "nl": "Compares two heuristic search nodes by their f values ."}}
{"translation": {"code": "public < T > T [ ] toArray ( T [ ] a ) { int size = size ( ) ; if ( a . length < size ) { a = ( T [ ] ) java . lang . reflect . Array . newInstance ( a . getClass ( ) . getComponentType ( ) , size ) ; } Iterator < E > it = iterator ( ) ; Object [ ] result = a ; for ( int i = 0 ; i < size ; i ++ ) { result [ i ] = it . next ( ) ; } if ( a . length > size ) { a [ size ] = null ; } return a ; }", "nl": "Returns an array containing all of the elements in this heap ; the runtime type of the returned array is that of the specified array . If the collection fits in the specified array it is returned therein . Otherwise a new array is allocated with the runtime type of the specified array and the size of this collection ."}}
{"translation": {"code": "public void setArguments ( Term [ ] arguments ) { // Check that there is at least one and at most two arguments. if ( ( arguments == null ) || ( arguments . length < 1 ) || ( arguments . length > 2 ) ) { throw new IllegalArgumentException ( \"An operator has minimum 1 and maximum 2 arguments.\" ) ; } this . arguments = arguments ; this . arity = arguments . length ; }", "nl": "Sets the arguments of this operator . It can be convenient to be able to set the outside of the constructor for example when parsing may want to create the operator first and fill in its arguments later ."}}
{"translation": {"code": "public Fixity getFixity ( ) { switch ( associativity ) { case FX : case FY : return Fixity . Pre ; case XF : case YF : return Fixity . Post ; case XFX : case XFY : case YFX : return Fixity . In ; default : throw new IllegalStateException ( \"Unknown associativity.\" ) ; } }", "nl": "Provides the symbols fixity derived from its associativity ."}}
{"translation": {"code": "public boolean isInfix ( ) { return ( ( associativity == Associativity . XFY ) || ( associativity == Associativity . YFX ) || ( associativity == Associativity . XFX ) ) ; }", "nl": "Reports whether this operator is an infix operator ."}}
{"translation": {"code": "public int compareTo ( Object o ) { OpSymbol opSymbol = ( OpSymbol ) o ; return ( priority < opSymbol . priority ) ? - 1 : ( ( priority > opSymbol . priority ) ? 1 : 0 ) ; }", "nl": "Compares this object with the specified object for order providing a negative integer zero or a positive integer as this symbols priority is less than equal to or greater than the comparator . If this symbol is less than another that means that it has a lower priority value which means that it binds more tightly ."}}
{"translation": {"code": "public void propertyChange ( PropertyChangeEvent event ) { /*log.fine(\"void propertyChange(PropertyChangeEvent): called\");*/ /*log.fine(\"source class = \" + event.getSource().getClass());*/ /*log.fine(\"source object = \" + event.getSource());*/ /*log.fine(\"property name = \" + event.getPropertyName());*/ /*log.fine(\"new value = \" + event.getNewValue());*/ /*log.fine(\"old value = \" + event.getOldValue());*/ Object source = event . getSource ( ) ; Object oldValue = event . getOldValue ( ) ; String propertyName = event . getPropertyName ( ) ; // Check if the event source is an individual screen state if ( source instanceof WorkFlowScreenState ) { WorkFlowScreenState wfsState = ( WorkFlowScreenState ) source ; // Update the buttons to reflect the change in screen state updateButtonsForScreen ( wfsState ) ; } // Check if the event source is the whole work flow if ( source instanceof WorkFlowState ) { WorkFlowState wfState = ( WorkFlowState ) source ; // Check if the event cause is a change in current screen if ( \"currentScreenState\" . equals ( propertyName ) ) { WorkFlowScreenState newScreenState = wfState . getCurrentScreenState ( ) ; WorkFlowScreenState oldScreenState = ( WorkFlowScreenState ) oldValue ; // De-register this as a listener for the old current screen state if ( oldScreenState != null ) { oldScreenState . removePropertyChangeListener ( this ) ; } // Register this as a listener for the new current screen state if ( newScreenState != null ) { newScreenState . addPropertyChangeListener ( this ) ; } // Update the buttons to reflect the current screen state updateButtonsForScreen ( newScreenState ) ; } // Check if the event cause is a change in the work flow state else if ( \"state\" . equals ( propertyName ) ) { // Update the buttons to reflect the change in state updateButtonsForWorkFlow ( wfState ) ; } } }", "nl": "Called when a property in the work flow state is changed ."}}
{"translation": {"code": "public void registerWorkFlowController ( WorkFlowController controller ) { // Set the work flow controller to listen for button events backButton . addActionListener ( controller ) ; nextButton . addActionListener ( controller ) ; finishButton . addActionListener ( controller ) ; cancelButton . addActionListener ( controller ) ; // Register this to listen for changes to the work flow state controller . getWorkFlowState ( ) . addPropertyChangeListener ( this ) ; // Register this to listen for changes to the state for the current screen if it is not null WorkFlowScreenState currentScreenState = controller . getWorkFlowState ( ) . getCurrentScreenState ( ) ; if ( currentScreenState != null ) { currentScreenState . addPropertyChangeListener ( this ) ; } }", "nl": "Registers the work flow button panel with the specified work flow controller . This will cause the work flow controller to receive button press events from the panel and register the button panel to receive state changes from the underlying work flow model ."}}
{"translation": {"code": "public boolean isInstance ( CharSequence value ) { // Check the value is under the maximum if one is set. // Check the value matches the pattern if one is set. return ( ( maxLength <= 0 ) || ( value . length ( ) <= maxLength ) ) && compiledPattern . matcher ( value ) . matches ( ) ; }", "nl": "Checks a string value against this type to see if it is a valid instance of the type ."}}
{"translation": {"code": "public void setPrevAvailable ( boolean avail ) { // Check if the state has changed if ( prevAvailable != avail ) { // Keep the new state prevAvailable = avail ; // Notify any listeners fo the change in state firePropertyChange ( new PropertyChangeEvent ( this , \"prevAvailable\" , ! avail , avail ) ) ; } }", "nl": "Sets the state of the previous available flag and notifies any listeners of this change ."}}
{"translation": {"code": "public Variable getStorageCell ( Variable variable ) { VariableBindingContext < Variable > context = getBindingContext ( ) ; if ( context == null ) { return null ; } else { return context . getStorageCell ( this ) ; } }", "nl": "Provides the storage cell for the specified variable . Some types of variable may defer their storage onto a storage cell other than themselves other variable types may simply return themselves as their own storage cells ."}}
{"translation": {"code": "public void actionPerformed ( ActionEvent event ) { /*log.fine(\"void actionPerformed(ActionEvent): called\");*/ /*log.fine(\"Action is \" + event.getActionCommand());*/ // Check which action was performed String action = event . getActionCommand ( ) ; if ( \"OK\" . equals ( action ) ) { // Check if the state is NOT_SAVED if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { // Save the work saveWork ( ) ; } } else if ( \"Cancel\" . equals ( action ) ) { // Check if the state is NOT_SAVED if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { // Discard the work discardWork ( ) ; } } else if ( \"Apply\" . equals ( action ) ) { // Check if the state is NOT_SAVED if ( state . getState ( ) . equals ( WorkPanelState . NOT_SAVED ) ) { // Save the work saveWork ( ) ; } } }", "nl": "Listens for the button events Ok Cancel and Apply . If the event is Ok or Apply the saveWork method is triggered . If the event is Cancel then the discardWork method is triggered ."}}
{"translation": {"code": "public void setNextAvailable ( boolean avail ) { // Check if the state has changed if ( nextAvailable != avail ) { // Keep the new state nextAvailable = avail ; // Notify any listeners fo the change in state firePropertyChange ( new PropertyChangeEvent ( this , \"nextAvailable\" , ! avail , avail ) ) ; } }", "nl": "Sets the state of the next available flag and notifies any listeners of this change ."}}
{"translation": {"code": "public static long ticksWithMinutesSetTo ( long ticks , int minutes ) { long oldMinutes = ticksToMinutes ( ticks ) ; return ticks - ( oldMinutes * MILLIS_PER_MINUTE ) + ( minutes * MILLIS_PER_MINUTE ) ; }", "nl": "Sets the minutes component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "public static long ticksWithHoursSetTo ( long ticks , int hours ) { long oldHours = ticksToHours ( ticks ) ; return ticks - ( oldHours * MILLIS_PER_HOUR ) + ( hours * MILLIS_PER_HOUR ) ; }", "nl": "Sets the component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "public static long ticksWithYearSetTo ( long ticks , int year ) { int oldYear = ticksToYears ( ticks ) ; return ticks - millisToYearStart ( oldYear ) + millisToYearStart ( year ) ; }", "nl": "Sets the year component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "public static long ticksWithMonthSetTo ( long ticks , int month ) { int year = ticksToYears ( ticks ) ; boolean isLeapYear = isLeapYear ( year ) ; int oldMonth = ticksToMonths ( ticks ) ; return ticks - millisToStartOfMonth ( oldMonth , isLeapYear ) + millisToStartOfMonth ( month , isLeapYear ) ; }", "nl": "Sets the month component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "public static int ticksToYears ( long ticks ) { // The number of years is ticks floor divided by number of milliseconds in 365 1/4 days. //return flooredDiv(ticks, MILLIS_PER_REAL_YEAR) + 1970; //return flooredDiv(ticks + ((long)DAYS_TO_1970 * MILLIS_PER_DAY), MILLIS_PER_REAL_YEAR); long unitMillis = MILLIS_PER_YEAR / 2 ; long i2 = ( ticks >> 1 ) + ( ( 1970L * MILLIS_PER_YEAR ) / 2 ) ; if ( i2 < 0 ) { i2 = i2 - unitMillis + 1 ; } int year = ( int ) ( i2 / unitMillis ) ; long yearStart = millisToYearStart ( year ) ; long diff = ticks - yearStart ; if ( diff < 0 ) { year -- ; } else if ( diff >= ( MILLIS_PER_DAY * 365L ) ) { // One year may need to be added to fix estimate. long oneYear ; if ( isLeapYear ( year ) ) { oneYear = MILLIS_PER_DAY * 366L ; } else { oneYear = MILLIS_PER_DAY * 365L ; } yearStart += oneYear ; if ( yearStart <= ticks ) { year ++ ; } } return year ; }", "nl": "Extracts the years component of a time in millisecond ticks ."}}
{"translation": {"code": "public static int get24BitIntFromBytes ( byte [ ] buf , int offset ) { int i = 0 ; offset ++ ; i += buf [ offset ++ ] & 0xFF ; i += ( ( buf [ offset ++ ] & 0xFF ) << 8 ) ; i += ( ( buf [ offset ] & 0xFF ) << 16 ) ; return i ; }", "nl": "Extracts an int from an array of bytes . Only three bytes are pulled together from the array to make a 24 bit integer albeit returned as a java 32 bit int ."}}
{"translation": {"code": "public static long ticksWithDateSetTo ( long ticks , int date ) { int oldDays = ticksToDate ( ticks ) ; return ticks - ( oldDays * MILLIS_PER_DAY ) + ( date * MILLIS_PER_DAY ) ; }", "nl": "Sets the date component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "public static long millisToYearStart ( int year ) { // Calculate how many leap years elapsed prior to the year in question. int leapYears = year / 100 ; if ( year < 0 ) { leapYears = ( ( year + 3 ) >> 2 ) - leapYears + ( ( leapYears + 3 ) >> 2 ) - 1 ; } else { leapYears = ( year >> 2 ) - leapYears + ( leapYears >> 2 ) ; if ( isLeapYear ( year ) ) { leapYears -- ; } } return ( ( year * 365L ) + leapYears - DAYS_TO_1970 ) * MILLIS_PER_DAY ; }", "nl": "Calculates the number of milliseconds to the start of the specified year taking 1970 as zero ."}}
{"translation": {"code": "private static int getMonthOfYear ( long ticks , int year ) { int i = ( int ) ( ( ticks - millisToYearStart ( year ) ) >> 10 ) ; return ( isLeapYear ( year ) ) ? ( ( i < ( 182 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 91 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 60 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 121 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 152 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 274 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 213 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 244 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 305 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 335 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) : ( ( i < ( 181 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 90 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 31 * MILLIS_PER_DAY_OVER_1024 ) ) ? 1 : ( ( i < ( 59 * MILLIS_PER_DAY_OVER_1024 ) ) ? 2 : 3 ) ) : ( ( i < ( 120 * MILLIS_PER_DAY_OVER_1024 ) ) ? 4 : ( ( i < ( 151 * MILLIS_PER_DAY_OVER_1024 ) ) ? 5 : 6 ) ) ) : ( ( i < ( 273 * MILLIS_PER_DAY_OVER_1024 ) ) ? ( ( i < ( 212 * MILLIS_PER_DAY_OVER_1024 ) ) ? 7 : ( ( i < ( 243 * MILLIS_PER_DAY_OVER_1024 ) ) ? 8 : 9 ) ) : ( ( i < ( 304 * MILLIS_PER_DAY_OVER_1024 ) ) ? 10 : ( ( i < ( 334 * MILLIS_PER_DAY_OVER_1024 ) ) ? 11 : 12 ) ) ) ) ; }", "nl": "Given a millisecond timestamp that lands in a specified year calculate what month the timestamp corresponds to ."}}
{"translation": {"code": "public static short getShortFromBytes ( byte [ ] buf , int offset ) { short result = 0 ; result += buf [ offset ++ ] & 0xFF ; result += ( ( buf [ offset ] ) << 8 ) ; return result ; }", "nl": "Extracts a short from an array of bytes ."}}
{"translation": {"code": "public static long timeOfDayToTicks ( int hour , int minute , int second , int millisecond ) { return millisecond + ( MILLIS_PER_SECOND * second ) + ( MILLIS_PER_MINUTE * minute ) + ( MILLIS_PER_HOUR * hour ) ; }", "nl": "Converts a field by field time of day into millisecond ticks ."}}
{"translation": {"code": "public ByteBlock read ( byte [ ] b ) throws IOException { int count = source . read ( b ) ; return new ByteBlock ( b , count ) ; }", "nl": "Reads some number of bytes from the input stream and stores them into the buffer array b . The bytes are also returned wrapped in a byte block so that they can be returnd over RMI ."}}
{"translation": {"code": "public CallPoint reserveCallPoint ( int name , int length ) { // Work out where the code will go and advance the insertion point beyond its end, so that additional code // will be added beyond the reserved space. int address = getCodeInsertionPoint ( ) ; advanceCodeInsertionPoint ( length ) ; // Create a call point for the reserved space. CallPoint callPoint = new CallPoint ( address , length , name ) ; // Add the call point to the symbol table under the interned name. symbolTable . put ( name , getCallPointSymbolField ( ) , callPoint ) ; return callPoint ; }", "nl": "Reserves a call point for a block of named callable code . The size of the block of code must be known fully in advance . If the named block already has a call point this will replace it with a new one ."}}
{"translation": {"code": "private Integer applyWithEntry ( K key , Entry < K > entry , boolean tryRehashing ) { // Used to hold a new entry if one has to be created, or can re-use an entry passed in as a parameter. Entry < K > uninsertedEntry = entry ; // Holds a flag to indicate that a new sequence number has been taken. boolean createdNewEntry = false ; // Check if there is already an entry for the key, and return it if so. Entry < K > existingEntry = entryForKey ( key ) ; Integer result = null ; if ( existingEntry != null ) { result = existingEntry . seq ; } else { // Create a new entry, if one has not already been created and cached. if ( uninsertedEntry == null ) { uninsertedEntry = new Entry < K > ( ) ; uninsertedEntry . key = key ; uninsertedEntry . seq = nextSequenceNumber ; nextSequenceNumber ++ ; count ++ ; createdNewEntry = true ; result = uninsertedEntry . seq ; } // Attempt to insert the new entry. The sequence number is only incremented when this succeeds for a new // entry. Existing entries that are being re-hashed into a new table will not increment the sequence // number. while ( true ) { // Hash the entry for the current hash functions. int keyHashCode = uninsertedEntry . key . hashCode ( ) ; uninsertedEntry . hash1 = hash1 ( keyHashCode ) ; uninsertedEntry . hash2 = hash2 ( uninsertedEntry . hash1 , keyHashCode ) ; // Try and insert the entry, checking that no entry is left uninserted as a result. uninsertedEntry = cuckoo ( uninsertedEntry ) ; if ( uninsertedEntry == null ) { result = createdNewEntry ? result : - 1 ; break ; } // If the cuckoo algorithm fails then change the hash function/table size and try again. if ( tryRehashing ) { rehash ( ) ; } else { result = null ; break ; } } } return result ; }", "nl": "Looks up the specified key in hash table using cuckoo hashing . If the key cannot be found in the table then the next available sequence number is allocated to it and a new entry is added to the hash table for the key again using cuckoo hashing ."}}
{"translation": {"code": "private Entry < K > entryForKey ( K key ) { int keyHashCode = key . hashCode ( ) ; int hash1 = hash1 ( keyHashCode ) ; Entry < K > entry = hashTable [ indexFor ( hash1 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } int hash2 = hash2 ( hash1 , keyHashCode ) ; entry = hashTable [ indexFor ( hash2 ) ] ; if ( ( entry != null ) && key . equals ( entry . key ) ) { return entry ; } return null ; }", "nl": "Checks if the specified key can be found in the set and returns its entry if so ."}}
{"translation": {"code": "private Entry < K > cuckoo ( Entry < K > entry ) { // Holds the entry currently being placed in the hash table. Entry < K > currentEntry = entry ; // Holds the index into the hash table where the current entry will be placed. int hash = entry . hash1 ; int index = indexFor ( hash ) ; Entry < K > nextEntry = hashTable [ index ] ; int previousFlag = 0 ; int [ ] previousIndex = new int [ 2 ] ; int [ ] previousSeq = new int [ 2 ] ; for ( int i = 0 ; i < hashTableSize ; i ++ ) { // Check the current index, to see if it is an empty slot. If it is an empty slot then the current // entry is placed there and the algorithm completes. if ( nextEntry == null ) { hashTable [ index ] = currentEntry ; return null ; } // If the current index does not point to an empty slot, the current entry is placed there anyway, but the // displaced entry (the egg displaced by the cuckoo) becomes the current entry for placing. hashTable [ index ] = currentEntry ; currentEntry = nextEntry ; // A new index is selected depending on whether the entry is currently at its primary or secondary hashing. int firstPosition = indexFor ( currentEntry . hash1 ) ; hash = ( index == firstPosition ) ? currentEntry . hash2 : currentEntry . hash1 ; index = indexFor ( hash ) ; // A check for infinite loops of size 2 is made here, to circumvent the simplest and most common infinite // looping condition. previousIndex [ previousFlag ] = index ; previousSeq [ previousFlag ] = nextEntry . seq ; previousFlag = ( previousFlag == 1 ) ? 0 : 1 ; nextEntry = hashTable [ index ] ; if ( ( nextEntry != null ) && ( index == previousIndex [ previousFlag ] ) && ( nextEntry . seq == previousSeq [ previousFlag ] ) ) { break ; } } return currentEntry ; }", "nl": "Adds a new entry to a hash table using the cuckoo algorithm ."}}
{"translation": {"code": "private void rehash ( ) { // Increase the table size, to keep the load factory < 0.5. int newSize = hashTableSize ; if ( hashTableSize < ( count * 2 ) ) { newSize = hashTableSize * 2 ; if ( newSize > maxSize ) { throw new IllegalStateException ( \"'newSize' of \" + newSize + \" would put the table over the maximum size limit of \" + maxSize ) ; } } // Keep hold of the old table, until a new one is succesfully buily. Entry < K > [ ] oldTable = hashTable ; hashTableSize = newSize ; length = hashTable . length ; // Keep rehashing the table until it is succesfully rebuilt. boolean rehashedOk ; do { // Start by assuming that this will work. rehashedOk = true ; // Alter the hash functions. changeHashFunctions ( ) ; // Create a new table from the old one, to rehash everything into. hashTable = ( Entry < K > [ ] ) new Entry [ hashTableSize ] ; for ( Entry < K > entry : oldTable ) { if ( entry != null ) { // Add the entry to the new table, dropping out if this fails. if ( applyWithEntry ( entry . key , entry , false ) == null ) { rehashedOk = false ; break ; } } } } while ( ! rehashedOk ) ; }", "nl": "Creates a new hashtable that is twice the size of the old one then re - hashes everything from the old table into the new table ."}}
{"translation": {"code": "public static void write24BitIntToByteArray ( byte [ ] buf , int offset , int value ) { buf [ offset ++ ] = ( byte ) ( value & 0x000000ff ) ; buf [ offset ++ ] = ( byte ) ( ( value & 0x0000ff00 ) >> 8 ) ; buf [ offset ] = ( byte ) ( ( value & 0x00ff0000 ) >> 16 ) ; }", "nl": "Outputs an int into a byte array copying only the bottom 24 bits of the integer . The top sign bit is lost by this operation so this only works on positive ints below 2^24 ."}}
{"translation": {"code": "public static long ticksWithSecondsSetTo ( long ticks , int seconds ) { long oldSeconds = ticksToSeconds ( ticks ) ; return ticks - ( oldSeconds * MILLIS_PER_SECOND ) + ( seconds * MILLIS_PER_SECOND ) ; }", "nl": "Sets the seconds component of the timestamp returning the new timestamp with updated component ."}}
{"translation": {"code": "private boolean peekAndConsume ( int kind ) { Token nextToken = tokenSource . peek ( ) ; if ( nextToken . kind == kind ) { try { consumeToken ( kind ) ; } catch ( SourceCodeException e ) { // If the peek ahead kind can not be consumed then something strange has gone wrong so report this // as a bug rather than try to recover from it. throw new IllegalStateException ( e ) ; } return true ; } else { return false ; } }", "nl": "Peeks ahead for the given token type and if one is foudn with that type it is consumed ."}}
{"translation": {"code": "public Directive peekAndConsumeDirective ( ) throws SourceCodeException { if ( peekAndConsumeTrace ( ) ) { return Directive . Trace ; } if ( peekAndConsumeInfo ( ) ) { return Directive . Info ; } if ( peekAndConsumeUser ( ) ) { return Directive . User ; } return null ; }", "nl": "Peeks and consumes the next interactive system directive ."}}
{"translation": {"code": "private ConsoleReader initializeCommandLineReader ( ) throws IOException { ConsoleReader reader = new ConsoleReader ( ) ; reader . setBellEnabled ( false ) ; return reader ; }", "nl": "Sets up the JLine console reader ."}}