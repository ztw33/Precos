{"translation": {"code": "private void printIntroduction ( ) { System . out . println ( \"| LoJiX Prolog.\" ) ; System . out . println ( \"| Copyright The Sett Ltd.\" ) ; System . out . println ( \"| Licensed under the Apache License, Version 2.0.\" ) ; System . out . println ( \"| //www.apache.org/licenses/LICENSE-2.0\" ) ; System . out . println ( ) ; }", "nl": "Prints a welcome message ."}}
{"translation": {"code": "public byte [ ] retrieveCode ( WAMCallPoint callPoint ) { byte [ ] result = new byte [ callPoint . length ] ; codeBuffer . get ( result , callPoint . entryPoint , callPoint . length ) ; return result ; }", "nl": "Extracts the raw byte code from the machine for a given call table entry ."}}
{"translation": {"code": "private boolean unifyConst ( int fn , int addr ) { boolean success ; int deref = deref ( addr ) ; int tag = derefTag ; int val = derefVal ; // case STORE[addr] of switch ( tag ) { case REF : { // <REF, _> : // STORE[addr] <- <CON, c> data . put ( deref , constantCell ( fn ) ) ; // trail(addr) trail ( deref ) ; success = true ; break ; } case CON : { // <CON, c'> : // fail <- (c != c'); success = val == fn ; break ; } default : { // other: fail <- true; success = false ; } } return success ; }", "nl": "A simplified unification algorithm for unifying against a constant ."}}
{"translation": {"code": "private boolean isNonArg ( WAMInstruction instruction ) { SymbolKey symbolKey = instruction . getSymbolKeyReg1 ( ) ; if ( symbolKey != null ) { Boolean nonArgPositionOnly = ( Boolean ) symbolTable . get ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG ) ; if ( TRUE . equals ( nonArgPositionOnly ) ) { return true ; } } return false ; }", "nl": "Checks if the term argument to an instruction was in a non - argument position ."}}
{"translation": {"code": "private void allocatePermanentQueryRegisters ( Term clause , Map < Byte , Integer > varNames ) { // Allocate local variable slots for all variables in a query. QueryRegisterAllocatingVisitor allocatingVisitor = new QueryRegisterAllocatingVisitor ( symbolTable , varNames , null ) ; PositionalTermTraverser positionalTraverser = new PositionalTermTraverserImpl ( ) ; positionalTraverser . setContextChangeVisitor ( allocatingVisitor ) ; TermWalker walker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , positionalTraverser , allocatingVisitor ) ; walker . walk ( clause ) ; }", "nl": "Allocates stack slots to all free variables in a query clause ."}}
{"translation": {"code": "private void displayCompiledPredicate ( Term predicate ) { // Pretty print the clause. StringBuffer result = new StringBuffer ( ) ; PositionalTermVisitor displayVisitor = new WAMCompiledPredicatePrintingVisitor ( interner , symbolTable , result ) ; TermWalkers . positionalWalker ( displayVisitor ) . walk ( predicate ) ; /*log.fine(result.toString());*/ }", "nl": "Pretty prints a compiled predicate ."}}
{"translation": {"code": "private void substituteBuiltIns ( Term clause ) { TermWalker walk = TermWalkers . positionalWalker ( new BuiltInTransformVisitor ( interner , symbolTable , null , builtInTransform ) ) ; walk . walk ( clause ) ; }", "nl": "Substitutes built - ins within a clause with their built - in definitions ."}}
{"translation": {"code": "private void compileQuery ( Clause clause ) throws SourceCodeException { // Used to build up the compiled result in. WAMCompiledQuery result ; // A mapping from top stack frame slots to interned variable names is built up in this. // This is used to track the stack positions that variables in a query are assigned to. Map < Byte , Integer > varNames = new TreeMap < Byte , Integer > ( ) ; // Used to keep track of registers as they are seen during compilation. The first time a variable is seen, // a variable is written onto the heap, subsequent times its value. The first time a functor is seen, // its structure is written onto the heap, subsequent times it is compared with. seenRegisters = new TreeSet < Integer > ( ) ; // This is used to keep track of the next temporary register available to allocate. lastAllocatedTempReg = findMaxArgumentsInClause ( clause ) ; // This is used to keep track of the number of permanent variables. numPermanentVars = 0 ; // This is used to keep track of the allocation slot for the cut level variable, when needed. -1 means it is // not needed, so it is initialized to this. cutLevelVarSlot = - 1 ; // These are used to generate pre and post instructions for the clause, for example, for the creation and // clean-up of stack frames. SizeableList < WAMInstruction > preFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; SizeableList < WAMInstruction > postFixInstructions = new SizeableLinkedList < WAMInstruction > ( ) ; // Find all the free non-anonymous variables in the clause. Set < Variable > freeVars = TermUtils . findFreeNonAnonymousVariables ( clause ) ; Set < Integer > freeVarNames = new TreeSet < Integer > ( ) ; for ( Variable var : freeVars ) { freeVarNames . add ( var . getName ( ) ) ; } // Allocate permanent variables for a query. In queries all variables are permanent so that they are preserved // on the stack upon completion of the query. allocatePermanentQueryRegisters ( clause , varNames ) ; // Gather information about the counts and positions of occurrence of variables and constants within the clause. gatherPositionAndOccurrenceInfo ( clause ) ; result = new WAMCompiledQuery ( varNames , freeVarNames ) ; // Generate the prefix code for the clause. Queries require a stack frames to hold their environment. /*log.fine(\"ALLOCATE \" + numPermanentVars);*/ preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . AllocateN , REG_ADDR , ( byte ) ( numPermanentVars & 0xff ) ) ) ; // Deep cuts require the current choice point to be kept in a permanent variable, so that it can be recovered // once deeper choice points or environments have been reached. if ( cutLevelVarSlot >= 0 ) { /*log.fine(\"GET_LEVEL \"+ cutLevelVarSlot);*/ preFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . GetLevel , STACK_ADDR , ( byte ) cutLevelVarSlot ) ) ; } result . addInstructions ( preFixInstructions ) ; // Compile all of the conjunctive parts of the body of the clause, if there are any. Functor [ ] expressions = clause . getBody ( ) ; // The current query does not have a name, so invent one for it. FunctorName fn = new FunctorName ( \"tq\" , 0 ) ; for ( int i = 0 ; i < expressions . length ; i ++ ) { Functor expression = expressions [ i ] ; boolean isFirstBody = i == 0 ; // Select a non-default built-in implementation to compile the functor with, if it is a built-in. BuiltIn builtIn ; if ( expression instanceof BuiltIn ) { builtIn = ( BuiltIn ) expression ; } else { builtIn = this ; } // The 'isFirstBody' parameter is only set to true, when this is the first functor of a rule, which it // never is for a query. SizeableLinkedList < WAMInstruction > instructions = builtIn . compileBodyArguments ( expression , false , fn , i ) ; result . addInstructions ( expression , instructions ) ; // Queries are never chain rules, and as all permanent variables are preserved, bodies are never called // as last calls. instructions = builtIn . compileBodyCall ( expression , isFirstBody , false , false , numPermanentVars ) ; result . addInstructions ( expression , instructions ) ; } // Generate the postfix code for the clause. /*log.fine(\"DEALLOCATE\");*/ postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Suspend ) ) ; postFixInstructions . add ( new WAMInstruction ( WAMInstruction . WAMInstructionSet . Deallocate ) ) ; result . addInstructions ( postFixInstructions ) ; // Run the optimizer on the output. result = optimizer . apply ( result ) ; displayCompiledQuery ( result ) ; observer . onQueryCompilation ( result ) ; }", "nl": "Compiles a clause as a query . The clause should have no head only a body ."}}
{"translation": {"code": "private boolean isLastBodyTermInArgPositionOnly ( Term var , Functor body ) { return body == symbolTable . get ( var . getSymbolKey ( ) , SymbolTableKeys . SYMKEY_VAR_LAST_ARG_FUNCTOR ) ; }", "nl": "Checks if a variable is appearing within the last body functor in which it occurs and only does so within argument position ."}}
{"translation": {"code": "protected void leaveClause ( Clause clause ) { // Remove the set of constants appearing in argument positions, from the set of all constants, to derive // the set of constants that appear in non-argument positions only. constants . keySet ( ) . removeAll ( argumentConstants ) ; // Set the nonArgPosition flag on all symbol keys for all constants that only appear in non-arg positions. for ( List < SymbolKey > symbolKeys : constants . values ( ) ) { for ( SymbolKey symbolKey : symbolKeys ) { symbolTable . put ( symbolKey , SymbolTableKeys . SYMKEY_FUNCTOR_NON_ARG , true ) ; } } }", "nl": "Upon leaving the clause sets the nonArgPosition flag on any constants that need it ."}}
{"translation": {"code": "public static TermWalker simpleWalker ( TermVisitor visitor ) { DepthFirstBacktrackingSearch < Term , Term > search = new DepthFirstBacktrackingSearch < Term , Term > ( ) ; return new TermWalker ( search , new DefaultTraverser ( ) , visitor ) ; }", "nl": "Provides a simple depth first walk over a term ."}}
{"translation": {"code": "private void initialiseSymbolTable ( Term clause ) { // Run the symbol key traverser over the clause, to ensure that all terms have their symbol keys correctly // set up. SymbolKeyTraverser symbolKeyTraverser = new SymbolKeyTraverser ( interner , symbolTable , null ) ; symbolKeyTraverser . setContextChangeVisitor ( symbolKeyTraverser ) ; TermWalker symWalker = new TermWalker ( new DepthFirstBacktrackingSearch < Term , Term > ( ) , symbolKeyTraverser , symbolKeyTraverser ) ; symWalker . walk ( clause ) ; }", "nl": "Runs a symbol key traverser over the clause to be compiled to ensure that all of its terms and sub - terms have their symbol keys initialised ."}}
{"translation": {"code": "public void updateRegisters ( WAMInternalRegisters registers ) { List < PropertyChangeEvent > changes = delta ( this , registers ) ; ip = registers . ip ; hp = registers . hp ; hbp = registers . hbp ; sp = registers . sp ; up = registers . up ; ep = registers . ep ; bp = registers . bp ; b0 = registers . b0 ; trp = registers . trp ; writeMode = registers . writeMode ; notifyChanges ( changes ) ; }", "nl": "Updates the register file with a new set of registers ."}}
{"translation": {"code": "public void terminating ( ) { try { stateLock . writeLock ( ) . lock ( ) ; if ( state == State . Running ) { state = State . Shutdown ; stateChange . signalAll ( ) ; } } finally { stateLock . writeLock ( ) . unlock ( ) ; } }", "nl": "Makes a transaction from the Running state to the Shutdown state or no transition if the current state is not Running ."}}
{"translation": {"code": "private void updatePresentComponentFlags ( ) { hasConsole = componentMap . containsKey ( CONSOLE ) ; hasStatusBar = componentMap . containsKey ( STATUS_BAR ) ; hasLeftBar = componentMap . containsKey ( LEFT_VERTICAL_BAR ) ; hasLeftPane = componentMap . containsKey ( LEFT_PANE ) ; hasRightBar = componentMap . containsKey ( RIGHT_VERTICAL_BAR ) ; hasRightPane = componentMap . containsKey ( RIGHT_PANE ) ; }", "nl": "Keeps the set of flags indicating which window components are present up - to - date ."}}
{"translation": {"code": "private void showRightBar ( ) { // Right vertical bar. Component bar = factory . createGripPanel ( layout . getRightPaneWidthResizer ( ) , true ) ; frame . getContentPane ( ) . add ( bar , DesktopAppLayout . RIGHT_VERTICAL_BAR ) ; }", "nl": "Creates a vertical grip - able bar for adjusting the right panel width ."}}
{"translation": {"code": "private void updateMaxColumnWidth ( int column , int width ) { Integer previousValue = maxColumnSizes . get ( column ) ; if ( previousValue == null ) { maxColumnSizes . put ( column , width ) ; } else if ( previousValue < width ) { maxColumnSizes . put ( column , width ) ; } }", "nl": "Updates the maximum column width for a column of the data table ."}}
{"translation": {"code": "public void setMaxRowHeight ( int row , int height ) { Integer previousValue = maxRowSizes . get ( row ) ; if ( previousValue == null ) { maxRowSizes . put ( row , height ) ; } else if ( previousValue < height ) { maxRowSizes . put ( row , height ) ; } }", "nl": "Updates the maximum row height for a row of the data table ."}}
{"translation": {"code": "private void internalInsert ( char character , int c , int r ) { maxColumn = ( c > maxColumn ) ? c : maxColumn ; maxRow = ( r > maxRow ) ? r : maxRow ; data . put ( ( long ) c , ( long ) r , character ) ; }", "nl": "Inserts a single character into the grid at the specified location . This is a private insert method that does not notify model listeners so that the public insert methods can do that as a separate step ."}}
{"translation": {"code": "private void initializeFontMetrics ( ) { if ( ! fontMetricsInitialized ) { FontMetrics fontMetrics = getFontMetrics ( getFont ( ) ) ; charWidth = fontMetrics . charWidth ( ' ' ) ; charHeight = fontMetrics . getHeight ( ) ; descent = fontMetrics . getDescent ( ) ; fontMetricsInitialized = true ; } }", "nl": "Sets up metrics relating to the size of the font used to display the text grid . This only needs to be done once but this method can be called many times as it is guarded by an initialization flag to prevent these being calculated many times ."}}
{"translation": {"code": "public void doFade ( ColorDelta target , String groupName ) { FadeState fadeState = timers . get ( groupName ) ; // Set up the color interpolator. Iterator < Color > interpolator = new ColorInterpolator ( startColor , endColor , 8 ) . iterator ( ) ; if ( fadeState == null ) { // Create a new fade state for the target group, and a timer to run it. Timer timer = new Timer ( 20 , this ) ; fadeState = new FadeState ( timer , target , interpolator ) ; timers . put ( groupName , fadeState ) ; } else { // Kill any previous fade and replace the target with the new one. fadeState . timer . stop ( ) ; fadeState . target = target ; fadeState . interpolator = interpolator ; } // Iterate to the initial color. Color firstColor = fadeState . interpolator . next ( ) ; fadeState . target . changeColor ( firstColor ) ; // Kick off the fade timer. fadeState . timer . setActionCommand ( groupName ) ; fadeState . timer . setInitialDelay ( 400 ) ; fadeState . timer . start ( ) ; }", "nl": "Requests a color fade against the specified target under a group name ."}}
{"translation": {"code": "private AttributeSet getColumnAttributeOrNull ( int c ) { if ( ( c >= 0 ) && ( c < columnAttributes . size ( ) ) ) { return columnAttributes . get ( c ) ; } else { return null ; } }", "nl": "Gets a columns attribute if possible without overflowing the underlying array ."}}
{"translation": {"code": "private AttributeSet getRowAttributeOrNull ( int r ) { if ( ( r >= 0 ) && ( r < rowAttributes . size ( ) ) ) { return rowAttributes . get ( r ) ; } else { return null ; } }", "nl": "Gets a rows attribute if possible without overflowing the underlying array ."}}
{"translation": {"code": "private void internalInsert ( AttributeSet attributes , int c , int r ) { cellAttributes . put ( ( long ) c , ( long ) r , attributes ) ; }", "nl": "Inserts a set of attributes into the grid at the specified location . This is a private insert method that does not notify model listeners so that the public insert methods can do that as a separate step ."}}
{"translation": {"code": "private void setColumnAttribute ( AttributeSet attributes , int c ) { if ( c >= columnAttributes . size ( ) ) { for ( int i = columnAttributes . size ( ) ; i <= c ; i ++ ) { columnAttributes . add ( null ) ; } } columnAttributes . set ( c , attributes ) ; }", "nl": "Sets a column attribute adding padding to the underlying array as necessary to ensure it is large enough to hold the attribute at the requested position ."}}
{"translation": {"code": "private void renderInstructions ( Iterable < WAMInstruction > instructions , int row , int address ) { for ( WAMInstruction instruction : instructions ) { WAMLabel label = instruction . getLabel ( ) ; labeledTable . put ( ADDRESS , row , String . format ( \"%08X\" , address ) ) ; labeledTable . put ( LABEL , row , ( label == null ) ? \"\" : ( label . toPrettyString ( ) + \":\" ) ) ; labeledTable . put ( MNEMONIC , row , instruction . getMnemonic ( ) . getPretty ( ) ) ; int fieldMask = instruction . getMnemonic ( ) . getFieldMask ( ) ; String arg = \"\" ; for ( int i = 2 ; i < 32 ; i = i * 2 ) { if ( ( fieldMask & i ) != 0 ) { if ( ! \"\" . equals ( arg ) ) { arg += \", \" ; } switch ( i ) { case 2 : arg += Integer . toString ( instruction . getReg1 ( ) ) ; break ; case 4 : arg += Integer . toString ( instruction . getReg2 ( ) ) ; break ; case 8 : FunctorName fn = instruction . getFn ( ) ; if ( fn != null ) { arg += fn . getName ( ) + \"/\" + fn . getArity ( ) ; } break ; case 16 : WAMLabel target1 = instruction . getTarget1 ( ) ; if ( target1 != null ) { arg += target1 . getName ( ) + \"/\" + target1 . getArity ( ) + \"_\" + target1 . getId ( ) ; } break ; } } } labeledTable . put ( ARG_1 , row , arg ) ; row ++ ; address += instruction . sizeof ( ) ; } }", "nl": "Renders disassembled instructions into the code table starting at the specified row and instruction address ."}}
{"translation": {"code": "public void onCodeUpdate ( ByteBuffer codeBuffer , int start , int length , VariableAndFunctorInterner interner , WAMCodeView codeView ) { log . fine ( \"public void onCodeUpdate(ByteBuffer codeBuffer, int start = \" + start + \", int length = \" + length + \", VariableAndFunctorInterner interner, WAMCodeView codeView): called\" ) ; // Take a copy of the new bytecode. copyAndResizeCodeBuffer ( codeBuffer , start , length ) ; // Disassemble the new area of byte code. SizeableList < WAMInstruction > instructions = WAMInstruction . disassemble ( start , length , this . codeBuffer , interner , codeView ) ; // Figure out where to start writing the disassembled code into the table. Map . Entry < Integer , Integer > entry = addressToRow . floorEntry ( start ) ; int firstRow = ( entry == null ) ? 0 : ( entry . getValue ( ) + 1 ) ; int address = start ; int row = firstRow ; // Build the mapping between addresses and rows. for ( WAMInstruction instruction : instructions ) { addressToRow . put ( address , row ) ; rowToAddress . add ( row , address ) ; row ++ ; address += instruction . sizeof ( ) ; } // Render the instructions into the table to be displayed. renderInstructions ( instructions , firstRow , start ) ; }", "nl": "Should be notified every time byte - code is added to the machine ."}}
{"translation": {"code": "public static ComponentFactory createComponentFactory ( String className ) { return ( ComponentFactory ) ReflectionUtils . newInstance ( ReflectionUtils . forName ( className ) ) ; }", "nl": "Creates an instance of the named component factory ."}}
{"translation": {"code": "public String getRequestInfo ( ) { Map info = new TreeMap ( ) ; HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; info . put ( \"authType\" , nullToString ( req . getAuthType ( ) ) ) ; info . put ( \"characterEncoding\" , nullToString ( req . getCharacterEncoding ( ) ) ) ; info . put ( \"contentLength\" , Integer . toString ( req . getContentLength ( ) ) ) ; info . put ( \"contentType\" , nullToString ( req . getContentType ( ) ) ) ; info . put ( \"contextPath\" , nullToString ( req . getContextPath ( ) ) ) ; info . put ( \"pathInfo\" , nullToString ( req . getPathInfo ( ) ) ) ; info . put ( \"protocol\" , nullToString ( req . getProtocol ( ) ) ) ; info . put ( \"queryString\" , nullToString ( req . getQueryString ( ) ) ) ; info . put ( \"remoteAddr\" , nullToString ( req . getRemoteAddr ( ) ) ) ; info . put ( \"remoteHost\" , nullToString ( req . getRemoteHost ( ) ) ) ; info . put ( \"remoteUser\" , nullToString ( req . getRemoteUser ( ) ) ) ; info . put ( \"requestURI\" , nullToString ( req . getRequestURI ( ) ) ) ; info . put ( \"scheme\" , nullToString ( req . getScheme ( ) ) ) ; info . put ( \"serverName\" , nullToString ( req . getServerName ( ) ) ) ; info . put ( \"serverPort\" , Integer . toString ( req . getServerPort ( ) ) ) ; info . put ( \"servletPath\" , nullToString ( req . getServletPath ( ) ) ) ; return toHTMLTable ( \"request properties\" , info ) ; }", "nl": "Returns a String with all basic request information in an HTML table ."}}
{"translation": {"code": "private String toHTMLTable ( String propName , Map values ) { StringBuffer tableSB = new StringBuffer ( ) ; tableSB . append ( \"<tr class=\\\"debug\\\"><th class=\\\"debug\\\">\" ) . append ( propName ) . append ( \"</th></tr>\" ) ; for ( Iterator it = values . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Object o = it . next ( ) ; String key = ( String ) o ; tableSB . append ( \"<tr class=\\\"debug\\\"><td class=\\\"debug\\\">\" ) . append ( key ) . append ( \"</td><td>\" ) . append ( values . get ( key ) ) . append ( \"</td></tr>\" ) ; } return tableSB . toString ( ) ; }", "nl": "Returns an HTML table with all the values of the specified property ."}}
{"translation": {"code": "public void init ( ) { log . fine ( \"public void init(): called\" ) ; // Get the name of the property file resource to load and the application variable name to store it under String propertyResource = getInitParameter ( PROPERTY_RESOURCE ) ; String varName = getInitParameter ( APP_VAR_NAME ) ; log . fine ( \"varName = \" + varName ) ; // Use the default property reader to load the resource Properties properties = DefaultPropertyReader . getProperties ( propertyResource ) ; log . fine ( \"properties = \" + properties ) ; // Store the properties under the specified variable name in the application scope getServletContext ( ) . setAttribute ( varName , properties ) ; }", "nl": "Loads a properties file and stores it in the application context . The property resource name and the application scope variable name are passed as initialization parameters in the servlet config in the web . xml ."}}
{"translation": {"code": "public ActionForward executeWithErrorHandling ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response , ActionErrors errors ) throws Exception { // Get a reference to the session. HttpSession session = request . getSession ( false ) ; // Extract the page form. DynaActionForm pageForm = ( DynaActionForm ) form ; log . fine ( \"pageForm = \" + pageForm ) ; // Get the paged list object from the session. String listingVarName = pageForm . getString ( VAR_NAME_PARAM ) ; log . fine ( \"listingVarName = \" + listingVarName ) ; PagedList pagedList = ( PagedList ) session . getAttribute ( listingVarName ) ; // Set its current page. pagedList . setCurrentPage ( ( Integer ) pageForm . get ( NUMBER_PARAM ) ) ; // Set its index offset if one is specified. Integer index = ( Integer ) pageForm . get ( INDEX_PARAM ) ; if ( index != null ) { pagedList . setCurrentIndex ( index ) ; } // Forward to the success location. return mapping . findForward ( SUCCESS_FORWARD ) ; }", "nl": "Updates the current page or index offset of a paged list in the session scope ."}}
{"translation": {"code": "public String getUserPrincipal ( ) { // Create a hash table to hold the results in Map info = new TreeMap ( ) ; // Extract the request from the page context HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; // Get the principal from the request Principal principal = request . getUserPrincipal ( ) ; // Check if there is a principal if ( principal != null ) { info . put ( \"principal name\" , principal . getName ( ) ) ; } else { info . put ( \"principal name\" , \"no principal\" ) ; } // Convert the results to an HTML table return toHTMLTable ( \"container security\" , info ) ; }", "nl": "Returns the user principal name ."}}
{"translation": {"code": "public void write ( String str , int off , int len ) throws IOException { // Get just the portion of the input string to display String inputString = str . substring ( off , off + len ) ; StringBuffer outputString = new StringBuffer ( ) ; // Build a string tokenizer that uses '\\n' as its splitting character // Cycle through all tokens for ( StringTokenizer tokenizer = new StringTokenizer ( inputString , \"\\n\" , true ) ; tokenizer . hasMoreTokens ( ) ; ) { // Replace '\\n' token with a <br> String nextToken = tokenizer . nextToken ( ) ; if ( \"\\n\" . equals ( nextToken ) ) { outputString . append ( \"<br>\" ) ; } else { outputString . append ( nextToken ) ; } } // Write out the generated string out . write ( outputString . toString ( ) ) ; }", "nl": "Writes a string of characters to the filtered writer . Any newline characters \\ n are replaced with an HTML break tag &lt ; br&gt ; ."}}
{"translation": {"code": "public String getRequestScope ( ) { Map info = new TreeMap ( ) ; ServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; Enumeration names = req . getAttributeNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Object value = req . getAttribute ( name ) ; info . put ( name , toStringValue ( value ) ) ; } return toHTMLTable ( \"request scope\" , info ) ; }", "nl": "Returns a String with all request scope variables ."}}
{"translation": {"code": "public ActionForward perform ( ActionMapping mapping , ActionForm form , HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { log . fine ( \"perform: called\" ) ; // Reference the SortForm as a SortForm rather than the generic ActionForm SortForm sortForm = ( SortForm ) form ; // Get a reference to the session scope HttpSession session = request . getSession ( ) ; // Get a reference to the application scope ServletContext application = session . getServletContext ( ) ; log . fine ( \"variables in the servlet context: \" ) ; for ( Enumeration e = application . getAttributeNames ( ) ; e . hasMoreElements ( ) ; ) { log . fine ( e . nextElement ( ) . toString ( ) ) ; } // Get a reference to the list to be sorted List list = ( List ) session . getAttribute ( sortForm . getList ( ) ) ; // Get a reference to the comparator from the application scope to use to perform the sort Comparator comparator = ( Comparator ) application . getAttribute ( sortForm . getComparator ( ) ) ; log . fine ( \"comparator = \" + comparator ) ; // Get a reference to the current sort state (if there is one) SortStateBean sortStateBean = ( SortStateBean ) session . getAttribute ( sortForm . getSortState ( ) ) ; // Check if there is no sort state bean and create one if so if ( sortStateBean == null ) { log . fine ( \"There is no sort state bean\" ) ; sortStateBean = new SortStateBean ( ) ; } // Determine whether a forward or reverse sort is to be done // If its reverse sorted, unsorted or not sorted by the current sort property then forward sort it if ( ! sortStateBean . getState ( ) . equals ( SortStateBean . FORWARD ) || ! sortStateBean . getSortProperty ( ) . equals ( sortForm . getSortStateProperty ( ) ) ) { // Sort the list Collections . sort ( list , comparator ) ; // Update the current sort state sortStateBean . setState ( SortStateBean . FORWARD ) ; } // If its already forward sorted then reverse sort it else { // Sort the list Collections . sort ( list , comparator ) ; // Reverse the list Collections . reverse ( list ) ; // Update the current sort state sortStateBean . setState ( SortStateBean . REVERSE ) ; } // Store the sorted list in the variable from which the original list was taken session . setAttribute ( sortForm . getList ( ) , list ) ; // Store the new sort state, setting the property that has been sorted by in the sort state sortStateBean . setSortProperty ( sortForm . getSortStateProperty ( ) ) ; session . setAttribute ( sortForm . getSortState ( ) , sortStateBean ) ; // Forward to the success page return ( mapping . findForward ( \"success\" ) ) ; }", "nl": "Processes the action ."}}
{"translation": {"code": "public void service ( HttpServletRequest request , HttpServletResponse response ) throws IOException { log . fine ( \"void service(HttpServletRequest, HttpServletResponse): called\" ) ; // Read the parameters and attributes from the request String contentType = ( String ) request . getAttribute ( \"contentType\" ) ; String contentDisposition = ( String ) request . getAttribute ( \"contentDisposition\" ) ; InputStream inputStream = ( InputStream ) request . getAttribute ( \"inputStream\" ) ; // Build the response header // response.addHeader(\"Content-disposition\", \"attachment; filename=\" + fileName); if ( contentType != null ) { response . setContentType ( contentType ) ; } if ( contentDisposition != null ) { response . addHeader ( \"Content-disposition\" , contentDisposition ) ; } // response.setContentLength((int)f.length()); // Create a stream to write the data out to BufferedOutputStream outputStream = new BufferedOutputStream ( response . getOutputStream ( ) ) ; // Read the entire input stream until no more bytes can be read and write the results into the response // This is done in chunks of 8k at a time. int length = - 1 ; byte [ ] chunk = new byte [ 8192 ] ; while ( ( length = inputStream . read ( chunk ) ) != - 1 ) { outputStream . write ( chunk , 0 , length ) ; } // Clear up any open stream and ensure that they are flushed outputStream . flush ( ) ; inputStream . close ( ) ; }", "nl": "Processes the http request that is directed to this servlet ."}}
{"translation": {"code": "private void renderButton ( boolean render , int page , int index , String openDelim , String url , String text , boolean active ) throws JspException { log . fine ( \"private void renderButton(boolean render, int page, int index, String openDelim, String url, String text, boolean active): called\" ) ; log . fine ( \"render = \" + render ) ; log . fine ( \"page = \" + page ) ; log . fine ( \"index = \" + index ) ; log . fine ( \"openDelim = \" + openDelim ) ; log . fine ( \"url = \" + url ) ; log . fine ( \"text = \" + text ) ; log . fine ( \"active = \" + active ) ; TagUtils tagUtils = TagUtils . getInstance ( ) ; if ( render ) { tagUtils . write ( pageContext , openDelim ) ; // Only render the button as active if the active flag is set. if ( active ) { tagUtils . write ( pageContext , \"<a href=\\\"\" + url + \"?varName=\" + name + \"&number=\" + page + \"&index=\" + index + \"\\\">\" + text + \"</a>\" ) ; } // Render an inactive button. else { tagUtils . write ( pageContext , text ) ; } tagUtils . write ( pageContext , closeDelim ) ; } }", "nl": "Renders a button control as a hyperlink for the page control ."}}
{"translation": {"code": "public String getHeaders ( ) { Map info = new TreeMap ( ) ; HttpServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; Enumeration names = req . getHeaderNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; Enumeration values = req . getHeaders ( name ) ; StringBuffer sb = new StringBuffer ( ) ; boolean first = true ; while ( values . hasMoreElements ( ) ) { if ( ! first ) { sb . append ( \" | \" ) ; } first = false ; sb . append ( values . nextElement ( ) ) ; } info . put ( name , sb . toString ( ) ) ; } return toHTMLTable ( \"headers\" , info ) ; }", "nl": "Returns a String with all header information as an HTML table ."}}
{"translation": {"code": "public String getParameters ( ) { Map info = new TreeMap ( ) ; ServletRequest req = ( HttpServletRequest ) pageContext . getRequest ( ) ; Enumeration names = req . getParameterNames ( ) ; while ( names . hasMoreElements ( ) ) { String name = ( String ) names . nextElement ( ) ; String [ ] values = req . getParameterValues ( name ) ; StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < values . length ; i ++ ) { if ( i != 0 ) { sb . append ( \" | \" ) ; } sb . append ( values [ i ] ) ; } info . put ( name , sb . toString ( ) ) ; } return toHTMLTable ( \"request parameters\" , info ) ; }", "nl": "Returns a String with all request parameter information ."}}
{"translation": {"code": "private void capture ( boolean ignoreNull ) { // Get the class of the object to build a memento for. Class cls = ob . getClass ( ) ; // Iterate through all the public methods of the class including all super-interfaces and super-classes. Method [ ] methods = cls . getMethods ( ) ; for ( Method nextMethod : methods ) { // Get the next method. /*log.fine(\"nextMethod = \" + nextMethod.getName());*/ // Check if the method is a 'getter' method, is public and takes no arguments. String methodName = nextMethod . getName ( ) ; if ( methodName . startsWith ( \"get\" ) && ( methodName . length ( ) >= 4 ) && Character . isUpperCase ( methodName . charAt ( 3 ) ) && Modifier . isPublic ( nextMethod . getModifiers ( ) ) && ( nextMethod . getParameterTypes ( ) . length == 0 ) ) { String propName = Character . toLowerCase ( methodName . charAt ( 3 ) ) + methodName . substring ( 4 ) ; /*log.fine(methodName + \" is a valid getter method for the property \" + propName + \".\");*/ try { // Call the 'getter' method to extract the properties value. Object [ ] params = new Object [ ] { } ; Object value = nextMethod . invoke ( ob , params ) ; /*log.fine(\"The result of calling the getter method is: \" + value);*/ // Store the property value for the object. if ( ! ignoreNull || ( value != null ) ) { values . put ( propName , value ) ; } } catch ( IllegalAccessException e ) { /*log.log(java.util.logging.Level.FINE, \"IllegalAccessException during call to getter method.\", e);*/ throw new IllegalStateException ( e ) ; } catch ( InvocationTargetException e ) { /*log.log(java.util.logging.Level.FINE, \"InvocationTargetException during call to getter method.\", e);*/ throw new IllegalStateException ( e ) ; } } // Should also check if the method is a 'setter' method, is public and takes exactly one argument. } }", "nl": "Captures the fields of the associated object ."}}