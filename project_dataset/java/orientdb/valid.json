{"translation": {"code": "public final void release ( OPointer pointer ) { if ( TRACK ) { pointerMapping . remove ( pointer ) ; } long poolSize = pointersPoolSize . incrementAndGet ( ) ; if ( poolSize > this . poolSize ) { pointersPoolSize . decrementAndGet ( ) ; allocator . deallocate ( pointer ) ; } else { pointersPool . add ( pointer ) ; } }", "nl": "Put buffer which is not used any more back to the pool or frees direct memory if pool is full ."}}
{"translation": {"code": "private Map < String , Set < String > > getMinimalSetOfNodesForShardedQuery ( String localNode , Map < String , Set < String > > clusterMap , Set < String > queryClusters ) { //approximate algorithm, the problem is NP-complete Map < String , Set < String > > result = new LinkedHashMap <> ( ) ; Set < String > uncovered = new HashSet <> ( ) ; uncovered . addAll ( queryClusters ) ; uncovered = uncovered . stream ( ) . filter ( x -> x != null ) . map ( x -> x . toLowerCase ( Locale . ENGLISH ) ) . collect ( Collectors . toSet ( ) ) ; //try local node first Set < String > nextNodeClusters = new HashSet <> ( ) ; Set < String > clustersForNode = clusterMap . get ( localNode ) ; if ( clustersForNode != null ) { nextNodeClusters . addAll ( clustersForNode ) ; } nextNodeClusters . retainAll ( uncovered ) ; if ( nextNodeClusters . size ( ) > 0 ) { result . put ( localNode , nextNodeClusters ) ; uncovered . removeAll ( nextNodeClusters ) ; } while ( uncovered . size ( ) > 0 ) { String nextNode = findItemThatCoversMore ( uncovered , clusterMap ) ; nextNodeClusters = new HashSet <> ( ) ; nextNodeClusters . addAll ( clusterMap . get ( nextNode ) ) ; nextNodeClusters . retainAll ( uncovered ) ; if ( nextNodeClusters . size ( ) == 0 ) { throw new OCommandExecutionException ( \"Cannot execute a sharded query: clusters [\" + uncovered . stream ( ) . collect ( Collectors . joining ( \", \" ) ) + \"] are not present on any node\" + \"\\n [\" + clusterMap . entrySet ( ) . stream ( ) . map ( x -> \"\" + x . getKey ( ) + \":(\" + x . getValue ( ) . stream ( ) . collect ( Collectors . joining ( \",\" ) ) + \")\" ) . collect ( Collectors . joining ( \", \" ) ) + \"]\" ) ; } result . put ( nextNode , nextNodeClusters ) ; uncovered . removeAll ( nextNodeClusters ) ; } return result ; }", "nl": "given a cluster map and a set of clusters involved in a query tries to calculate the minimum number of nodes that will have to be involved in the query execution with clusters involved for each node ."}}
{"translation": {"code": "public void rollback ( final OMicroTransaction microTransaction ) { try { checkOpenness ( ) ; stateLock . acquireReadLock ( ) ; try { try { checkOpenness ( ) ; if ( transaction . get ( ) == null ) { return ; } if ( transaction . get ( ) . getMicroTransaction ( ) . getId ( ) != microTransaction . getId ( ) ) { throw new OStorageException ( \"Passed in and active micro-transaction are different micro-transactions. Passed in micro-transaction cannot be \" + \"rolled back.\" ) ; } makeStorageDirty ( ) ; rollbackStorageTx ( ) ; microTransaction . updateRecordCacheAfterRollback ( ) ; txRollback . incrementAndGet ( ) ; } catch ( final IOException e ) { throw OException . wrapException ( new OStorageException ( \"Error during micro-transaction rollback\" ) , e ) ; } finally { transaction . set ( null ) ; } } finally { stateLock . releaseReadLock ( ) ; } } catch ( final RuntimeException ee ) { throw logAndPrepareForRethrow ( ee ) ; } catch ( final Error ee ) { throw logAndPrepareForRethrow ( ee ) ; } catch ( final Throwable t ) { throw logAndPrepareForRethrow ( t ) ; } }", "nl": "Rollbacks the given micro - transaction ."}}
{"translation": {"code": "public void updateRecordCacheAfterRollback ( ) { final OLocalRecordCache databaseLocalCache = database . getLocalCache ( ) ; for ( ORecordOperation recordOperation : recordOperations . values ( ) ) databaseLocalCache . deleteRecord ( recordOperation . getRecord ( ) . getIdentity ( ) ) ; }", "nl": "Updates the record cache after unsuccessful micro - transaction commit ."}}
{"translation": {"code": "public void rollback ( ) { if ( ! active ) throw error ( \"Inactive micro-transaction on rollback\" ) ; if ( level < 1 ) throw error ( \"Unbalanced micro-transaction, level = \" + level ) ; -- level ; if ( level == 0 ) { active = false ; doRollback ( ) ; } }", "nl": "Rollbacks the micro - transaction if it s a top - level micro - transaction ."}}
{"translation": {"code": "public void updateIdentityAfterRecordCommit ( final ORID oldRid , final ORID newRid ) { if ( oldRid . equals ( newRid ) ) return ; // no change, ignore // XXX: Identity update may mutate the index keys, so we have to identify and reinsert potentially affected index keys to keep // the OTransactionIndexChanges.changesPerKey in a consistent state. final List < KeyChangesUpdateRecord > keyRecordsToReinsert = new ArrayList <> ( ) ; final OIndexManager indexManager = getDatabase ( ) . getMetadata ( ) . getIndexManager ( ) ; for ( Map . Entry < String , OTransactionIndexChanges > entry : indexOperations . entrySet ( ) ) { final OIndex < ? > index = indexManager . getIndex ( entry . getKey ( ) ) ; if ( index == null ) throw new OTransactionException ( \"Cannot find index '\" + entry . getValue ( ) + \"' while committing transaction\" ) ; final Dependency [ ] fieldRidDependencies = getIndexFieldRidDependencies ( index ) ; if ( ! isIndexMayDependOnRids ( fieldRidDependencies ) ) continue ; final OTransactionIndexChanges indexChanges = entry . getValue ( ) ; for ( final Iterator < OTransactionIndexChangesPerKey > iterator = indexChanges . changesPerKey . values ( ) . iterator ( ) ; iterator . hasNext ( ) ; ) { final OTransactionIndexChangesPerKey keyChanges = iterator . next ( ) ; if ( isIndexKeyMayDependOnRid ( keyChanges . key , oldRid , fieldRidDependencies ) ) { keyRecordsToReinsert . add ( new KeyChangesUpdateRecord ( keyChanges , indexChanges ) ) ; iterator . remove ( ) ; } } } // Update the identity. final ORecordOperation rec = resolveRecordOperation ( oldRid ) ; if ( rec != null ) { updatedRids . put ( newRid . copy ( ) , oldRid . copy ( ) ) ; if ( ! rec . getRecord ( ) . getIdentity ( ) . equals ( newRid ) ) { ORecordInternal . onBeforeIdentityChanged ( rec . getRecord ( ) ) ; final ORecordId recordId = ( ORecordId ) rec . getRecord ( ) . getIdentity ( ) ; if ( recordId == null ) { ORecordInternal . setIdentity ( rec . getRecord ( ) , new ORecordId ( newRid ) ) ; } else { recordId . setClusterPosition ( newRid . getClusterPosition ( ) ) ; recordId . setClusterId ( newRid . getClusterId ( ) ) ; } ORecordInternal . onAfterIdentityChanged ( rec . getRecord ( ) ) ; } } // Reinsert the potentially affected index keys. for ( KeyChangesUpdateRecord record : keyRecordsToReinsert ) record . indexChanges . changesPerKey . put ( record . keyChanges . key , record . keyChanges ) ; // Update the indexes. final List < OTransactionRecordIndexOperation > transactionIndexOperations = recordIndexOperations . get ( translateRid ( oldRid ) ) ; if ( transactionIndexOperations != null ) { for ( final OTransactionRecordIndexOperation indexOperation : transactionIndexOperations ) { OTransactionIndexChanges indexEntryChanges = indexOperations . get ( indexOperation . index ) ; if ( indexEntryChanges == null ) continue ; final OTransactionIndexChangesPerKey keyChanges ; if ( indexOperation . key == null ) { keyChanges = indexEntryChanges . nullKeyChanges ; } else { keyChanges = indexEntryChanges . changesPerKey . get ( indexOperation . key ) ; } if ( keyChanges != null ) updateChangesIdentity ( oldRid , newRid , keyChanges ) ; } } }", "nl": "Updates the record identity after its successful commit ."}}
{"translation": {"code": "public static void prepareForFileCreationOrReplacement ( Path path , Object requester , String operation ) throws IOException { if ( Files . deleteIfExists ( path ) ) OLogManager . instance ( ) . warn ( requester , \"'%s' deleted while %s\" , path , operation ) ; final Path parent = path . getParent ( ) ; if ( parent != null ) Files . createDirectories ( parent ) ; }", "nl": "Prepares the path for a file creation or replacement . If the file pointed by the path already exists it will be deleted a warning will be emitted to the log in this case . All absent directories along the path will be created ."}}
{"translation": {"code": "private static Set < ORecord > mergeSet ( Set < ORecord > target , Set < ORecord > source ) { if ( source != null ) { if ( target == null ) { return source ; } else { if ( target . size ( ) > source . size ( ) ) { target . addAll ( source ) ; return target ; } else { source . addAll ( target ) ; return source ; } } } else { return target ; } }", "nl": "Merge the two set try to use the optimum case"}}
{"translation": {"code": "public ODocument status ( ) { ODocument status = new ODocument ( ) ; Collection < ODocument > jobs = new ArrayList < ODocument > ( ) ; if ( currentJob != null ) { jobs . add ( currentJob . status ( ) ) ; } status . field ( \"jobs\" , jobs ) ; return status ; }", "nl": "Status of the Running Jobs"}}
{"translation": {"code": "public ODocument status ( ) { synchronized ( listener ) { ODocument status = new ODocument ( ) ; status . field ( \"cfg\" , cfg ) ; status . field ( \"status\" , this . status ) ; String lastBatchLog = \"\" ; if ( this . messageHandler != null ) { lastBatchLog = extractBatchLog ( ) ; } status . field ( \"log\" , lastBatchLog ) ; if ( this . status == Status . FINISHED ) { listener . notifyAll ( ) ; } return status ; } }", "nl": "Single Job Status"}}
{"translation": {"code": "public List < String > getMissingNodes ( ) { synchronousResponsesLock . lock ( ) ; try { final List < String > missingNodes = new ArrayList < String > ( ) ; for ( Map . Entry < String , Object > entry : responses . entrySet ( ) ) if ( entry . getValue ( ) == NO_RESPONSE ) missingNodes . add ( entry . getKey ( ) ) ; return missingNodes ; } finally { synchronousResponsesLock . unlock ( ) ; } }", "nl": "Returns the list of node names that didn t provide a response ."}}
{"translation": {"code": "private boolean computeQuorumResponse ( boolean reachedTimeout ) { if ( quorumResponse != null ) // ALREADY COMPUTED return true ; if ( groupResponsesByResult ) { for ( List < ODistributedResponse > group : responseGroups ) { if ( group . size ( ) >= quorum ) { int responsesForQuorum = 0 ; for ( ODistributedResponse r : group ) { if ( nodesConcurInQuorum . contains ( r . getExecutorNodeName ( ) ) ) { final Object payload = r . getPayload ( ) ; if ( payload instanceof Throwable ) { if ( payload instanceof ODistributedRecordLockedException ) // JUST ONE ODistributedRecordLockedException IS ENOUGH TO FAIL THE OPERATION BECAUSE RESOURCES CANNOT BE LOCKED break ; if ( payload instanceof OConcurrentCreateException ) // JUST ONE OConcurrentCreateException IS ENOUGH TO FAIL THE OPERATION BECAUSE RID ARE DIFFERENT break ; } else if ( ++ responsesForQuorum >= quorum ) { // QUORUM REACHED setQuorumResponse ( r ) ; return true ; } } } } } } else { if ( receivedResponses >= quorum ) { int responsesForQuorum = 0 ; for ( Map . Entry < String , Object > response : responses . entrySet ( ) ) { if ( response . getValue ( ) != NO_RESPONSE && nodesConcurInQuorum . contains ( response . getKey ( ) ) && ++ responsesForQuorum >= quorum ) { // QUORUM REACHED ODistributedResponse resp = ( ODistributedResponse ) response . getValue ( ) ; if ( resp != null && ! ( resp . getPayload ( ) instanceof Throwable ) ) setQuorumResponse ( resp ) ; return true ; } } } } return false ; }", "nl": "Computes the quorum response if possible by returning true and setting the field quorumResponse with the ODistributedResponse ."}}
{"translation": {"code": "public final void handleJVMError ( final Error e ) { if ( jvmError . compareAndSet ( null , e ) ) { OLogManager . instance ( ) . errorNoDb ( this , \"JVM error was thrown\" , e ) ; } }", "nl": "That is internal method which is called once we encounter any error inside of JVM . In such case we need to restart JVM to avoid any data corruption . Till JVM is not restarted storage will be put in read - only state ."}}
{"translation": {"code": "protected void setTypeInternal ( final OType iType ) { getDatabase ( ) . checkSecurity ( ORule . ResourceGeneric . SCHEMA , ORole . PERMISSION_UPDATE ) ; acquireSchemaWriteLock ( ) ; try { if ( iType == globalRef . getType ( ) ) // NO CHANGES return ; if ( ! iType . getCastable ( ) . contains ( globalRef . getType ( ) ) ) throw new IllegalArgumentException ( \"Cannot change property type from \" + globalRef . getType ( ) + \" to \" + iType ) ; this . globalRef = owner . owner . findOrCreateGlobalProperty ( this . globalRef . getName ( ) , iType ) ; } finally { releaseSchemaWriteLock ( ) ; } }", "nl": "Change the type . It checks for compatibility between the change of type ."}}
{"translation": {"code": "public void attach ( final Object self ) throws IllegalArgumentException , IllegalAccessException , NoSuchMethodException , InvocationTargetException { for ( Class < ? > currentClass = self . getClass ( ) ; currentClass != Object . class ; ) { if ( Proxy . class . isAssignableFrom ( currentClass ) ) { currentClass = currentClass . getSuperclass ( ) ; continue ; } for ( Field f : currentClass . getDeclaredFields ( ) ) { final String fieldName = f . getName ( ) ; final Class < ? > declaringClass = f . getDeclaringClass ( ) ; if ( OObjectEntitySerializer . isTransientField ( declaringClass , fieldName ) || OObjectEntitySerializer . isVersionField ( declaringClass , fieldName ) || OObjectEntitySerializer . isIdField ( declaringClass , fieldName ) ) continue ; Object value = OObjectEntitySerializer . getFieldValue ( f , self ) ; value = setValue ( self , fieldName , value ) ; OObjectEntitySerializer . setFieldValue ( f , self , value ) ; } currentClass = currentClass . getSuperclass ( ) ; if ( currentClass == null || currentClass . equals ( ODocument . class ) ) // POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER // ODOCUMENT FIELDS currentClass = Object . class ; } }", "nl": "Method that attaches all data contained in the object to the associated document"}}
{"translation": {"code": "public OExecutionStepInternal executeFull ( ) { for ( int i = 0 ; i < steps . size ( ) ; i ++ ) { ScriptLineStep step = steps . get ( i ) ; if ( step . containsReturn ( ) ) { OExecutionStepInternal returnStep = step . executeUntilReturn ( ctx ) ; if ( returnStep != null ) { return returnStep ; } } OResultSet lastResult = step . syncPull ( ctx , 100 ) ; while ( lastResult . hasNext ( ) ) { while ( lastResult . hasNext ( ) ) { lastResult . next ( ) ; } lastResult = step . syncPull ( ctx , 100 ) ; } } return null ; }", "nl": "executes the whole script and returns last statement ONLY if it s a RETURN otherwise it returns null ;"}}
{"translation": {"code": "@ Override public void characters ( char [ ] ch , int start , int length ) throws SAXException { builder . append ( ch , start , length ) ; }", "nl": "Collect up the characters as element s characters may be split across multiple calls . Isn t SAX lovely ..."}}
{"translation": {"code": "public Object toObjectDetermineType ( OResult source , OCommandContext ctx ) { String className = getClassNameForDocument ( ctx ) ; String type = getTypeForDocument ( ctx ) ; if ( className != null || ( type != null && \"d\" . equalsIgnoreCase ( type ) ) ) { return toDocument ( source , ctx , className ) ; } else { return toMap ( source , ctx ) ; } }", "nl": "choosing return type is based on existence of"}}
{"translation": {"code": "private ReadersEntry addState ( ) { final AtomicInteger state = new AtomicInteger ( SRWL_STATE_NOT_READING ) ; final ReadersEntry newEntry = new ReadersEntry ( state ) ; entry . set ( newEntry ) ; readersStateList . add ( state ) ; readersStateArrayRef . set ( null ) ; return newEntry ; }", "nl": "Creates a new ReadersEntry instance for the current thread and its associated AtomicInteger to store the state of the Reader"}}
{"translation": {"code": "protected long nextWithNewCurrentValue ( long currentValue , boolean executeViaDistributed ) throws OSequenceLimitReachedException , ODatabaseException { if ( ! executeViaDistributed ) { //we don't want synchronization on whole method, because called with executeViaDistributed == true //will later call nextWithNewCurrentValue with parameter executeViaDistributed == false //and that will cause deadlock synchronized ( this ) { cacheStart = currentValue ; return nextWork ( ) ; } } else { try { return sendSequenceActionSetAndNext ( currentValue ) ; } catch ( InterruptedException | ExecutionException exc ) { OLogManager . instance ( ) . error ( this , exc . getMessage ( ) , exc , ( Object [ ] ) null ) ; throw new ODatabaseException ( exc . getMessage ( ) ) ; } } }", "nl": "first set new current value then call next"}}
{"translation": {"code": "protected boolean executeOnlyLocally ( final String localNodeName , final ODistributedConfiguration dbCfg , final OCommandExecutor exec , final Collection < String > involvedClusters , final Collection < String > nodes ) { boolean executeLocally = false ; if ( exec . isIdempotent ( ) ) { final int availableNodes = nodes . size ( ) ; // IDEMPOTENT: CHECK IF CAN WORK LOCALLY ONLY int maxReadQuorum ; if ( involvedClusters . isEmpty ( ) ) maxReadQuorum = dbCfg . getReadQuorum ( null , availableNodes , localNodeName ) ; else { maxReadQuorum = 0 ; for ( String cl : involvedClusters ) maxReadQuorum = Math . max ( maxReadQuorum , dbCfg . getReadQuorum ( cl , availableNodes , localNodeName ) ) ; } if ( nodes . contains ( localNodeName ) && maxReadQuorum <= 1 ) executeLocally = true ; } return executeLocally ; } public boolean isLocalEnv ( ) { return localDistributedDatabase == null || dManager == null || distributedConfiguration == null || OScenarioThreadLocal . INSTANCE . isRunModeDistributed ( ) ; } public OStorageOperationResult < ORawBuffer > readRecord  ( final ORecordId iRecordId , final String iFetchPlan , final boolean iIgnoreCache , final boolean prefetchRecords , final ORecordCallback < ORawBuffer > iCallback ) { if ( isLocalEnv ( ) ) { // ALREADY DISTRIBUTED return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; } final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( iRecordId ) ; if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; try { final String clusterName = getClusterNameByRID ( iRecordId ) ; final ODistributedConfiguration dbCfg = distributedConfiguration ; final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; final int availableNodes = nodes . size ( ) ; // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER final String localNodeName = dManager . getLocalNodeName ( ) ; if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { // DON'T REPLICATE return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { @ Override public Object call ( ) throws Exception { return wrapped . readRecord ( iRecordId , iFetchPlan , iIgnoreCache , prefetchRecords , iCallback ) ; } } ) ; } final OReadRecordTask task = ( ( OReadRecordTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordTask . FACTORYID ) ) . init ( iRecordId ) ; // DISTRIBUTE IT final ODistributedResponse response = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) ; final Object dResult = response != null ? response . getPayload ( ) : null ; if ( dResult instanceof ONeedRetryException ) throw ( ONeedRetryException ) dResult ; else if ( dResult instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) dResult ) ; return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) dResult ) ; } catch ( ONeedRetryException e ) { // PASS THROUGH throw e ; } catch ( Exception e ) { handleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , iRecordId ) ; // UNREACHABLE return null ; } } @ Override public OStorageOperationResult < ORawBuffer > readRecordIfVersionIsNotLatest  ( final ORecordId rid , final String fetchPlan , final boolean ignoreCache , final int recordVersion ) throws ORecordNotFoundException { if ( isLocalEnv ( ) ) { return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; } final ORawBuffer memCopy = localDistributedDatabase . getRecordIfLocked ( rid ) ; if ( memCopy != null ) return new OStorageOperationResult < ORawBuffer > ( memCopy ) ; try { final String clusterName = getClusterNameByRID ( rid ) ; final ODistributedConfiguration dbCfg = distributedConfiguration ; final List < String > nodes = dbCfg . getServers ( clusterName , null ) ; final int availableNodes = nodes . size ( ) ; // CHECK IF LOCAL NODE OWNS THE DATA AND READ-QUORUM = 1: GET IT LOCALLY BECAUSE IT'S FASTER final String localNodeName = dManager . getLocalNodeName ( ) ; if ( nodes . isEmpty ( ) || nodes . contains ( dManager . getLocalNodeName ( ) ) && dbCfg . getReadQuorum ( clusterName , availableNodes , localNodeName ) <= 1 ) { // DON'T REPLICATE return ( OStorageOperationResult < ORawBuffer > ) OScenarioThreadLocal . executeAsDistributed ( new Callable ( ) { @ Override public Object call ( ) throws Exception { return wrapped . readRecordIfVersionIsNotLatest ( rid , fetchPlan , ignoreCache , recordVersion ) ; } } ) ; } final OReadRecordIfNotLatestTask task = ( OReadRecordIfNotLatestTask ) dManager . getTaskFactoryManager ( ) . getFactoryByServerNames ( nodes ) . createTask ( OReadRecordIfNotLatestTask . FACTORYID ) ; task . init ( rid , recordVersion ) ; // DISTRIBUTE IT final Object result = dManager . sendRequest ( getName ( ) , Collections . singleton ( clusterName ) , nodes , task , dManager . getNextMessageIdCounter ( ) , EXECUTION_MODE . RESPONSE , null , null , null ) . getPayload ( ) ; if ( result instanceof ONeedRetryException ) throw ( ONeedRetryException ) result ; else if ( result instanceof Exception ) throw OException . wrapException ( new ODistributedException ( \"Error on execution distributed read record\" ) , ( Exception ) result ) ; return new OStorageOperationResult < ORawBuffer > ( ( ORawBuffer ) result ) ; } catch ( ONeedRetryException e ) { // PASS THROUGH throw e ; } catch ( Exception e ) { handleDistributedException ( \"Cannot route read record operation for %s to the distributed node\" , e , rid ) ; // UNREACHABLE return null ; } } @ Override public OStorageOperationResult < Boolean > deleteRecord  ( final ORecordId iRecordId , final int iVersion , final int iMode , final ORecordCallback < Boolean > iCallback ) { // IF is a real delete should be with a tx return wrapped . deleteRecord ( iRecordId , iVersion , iMode , iCallback ) ; }", "nl": "Only idempotent commands that don t involve any other node can be executed locally ."}}
{"translation": {"code": "@ Override public void cancelRepairRecord ( final ORecordId rid ) { if ( ! active ) return ; if ( rid . getClusterPosition ( ) < - 1 ) // SKIP TRANSACTIONAL RIDS return ; // REMOVE THE RECORD TO REPAIR if ( records . remove ( rid ) != null ) // REMOVED recordCanceled . incrementAndGet ( ) ; }", "nl": "Cancel the repair against a record because the update succeed ."}}
{"translation": {"code": "@ Override public void enqueueRepairCluster ( final int clusterId ) { if ( ! active ) return ; if ( clusterId < - 1 ) // SKIP TRANSACTIONAL RIDS return ; recordProcessed . incrementAndGet ( ) ; // ADD CLUSTER TO REPAIR clusters . put ( clusterId , Boolean . TRUE ) ; }", "nl": "Enqueues the request to repair a cluster . The decision about repairing is taken by the timer task ."}}
{"translation": {"code": "@ Override public int getNodesWithStatus ( final Collection < String > iNodes , final String databaseName , final DB_STATUS ... statuses ) { for ( Iterator < String > it = iNodes . iterator ( ) ; it . hasNext ( ) ; ) { final String node = it . next ( ) ; if ( ! isNodeStatusEqualsTo ( node , databaseName , statuses ) ) it . remove ( ) ; } return iNodes . size ( ) ; }", "nl": "Returns the nodes with the requested status ."}}
{"translation": {"code": "@ Override public Object executeOnLocalNode ( final ODistributedRequestId reqId , final ORemoteTask task , final ODatabaseDocumentInternal database ) { if ( database != null && ! ( database . getStorage ( ) instanceof ODistributedStorage ) ) throw new ODistributedException ( \"Distributed storage was not installed for database '\" + database . getName ( ) + \"'. Implementation found: \" + database . getStorage ( ) . getClass ( ) . getName ( ) ) ; final ODistributedAbstractPlugin manager = this ; return OScenarioThreadLocal . executeAsDistributed ( new Callable < Object > ( ) { @ Override public Object call ( ) throws Exception { try { final Object result = task . execute ( reqId , serverInstance , manager , database ) ; if ( result instanceof Throwable && ! ( result instanceof OException ) ) // EXCEPTION ODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing request %d (%s) on local node: \" , ( Throwable ) result , reqId , task ) ; else { // OK final String sourceNodeName = task . getNodeSource ( ) ; if ( database != null ) { final ODistributedDatabaseImpl ddb = getMessageService ( ) . getDatabase ( database . getName ( ) ) ; if ( ddb != null && ! ( result instanceof Throwable ) && task instanceof OAbstractReplicatedTask && ! task . isIdempotent ( ) ) { // UPDATE LSN WITH LAST OPERATION ddb . setLSN ( sourceNodeName , ( ( OAbstractReplicatedTask ) task ) . getLastLSN ( ) , true ) ; // UPDATE LSN WITH LAST LOCAL OPERATION ddb . setLSN ( getLocalNodeName ( ) , ( ( OAbstractPaginatedStorage ) database . getStorage ( ) . getUnderlying ( ) ) . getLSN ( ) , true ) ; } } } return result ; } catch ( InterruptedException e ) { // IGNORE IT ODistributedServerLog . debug ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Interrupted execution on executing distributed request %s on local node: %s\" , e , reqId , task ) ; return e ; } catch ( Exception e ) { if ( ! ( e instanceof OException ) ) ODistributedServerLog . error ( this , nodeName , getNodeNameById ( reqId . getNodeId ( ) ) , DIRECTION . IN , \"Error on executing distributed request %s on local node: %s\" , e , reqId , task ) ; return e ; } } } ) ; }", "nl": "Executes the request on local node . In case of error returns the Exception itself"}}
{"translation": {"code": "protected void initReceiveMessages ( ) throws IOException { messageThread = new Thread ( ( ) -> { while ( ! Thread . interrupted ( ) ) { receiveMessages ( ) ; } } ) ; messageThread . setName ( \"OrientDB_DistributedDiscoveryThread\" ) ; messageThread . setDaemon ( true ) ; messageThread . start ( ) ; }", "nl": "inits the procedure that listens to pings from other servers eg . that discovers other nodes in the network"}}
{"translation": {"code": "public void create ( ) throws IOException { acquireWriteLock ( ) ; try { acquireExclusiveAccess ( ) ; openChannel ( ) ; init ( ) ; setVersion ( OFileClassic . CURRENT_VERSION ) ; version = OFileClassic . CURRENT_VERSION ; initAllocationMode ( ) ; } finally { releaseWriteLock ( ) ; } }", "nl": "Creates the file ."}}
{"translation": {"code": "public void replaceContentWith ( final Path newContentFile ) throws IOException { acquireWriteLock ( ) ; try { close ( ) ; Files . copy ( newContentFile , osFile , StandardCopyOption . REPLACE_EXISTING ) ; open ( ) ; } finally { releaseWriteLock ( ) ; } }", "nl": "Replaces the file content with the content of the provided file ."}}
{"translation": {"code": "private long checkRegions ( final long iOffset , final long iLength ) { acquireReadLock ( ) ; try { if ( iOffset < 0 || iOffset + iLength > size ) { throw new OIOException ( \"You cannot access outside the file size (\" + size + \" bytes). You have requested portion \" + iOffset + \"-\" + ( iOffset + iLength ) + \" bytes. File: \" + this ) ; } return iOffset + HEADER_SIZE ; } finally { releaseReadLock ( ) ; } }", "nl": "ALWAYS ADD THE HEADER SIZE BECAUSE ON THIS TYPE IS ALWAYS NEEDED"}}
{"translation": {"code": "public long countClass ( final String iClassName , final boolean iPolymorphic ) { final OClass cls = getMetadata ( ) . getImmutableSchemaSnapshot ( ) . getClass ( iClassName ) ; if ( cls == null ) throw new IllegalArgumentException ( \"Class '\" + cls + \"' not found in database\" ) ; return countClass ( cls , iPolymorphic ) ; }", "nl": "Returns the number of the records of the class iClassName considering also sub classes if polymorphic is true ."}}
{"translation": {"code": "@ Override public ODatabaseDocumentAbstract activateOnCurrentThread ( ) { final ODatabaseRecordThreadLocal tl = ODatabaseRecordThreadLocal . instance ( ) ; if ( tl != null ) tl . set ( this ) ; return this ; }", "nl": "Activates current database instance on current thread ."}}
{"translation": {"code": "public long countView ( final String viewName ) { final OView cls = getMetadata ( ) . getImmutableSchemaSnapshot ( ) . getView ( viewName ) ; if ( cls == null ) throw new IllegalArgumentException ( \"View '\" + cls + \"' not found in database\" ) ; return countClass ( cls , false ) ; }", "nl": "Returns the number of the records of the class iClassName ."}}
{"translation": {"code": "public OUser createMetadata ( ) { final ODatabaseDocument database = getDatabase ( ) ; OClass identityClass = database . getMetadata ( ) . getSchema ( ) . getClass ( OIdentity . CLASS_NAME ) ; // SINCE 1.2.0 if ( identityClass == null ) identityClass = database . getMetadata ( ) . getSchema ( ) . createAbstractClass ( OIdentity . CLASS_NAME ) ; OClass roleClass = createOrUpdateORoleClass ( database , identityClass ) ; createOrUpdateOUserClass ( database , identityClass , roleClass ) ; // CREATE ROLES AND USERS ORole adminRole = getRole ( ORole . ADMIN ) ; if ( adminRole == null ) { adminRole = createRole ( ORole . ADMIN , ORole . ALLOW_MODES . ALLOW_ALL_BUT ) ; adminRole . addRule ( ORule . ResourceGeneric . BYPASS_RESTRICTED , null , ORole . PERMISSION_ALL ) . save ( ) ; } OUser adminUser = getUser ( OUser . ADMIN ) ; if ( adminUser == null ) { // This will return the global value if a local storage context configuration value does not exist. boolean createDefUsers = getDatabase ( ) . getStorage ( ) . getConfiguration ( ) . getContextConfiguration ( ) . getValueAsBoolean ( OGlobalConfiguration . CREATE_DEFAULT_USERS ) ; if ( createDefUsers ) { adminUser = createUser ( OUser . ADMIN , OUser . ADMIN , adminRole ) ; } } // SINCE 1.2.0 createOrUpdateORestrictedClass ( database ) ; return adminUser ; }", "nl": "Repairs the security structure if broken by creating the ADMIN role and user with default password ."}}
{"translation": {"code": "public OStorageConfigurationImpl load ( final OContextConfiguration configuration ) throws OSerializationException { lock . acquireWriteLock ( ) ; try { initConfiguration ( configuration ) ; final byte [ ] record = storage . readRecord ( CONFIG_RID , null , false , false , null ) . getResult ( ) . buffer ; if ( record == null ) throw new OStorageException ( \"Cannot load database configuration. The database seems corrupted\" ) ; fromStream ( record , 0 , record . length , streamCharset ) ; } finally { lock . releaseWriteLock ( ) ; } return this ; }", "nl": "This method load the record information by the internal cluster segment . It s for compatibility with older database than 0 . 9 . 25 ."}}
{"translation": {"code": "public byte [ ] compress ( String jsonStr ) { if ( jsonStr == null || jsonStr . length ( ) == 0 ) { return null ; } GZIPOutputStream gout = null ; ByteArrayOutputStream baos = null ; try { byte [ ] incoming = jsonStr . getBytes ( \"UTF-8\" ) ; baos = new ByteArrayOutputStream ( ) ; gout = new GZIPOutputStream ( baos , 16384 ) ; // 16KB gout . write ( incoming ) ; gout . finish ( ) ; return baos . toByteArray ( ) ; } catch ( Exception ex ) { OLogManager . instance ( ) . error ( this , \"Error on compressing HTTP response\" , ex ) ; } finally { try { if ( gout != null ) { gout . close ( ) ; } if ( baos != null ) { baos . close ( ) ; } } catch ( Exception ex ) { } } return null ; }", "nl": "Compress content string"}}
{"translation": {"code": "public OEngine getEngine ( final String engineName ) { engineLock . readLock ( ) . lock ( ) ; try { return engines . get ( engineName ) ; } finally { engineLock . readLock ( ) . unlock ( ) ; } }", "nl": "Returns the engine by its name ."}}
{"translation": {"code": "public void endRequest ( final OChannelBinaryAsynchClient iNetwork ) throws IOException { if ( iNetwork == null ) return ; iNetwork . flush ( ) ; iNetwork . releaseWriteLock ( ) ; }", "nl": "Ends the request and unlock the write lock"}}
{"translation": {"code": "private int advanceProbe ( int probe ) { probe ^= probe << 13 ; // xorshift probe ^= probe >>> 17 ; probe ^= probe << 5 ; this . probe . get ( ) . set ( probe ) ; return probe ; }", "nl": "Pseudo - randomly advances and records the given probe value for the given thread ."}}
{"translation": {"code": "private int indexOf ( final int item , final int i ) { long hash = SEED [ i ] * item ; hash += hash >> 32 ; return ( ( int ) hash ) & tableMask ; }", "nl": "Returns the table index for the counter at the specified depth ."}}
{"translation": {"code": "public void interrupt ( final int iChannelId ) { final OClientConnection connection = connections . get ( iChannelId ) ; if ( connection != null ) { final ONetworkProtocol protocol = connection . getProtocol ( ) ; if ( protocol != null ) // INTERRUPT THE NEWTORK MANAGER protocol . softShutdown ( ) ; } }", "nl": "Interrupt the associated network manager ."}}
{"translation": {"code": "public boolean disconnect ( final int iChannelId ) { OLogManager . instance ( ) . debug ( this , \"Disconnecting connection with id=%d\" , iChannelId ) ; final OClientConnection connection = connections . remove ( iChannelId ) ; if ( connection != null ) { OServerPluginHelper . invokeHandlerCallbackOnClientDisconnection ( server , connection ) ; connection . close ( ) ; removeConnectionFromSession ( connection ) ; // CHECK IF THERE ARE OTHER CONNECTIONS for ( Entry < Integer , OClientConnection > entry : connections . entrySet ( ) ) { if ( entry . getValue ( ) . getProtocol ( ) . equals ( connection . getProtocol ( ) ) ) { OLogManager . instance ( ) . debug ( this , \"Disconnected connection with id=%d but are present other active channels\" , iChannelId ) ; return false ; } } OLogManager . instance ( ) . debug ( this , \"Disconnected connection with id=%d, no other active channels found\" , iChannelId ) ; return true ; } OLogManager . instance ( ) . debug ( this , \"Cannot find connection with id=%d\" , iChannelId ) ; return false ; }", "nl": "Disconnects a client connections"}}
{"translation": {"code": "public void kill ( final OClientConnection connection ) { if ( connection != null ) { final ONetworkProtocol protocol = connection . getProtocol ( ) ; try { // INTERRUPT THE NEWTORK MANAGER TOO protocol . interrupt ( ) ; } catch ( Exception e ) { OLogManager . instance ( ) . error ( this , \"Error during interruption of binary protocol\" , e ) ; } disconnect ( connection ) ; // KILL THE NETWORK MANAGER TOO protocol . sendShutdown ( ) ; } }", "nl": "Disconnects and kill the associated network manager ."}}
{"translation": {"code": "private IndexSearchDescriptor buildIndexSearchDescriptorForFulltext ( OCommandContext ctx , OIndex < ? > index , OAndBlock block , OClass clazz ) { List < String > indexFields = index . getDefinition ( ) . getFields ( ) ; OBinaryCondition keyCondition = new OBinaryCondition ( - 1 ) ; OIdentifier key = new OIdentifier ( \"key\" ) ; keyCondition . setLeft ( new OExpression ( key ) ) ; boolean found = false ; OAndBlock blockCopy = block . copy ( ) ; Iterator < OBooleanExpression > blockIterator ; OAndBlock indexKeyValue = new OAndBlock ( - 1 ) ; IndexSearchDescriptor result = new IndexSearchDescriptor ( ) ; result . idx = index ; result . keyCondition = indexKeyValue ; for ( String indexField : indexFields ) { blockIterator = blockCopy . getSubBlocks ( ) . iterator ( ) ; boolean breakHere = false ; boolean indexFieldFound = false ; while ( blockIterator . hasNext ( ) ) { OBooleanExpression singleExp = blockIterator . next ( ) ; if ( singleExp instanceof OContainsTextCondition ) { OExpression left = ( ( OContainsTextCondition ) singleExp ) . getLeft ( ) ; if ( left . isBaseIdentifier ( ) ) { String fieldName = left . getDefaultAlias ( ) . getStringValue ( ) ; if ( indexField . equals ( fieldName ) ) { found = true ; indexFieldFound = true ; OContainsTextCondition condition = new OContainsTextCondition ( - 1 ) ; condition . setLeft ( left ) ; condition . setRight ( ( ( OContainsTextCondition ) singleExp ) . getRight ( ) . copy ( ) ) ; indexKeyValue . getSubBlocks ( ) . add ( condition ) ; blockIterator . remove ( ) ; break ; } } } } if ( breakHere || ! indexFieldFound ) { break ; } } if ( result . keyCondition . getSubBlocks ( ) . size ( ) < index . getDefinition ( ) . getFields ( ) . size ( ) && ! index . supportsOrderedIterations ( ) ) { //hash indexes do not support partial key match return null ; } if ( found ) { result . remainingCondition = blockCopy ; return result ; } return null ; }", "nl": "given a full text index and a flat AND block returns a descriptor on how to process it with an index ( index index key and additional filters to apply after index fetch"}}