{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static ThriftMetaData fromThriftClass ( Class < ? > thriftClass ) { if ( thriftClass != null && TBase . class . isAssignableFrom ( thriftClass ) ) { Class < ? extends TBase < ? , ? > > tClass = ( Class < ? extends TBase < ? , ? > > ) thriftClass ; StructType descriptor = new ThriftSchemaConverter ( ) . toStructType ( tClass ) ; return new ThriftMetaData ( thriftClass . getName ( ) , descriptor ) ; } return null ; }", "nl": "Creates ThriftMetaData from a Thrift - generated class ."}}
{"translation": {"code": "@ Deprecated public static final ParquetMetadata readFooter ( InputFile file , MetadataFilter filter ) throws IOException { ParquetReadOptions options ; if ( file instanceof HadoopInputFile ) { options = HadoopReadOptions . builder ( ( ( HadoopInputFile ) file ) . getConfiguration ( ) ) . withMetadataFilter ( filter ) . build ( ) ; } else { options = ParquetReadOptions . builder ( ) . withMetadataFilter ( filter ) . build ( ) ; } try ( SeekableInputStream in = file . newStream ( ) ) { return readFooter ( file , options , in ) ; } }", "nl": "Reads the meta data block in the footer of the file using provided input stream"}}
{"translation": {"code": "private static Map < String , Class < ? > > getFieldsByName ( Class < ? > recordClass , boolean excludeJava ) { Map < String , Class < ? > > fields = new LinkedHashMap < String , Class < ? > > ( ) ; if ( recordClass != null ) { Class < ? > current = recordClass ; do { if ( excludeJava && current . getPackage ( ) != null && current . getPackage ( ) . getName ( ) . startsWith ( \"java.\" ) ) { break ; // skip java built-in classes } for ( Field field : current . getDeclaredFields ( ) ) { if ( field . isAnnotationPresent ( AvroIgnore . class ) || isTransientOrStatic ( field ) ) { continue ; } AvroName altName = field . getAnnotation ( AvroName . class ) ; Class < ? > existing = fields . put ( altName != null ? altName . value ( ) : field . getName ( ) , field . getType ( ) ) ; if ( existing != null ) { throw new AvroTypeException ( current + \" contains two fields named: \" + field . getName ( ) ) ; } } current = current . getSuperclass ( ) ; } while ( current != null ) ; } return fields ; }", "nl": "this was taken from Avro s ReflectData"}}
{"translation": {"code": "private List < Path > getInputFilesFromDirectory ( FileStatus partitionDir ) throws IOException { FileSystem fs = partitionDir . getPath ( ) . getFileSystem ( conf ) ; FileStatus [ ] inputFiles = fs . listStatus ( partitionDir . getPath ( ) , HiddenFileFilter . INSTANCE ) ; List < Path > input = new ArrayList < Path > ( ) ; for ( FileStatus f : inputFiles ) { input . add ( f . getPath ( ) ) ; } return input ; }", "nl": "Get all parquet files under partition directory ."}}
{"translation": {"code": "private List < Path > getInputFiles ( List < String > input ) throws IOException { List < Path > inputFiles = null ; if ( input . size ( ) == 1 ) { Path p = new Path ( input . get ( 0 ) ) ; FileSystem fs = p . getFileSystem ( conf ) ; FileStatus status = fs . getFileStatus ( p ) ; if ( status . isDir ( ) ) { inputFiles = getInputFilesFromDirectory ( status ) ; } } else { inputFiles = parseInputFiles ( input ) ; } checkParquetFiles ( inputFiles ) ; return inputFiles ; }", "nl": "Get all input files ."}}
{"translation": {"code": "public SchemaMapping map ( Schema arrowSchema , MessageType parquetSchema ) { List < TypeMapping > children = map ( arrowSchema . getFields ( ) , parquetSchema . getFields ( ) ) ; return new SchemaMapping ( arrowSchema , parquetSchema , children ) ; }", "nl": "Maps a Parquet and Arrow Schema For now does not validate primitive type compatibility"}}
{"translation": {"code": "private static Object makeValue ( String string , Schema schema ) { if ( string == null ) { return null ; } try { switch ( schema . getType ( ) ) { case BOOLEAN : return Boolean . valueOf ( string ) ; case STRING : return string ; case FLOAT : return Float . valueOf ( string ) ; case DOUBLE : return Double . valueOf ( string ) ; case INT : return Integer . valueOf ( string ) ; case LONG : return Long . valueOf ( string ) ; case ENUM : // TODO: translate to enum class if ( schema . hasEnumSymbol ( string ) ) { return string ; } else { try { return schema . getEnumSymbols ( ) . get ( Integer . parseInt ( string ) ) ; } catch ( IndexOutOfBoundsException ex ) { return null ; } } case UNION : Object value = null ; for ( Schema possible : schema . getTypes ( ) ) { value = makeValue ( string , possible ) ; if ( value != null ) { return value ; } } return null ; case NULL : return null ; default : // FIXED, BYTES, MAP, ARRAY, RECORD are not supported throw new RecordException ( \"Unsupported field type:\" + schema . getType ( ) ) ; } } catch ( NumberFormatException e ) { // empty string is considered null for numeric types if ( string . isEmpty ( ) ) { return null ; } else { throw e ; } } }", "nl": "Returns a the value as the first matching schema type or null ."}}
{"translation": {"code": "public static boolean nullOk ( Schema schema ) { if ( Schema . Type . NULL == schema . getType ( ) ) { return true ; } else if ( Schema . Type . UNION == schema . getType ( ) ) { for ( Schema possible : schema . getTypes ( ) ) { if ( nullOk ( possible ) ) { return true ; } } } return false ; }", "nl": "Returns whether null is allowed by the schema ."}}
{"translation": {"code": "public static RowRanges calculateRowRanges ( FilterCompat . Filter filter , ColumnIndexStore columnIndexStore , Set < ColumnPath > paths , long rowCount ) { return filter . accept ( new FilterCompat . Visitor < RowRanges > ( ) { @ Override public RowRanges visit ( FilterPredicateCompat filterPredicateCompat ) { try { return filterPredicateCompat . getFilterPredicate ( ) . accept ( new ColumnIndexFilter ( columnIndexStore , paths , rowCount ) ) ; } catch ( MissingOffsetIndexException e ) { LOGGER . info ( e . getMessage ( ) ) ; return RowRanges . createSingle ( rowCount ) ; } } @ Override public RowRanges visit ( UnboundRecordFilterCompat unboundRecordFilterCompat ) { return RowRanges . createSingle ( rowCount ) ; } @ Override public RowRanges visit ( NoOpFilter noOpFilter ) { return RowRanges . createSingle ( rowCount ) ; } } ) ; }", "nl": "Calculates the row ranges containing the indexes of the rows might match the specified filter ."}}
{"translation": {"code": "@ Override public void writeNull ( int repetitionLevel , int definitionLevel ) { if ( DEBUG ) log ( null , repetitionLevel , definitionLevel ) ; repetitionLevel ( repetitionLevel ) ; definitionLevel ( definitionLevel ) ; statistics . incrementNumNulls ( ) ; ++ valueCount ; }", "nl": "Writes the current null value"}}
{"translation": {"code": "public void add ( Statistics < ? > stats ) { if ( stats . hasNonNullValue ( ) ) { nullPages . add ( false ) ; Object min = stats . genericGetMin ( ) ; Object max = stats . genericGetMax ( ) ; addMinMax ( min , max ) ; pageIndexes . add ( nextPageIndex ) ; minMaxSize += sizeOf ( min ) ; minMaxSize += sizeOf ( max ) ; } else { nullPages . add ( true ) ; } nullCounts . add ( stats . getNumNulls ( ) ) ; ++ nextPageIndex ; }", "nl": "Adds the data from the specified statistics to this builder"}}