{"translation": {"code": "private void checkParquetFiles ( List < Path > inputFiles ) throws IOException { if ( inputFiles == null || inputFiles . size ( ) <= 1 ) { throw new IllegalArgumentException ( \"Not enough files to merge\" ) ; } for ( Path inputFile : inputFiles ) { FileSystem fs = inputFile . getFileSystem ( conf ) ; FileStatus status = fs . getFileStatus ( inputFile ) ; if ( status . isDir ( ) ) { throw new IllegalArgumentException ( \"Illegal parquet file: \" + inputFile . toUri ( ) ) ; } } }", "nl": "Check input files basically . ParquetFileReader will throw exception when reading an illegal parquet file ."}}
{"translation": {"code": "public SchemaMapping fromArrow ( Schema arrowSchema ) { List < Field > fields = arrowSchema . getFields ( ) ; List < TypeMapping > parquetFields = fromArrow ( fields ) ; MessageType parquetType = addToBuilder ( parquetFields , Types . buildMessage ( ) ) . named ( \"root\" ) ; return new SchemaMapping ( arrowSchema , parquetType , parquetFields ) ; }", "nl": "Creates a Parquet Schema from an Arrow one and returns the mapping"}}
{"translation": {"code": "public SchemaMapping fromParquet ( MessageType parquetSchema ) { List < Type > fields = parquetSchema . getFields ( ) ; List < TypeMapping > mappings = fromParquet ( fields ) ; List < Field > arrowFields = fields ( mappings ) ; return new SchemaMapping ( new Schema ( arrowFields ) , parquetSchema , mappings ) ; }", "nl": "Creates an Arrow Schema from an Parquet one and returns the mapping"}}
{"translation": {"code": "public InputStream open ( String filename ) throws IOException { if ( STDIN_AS_SOURCE . equals ( filename ) ) { return System . in ; } URI uri = qualifiedURI ( filename ) ; if ( RESOURCE_URI_SCHEME . equals ( uri . getScheme ( ) ) ) { return Resources . getResource ( uri . getRawSchemeSpecificPart ( ) ) . openStream ( ) ; } else { Path filePath = new Path ( uri ) ; // even though it was qualified using the default FS, it may not be in it FileSystem fs = filePath . getFileSystem ( getConf ( ) ) ; return fs . open ( filePath ) ; } }", "nl": "Opens an existing file or resource ."}}
{"translation": {"code": "public void output ( String content , Logger console , String filename ) throws IOException { if ( filename == null || \"-\" . equals ( filename ) ) { console . info ( content ) ; } else { FSDataOutputStream outgoing = create ( filename ) ; try { outgoing . write ( content . getBytes ( StandardCharsets . UTF_8 ) ) ; } finally { outgoing . close ( ) ; } } }", "nl": "Output content to the console or a file ."}}
{"translation": {"code": "@ SafeVarargs private static < E > E coalesce ( E ... objects ) { for ( E object : objects ) { if ( object != null ) { return object ; } } return null ; }", "nl": "Returns the first non - null object that is passed in ."}}
{"translation": {"code": "public static < E extends Exception > void throwIfInstance ( Throwable t , Class < E > excClass ) throws E { if ( excClass . isAssignableFrom ( t . getClass ( ) ) ) { // the throwable is already an exception, so return it throw excClass . cast ( t ) ; } }", "nl": "If the given throwable is an instance of E throw it as an E ."}}
{"translation": {"code": "public static Builder getBuilderForReading ( PrimitiveType type ) { switch ( type . getPrimitiveTypeName ( ) ) { case FLOAT : return new FloatBuilder ( type ) ; case DOUBLE : return new DoubleBuilder ( type ) ; default : return new Builder ( type ) ; } }", "nl": "Returns a builder to create new statistics object . Used to read the statistics from the parquet file ."}}
{"translation": {"code": "void writePage ( ) { if ( valueCount == 0 ) { throw new ParquetEncodingException ( \"writing empty page\" ) ; } this . rowsWrittenSoFar += pageRowCount ; if ( DEBUG ) LOG . debug ( \"write page\" ) ; try { writePage ( pageRowCount , valueCount , statistics , repetitionLevelColumn , definitionLevelColumn , dataColumn ) ; } catch ( IOException e ) { throw new ParquetEncodingException ( \"could not write page for \" + path , e ) ; } repetitionLevelColumn . reset ( ) ; definitionLevelColumn . reset ( ) ; dataColumn . reset ( ) ; valueCount = 0 ; resetStatistics ( ) ; pageRowCount = 0 ; }", "nl": "Writes the current data to a new page in the page store"}}
{"translation": {"code": "public void readValue ( ) { try { if ( ! valueRead ) { binding . read ( ) ; valueRead = true ; } } catch ( RuntimeException e ) { if ( CorruptDeltaByteArrays . requiresSequentialReads ( writerVersion , currentEncoding ) && e instanceof ArrayIndexOutOfBoundsException ) { // this is probably PARQUET-246, which may happen if reading data with // MR because this can't be detected without reading all footers throw new ParquetDecodingException ( \"Read failure possibly due to \" + \"PARQUET-246: try setting parquet.split.files to false\" , new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ) ; } throw new ParquetDecodingException ( format ( \"Can't read value in column %s at value %d out of %d, \" + \"%d out of %d in currentPage. repetition level: \" + \"%d, definition level: %d\" , path , readValues , totalValueCount , readValues - ( endOfPageValueCount - pageValueCount ) , pageValueCount , repetitionLevel , definitionLevel ) , e ) ; } }", "nl": "Reads the value into the binding ."}}