{"translation": {"code": "public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }", "nl": "Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded ."}}
{"translation": {"code": "@ Override public CsrfToken generateToken ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }", "nl": "Generates a new token"}}
{"translation": {"code": "public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }", "nl": "Creates a matcher that matches on the specific method and any of the provided patterns ."}}
{"translation": {"code": "public static ServerWebExchangeMatcher anyExchange ( ) { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher ( ) { @ Override public Mono < MatchResult > matches ( ServerWebExchange exchange ) { return ServerWebExchangeMatcher . MatchResult . match ( ) ; } } ; }", "nl": "Matches any exchange"}}
{"translation": {"code": "private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }", "nl": "Creates a TypeResolverBuilder that performs whitelisting ."}}
{"translation": {"code": "Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else { // Assume it should be a Long type identifier = convertToLong ( identifier ) ; } return identifier ; }", "nl": "Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String ."}}
{"translation": {"code": "public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }", "nl": "Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding ."}}
{"translation": {"code": "protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }", "nl": "Builds the target URL according to the logic defined in the main class Javadoc"}}
{"translation": {"code": "private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }", "nl": "Updates the cached JWK set from the configured URL ."}}
{"translation": {"code": "public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , \"resolveHiddenInputs cannot be null\" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }", "nl": "Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token ."}}
{"translation": {"code": "public void setContextEnvironmentProperties ( Map < String , Object > environment ) { Assert . notEmpty ( environment , \"environment must not be empty\" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }", "nl": "Allows a custom environment properties to be used to create initial LDAP context ."}}
{"translation": {"code": "public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }", "nl": "Configures OAuth 2 . 0 Client support ."}}
{"translation": {"code": "@ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }", "nl": "resolve the argument to inject into the controller parameter ."}}