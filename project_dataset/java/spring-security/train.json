{"translation": {"code": "public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Querying token for series '\" + seriesId + \"' returned no results.\" , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( \"Querying token for series '\" + seriesId + \"' returned more than one value. Series\" + \" should be unique\" ) ; } catch ( DataAccessException e ) { logger . error ( \"Failed to load token for series \" + seriesId , e ) ; } return null ; }", "nl": "Loads the token data for the supplied series identifier ."}}
{"translation": {"code": "public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }", "nl": "Assembles the Distinguished Name that should be used the given username ."}}
{"translation": {"code": "public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( \"No Authentication object set in SecurityContext - returning empty String as Principal\" ) ; return \"\" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( \"Anonymous Authentication, returning empty String as Principal\" ) ; } return \"\" ; } else { throw new IllegalArgumentException ( \"The principal property of the authentication object\" + \"needs to be an LdapUserDetails.\" ) ; } }", "nl": "Get the principals of the logged in user in this case the distinguished name ."}}
{"translation": {"code": "@ RequestMapping ( value = \"/hello.htm\" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( \"hello\" , \"contact\" , rnd ) ; }", "nl": "The public index page used for unauthenticated users ."}}
{"translation": {"code": "public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , \"HttpServletRequest required\" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( false ) ; if ( session != null ) { logger . debug ( \"Invalidating session: \" + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }", "nl": "Requires the request to be passed in ."}}
{"translation": {"code": "public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }", "nl": "Method that is suitable for user with traditional AspectJ - code aspects ."}}
{"translation": {"code": "public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }", "nl": "Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list ."}}
{"translation": {"code": "public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"J2EE roles [\" + j2eeUserRoles + \"] mapped to Granted Authorities: [\" + userGas + \"]\" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }", "nl": "Builds the authentication details object ."}}
{"translation": {"code": "private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; } // Check Spring Compatibility String springVersion = SpringVersion . getVersion ( ) ; String version = getVersion ( ) ; if ( disableChecks ( springVersion , version ) ) { return ; } logger . info ( \"You are running with Spring Security Core \" + version ) ; if ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) { logger . warn ( \"**** You are advised to use Spring \" + minSpringVersion + \" or later with this version. You are running: \" + springVersion ) ; } }", "nl": "Perform version checks with specific min Spring Version"}}
{"translation": {"code": "public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }", "nl": "Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping ."}}
{"translation": {"code": "public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( \"Encoding failed\" , e ) ; } }", "nl": "Get the bytes of the String in UTF - 8 encoded form ."}}
{"translation": {"code": "@ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }", "nl": "Creates the Spring Security Filter Chain"}}
{"translation": {"code": "public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , \"Class required\" ) ; Assert . hasText ( fieldName , \"Field name required\" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) { // Try superclass if ( clazz . getSuperclass ( ) != null ) { return getField ( clazz . getSuperclass ( ) , fieldName ) ; } throw new IllegalStateException ( \"Could not locate field '\" + fieldName + \"' on class \" + clazz ) ; } }", "nl": "Attempts to locate the specified field on the class ."}}
{"translation": {"code": "protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }", "nl": "Removes temporary authentication - related data which may have been stored in the session during the authentication process ."}}
{"translation": {"code": "protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( \"Cookie token did not contain \" + 2 + \" tokens, but contained '\" + Arrays . asList ( cookieTokens ) + \"'\" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException ( \"No persistent token found for series id: \" + presentedSeries ) ; } // We have a match for this user/series combination if ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository . removeUserTokens ( token . getUsername ( ) ) ; throw new CookieTheftException ( messages . getMessage ( \"PersistentTokenBasedRememberMeServices.cookieStolen\" , \"Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack.\" ) ) ; } if ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) { throw new RememberMeAuthenticationException ( \"Remember-me login has expired\" ) ; } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Refreshing persistent login token for user '\" + token . getUsername ( ) + \"', series '\" + token . getSeries ( ) + \"'\" ) ; } PersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; addCookie ( newToken , request , response ) ; } catch ( Exception e ) { logger . error ( \"Failed to update token: \" , e ) ; throw new RememberMeAuthenticationException ( \"Autologin failed due to data access problem\" ) ; } return getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; }", "nl": "Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response ."}}
{"translation": {"code": "protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }", "nl": "Allows test cases to override where application context obtained from ."}}
{"translation": {"code": "@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { logger . debug ( \"Returning random contact\" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }", "nl": "This is a public method ."}}
{"translation": {"code": "protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Failed to bind as \" + userDn + \": \" + cause ) ; } }", "nl": "Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger ."}}
{"translation": {"code": "public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , \"Can't configure anyRequest after itself\" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = true ; return configurer ; }", "nl": "Maps any request ."}}
{"translation": {"code": "private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( \"*\" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( \"*\" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }", "nl": "Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches ."}}
{"translation": {"code": "protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = \"\" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( \"Attempt to switch to user [\" + username + \"]\" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ; // OK, create the switch user token targetUserRequest = createSwitchUserToken ( request , targetUser ) ; if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( \"Switch User Token [\" + targetUserRequest + \"]\" ) ; } // publish event if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) , targetUser ) ) ; } return targetUserRequest ; }", "nl": "Attempt to switch to another user . If the user does not exist or is not active return null ."}}
{"translation": {"code": "@ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }", "nl": "Obtains the configuration attributes explicitly defined against this bean ."}}
{"translation": {"code": "private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , \"RegisteredMethod required\" ) ; Assert . notNull ( attr , \"Configuration attribute required\" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( \"Adding secure method [\" + method + \"] with attributes [\" + attr + \"]\" ) ; } this . methodMap . put ( method , attr ) ; }", "nl": "Add configuration attributes for a secure method ."}}
{"translation": {"code": "protected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( null == current ) { throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noCurrentUser\" , \"No current user associated with this request\" ) ) ; } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication ( current ) ; if ( original == null ) { this . logger . debug ( \"Could not find original user Authentication object!\" ) ; throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( \"SwitchUserFilter.noOriginalAuthentication\" , \"Could not find original Authentication object\" ) ) ; } // get the source user details UserDetails originalUser = null ; Object obj = original . getPrincipal ( ) ; if ( ( obj != null ) && obj instanceof UserDetails ) { originalUser = ( UserDetails ) obj ; } // publish event if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; } return original ; }", "nl": "Attempt to exit from an already switched user ."}}
{"translation": {"code": "@ RequestMapping ( value = \"/secure/add.htm\" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return \"add\" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return \"redirect:/secure/index.htm\" ; }", "nl": "Handles the submission of the contact form creating a new instance if the username and email are valid ."}}
{"translation": {"code": "public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , \"exitUserUrl cannot be empty and must be a valid redirect URL\" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }", "nl": "Set the URL to respond to exit user processing ."}}
{"translation": {"code": "private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = false ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = true ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }", "nl": "Gets the parameter names or null if not found ."}}
{"translation": {"code": "public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( \"Decoding failed\" , e ) ; } }", "nl": "Decode the bytes in UTF - 8 form into a String ."}}
{"translation": {"code": "protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }", "nl": "Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work ."}}
{"translation": {"code": "public String getFirstAttributeValue ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }", "nl": "Returns the first attribute value for a specified attribute"}}
{"translation": {"code": "public List < String > getAttributeValues ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }", "nl": "Returns the values for a specific attribute"}}
{"translation": {"code": "private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }", "nl": "Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix ."}}
{"translation": {"code": "@ RequestMapping ( value = \"/secure/deletePermission.htm\" ) public ModelAndView deletePermission ( @ RequestParam ( \"contactId\" ) long contactId , @ RequestParam ( \"sid\" ) String sid , @ RequestParam ( \"permission\" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( \"contact\" , contact ) ; model . put ( \"sid\" , sidObject ) ; model . put ( \"permission\" , permission ) ; return new ModelAndView ( \"deletePermission\" , \"model\" , model ) ; }", "nl": "Deletes a permission"}}
{"translation": {"code": "@ RequestMapping ( value = \"/secure/addPermission.htm\" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( \"recipients\" , listRecipients ( ) ) ; model . put ( \"permissions\" , listPermissions ( ) ) ; return \"addPermission\" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( \"recipient\" , \"err.recipientExistsForContact\" , \"Addition failure.\" ) ; model . put ( \"recipients\" , listRecipients ( ) ) ; model . put ( \"permissions\" , listPermissions ( ) ) ; return \"addPermission\" ; } return \"redirect:/secure/index.htm\" ; }", "nl": "Handles submission of the add permission form ."}}
{"translation": {"code": "@ RequestMapping ( value = \"/secure/addPermission.htm\" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( \"contactId\" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( \"addPermission\" , addPermission ) ; model . put ( \"recipients\" , listRecipients ( ) ) ; model . put ( \"permissions\" , listPermissions ( ) ) ; return new ModelAndView ( \"addPermission\" , model ) ; }", "nl": "Displays the add permission page for a contact ."}}
{"translation": {"code": "@ RequestMapping ( value = \"/secure/adminPermission.htm\" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( \"contactId\" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( \"contact\" , contact ) ; model . put ( \"acl\" , acl ) ; return new ModelAndView ( \"adminPermission\" , \"model\" , model ) ; }", "nl": "Displays the permission admin page for a particular contact ."}}
{"translation": {"code": "public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }", "nl": "Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined ."}}
{"translation": {"code": "public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return false ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }", "nl": "Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used ."}}
{"translation": {"code": "@ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }", "nl": "Will walk the method inheritance tree to find the most specific declaration applicable ."}}
{"translation": {"code": "protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , false ) ; }", "nl": "Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work ."}}
{"translation": {"code": "private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , \"DocumentDao required\" ) ; Assert . hasText ( username , \"Username required\" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; // Create the home directory first Directory home = new Directory ( username , Directory . ROOT_DIRECTORY ) ; documentDao . create ( home ) ; addPermission ( documentDao , home , username , LEVEL_GRANT_ADMIN ) ; addPermission ( documentDao , home , \"ROLE_USER\" , LEVEL_GRANT_READ ) ; createFiles ( documentDao , home ) ; // Now create the confidential directory Directory confid = new Directory ( \"confidential\" , home ) ; documentDao . create ( confid ) ; addPermission ( documentDao , confid , \"ROLE_USER\" , LEVEL_NEGATE_READ ) ; createFiles ( documentDao , confid ) ; // Now create the shared directory Directory shared = new Directory ( \"shared\" , home ) ; documentDao . create ( shared ) ; addPermission ( documentDao , shared , \"ROLE_USER\" , LEVEL_GRANT_READ ) ; addPermission ( documentDao , shared , \"ROLE_USER\" , LEVEL_GRANT_WRITE ) ; createFiles ( documentDao , shared ) ; } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder . clearContext ( ) ; } }", "nl": "Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared ."}}
{"translation": {"code": "private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }", "nl": "Checks the filter list for possible errors and logs them"}}
{"translation": {"code": "public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , \"GET\" ) . getRequest ( ) ) ) ) ; }", "nl": "Convenience method mainly for testing ."}}
{"translation": {"code": "private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( ) ; } } return null ; }", "nl": "Returns the first filter chain matching the supplied URL ."}}
{"translation": {"code": "private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }", "nl": "Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set ."}}
{"translation": {"code": "protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( \"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , \"Maximum sessions of {0} for this principal exceeded\" ) ) ; } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null ; for ( SessionInformation session : sessions ) { if ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) { leastRecentlyUsed = session ; } } leastRecentlyUsed . expireNow ( ) ; }", "nl": "Allows subclasses to customise behaviour when too many sessions are detected ."}}
{"translation": {"code": "protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }", "nl": "Creates a DN from a group name ."}}
{"translation": {"code": "public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , \"No authentication object found in security context. Can't change current user's password!\" ) ; String username = authentication . getName ( ) ; logger . debug ( \"Changing password for user '\" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }", "nl": "Changes the password for the current user . The username is obtained from the security context ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try { // TODO: Cache UserRegistry object ic = new InitialContext ( ) ; Object objRef = ic . lookup ( USER_REGISTRY ) ; Object userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( \"com.ibm.websphere.security.UserRegistry\" ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Determining WebSphere groups for user \" + securityName + \" using WebSphere UserRegistry \" + userReg ) ; } final Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { securityName } ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Groups for user \" + securityName + \": \" + groups . toString ( ) ) ; } return new ArrayList ( groups ) ; } catch ( Exception e ) { logger . error ( \"Exception occured while looking up groups for user\" , e ) ; throw new RuntimeException ( \"Exception occured while looking up groups for user\" , e ) ; } finally { try { if ( ic != null ) { ic . close ( ) ; } } catch ( NamingException e ) { logger . debug ( \"Exception occured while closing context\" , e ) ; } } }", "nl": "Get the WebSphere group names for the given security name ."}}
{"translation": {"code": "private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Determining Websphere security name for subject \" + subject ) ; } String userSecurityName = null ; if ( subject != null ) { // SEC-803 Object credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; if ( credential != null ) { userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Websphere security name is \" + userSecurityName + \" for subject \" + subject ) ; } return userSecurityName ; }", "nl": "Get the security name for the given subject ."}}
{"translation": {"code": "protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }", "nl": "Provided so that subclasses may configure what is put into the authentication request s details property ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) private static void updateCache ( HashMap cache , Object key , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , value ) ; }", "nl": "Updates cache ."}}
{"translation": {"code": "private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }", "nl": "Parses date with given formatters ."}}
{"translation": {"code": "public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }", "nl": "Gets the current date in HTTP format ."}}
{"translation": {"code": "private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = false ; int n = 1 ; final String prefix = \"login.config.url.\" ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( \"Setting security property [\" + key + \"] to: \" + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }", "nl": "Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property ."}}
{"translation": {"code": "private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( \"parent_directory_id\" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; } Directory directory = new Directory ( rs . getString ( \"directory_name\" ) , parentDirectory ) ; FieldUtils . setProtectedFieldValue ( \"id\" , directory , new Long ( rs . getLong ( \"id\" ) ) ) ; return directory ; } } ) ; }", "nl": "Executes recursive SQL as needed to build a full Directory hierarchy of objects"}}
{"translation": {"code": "public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , \"targetUrlParameter cannot be empty\" ) ; } this . targetUrlParameter = targetUrlParameter ; }", "nl": "If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present ."}}
{"translation": {"code": "protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; } // Check for the parameter and use that if available String targetUrl = null ; if ( targetUrlParameter != null ) { targetUrl = request . getParameter ( targetUrlParameter ) ; if ( StringUtils . hasText ( targetUrl ) ) { logger . debug ( \"Found targetUrlParameter in request: \" + targetUrl ) ; return targetUrl ; } } if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { targetUrl = request . getHeader ( \"Referer\" ) ; logger . debug ( \"Using Referer header: \" + targetUrl ) ; } if ( ! StringUtils . hasText ( targetUrl ) ) { targetUrl = defaultTargetUrl ; logger . debug ( \"Using default Url: \" + targetUrl ) ; } return targetUrl ; }", "nl": "Builds the target URL according to the logic defined in the main class Javadoc ."}}
{"translation": {"code": "public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + \" \" + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }", "nl": "Writes the X - Frame - Options header value overwritting any previous value ."}}
{"translation": {"code": "private static String [ ] hasAnyRole ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = \"ROLE_\" + roles [ i ] ; } return roles ; }", "nl": "Creates a String for specifying that a user requires one of many roles ."}}
{"translation": {"code": "private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }", "nl": "Extracts the cause of the given throwable using an appropriate extractor ."}}
{"translation": {"code": "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }", "nl": "Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled ."}}
{"translation": {"code": "public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , \"userAuthorities cannot be null\" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }", "nl": "Converts an array of GrantedAuthority objects to a Set ."}}
{"translation": {"code": "private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return false ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }", "nl": "Constant time comparison to prevent against timing attacks ."}}
{"translation": {"code": "public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> \"'\" + defaultFailureUrl + \"' is not a valid redirect URL\" ) ; this . defaultFailureUrl = defaultFailureUrl ; }", "nl": "The URL which will be used as the failure destination ."}}
{"translation": {"code": "public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Pre-authenticated entry point called. Rejecting access\" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , \"Access Denied\" ) ; }", "nl": "Always returns a 403 error code to the client ."}}
{"translation": {"code": "private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( \"?\" ) . append ( queryString ) ; } return url . toString ( ) ; }", "nl": "Obtains the web application - specific fragment of the URL ."}}
{"translation": {"code": "protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , \"Unknown ACE class\" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }", "nl": "Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object ."}}
{"translation": {"code": "protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , true ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , true , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }", "nl": "Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null ."}}
{"translation": {"code": "protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , \"Implementation only supports ObjectIdentityImpl\" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , \"Owner is required in this implementation\" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( \"Unable to locate ACL to update\" ) ; } }", "nl": "Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl ."}}
{"translation": {"code": "public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( false ) != null ) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; logger . debug ( \"DefaultSavedRequest added to Session: \" + savedRequest ) ; } } else { logger . debug ( \"Request not saved as configured RequestMatcher did not match\" ) ; } }", "nl": "Stores the current request provided the configuration properties allow it ."}}
{"translation": {"code": "public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }", "nl": "Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded ."}}
{"translation": {"code": "public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }", "nl": "Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded ."}}
{"translation": {"code": "public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return false ; } final Pattern ABSOLUTE_URL = Pattern . compile ( \"\\\\A[a-z0-9.+-]+://.*\" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }", "nl": "Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }", "nl": "Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor ."}}
{"translation": {"code": "protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( \"Creating new persistent login for user \" + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( \"Failed to save persistent token \" , e ) ; } }", "nl": "Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response ."}}
{"translation": {"code": "protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( \"https\" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; } // Fall through to server-side forward with warning message logger . warn ( \"Unable to redirect to HTTPS as no port mapping found for HTTP port \" + serverPort ) ; return null ; }", "nl": "Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page ."}}
{"translation": {"code": "protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; }", "nl": "Sets the cookie on the response ."}}
{"translation": {"code": "protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }", "nl": "Inverse operation of decodeCookie ."}}
{"translation": {"code": "protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }", "nl": "Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path ."}}
{"translation": {"code": "protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) { // Assume it's binary passwordValue = new String ( ( byte [ ] ) passwordValue ) ; } return ( String ) passwordValue ; }", "nl": "Extension point to allow customized creation of the user s password from the attribute stored in the directory ."}}
{"translation": {"code": "private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( \"ROLE_\" ) , ( ) -> role + \" should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead.\" ) ; return \"ROLE_\" + role ; }", "nl": "Creates a String for specifying a user requires a role ."}}
{"translation": {"code": "protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + \"?error\" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + \"?logout\" ) ; } }", "nl": "Updates the default values for authentication ."}}
{"translation": {"code": "public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }", "nl": "Specifies the URL to validate the credentials ."}}
{"translation": {"code": "private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"No pre-authenticated principal found in request\" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"preAuthenticatedPrincipal = \" + principal + \", trying to authenticate\" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }", "nl": "Do the actual authentication for a pre - authenticated user ."}}
{"translation": {"code": "public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Checking secure context token: \" + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }", "nl": "Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated ."}}
{"translation": {"code": "@ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException ( e ) ; } Assert . notNull ( authenticationManager , \"An AuthenticationManager must be set\" ) ; }", "nl": "Check whether all required properties have been set ."}}
{"translation": {"code": "public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( \"Not a valid encryption algorithm\" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( \"Should not happen\" , e ) ; } }", "nl": "Constructs a new Cipher ."}}
{"translation": {"code": "public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }", "nl": "Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities ."}}
{"translation": {"code": "private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; }", "nl": "Registers the springSecurityFilterChain"}}
{"translation": {"code": "private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( \"\" ) ; if ( result . length ( ) == 0 ) { return null ; } // strip off the trailing & only if the artifact was the first query param return result . startsWith ( \"&\" ) ? result . substring ( 1 ) : result ; }", "nl": "If present removes the artifactParameterName and the corresponding value from the query String ."}}
{"translation": {"code": "private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = \"jaas-api-provision\" ; final String DEF_JAAS_API_PROVISION = \"false\" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( \"true\" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }", "nl": "Adds the jaas - api integration filter if required"}}
{"translation": {"code": "private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Using default port of \" + port ) ; } } String url = \"ldap://127.0.0.1:\" + port + \"/\" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( \"userDn\" , \"uid=admin,ou=system\" ) ; contextSource . addPropertyValue ( \"password\" , \"secret\" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( \"org.springframework.security.ldap.server.ApacheDSContainer\" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( \"port\" , port ) ; logger . info ( \"Embedded LDAP server bean definition created for URL: \" + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( \"Only one embedded server bean is allowed per application context\" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }", "nl": "Will be called if no url attribute is supplied ."}}
{"translation": {"code": "private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , \"ACLs are required\" ) ; Assert . notEmpty ( findNow , \"Items to find now required\" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ; // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if ( parentsToLookup . size ( ) > 0 ) { lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; } }", "nl": "Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map ."}}
{"translation": {"code": "private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }", "nl": "We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances ."}}
{"translation": {"code": "public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Searching for entry under DN '\" + ctxBaseDn + \"', base = '\" + searchBaseDn + \"', filter = '\" + filter + \"'\" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , \"No object returned by search, DirContext is not correctly configured\" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Found DN: \" + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( \"Ignoring PartialResultException\" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }", "nl": "Internal method extracted to avoid code duplication in AD search ."}}
{"translation": {"code": "public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { // Escape the params acording to RFC2254 Object [ ] encodedParams = new String [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; } String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; logger . debug ( \"Using filter: \" + formattedFilter ) ; final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; ContextMapper roleMapper = new ContextMapper ( ) { public Object mapFromContext ( Object ctx ) { DirContextAdapter adapter = ( DirContextAdapter ) ctx ; Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; if ( attributeNames == null || attributeNames . length == 0 ) { try { for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; ae . hasMore ( ) ; ) { Attribute attr = ( Attribute ) ae . next ( ) ; extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; } } catch ( NamingException x ) { org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; } } else { for ( String attributeName : attributeNames ) { extractStringAttributeValues ( adapter , record , attributeName ) ; } } record . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; set . add ( record ) ; return null ; } } ; SearchControls ctls = new SearchControls ( ) ; ctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; ctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; search ( base , formattedFilter , ctls , roleMapper ) ; return set ; }", "nl": "Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios ."}}
{"translation": {"code": "public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }", "nl": "Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios ."}}
{"translation": {"code": "public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ; // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter ( attrs , new DistinguishedName ( dn ) , new DistinguishedName ( ctx . getNameInNamespace ( ) ) ) ; } } ) ; }", "nl": "Composes an object from the attributes of the given DN ."}}
{"translation": {"code": "public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = \"(\" + attributeName + \"={0})\" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }", "nl": "Performs an LDAP compare operation of the value of an attribute for a particular directory entry ."}}
{"translation": {"code": "public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }", "nl": "Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided ."}}
{"translation": {"code": "public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }", "nl": "Sets up OpenID attribute exchange for OpenID s matching the specified pattern ."}}
{"translation": {"code": "private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return true ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }", "nl": "Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars ."}}
{"translation": {"code": "@ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Searching for user '\" + username + \"', with user search \" + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( \"User \" + username + \" not found in directory.\" ) ; } // Search should never return multiple results if properly configured, so just // rethrow throw notFound ; } }", "nl": "Return the LdapUserDetails containing the user s information"}}
{"translation": {"code": "private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }", "nl": "Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null ."}}
{"translation": {"code": "private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = \"servlet-api-provision\" ; final String DEF_SERVLET_API_PROVISION = \"true\" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( \"true\" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( \"authenticationManager\" , authenticationManager ) ; } }", "nl": "Adds the servlet - api integration filter if required"}}
{"translation": {"code": "private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }", "nl": "Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used ."}}
{"translation": {"code": "public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }", "nl": "Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered ."}}
{"translation": {"code": "private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , \"The Base DN for the LDAP server must not be null.\" ) ; Assert . notEmpty ( urls , \"At least one LDAP server URL must be provided.\" ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( \"\" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( \"/\" ) ) { providerUrl . append ( \"/\" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( \" \" ) ; } return providerUrl . toString ( ) ; }", "nl": "Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once ."}}
{"translation": {"code": "private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"WebSphere groups: \" + webSphereGroups + \" mapped to Granted Authorities: \" + userGas ) ; } return userGas ; }", "nl": "Get a list of Granted Authorities based on the current user s WebSphere groups ."}}
{"translation": {"code": "protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , \"\" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }", "nl": "Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire ."}}
{"translation": {"code": "protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }", "nl": "Creates the root object for expression evaluation ."}}
{"translation": {"code": "protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"PreAuthenticated WebSphere principal: \" + principal ) ; } return principal ; }", "nl": "Return the WebSphere user name ."}}
{"translation": {"code": "public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }", "nl": "Combine the individual byte arrays into one array ."}}
{"translation": {"code": "private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"proxyReceptorRequest = \" + result ) ; } return result ; }", "nl": "Indicates if the request is elgible to be processed as the proxy receptor ."}}
{"translation": {"code": "private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }", "nl": "Determines if a user is already authenticated ."}}
{"translation": {"code": "public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }", "nl": "Extract a sub array of bytes out of the byte array ."}}
{"translation": {"code": "public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }", "nl": "Map the given array of attributes to Spring Security GrantedAuthorities ."}}
{"translation": {"code": "private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return false ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"proxyTicketRequest = \" + result ) ; } return result ; }", "nl": "Indicates if the request is elgible to process a proxy ticket ."}}
{"translation": {"code": "private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , \"attributes2grantedAuthoritiesMap contains non-String objects as keys\" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }", "nl": "Preprocess the given map to convert all the values to GrantedAuthority collections"}}
{"translation": {"code": "private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"serviceTicketRequest = \" + result ) ; } return result ; }", "nl": "Indicates if the request is elgible to process a service ticket . This method exists for readability ."}}
{"translation": {"code": "protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"requiresAuthentication = \" + result ) ; } return result ; }", "nl": "Overridden to provide proxying capabilities ."}}
{"translation": {"code": "private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }", "nl": "Convert the given value to a collection of Granted Authorities"}}
{"translation": {"code": "private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( \"No UserDetailsService registered.\" ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( \"More than one UserDetailsService registered. Please \" + \"use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements.\" ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }", "nl": "Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two ."}}
{"translation": {"code": "@ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }", "nl": "Populates the users that have been added ."}}
{"translation": {"code": "public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }", "nl": "Default processing of the end tag returning EVAL_PAGE ."}}
{"translation": {"code": "private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( \"Invalid object type: \" + value . getClass ( ) . getName ( ) ) ; } }", "nl": "Convert the given value to a collection of Granted Authorities adding the result to the given result collection ."}}
{"translation": {"code": "@ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }", "nl": "Indicates the URL that the user agent used for this request ."}}
{"translation": {"code": "protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"PreAuthenticated J2EE principal: \" + principal ) ; } return principal ; }", "nl": "Return the J2EE user name ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }", "nl": "Gets a shared Object . Note that object heirarchies are not considered ."}}
{"translation": {"code": "private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , \"UTF-8\" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( \"The Java platform guarantees UTF-8 support, but it seemingly is not present.\" ) ; err . initCause ( e ) ; throw err ; } }", "nl": "Performs URL encoding with UTF - 8"}}
{"translation": {"code": "public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext . login ( ) ; // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet <> ( ) ; // Get the subject principals and pass them to each of the AuthorityGranters Set < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; for ( Principal principal : principals ) { for ( AuthorityGranter granter : this . authorityGranters ) { Set < String > roles = granter . grant ( principal ) ; // If the granter doesn't wish to grant any authorities, it should // return null. if ( ( roles != null ) && ! roles . isEmpty ( ) ) { for ( String role : roles ) { authorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList <> ( authorities ) , loginContext ) ; // Publish the success event publishSuccessEvent ( result ) ; // we're done, return the token. return result ; } catch ( LoginException loginException ) { AuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; publishFailureEvent ( request , ase ) ; throw ase ; } }", "nl": "Attempts to login the user given the Authentication objects principal and credential"}}