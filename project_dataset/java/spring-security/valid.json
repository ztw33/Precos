{"translation": {"code": "private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }", "nl": "Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written ."}}
{"translation": {"code": "protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return false ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return false ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Pre-authenticated principal has changed to \" + principal + \" and will be reauthenticated\" ) ; } return true ; }", "nl": "Determines if the current principal has changed . The default implementation tries"}}
{"translation": {"code": "private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }", "nl": "Creates the shared objects"}}
{"translation": {"code": "public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }", "nl": "Creates a UserDetailsResourceFactoryBean with a resource from the provided String"}}
{"translation": {"code": "public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }", "nl": "Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value"}}
{"translation": {"code": "private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( \"{\" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( \"Couldn't find closing brace for SHA prefix\" ) ; } return encPass . substring ( 0 , secondBrace + 1 ) ; }", "nl": "Returns the hash prefix or null if there isn t one ."}}
{"translation": {"code": "public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }", "nl": "Configures OAuth 2 . 0 Resource Server support ."}}
{"translation": {"code": "private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( \"META-INF/spring-security.versions\" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( \"org.springframework:spring-core\" ) ; }", "nl": "Loads the spring version or null if it cannot be found ."}}
{"translation": {"code": "protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }", "nl": "Updates the default values for access ."}}
{"translation": {"code": "@ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( \"Unsupported algorithm of \" + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }", "nl": "Decode and validate the JWT from its compact claims representation format"}}
{"translation": {"code": "@ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }", "nl": "Extracts the authorities"}}
{"translation": {"code": "private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , \"S256\" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }", "nl": "Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests"}}