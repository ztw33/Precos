{"translation": {"code": "protected ModelNode parseConfig ( XMLExtendedStreamReader reader , ModelElement xmlElement , String key , ModelNode lastNode , List < SimpleAttributeDefinition > attributes , List < ModelNode > addOperations ) throws XMLStreamException { if ( ! reader . getLocalName ( ) . equals ( xmlElement . getName ( ) ) ) { return null ; } ModelNode modelNode = Util . getEmptyOperation ( ADD , null ) ; int attributeCount = reader . getAttributeCount ( ) ; for ( int i = 0 ; i < attributeCount ; i ++ ) { String attributeLocalName = reader . getAttributeLocalName ( i ) ; if ( ModelElement . forName ( attributeLocalName ) == null ) { throw unexpectedAttribute ( reader , i ) ; } } for ( SimpleAttributeDefinition simpleAttributeDefinition : attributes ) { String attributeValue = reader . getAttributeValue ( \"\" , simpleAttributeDefinition . getXmlName ( ) ) ; simpleAttributeDefinition . parseAndSetParameter ( attributeValue , modelNode , reader ) ; } String name = xmlElement . getName ( ) ; if ( key != null ) { name = key ; if ( modelNode . hasDefined ( key ) ) { name = modelNode . get ( key ) . asString ( ) ; } else { String attributeValue = reader . getAttributeValue ( \"\" , key ) ; if ( attributeValue != null ) { name = attributeValue ; } } } modelNode . get ( ModelDescriptionConstants . OP_ADDR ) . set ( lastNode . clone ( ) . get ( OP_ADDR ) . add ( xmlElement . getName ( ) , name ) ) ; addOperations . add ( modelNode ) ; return modelNode ; }", "nl": "Reads a element from the stream considering the parameters ."}}
{"translation": {"code": "private ModelNode createSubsystemRoot ( ) { ModelNode subsystemAddress = new ModelNode ( ) ; subsystemAddress . add ( ModelDescriptionConstants . SUBSYSTEM , FederationExtension . SUBSYSTEM_NAME ) ; subsystemAddress . protect ( ) ; return Util . getEmptyOperation ( ADD , subsystemAddress ) ; }", "nl": "Creates the root subsystem s root address ."}}
{"translation": {"code": "protected static void registerTransformers ( final SubsystemRegistration subsystem ) { ChainedTransformationDescriptionBuilder chained = ResourceTransformationDescriptionBuilder . Factory . createChainedSubystemInstance ( CURRENT_MODEL_VERSION ) ; ModelVersion MODEL_VERSION_EAP64 = ModelVersion . create ( 1 , 4 , 0 ) ; ModelVersion MODEL_VERSION_EAP63 = ModelVersion . create ( 1 , 3 , 0 ) ; //also EAP6.2 ResourceTransformationDescriptionBuilder builder64 = chained . createBuilder ( CURRENT_MODEL_VERSION , MODEL_VERSION_EAP64 ) ; builder64 . getAttributeBuilder ( ) . addRejectCheck ( RejectAttributeChecker . DEFINED , JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID . getDefaultValue ( ) ) , JacORBSubsystemDefinitions . PERSISTENT_SERVER_ID ) . setValueConverter ( new AttributeConverter . DefaultValueAttributeConverter ( JacORBSubsystemDefinitions . INTEROP_CHUNK_RMI_VALUETYPES ) , JacORBSubsystemDefinitions . INTEROP_CHUNK_RMI_VALUETYPES ) ; ResourceTransformationDescriptionBuilder builder63 = chained . createBuilder ( MODEL_VERSION_EAP64 , MODEL_VERSION_EAP63 ) ; builder63 . getAttributeBuilder ( ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORTransportConfigDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORASContextDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , IORSASContextDefinition . ATTRIBUTES . toArray ( new AttributeDefinition [ 0 ] ) ) . end ( ) . rejectChildResource ( IORSettingsDefinition . INSTANCE . getPathElement ( ) ) ; chained . buildAndRegister ( subsystem , new ModelVersion [ ] { MODEL_VERSION_EAP64 , MODEL_VERSION_EAP63 } ) ; }", "nl": "Register the transformers for the 1 . 3 . 0 version ."}}
{"translation": {"code": "private boolean checkJtsEnabled ( final OperationContext context ) { try { final ModelNode jtsNode = context . readResourceFromRoot ( PathAddress . pathAddress ( \"subsystem\" , \"transactions\" ) , false ) . getModel ( ) . get ( \"jts\" ) ; return jtsNode . isDefined ( ) ? jtsNode . asBoolean ( ) : false ; } catch ( NoSuchResourceException ex ) { return false ; } }", "nl": "not necessary ."}}
{"translation": {"code": "public static ModelNode getAttributeValue ( ModelNode operation ) { return operation . hasDefined ( ModelDescriptionConstants . VALUE ) ? operation . get ( ModelDescriptionConstants . VALUE ) : new ModelNode ( ) ; }", "nl": "Returns the attribute value of the specified operation"}}
{"translation": {"code": "public static Map < String , Object > getParameters ( final OperationContext context , final ModelNode config , final Map < String , String > mapping ) throws OperationFailedException { Map < String , String > fromModel = CommonAttributes . PARAMS . unwrap ( context , config ) ; Map < String , Object > parameters = new HashMap <> ( ) ; for ( Map . Entry < String , String > entry : fromModel . entrySet ( ) ) { parameters . put ( mapping . getOrDefault ( entry . getKey ( ) , entry . getKey ( ) ) , entry . getValue ( ) ) ; } return parameters ; }", "nl": "Get the parameters ."}}
{"translation": {"code": "private static Set < String > getAvailableConnectors ( final OperationContext context , final ModelNode operation ) throws OperationFailedException { PathAddress address = PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP_ADDR ) ) ; PathAddress active = MessagingServices . getActiveMQServerPathAddress ( address ) ; Set < String > availableConnectors = new HashSet < String > ( ) ; Resource subsystemResource = context . readResourceFromRoot ( active . getParent ( ) , false ) ; availableConnectors . addAll ( subsystemResource . getChildrenNames ( CommonAttributes . REMOTE_CONNECTOR ) ) ; Resource activeMQServerResource = context . readResourceFromRoot ( active , false ) ; availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . HTTP_CONNECTOR ) ) ; availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . IN_VM_CONNECTOR ) ) ; availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . REMOTE_CONNECTOR ) ) ; availableConnectors . addAll ( activeMQServerResource . getChildrenNames ( CommonAttributes . CONNECTOR ) ) ; return availableConnectors ; }", "nl": "FIXME use capabilities & requirements"}}
{"translation": {"code": "@ Override public void unbind ( String name ) { if ( name == null || name . isEmpty ( ) ) { throw MessagingLogger . ROOT_LOGGER . cannotUnbindJndiName ( ) ; } final ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; ServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; if ( bindingService == null ) { ROOT_LOGGER . debugf ( \"Cannot unbind %s since no binding exists with that name\" , name ) ; return ; } // remove the binding service bindingService . setMode ( ServiceController . Mode . REMOVE ) ; final StabilityMonitor monitor = new StabilityMonitor ( ) ; monitor . addController ( bindingService ) ; try { monitor . awaitStability ( ) ; ROOT_LOGGER . unboundJndiName ( bindInfo . getAbsoluteJndiName ( ) ) ; } catch ( InterruptedException e ) { ROOT_LOGGER . failedToUnbindJndiName ( name , 5 , SECONDS . toString ( ) . toLowerCase ( Locale . US ) ) ; } finally { monitor . removeController ( bindingService ) ; } }", "nl": "Unbind the resource and wait until the corresponding binding service is effectively removed ."}}
{"translation": {"code": "protected void removeJNDIAliases ( OperationContext context , List < ModelNode > entries ) { if ( entries . size ( ) > 1 ) { for ( int i = 1 ; i < entries . size ( ) ; i ++ ) { ContextNames . BindInfo aliasBindInfo = ContextNames . bindInfoFor ( entries . get ( i ) . asString ( ) ) ; context . removeService ( aliasBindInfo . getBinderServiceName ( ) ) ; } } }", "nl": "Remove JNDI alias binder services ."}}
{"translation": {"code": "@ Override public Object lookup ( String name ) { final ContextNames . BindInfo bindInfo = ContextNames . bindInfoFor ( name ) ; ServiceController < ? > bindingService = container . getService ( bindInfo . getBinderServiceName ( ) ) ; if ( bindingService == null ) { return null ; } ManagedReferenceFactory managedReferenceFactory = ManagedReferenceFactory . class . cast ( bindingService . getValue ( ) ) ; return managedReferenceFactory . getReference ( ) . getInstance ( ) ; }", "nl": "SPI contract for this method"}}
{"translation": {"code": "@ Override public void beforeCompletion ( ) { // This is needed to guard against syncs being registered during the run, otherwise we could have used an iterator int lastIndexProcessed = 0 ; while ( ( lastIndexProcessed < preJcaSyncs . size ( ) ) ) { Synchronization preJcaSync = preJcaSyncs . get ( lastIndexProcessed ) ; if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.before_completion - Class: \" + preJcaSync . getClass ( ) + \" HashCode: \" + preJcaSync . hashCode ( ) + \" toString: \" + preJcaSync ) ; } preJcaSync . beforeCompletion ( ) ; lastIndexProcessed = lastIndexProcessed + 1 ; } // Do the same for the jca syncs lastIndexProcessed = 0 ; while ( ( lastIndexProcessed < jcaSyncs . size ( ) ) ) { Synchronization jcaSync = jcaSyncs . get ( lastIndexProcessed ) ; if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.before_completion - Class: \" + jcaSync . getClass ( ) + \" HashCode: \" + jcaSync . hashCode ( ) + \" toString: \" + jcaSync ) ; } jcaSync . beforeCompletion ( ) ; lastIndexProcessed = lastIndexProcessed + 1 ; } }", "nl": "Exceptions from Synchronizations that are registered with this TSR are not trapped for before completion . This is because an error in a Sync here should result in the transaction rolling back ."}}
{"translation": {"code": "public static void setPathAddress ( ModelNode operation , PathAddress address ) { operation . get ( ModelDescriptionConstants . OP_ADDR ) . set ( address . toModelNode ( ) ) ; }", "nl": "Sets the address of the specified operation ."}}
{"translation": {"code": "public void addPostConstructInterceptor ( InterceptorFactory interceptorFactory , int priority ) { postConstructInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; }", "nl": "Adds a post construct interceptor"}}
{"translation": {"code": "public void addPostActivateInterceptor ( InterceptorFactory interceptorFactory , int priority ) { postActivateInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; }", "nl": "Adds a post activate interceptor"}}
{"translation": {"code": "@ Override public boolean doesScopedPersistenceUnitNameIdentifyCacheRegionName ( PersistenceUnitMetadata pu ) { String cacheRegionPrefix = pu . getProperties ( ) . getProperty ( AvailableSettings . CACHE_REGION_PREFIX ) ; return cacheRegionPrefix == null || cacheRegionPrefix . equals ( pu . getScopedPersistenceUnitName ( ) ) ; }", "nl": "determine if management console can display the second level cache entries"}}
{"translation": {"code": "private TransportConfiguration createInVMTransportConfiguration ( OperationContext context ) throws OperationFailedException { final Resource serverResource = context . readResource ( EMPTY_ADDRESS , false ) ; Set < Resource . ResourceEntry > invmConnectors = serverResource . getChildren ( CommonAttributes . IN_VM_CONNECTOR ) ; if ( invmConnectors . isEmpty ( ) ) { throw MessagingLogger . ROOT_LOGGER . noInVMConnector ( ) ; } Resource . ResourceEntry connectorEntry = invmConnectors . iterator ( ) . next ( ) ; Resource connectorResource = context . readResource ( PathAddress . pathAddress ( connectorEntry . getPathElement ( ) ) , false ) ; ModelNode model = connectorResource . getModel ( ) ; Map < String , Object > params = new HashMap <> ( CommonAttributes . PARAMS . unwrap ( context , model ) ) ; params . put ( InVMTransportDefinition . SERVER_ID . getName ( ) , InVMTransportDefinition . SERVER_ID . resolveModelAttribute ( context , model ) . asInt ( ) ) ; TransportConfiguration transportConfiguration = new TransportConfiguration ( InVMConnectorFactory . class . getName ( ) , params ) ; return transportConfiguration ; }", "nl": "The XmlDataImporter requires a connector to connect to the artemis broker ."}}
{"translation": {"code": "private void createIoSubsystem ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , PathAddress baseAddress ) { Resource root = context . readResourceFromRoot ( baseAddress , false ) ; if ( root . getChildrenNames ( SUBSYSTEM ) . contains ( IOExtension . SUBSYSTEM_NAME ) ) { // subsystem is already added, do nothing return ; } //these addresses will be fixed later, no need to use the base address PathAddress address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) ) ; migrationOperations . put ( address , createAddOperation ( address ) ) ; address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"worker\" , \"default\" ) ) ; migrationOperations . put ( address , createAddOperation ( address ) ) ; address = pathAddress ( pathElement ( SUBSYSTEM , IOExtension . SUBSYSTEM_NAME ) , pathElement ( \"buffer-pool\" , \"default\" ) ) ; migrationOperations . put ( address , createAddOperation ( address ) ) ; }", "nl": "We need to create the IO subsystem if it does not already exist"}}
{"translation": {"code": "private void createWelcomeContentHandler ( Map < PathAddress , ModelNode > migrationOperations ) { PathAddress address = pathAddress ( pathElement ( SUBSYSTEM , UndertowExtension . SUBSYSTEM_NAME ) , pathElement ( Constants . CONFIGURATION , Constants . HANDLER ) ) ; migrationOperations . put ( address , createAddOperation ( address ) ) ; address = pathAddress ( pathElement ( SUBSYSTEM , UndertowExtension . SUBSYSTEM_NAME ) , pathElement ( Constants . CONFIGURATION , Constants . HANDLER ) , pathElement ( Constants . FILE , \"welcome-content\" ) ) ; final ModelNode add = createAddOperation ( address ) ; add . get ( Constants . PATH ) . set ( new ModelNode ( new ValueExpression ( \"${jboss.home.dir}/welcome-content\" ) ) ) ; migrationOperations . put ( address , add ) ; }", "nl": "create a handler for serving welcome content"}}
{"translation": {"code": "public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; if ( JPADeploymentMarker . isJPADeployment ( deploymentUnit ) ) { addSearchDependency ( moduleSpecification , moduleLoader , deploymentUnit ) ; } }", "nl": "if set to auto will behave like not having set the property"}}
{"translation": {"code": "private TransactionSynchronizationRegistry getTransactionSynchronizationRegistry ( ) { TransactionSynchronizationRegistry cachedTSR = transactionSynchronizationRegistry ; if ( cachedTSR == null ) { cachedTSR = ( TransactionSynchronizationRegistry ) lookup ( TRANSACTION_SYNCHRONIZATION_REGISTRY_LOOKUP ) ; transactionSynchronizationRegistry = cachedTSR ; } return cachedTSR ; }", "nl": "lookup the transactionSynchronizationRegistry and cache it ."}}
{"translation": {"code": "public static boolean isIncludeDefaults ( ModelNode operation ) { return operation . hasDefined ( ModelDescriptionConstants . INCLUDE_DEFAULTS ) ? operation . get ( ModelDescriptionConstants . INCLUDE_DEFAULTS ) . asBoolean ( ) : true ; }", "nl": "Indicates whether or not this operation expects to include default values ."}}
{"translation": {"code": "public static ResourceDefinition getElytronTrustManagersResourceDefinition ( ) { final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { LEGACY_JSSE_CONFIG } ; final AbstractAddStepHandler addHandler = new BasicAddHandler < TrustManager > ( attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) { @ Override protected BasicService . ValueSupplier < TrustManager > getValueSupplier ( ServiceBuilder < TrustManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue <> ( ) ; if ( legacyJSSEConfig != null ) { serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; } return ( ) -> { final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; if ( jsseDomain == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; } final TrustManager [ ] trustManagers = jsseDomain . getTrustManagers ( ) ; if ( trustManagers == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"TrustManager\" , legacyJSSEConfig ) ; } for ( TrustManager trustManager : trustManagers ) { if ( trustManager instanceof X509ExtendedTrustManager ) return trustManager ; } throw SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( \"TrustManager\" , X509ExtendedTrustManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; } ; } } ; return new BasicResourceDefinition ( Constants . ELYTRON_TRUST_MANAGER , addHandler , attributes , TRUST_MANAGER_RUNTIME_CAPABILITY ) ; }", "nl": "Defines a resource that represents Elytron - compatible trust managers that can be exported by a JSSE - enabled domain in the legacy security subsystem ."}}
{"translation": {"code": "public static ResourceDefinition getElytronKeyStoreResourceDefinition ( ) { final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { LEGACY_JSSE_CONFIG } ; final AbstractAddStepHandler addHandler = new BasicAddHandler < KeyStore > ( attributes , KEY_STORE_RUNTIME_CAPABILITY ) { @ Override protected BasicService . ValueSupplier < KeyStore > getValueSupplier ( ServiceBuilder < KeyStore > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue <> ( ) ; if ( legacyJSSEConfig != null ) { serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; } return ( ) -> { final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; if ( jsseDomain == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; } final KeyStore keyStore = jsseDomain . getKeyStore ( ) ; if ( keyStore == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"KeyStore\" , legacyJSSEConfig ) ; } return keyStore ; } ; } } ; return new BasicResourceDefinition ( Constants . ELYTRON_KEY_STORE , addHandler , attributes , KEY_STORE_RUNTIME_CAPABILITY ) ; }", "nl": "Defines a resource that represents an Elytron - compatible key store that can be exported by a JSSE - enabled domain in the legacy security subsystem ."}}
{"translation": {"code": "public static ResourceDefinition getElytronKeyManagersResourceDefinition ( ) { final AttributeDefinition [ ] attributes = new AttributeDefinition [ ] { LEGACY_JSSE_CONFIG } ; final AbstractAddStepHandler addHandler = new BasicAddHandler < KeyManager > ( attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) { @ Override protected BasicService . ValueSupplier < KeyManager > getValueSupplier ( ServiceBuilder < KeyManager > serviceBuilder , OperationContext context , ModelNode model ) throws OperationFailedException { final String legacyJSSEConfig = asStringIfDefined ( context , LEGACY_JSSE_CONFIG , model ) ; final InjectedValue < SecurityDomainContext > securityDomainContextInjector = new InjectedValue <> ( ) ; if ( legacyJSSEConfig != null ) { serviceBuilder . addDependency ( SecurityDomainService . SERVICE_NAME . append ( legacyJSSEConfig ) , SecurityDomainContext . class , securityDomainContextInjector ) ; } return ( ) -> { final SecurityDomainContext domainContext = securityDomainContextInjector . getValue ( ) ; final JSSESecurityDomain jsseDomain = domainContext . getJSSE ( ) ; if ( jsseDomain == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateJSSEConfig ( legacyJSSEConfig ) ; } final KeyManager [ ] keyManagers = jsseDomain . getKeyManagers ( ) ; if ( keyManagers == null ) { throw SecurityLogger . ROOT_LOGGER . unableToLocateComponentInJSSEDomain ( \"KeyManager\" , legacyJSSEConfig ) ; } for ( KeyManager keyManager : keyManagers ) { if ( keyManager instanceof X509ExtendedKeyManager ) { return keyManager ; } } throw SecurityLogger . ROOT_LOGGER . expectedManagerTypeNotFound ( \"KeyManager\" , X509ExtendedKeyManager . class . getSimpleName ( ) , legacyJSSEConfig ) ; } ; } } ; return new BasicResourceDefinition ( Constants . ELYTRON_KEY_MANAGER , addHandler , attributes , KEY_MANAGER_RUNTIME_CAPABILITY ) ; }", "nl": "Defines a resource that represents Elytron - compatible key managers that can be exported by a JSSE - enabled domain in the legacy security subsystem ."}}
{"translation": {"code": "public static boolean skipMixedSynchronizationTypeCheck ( EntityManagerFactory emf , Map targetEntityManagerProperties ) { boolean result = false ; // EntityManager properties will take priority over persistence.xml level (emf) properties if ( targetEntityManagerProperties != null && targetEntityManagerProperties . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { result = Boolean . parseBoolean ( ( String ) targetEntityManagerProperties . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; } else if ( emf . getProperties ( ) != null && emf . getProperties ( ) . containsKey ( SKIPMIXEDSYNCTYPECHECKING ) ) { result = Boolean . parseBoolean ( ( String ) emf . getProperties ( ) . get ( SKIPMIXEDSYNCTYPECHECKING ) ) ; } return result ; }", "nl": "Allow the mixed synchronization checking to be skipped for backward compatibility with WildFly 10 . 1 . 0"}}
{"translation": {"code": "private SecurityIdentity authenticate ( final String username , final String password ) { ServerAuthenticationContext context = this . securityDomain . createNewAuthenticationContext ( ) ; PasswordGuessEvidence evidence = null ; try { if ( password == null ) { if ( username == null ) { if ( context . authorizeAnonymous ( ) ) { context . succeed ( ) ; return context . getAuthorizedIdentity ( ) ; } else { context . fail ( ) ; return null ; } } else { // treat a non-null user name with a null password as a auth failure context . fail ( ) ; return null ; } } context . setAuthenticationName ( username ) ; evidence = new PasswordGuessEvidence ( password . toCharArray ( ) ) ; if ( context . verifyEvidence ( evidence ) ) { if ( context . authorize ( ) ) { context . succeed ( ) ; return context . getAuthorizedIdentity ( ) ; } else { context . fail ( ) ; MessagingLogger . ROOT_LOGGER . failedAuthorization ( username ) ; } } else { context . fail ( ) ; MessagingLogger . ROOT_LOGGER . failedAuthentication ( username ) ; } } catch ( IllegalArgumentException | IllegalStateException | RealmUnavailableException e ) { context . fail ( ) ; MessagingLogger . ROOT_LOGGER . failedAuthenticationWithException ( e , username , e . getMessage ( ) ) ; } finally { if ( evidence != null ) { evidence . destroy ( ) ; } } return null ; }", "nl": "Attempt to authenticate and authorize an username with the specified password evidence ."}}
{"translation": {"code": "Set < String > getJobXmlNames ( final String jobName ) { if ( jobNames . containsKey ( jobName ) ) { return Collections . unmodifiableSet ( jobNames . get ( jobName ) ) ; } return Collections . emptySet ( ) ; }", "nl": "Returns the job XML file names which contain the job name ."}}
{"translation": {"code": "public static BatchPermission forName ( final String name ) { Assert . checkNotNullParam ( \"name\" , name ) ; return \"*\" . equals ( name ) ? allPermission : mapping . getItemByString ( name ) ; }", "nl": "Get the permission with the given name ."}}
{"translation": {"code": "public void accept ( final EJBClientContext . Builder builder ) { final EJBTransportProvider remoteTransportProvider = this . remoteTransportProvider ; if ( remoteTransportProvider != null ) { builder . addTransportProvider ( remoteTransportProvider ) ; builder . addTransportProvider ( remoteHttpTransportProvider ) ; } }", "nl": "Perform the configuration of the transport provider ."}}
{"translation": {"code": "private void addPrivateCredential ( final Subject subject , final Object credential ) { if ( ! WildFlySecurityManager . isChecking ( ) ) { subject . getPrivateCredentials ( ) . add ( credential ) ; } else { AccessController . doPrivileged ( ( PrivilegedAction < Void > ) ( ) -> { subject . getPrivateCredentials ( ) . add ( credential ) ; return null ; } ) ; } }", "nl": "Add the specified credential to the subject s private credentials set ."}}
{"translation": {"code": "@ Override public void transactionCreated ( AbstractTransaction transaction , CreatedBy createdBy ) { activeTransactionCountUpdater . incrementAndGet ( this ) ; try { transaction . registerSynchronization ( this ) ; } catch ( RollbackException | IllegalStateException e ) { // it means the transaction is marked for rollback, or is prepared for commit, at this point we cannot register synchronization decrementTransactionCount ( ) ; } catch ( SystemException e ) { decrementTransactionCount ( ) ; EjbLogger . ROOT_LOGGER . debug ( \"Unexpected exception\" , e ) ; throw new RuntimeException ( e ) ; } }", "nl": "Notifies handler that a new transaction has been created ."}}
{"translation": {"code": "public void start ( StartContext context ) { final SuspendController suspendController = suspendControllerInjectedValue . getValue ( ) ; suspendController . registerActivity ( this ) ; final LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue . getValue ( ) ; localTransactionContext . registerCreationListener ( this ) ; }", "nl": "Starts the service . Registers server activity sets transaction listener on local transaction context and creates and installs deployment controller service ."}}
{"translation": {"code": "public void stop ( StopContext context ) { final SuspendController suspendController = suspendControllerInjectedValue . getValue ( ) ; suspendController . unRegisterActivity ( this ) ; final LocalTransactionContext localTransactionContext = localTransactionContextInjectedValue . getValue ( ) ; localTransactionContext . removeCreationListener ( this ) ; }", "nl": "Stops the service . Unregisters service activity and clears transaction listener ."}}
{"translation": {"code": "private Date stringAsSchedulerDate ( final String date , final String timerId ) { if ( date == null ) { return null ; } try { return new SimpleDateFormat ( SCHEDULER_DATE_FORMAT ) . parse ( date ) ; } catch ( ParseException e ) { EjbLogger . EJB3_TIMER_LOGGER . scheduleExpressionDateFromTimerPersistenceInvalid ( timerId , e . getMessage ( ) ) ; return null ; } }", "nl": "Convert the stored date - string from database back to Date"}}
{"translation": {"code": "void registerCleanUpListener ( TransactionSynchronizationRegistry transactionSynchronizationRegistry , JMSContext contextInstance ) { //to avoid registration of more listeners for one context, flag in transaction is used. Object alreadyRegistered = transactionSynchronizationRegistry . getResource ( contextInstance ) ; if ( alreadyRegistered == null ) { transactionSynchronizationRegistry . registerInterposedSynchronization ( new AfterCompletionSynchronization ( contextInstance ) ) ; transactionSynchronizationRegistry . putResource ( contextInstance , AfterCompletionSynchronization . class . getName ( ) ) ; } }", "nl": "Closing of transaction scoped JMSContext is executed through Synchronization listener . This method registers listener which takes care of closing JMSContext ."}}
{"translation": {"code": "public boolean isMethodLevel ( MethodIntf methodIntf , Method method , MethodIntf defaultMethodIntf ) { assert methodIntf != null : \"methodIntf is null\" ; assert method != null : \"method is null\" ; Method classMethod = resolveRealMethod ( method ) ; String [ ] methodParams = MethodInfoHelper . getCanonicalParameterTypes ( classMethod ) ; final String methodName = classMethod . getName ( ) ; final String className = classMethod . getDeclaringClass ( ) . getName ( ) ; ArrayKey methodParamsKey = new ArrayKey ( ( Object [ ] ) methodParams ) ; T attr = get ( get ( get ( perViewStyle3 , methodIntf ) , methodName ) , methodParamsKey ) ; if ( attr != null ) return true ; attr = get ( get ( perViewStyle2 , methodIntf ) , methodName ) ; if ( attr != null ) return true ; attr = get ( perViewStyle1 , methodIntf ) ; if ( attr != null ) return false ; attr = get ( get ( get ( style3 , className ) , methodName ) , methodParamsKey ) ; if ( attr != null ) return true ; attr = get ( style2 , methodName ) ; if ( attr != null ) return true ; attr = get ( style1 , className ) ; if ( attr != null ) return false ; if ( defaultMethodIntf == null ) { return false ; } else { return isMethodLevel ( defaultMethodIntf , method , null ) ; } }", "nl": "Returns true if the given transaction specification was expliitly specified at a method level returns false if it was inherited from the default"}}
{"translation": {"code": "public void observeResources ( @ Observes @ WithAnnotations ( { Health . class } ) ProcessAnnotatedType < ? extends HealthCheck > event ) { AnnotatedType < ? extends HealthCheck > annotatedType = event . getAnnotatedType ( ) ; Class < ? extends HealthCheck > javaClass = annotatedType . getJavaClass ( ) ; MicroProfileHealthLogger . LOGGER . infof ( \"Discovered health check procedure %s\" , javaClass ) ; delegates . add ( annotatedType ) ; }", "nl": "Discover all classes that implements HealthCheckProcedure"}}
{"translation": {"code": "public void close ( @ Observes final BeforeShutdown bs ) { healthCheckInstances . forEach ( healthCheck -> { healthReporter . removeHealthCheck ( healthCheck . get ( ) ) ; healthCheck . preDestroy ( ) . dispose ( ) ; } ) ; healthCheckInstances . clear ( ) ; }", "nl": "Called when the deployment is undeployed ."}}
{"translation": {"code": "static boolean targetsExternalPooledConnectionFactory ( String resourceAdapter , ServiceRegistry serviceRegistry ) { // if the resourceAdapter is not defined, the default behaviour is to create a pooled-connection-factory. if ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) { return false ; } //let's look into the external-pooled-connection-factory ServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( MessagingServices . getActiveMQServiceName ( \"\" ) ) . append ( resourceAdapter ) ; return serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; }", "nl": "Return whether the definition targets an existing external pooled connection factory ."}}
{"translation": {"code": "private static Map < String , Object > getExtraParameters ( final Set < String > allowedKeys , final Map < String , Object > parameters ) { Map < String , Object > extraParameters = new HashMap <> ( ) ; for ( Map . Entry < String , Object > parameter : parameters . entrySet ( ) ) { if ( ! allowedKeys . contains ( parameter . getKey ( ) ) ) { extraParameters . put ( parameter . getKey ( ) , parameter . getValue ( ) ) ; } } for ( String extraParam : extraParameters . keySet ( ) ) { parameters . remove ( extraParam ) ; } return extraParameters ; }", "nl": "Extract extra parameters from the map of parameters ."}}
{"translation": {"code": "public static ServiceName getCapabilityServiceName ( String capabilityBaseName , String ... dynamicParts ) { if ( capabilityServiceSupport == null ) { throw new IllegalStateException ( ) ; } if ( dynamicParts == null || dynamicParts . length == 0 ) { return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName ) ; } return capabilityServiceSupport . getCapabilityServiceName ( capabilityBaseName , dynamicParts ) ; }", "nl": "Determines a ServiceName from a capability name . Only supported for use by services installed by this subsystem ; will not function reliably until the subsystem has begun adding runtime services ."}}
{"translation": {"code": "public MetricRegistration collectResourceMetrics ( final Resource resource , ImmutableManagementResourceRegistration managementResourceRegistration , Function < PathAddress , PathAddress > resourceAddressResolver ) { MetricRegistration registration = new MetricRegistration ( ) ; collectResourceMetrics0 ( resource , managementResourceRegistration , EMPTY_ADDRESS , resourceAddressResolver , registration ) ; return registration ; }", "nl": "collect metrics from the resources"}}
{"translation": {"code": "private Class checkParamType ( Type genParamType , final Method method , final int paramPos , final ClassLoader classLoader ) { Class paramClazz = null ; if ( genParamType instanceof ParameterizedType ) { ParameterizedType pType = ( ParameterizedType ) genParamType ; Type [ ] actualTypeArgs = pType . getActualTypeArguments ( ) ; // skip Map types. Don't know how to set default value for these if ( actualTypeArgs . length == 1 ) { try { paramClazz = classLoader . loadClass ( actualTypeArgs [ 0 ] . getTypeName ( ) ) ; } catch ( Exception ee ) { JAXRS_LOGGER . classIntrospectionFailure ( ee . getClass ( ) . getName ( ) , ee . getMessage ( ) ) ; } } } else { Class < ? > [ ] paramArr = method . getParameterTypes ( ) ; if ( paramArr [ paramPos ] . isArray ( ) ) { Class compClazz = paramArr [ paramPos ] . getComponentType ( ) ; if ( ! compClazz . isPrimitive ( ) ) { paramClazz = compClazz ; } } else { if ( ! paramArr [ paramPos ] . isPrimitive ( ) ) { paramClazz = paramArr [ paramPos ] ; } } } return paramClazz ; }", "nl": "Take steps to properly identify the parameter s data type"}}
{"translation": {"code": "private void validateBaseType ( Method method , String defaultValue , ParamDetail detail ) throws DeploymentUnitProcessingException { if ( defaultValue != null ) { try { method . invoke ( method . getDeclaringClass ( ) , defaultValue ) ; } catch ( Exception e ) { JAXRS_LOGGER . baseTypeMethodFailed ( defaultValue , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , method . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; } } }", "nl": "Confirm the method can handle the default value without throwing and exception ."}}
{"translation": {"code": "private DefaultValue lookupDefaultValueAnn ( Annotation [ ] annotationArr ) { for ( Annotation ann : annotationArr ) { if ( ann instanceof DefaultValue ) { return ( DefaultValue ) ann ; } } return null ; }", "nl": "Extract a DefaultValue annotation from the list of parameter annotations"}}