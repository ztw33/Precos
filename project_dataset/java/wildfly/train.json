{"translation": {"code": "public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final VirtualFile deploymentRoot = phaseContext . getDeploymentUnit ( ) . getAttachment ( Attachments . DEPLOYMENT_ROOT ) . getRoot ( ) ; if ( deploymentRoot == null || ! deploymentRoot . exists ( ) ) return ; VirtualFile serviceXmlFile = null ; if ( deploymentRoot . isDirectory ( ) ) { serviceXmlFile = deploymentRoot . getChild ( SERVICE_DESCRIPTOR_PATH ) ; } else if ( deploymentRoot . getName ( ) . toLowerCase ( Locale . ENGLISH ) . endsWith ( SERVICE_DESCRIPTOR_SUFFIX ) ) { serviceXmlFile = deploymentRoot ; } if ( serviceXmlFile == null || ! serviceXmlFile . exists ( ) ) return ; final XMLMapper xmlMapper = XMLMapper . Factory . create ( ) ; final JBossServiceXmlDescriptorParser jBossServiceXmlDescriptorParser = new JBossServiceXmlDescriptorParser ( JBossDescriptorPropertyReplacement . propertyReplacer ( phaseContext . getDeploymentUnit ( ) ) ) ; xmlMapper . registerRootElement ( new QName ( \"urn:jboss:service:7.0\" , \"server\" ) , jBossServiceXmlDescriptorParser ) ; xmlMapper . registerRootElement ( new QName ( null , \"server\" ) , jBossServiceXmlDescriptorParser ) ; InputStream xmlStream = null ; try { xmlStream = serviceXmlFile . openStream ( ) ; final XMLStreamReader reader = inputFactory . createXMLStreamReader ( xmlStream ) ; final ParseResult < JBossServiceXmlDescriptor > result = new ParseResult < JBossServiceXmlDescriptor > ( ) ; xmlMapper . parseDocument ( result , reader ) ; final JBossServiceXmlDescriptor xmlDescriptor = result . getResult ( ) ; if ( xmlDescriptor != null ) phaseContext . getDeploymentUnit ( ) . putAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; else throw SarLogger . ROOT_LOGGER . failedXmlParsing ( serviceXmlFile ) ; } catch ( Exception e ) { throw SarLogger . ROOT_LOGGER . failedXmlParsing ( e , serviceXmlFile ) ; } finally { VFSUtils . safeClose ( xmlStream ) ; } }", "nl": "Process a deployment for jboss - service . xml files . Will parse the xml file and attach a configuration discovered during processing ."}}
{"translation": {"code": "public T getValue ( ) throws IllegalStateException { final Context context = contextValue . getValue ( ) ; try { return ( T ) context . lookup ( contextName ) ; } catch ( NamingException e ) { throw NamingLogger . ROOT_LOGGER . entryNotRegistered ( e , contextName , context ) ; } }", "nl": "Lookup the value from the naming context ."}}
{"translation": {"code": "public void start ( StartContext context ) throws StartException { ROOT_LOGGER . startingService ( ) ; try { NamingContext . setActiveNamingStore ( namingStore . getValue ( ) ) ; } catch ( Throwable t ) { throw new StartException ( NamingLogger . ROOT_LOGGER . failedToStart ( \"naming service\" ) , t ) ; } }", "nl": "Creates a new NamingServer and sets the naming context to use the naming server ."}}
{"translation": {"code": "public void unbind ( final Name name ) throws NamingException { if ( isLastComponentEmpty ( name ) ) { throw emptyNameException ( ) ; } writeLock . lock ( ) ; try { root . accept ( new UnbindVisitor ( name ) ) ; } finally { writeLock . unlock ( ) ; } }", "nl": "Unbind the entry in the provided location . This will remove the node in the tree and no longer manage it ."}}
{"translation": {"code": "public Object lookup ( final Name name ) throws NamingException { if ( isEmpty ( name ) ) { final Name emptyName = new CompositeName ( \"\" ) ; return new NamingContext ( emptyName , this , new Hashtable < String , Object > ( ) ) ; } return root . accept ( new LookupVisitor ( name ) ) ; }", "nl": "Lookup the object value of a binding node in the tree ."}}
{"translation": {"code": "public static void setActiveNamingStore ( final NamingStore namingStore ) { if ( WildFlySecurityManager . isChecking ( ) ) { System . getSecurityManager ( ) . checkPermission ( SET_ACTIVE_NAMING_STORE ) ; } ACTIVE_NAMING_STORE = namingStore ; }", "nl": "Set the active naming store"}}
{"translation": {"code": "public List < NameClassPair > list ( final Name name ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( \"\" ) : name ; return root . accept ( new ListVisitor ( nodeName ) ) ; }", "nl": "List all NameClassPair instances at a given location in the tree ."}}
{"translation": {"code": "public List < Binding > listBindings ( final Name name ) throws NamingException { final Name nodeName = name . isEmpty ( ) ? new CompositeName ( \"\" ) : name ; return root . accept ( new ListBindingsVisitor ( nodeName ) ) ; }", "nl": "List all the Binding instances at a given location in the tree ."}}
{"translation": {"code": "public static String getLastComponent ( final Name name ) { if ( name . size ( ) > 0 ) return name . get ( name . size ( ) - 1 ) ; return \"\" ; }", "nl": "Get the last component of a name ."}}
{"translation": {"code": "public static boolean isEmpty ( final Name name ) { return name . isEmpty ( ) || ( name . size ( ) == 1 && \"\" . equals ( name . get ( 0 ) ) ) ; }", "nl": "Determine if a name is empty or if ot contains only one component which is the empty string ."}}
{"translation": {"code": "public static NamingException namingException ( final String message , final Throwable cause ) { final NamingException exception = new NamingException ( message ) ; if ( cause != null ) exception . initCause ( cause ) ; return exception ; }", "nl": "Return a general naming exception with a root cause ."}}
{"translation": {"code": "public static NamingException namingException ( final String message , final Throwable cause , final Name remainingName ) { final NamingException exception = namingException ( message , cause ) ; exception . setRemainingName ( remainingName ) ; return exception ; }", "nl": "Return a general naming exception with a root cause and a remaining name field ."}}
{"translation": {"code": "public static NameNotFoundException nameNotFoundException ( final String name , final Name contextName ) { return NamingLogger . ROOT_LOGGER . nameNotFoundInContext ( name , contextName ) ; }", "nl": "Create a name - not - found exception ."}}
{"translation": {"code": "public static < T > NamingEnumeration < T > namingEnumeration ( final Collection < T > collection ) { final Iterator < T > iterator = collection . iterator ( ) ; return new NamingEnumeration < T > ( ) { public T next ( ) { return nextElement ( ) ; } public boolean hasMore ( ) { return hasMoreElements ( ) ; } public void close ( ) { } public boolean hasMoreElements ( ) { return iterator . hasNext ( ) ; } public T nextElement ( ) { return iterator . next ( ) ; } } ; }", "nl": "Return a naming enumeration over a collection ."}}
{"translation": {"code": "void fireEvent ( final EventContext context , final Name name , final Binding existingBinding , final Binding newBinding , int type , final String changeInfo , final Integer ... scopes ) { final String target = name . toString ( ) ; final Set < Integer > scopeSet = new HashSet < Integer > ( Arrays . asList ( scopes ) ) ; final NamingEvent event = new NamingEvent ( context , type , newBinding , existingBinding , changeInfo ) ; final Set < ListenerHolder > holdersToFire = new HashSet < ListenerHolder > ( ) ; // Check for OBJECT_SCOPE based listeners if ( scopeSet . contains ( EventContext . OBJECT_SCOPE ) ) { final TargetScope targetScope = new TargetScope ( target , EventContext . OBJECT_SCOPE ) ; final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; if ( holders != null ) { for ( ListenerHolder holder : holders ) { holdersToFire . add ( holder ) ; } } } // Check for ONELEVEL_SCOPE based listeners if ( scopeSet . contains ( EventContext . ONELEVEL_SCOPE ) && ! name . isEmpty ( ) ) { final TargetScope targetScope = new TargetScope ( name . getPrefix ( name . size ( ) - 1 ) . toString ( ) , EventContext . ONELEVEL_SCOPE ) ; final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; if ( holders != null ) { for ( ListenerHolder holder : holders ) { holdersToFire . add ( holder ) ; } } } // Check for SUBTREE_SCOPE based listeners if ( scopeSet . contains ( EventContext . SUBTREE_SCOPE ) && ! name . isEmpty ( ) ) { for ( int i = 1 ; i < name . size ( ) ; i ++ ) { final Name parentName = name . getPrefix ( i ) ; final TargetScope targetScope = new TargetScope ( parentName . toString ( ) , EventContext . SUBTREE_SCOPE ) ; final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; if ( holders != null ) { for ( ListenerHolder holder : holders ) { holdersToFire . add ( holder ) ; } } } } executor . execute ( new FireEventTask ( holdersToFire , event ) ) ; }", "nl": "Fire a naming event . An event will be created with the provided information and sent to each listener that matches the target and scope information ."}}
{"translation": {"code": "synchronized void removeListener ( final NamingListener namingListener ) { // Do we have a holder for this listener final ListenerHolder holder = holdersByListener . get ( namingListener ) ; if ( holder == null ) { return ; } final Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; byListenerCopy . remove ( namingListener ) ; holdersByListener = byListenerCopy ; final Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; for ( TargetScope targetScope : holder . targets ) { final List < ListenerHolder > holders = holdersByTarget . get ( targetScope ) ; holders . remove ( holder ) ; if ( holders . isEmpty ( ) ) { byTargetCopy . remove ( targetScope ) ; } } holdersByTarget = byTargetCopy ; }", "nl": "Remove a listener . Will remove it from all target mappings . Once this method returns the listener will no longer receive any events ."}}
{"translation": {"code": "synchronized void addListener ( final String target , final int scope , final NamingListener namingListener ) { final TargetScope targetScope = new TargetScope ( target , scope ) ; // Do we have a holder for this listener ListenerHolder holder = holdersByListener . get ( namingListener ) ; if ( holder == null ) { holder = new ListenerHolder ( namingListener , targetScope ) ; final Map < NamingListener , ListenerHolder > byListenerCopy = new FastCopyHashMap < NamingListener , ListenerHolder > ( holdersByListener ) ; byListenerCopy . put ( namingListener , holder ) ; holdersByListener = byListenerCopy ; } else { holder . addTarget ( targetScope ) ; } List < ListenerHolder > holdersForTarget = holdersByTarget . get ( targetScope ) ; if ( holdersForTarget == null ) { holdersForTarget = new CopyOnWriteArrayList < ListenerHolder > ( ) ; final Map < TargetScope , List < ListenerHolder > > byTargetCopy = new FastCopyHashMap < TargetScope , List < ListenerHolder > > ( holdersByTarget ) ; byTargetCopy . put ( targetScope , holdersForTarget ) ; holdersByTarget = byTargetCopy ; } holdersForTarget . add ( holder ) ; }", "nl": "Add a listener to the coordinator with a given target name and event scope . This information is used when an event is fired to determine whether or not to fire this listener ."}}
{"translation": {"code": "public static CannotProceedException cannotProceedException ( final Object resolvedObject , final Name remainingName ) { final CannotProceedException cpe = new CannotProceedException ( ) ; cpe . setResolvedObj ( resolvedObject ) ; cpe . setRemainingName ( remainingName ) ; return cpe ; }", "nl": "Return a cannot - proceed exception ."}}
{"translation": {"code": "public void stop ( StopContext context ) { final ServiceBasedNamingStore namingStore = namingStoreValue . getValue ( ) ; namingStore . remove ( controller . getName ( ) ) ; ROOT_LOGGER . tracef ( \"Unbound resource %s into naming store %s (service name %s)\" , name , namingStore , context . getController ( ) . getName ( ) ) ; }", "nl": "Unbind the entry from the injected context ."}}
{"translation": {"code": "public static NamespaceContextSelector getCurrentSelector ( ) { NamespaceContextSelector selector = currentSelector . peek ( ) ; if ( selector != null ) { return selector ; } return defaultSelector ; }", "nl": "Get the current context selector for the current thread ."}}
{"translation": {"code": "public void start ( StartContext context ) throws StartException { final ServiceBasedNamingStore namingStore = namingStoreValue . getValue ( ) ; controller = context . getController ( ) ; namingStore . add ( controller . getName ( ) ) ; ROOT_LOGGER . tracef ( \"Bound resource %s into naming store %s (service name %s)\" , name , namingStore , controller . getName ( ) ) ; }", "nl": "Bind the entry into the injected context ."}}
{"translation": {"code": "public String getAbsoluteName ( ) { final StringBuilder absolute = new StringBuilder ( ) ; if ( parent != null ) { absolute . append ( parent ) . append ( ENTRY_SEPARATOR ) ; } absolute . append ( local ) ; return absolute . toString ( ) ; }", "nl": "Get the absolute JNDI name as a string ."}}
{"translation": {"code": "public static JndiName of ( final String name ) { if ( name == null || name . isEmpty ( ) ) throw NamingLogger . ROOT_LOGGER . invalidJndiName ( name ) ; final String [ ] parts = name . split ( ENTRY_SEPARATOR ) ; JndiName current = null ; for ( String part : parts ) { current = new JndiName ( current , part ) ; } return current ; }", "nl": "Create a new instance of the JndiName by breaking the provided string format into a JndiName parts ."}}
{"translation": {"code": "public static < T > T notNull ( T value ) { if ( value == null ) throw ConnectorLogger . ROOT_LOGGER . serviceNotStarted ( ) ; return value ; }", "nl": "convenient method to check notNull of value"}}
{"translation": {"code": "@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ResourceRoot resourceRoot = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; final VirtualFile deploymentRoot = resourceRoot . getRoot ( ) ; final boolean resolveProperties = Util . shouldResolveJBoss ( deploymentUnit ) ; IronJacamarXmlDescriptor xmlDescriptor = process ( deploymentRoot , resolveProperties ) ; if ( xmlDescriptor != null ) { deploymentUnit . putAttachment ( IronJacamarXmlDescriptor . ATTACHMENT_KEY , xmlDescriptor ) ; } }", "nl": "Process a deployment for iron - jacamar . xml files . Will parse the xml file and attach metadata discovered during processing ."}}
{"translation": {"code": "protected Field findField ( Class < ? > clz , String fieldName , String fieldType ) { while ( ! clz . equals ( Object . class ) ) { List < Field > hits = null ; Field [ ] fields = SecurityActions . getDeclaredFields ( clz ) ; for ( int i = 0 ; i < fields . length ; i ++ ) { final Field field = fields [ i ] ; if ( fieldName . equals ( field . getName ( ) ) ) { if ( fieldType == null || argumentMatches ( fieldType , field . getType ( ) . getName ( ) ) ) { if ( hits == null ) hits = new ArrayList < Field > ( 1 ) ; SecurityActions . setAccessible ( field ) ; hits . add ( field ) ; } } } if ( hits != null ) { if ( hits . size ( ) == 1 ) { return hits . get ( 0 ) ; } else { Collections . sort ( hits , new FieldSorter ( ) ) ; if ( fieldType != null ) { for ( Field f : hits ) { if ( fieldType . equals ( f . getType ( ) . getName ( ) ) ) return f ; } } return hits . get ( 0 ) ; } } clz = clz . getSuperclass ( ) ; } return null ; }", "nl": "Find a field"}}
{"translation": {"code": "protected Method findMethod ( Class < ? > clz , String methodName , String propertyType ) { while ( ! clz . equals ( Object . class ) ) { List < Method > hits = null ; Method [ ] methods = SecurityActions . getDeclaredMethods ( clz ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { final Method method = methods [ i ] ; if ( methodName . equals ( method . getName ( ) ) && method . getParameterTypes ( ) . length == 1 ) { if ( propertyType == null || argumentMatches ( propertyType , method . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) { if ( hits == null ) hits = new ArrayList < Method > ( 1 ) ; SecurityActions . setAccessible ( method ) ; hits . add ( method ) ; } } } if ( hits != null ) { if ( hits . size ( ) == 1 ) { return hits . get ( 0 ) ; } else { Collections . sort ( hits , new MethodSorter ( ) ) ; if ( propertyType != null ) { for ( Method m : hits ) { if ( propertyType . equals ( m . getParameterTypes ( ) [ 0 ] . getName ( ) ) ) return m ; } } return hits . get ( 0 ) ; } } clz = clz . getSuperclass ( ) ; } return null ; }", "nl": "Find a method"}}
{"translation": {"code": "public Object getObjectInstance ( final Object ref , final Name name , final Context nameCtx , final Hashtable < ? , ? > environment ) throws Exception { final ClassLoader classLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; if ( classLoader == null ) { return ref ; } final String factoriesProp = ( String ) environment . get ( Context . OBJECT_FACTORIES ) ; if ( factoriesProp != null ) { final String [ ] classes = factoriesProp . split ( \":\" ) ; for ( String className : classes ) { try { final Class < ? > factoryClass = classLoader . loadClass ( className ) ; final ObjectFactory objectFactory = ObjectFactory . class . cast ( factoryClass . newInstance ( ) ) ; final Object result = objectFactory . getObjectInstance ( ref , name , nameCtx , environment ) ; if ( result != null ) { return result ; } } catch ( Throwable ignored ) { } } } return ref ; }", "nl": "Create an object instance ."}}
{"translation": {"code": "public void unregisterResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { if ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; DEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Removing deployment: %s\" , deployment ) ; deployments . remove ( deployment ) ; }", "nl": "Unregister a resource adapter deployment"}}
{"translation": {"code": "public void registerResourceAdapterDeployment ( ResourceAdapterDeployment deployment ) { if ( deployment == null ) throw new IllegalArgumentException ( ConnectorLogger . ROOT_LOGGER . nullVar ( \"Deployment\" ) ) ; DEPLOYMENT_CONNECTOR_REGISTRY_LOGGER . tracef ( \"Adding deployment: %s\" , deployment ) ; deployments . add ( deployment ) ; }", "nl": "Register a resource adapter deployment"}}
{"translation": {"code": "public static ModularReference create ( final Class < ? > type , final Class < ? > factoryClass ) { return create ( type . getName ( ) , factoryClass ) ; }", "nl": "Create a ModuleReference from a target type and factory class ."}}
{"translation": {"code": "public static ModularReference create ( final String className , final Class < ? > factoryClass ) { return new ModularReference ( className , factoryClass . getName ( ) , Module . forClass ( factoryClass ) . getIdentifier ( ) ) ; }", "nl": "Create a ModuleReference from a target class name and factory class ."}}
{"translation": {"code": "public static ModularReference create ( final Class < ? > type , final RefAddr addr , final Class < ? > factoryClass ) { return create ( type . getName ( ) , addr , factoryClass ) ; }", "nl": "Create a ModuleReference from a target type reference address and factory class ."}}
{"translation": {"code": "protected final Endpoint newHttpEndpoint ( final String endpointClass , final String endpointName , final Deployment dep ) { if ( endpointName == null ) throw WSLogger . ROOT_LOGGER . nullEndpointName ( ) ; if ( endpointClass == null ) throw WSLogger . ROOT_LOGGER . nullEndpointClass ( ) ; final Endpoint endpoint = this . deploymentModelFactory . newHttpEndpoint ( endpointClass ) ; endpoint . setShortName ( endpointName ) ; endpoint . setType ( endpointType ) ; dep . getService ( ) . addEndpoint ( endpoint ) ; return endpoint ; }", "nl": "Creates new Http Web Service endpoint ."}}
{"translation": {"code": "public static < A > A getOptionalAttachment ( final DeploymentUnit unit , final AttachmentKey < A > key ) { return unit . getAttachment ( key ) ; }", "nl": "Returns optional attachment value from deployment unit or null if not bound ."}}
{"translation": {"code": "public static < A > A getRequiredAttachment ( final DeploymentUnit unit , final AttachmentKey < A > key ) { final A value = unit . getAttachment ( key ) ; if ( value == null ) { throw new IllegalStateException ( ) ; } return value ; }", "nl": "Returns required attachment value from deployment unit ."}}
{"translation": {"code": "public static ServletMetaData getServletForName ( final JBossWebMetaData jbossWebMD , final String servletName ) { for ( JBossServletMetaData servlet : jbossWebMD . getServlets ( ) ) { if ( servlet . getName ( ) . equals ( servletName ) ) { return servlet ; } } return null ; }", "nl": "Returns servlet meta data for requested servlet name ."}}
{"translation": {"code": "public static String getEndpointClassName ( final ServletMetaData servletMD ) { final String endpointClass = servletMD . getServletClass ( ) ; return endpointClass != null ? endpointClass . trim ( ) : null ; }", "nl": "Returns endpoint class name ."}}
{"translation": {"code": "public static ServletMappingMetaData newServletMapping ( final String servletName , final List < String > urlPatterns , final List < ServletMappingMetaData > servletMappingsMD ) { final ServletMappingMetaData servletMappingMD = new ServletMappingMetaData ( ) ; servletMappingMD . setServletName ( servletName ) ; servletMappingMD . setUrlPatterns ( urlPatterns ) ; servletMappingsMD . add ( servletMappingMD ) ; return servletMappingMD ; }", "nl": "Creates new servlet mapping meta data and associates them with servlet mappings meta data ."}}
{"translation": {"code": "private EJBSecurityMetaData getEjbSecurityMetaData ( final Endpoint endpoint ) { final String ejbName = endpoint . getShortName ( ) ; final Deployment dep = endpoint . getService ( ) . getDeployment ( ) ; final EJBArchiveMetaData ejbArchiveMD = WSHelper . getOptionalAttachment ( dep , EJBArchiveMetaData . class ) ; final EJBMetaData ejbMD = ejbArchiveMD != null ? ejbArchiveMD . getBeanByEjbName ( ejbName ) : null ; return ejbMD != null ? ejbMD . getSecurityMetaData ( ) : null ; }", "nl": "Gets EJB security meta data if associated with EJB endpoint ."}}
{"translation": {"code": "public static JBossServletMetaData newServlet ( final String servletName , final String servletClass , final JBossServletsMetaData servletsMD ) { final JBossServletMetaData servletMD = new JBossServletMetaData ( ) ; servletMD . setServletName ( servletName ) ; servletMD . setServletClass ( servletClass ) ; servletsMD . add ( servletMD ) ; return servletMD ; }", "nl": "Creates new servlet meta data and associates them with servlets meta data ."}}
{"translation": {"code": "public static WebResourceCollectionMetaData newWebResourceCollection ( final String servletName , final String urlPattern , final boolean securedWsdl , final WebResourceCollectionsMetaData webResourceCollectionsMD ) { final WebResourceCollectionMetaData webResourceCollectionMD = new WebResourceCollectionMetaData ( ) ; webResourceCollectionMD . setWebResourceName ( servletName ) ; webResourceCollectionMD . setUrlPatterns ( WebMetaDataHelper . getUrlPatterns ( urlPattern ) ) ; webResourceCollectionMD . setHttpMethods ( WebMetaDataHelper . getHttpMethods ( securedWsdl ) ) ; webResourceCollectionsMD . add ( webResourceCollectionMD ) ; return webResourceCollectionMD ; }", "nl": "Creates new web resource collection meta data and associates them with web resource collections meta data ."}}
{"translation": {"code": "public static SecurityConstraintMetaData newSecurityConstraint ( final List < SecurityConstraintMetaData > securityConstraintsMD ) { final SecurityConstraintMetaData securityConstraintMD = new SecurityConstraintMetaData ( ) ; securityConstraintsMD . add ( securityConstraintMD ) ; return securityConstraintMD ; }", "nl": "Creates new security constraint meta data and associates them with security constraints meta data ."}}
{"translation": {"code": "public static List < ParamValueMetaData > getServletInitParams ( final ServletMetaData servletMD ) { List < ParamValueMetaData > initParamsMD = servletMD . getInitParam ( ) ; if ( initParamsMD == null ) { initParamsMD = new LinkedList < ParamValueMetaData > ( ) ; servletMD . setInitParam ( initParamsMD ) ; } return initParamsMD ; }", "nl": "Gets init parameters meta data from servlet meta data . If not found it creates new init parameters meta data and associates them with servlet meta data ."}}
{"translation": {"code": "public static AuthConstraintMetaData newAuthConstraint ( final List < String > roleNames , final SecurityConstraintMetaData securityConstraintMD ) { final AuthConstraintMetaData authConstraintMD = new AuthConstraintMetaData ( ) ; authConstraintMD . setRoleNames ( roleNames ) ; securityConstraintMD . setAuthConstraint ( authConstraintMD ) ; return authConstraintMD ; }", "nl": "Creates new authentication constraint and associates it with security constraint meta data ."}}
{"translation": {"code": "public static WebResourceCollectionsMetaData getWebResourceCollections ( final SecurityConstraintMetaData securityConstraintMD ) { WebResourceCollectionsMetaData webResourceCollectionsMD = securityConstraintMD . getResourceCollections ( ) ; if ( webResourceCollectionsMD == null ) { webResourceCollectionsMD = new WebResourceCollectionsMetaData ( ) ; securityConstraintMD . setResourceCollections ( webResourceCollectionsMD ) ; } return webResourceCollectionsMD ; }", "nl": "Gets web resource collections meta data from security constraint meta data . If not found it creates new web resource collections meta data and associates them with security constraint meta data ."}}
{"translation": {"code": "public static List < ParamValueMetaData > getContextParams ( final JBossWebMetaData jbossWebMD ) { List < ParamValueMetaData > contextParamsMD = jbossWebMD . getContextParams ( ) ; if ( contextParamsMD == null ) { contextParamsMD = new LinkedList < ParamValueMetaData > ( ) ; jbossWebMD . setContextParams ( contextParamsMD ) ; } return contextParamsMD ; }", "nl": "Gets context parameters meta data from jboss web meta data . If not found it creates new context parameters meta data and associates them with jboss web meta data ."}}
{"translation": {"code": "public static LoginConfigMetaData getLoginConfig ( final JBossWebMetaData jbossWebMD ) { LoginConfigMetaData loginConfigMD = jbossWebMD . getLoginConfig ( ) ; if ( loginConfigMD == null ) { loginConfigMD = new LoginConfigMetaData ( ) ; jbossWebMD . setLoginConfig ( loginConfigMD ) ; } return loginConfigMD ; }", "nl": "Gets login config meta data from jboss web meta data . If not found it creates new login config meta data and associates them with jboss web meta data ."}}
{"translation": {"code": "public static List < SecurityConstraintMetaData > getSecurityConstraints ( final JBossWebMetaData jbossWebMD ) { List < SecurityConstraintMetaData > securityConstraintsMD = jbossWebMD . getSecurityConstraints ( ) ; if ( securityConstraintsMD == null ) { securityConstraintsMD = new LinkedList < SecurityConstraintMetaData > ( ) ; jbossWebMD . setSecurityConstraints ( securityConstraintsMD ) ; } return securityConstraintsMD ; }", "nl": "Gets security constraints meta data from jboss web meta data . If not found it creates new security constraints meta data and associates them with jboss web meta data ."}}
{"translation": {"code": "public static List < ServletMappingMetaData > getServletMappings ( final JBossWebMetaData jbossWebMD ) { List < ServletMappingMetaData > servletMappingsMD = jbossWebMD . getServletMappings ( ) ; if ( servletMappingsMD == null ) { servletMappingsMD = new LinkedList < ServletMappingMetaData > ( ) ; jbossWebMD . setServletMappings ( servletMappingsMD ) ; } return servletMappingsMD ; }", "nl": "Gets servlet mappings meta data from jboss web meta data . If not found it creates new servlet mappings meta data and associates them with jboss web meta data ."}}
{"translation": {"code": "private Map < String , String > getServletUrlPatternsMappings ( final JBossWebMetaData jbossWebMD , final List < POJOEndpoint > pojoEndpoints ) { final Map < String , String > mappings = new HashMap < String , String > ( ) ; final List < ServletMappingMetaData > servletMappings = WebMetaDataHelper . getServletMappings ( jbossWebMD ) ; for ( final POJOEndpoint pojoEndpoint : pojoEndpoints ) { mappings . put ( pojoEndpoint . getName ( ) , pojoEndpoint . getUrlPattern ( ) ) ; if ( ! pojoEndpoint . isDeclared ( ) ) { final String endpointName = pojoEndpoint . getName ( ) ; final List < String > urlPatterns = WebMetaDataHelper . getUrlPatterns ( pojoEndpoint . getUrlPattern ( ) ) ; WebMetaDataHelper . newServletMapping ( endpointName , urlPatterns , servletMappings ) ; } } return mappings ; }", "nl": "Returns servlet name to url pattern mappings ."}}
{"translation": {"code": "private List < JSESecurityMetaData > getSecurityMetaData ( final List < SecurityConstraintMetaData > securityConstraintsMD ) { final List < JSESecurityMetaData > jseSecurityMDs = new LinkedList < JSESecurityMetaData > ( ) ; if ( securityConstraintsMD != null ) { for ( final SecurityConstraintMetaData securityConstraintMD : securityConstraintsMD ) { final JSESecurityMetaData . Builder jseSecurityMDBuilder = new JSESecurityMetaData . Builder ( ) ; // transport guarantee jseSecurityMDBuilder . setTransportGuarantee ( securityConstraintMD . getTransportGuarantee ( ) . name ( ) ) ; // web resources for ( final WebResourceCollectionMetaData webResourceMD : securityConstraintMD . getResourceCollections ( ) ) { jseSecurityMDBuilder . addWebResource ( webResourceMD . getName ( ) , webResourceMD . getUrlPatterns ( ) ) ; } jseSecurityMDs . add ( jseSecurityMDBuilder . build ( ) ) ; } } return jseSecurityMDs ; }", "nl": "Builds security meta data ."}}
{"translation": {"code": "private void setConfigNameAndFile ( final JSEArchiveMetaData . Builder builder , final JBossWebMetaData jbossWebMD , final JBossWebservicesMetaData jbossWebservicesMD ) { if ( jbossWebservicesMD != null ) { if ( jbossWebservicesMD . getConfigName ( ) != null ) { final String configName = jbossWebservicesMD . getConfigName ( ) ; builder . setConfigName ( configName ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; final String configFile = jbossWebservicesMD . getConfigFile ( ) ; builder . setConfigFile ( configFile ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; // ensure higher priority against web.xml context parameters return ; } } final List < ParamValueMetaData > contextParams = jbossWebMD . getContextParams ( ) ; if ( contextParams != null ) { for ( final ParamValueMetaData contextParam : contextParams ) { if ( WSConstants . JBOSSWS_CONFIG_NAME . equals ( contextParam . getParamName ( ) ) ) { final String configName = contextParam . getParamValue ( ) ; builder . setConfigName ( configName ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting config name: %s\" , configName ) ; } if ( WSConstants . JBOSSWS_CONFIG_FILE . equals ( contextParam . getParamName ( ) ) ) { final String configFile = contextParam . getParamValue ( ) ; builder . setConfigFile ( configFile ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting config file: %s\" , configFile ) ; } } } }", "nl": "Sets config name and config file ."}}
{"translation": {"code": "JSEArchiveMetaData create ( final Deployment dep ) { if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { WSLogger . ROOT_LOGGER . tracef ( \"Creating JBoss agnostic meta data for POJO webservice deployment: %s\" , dep . getSimpleName ( ) ) ; } final JBossWebMetaData jbossWebMD = WSHelper . getRequiredAttachment ( dep , JBossWebMetaData . class ) ; final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; final List < POJOEndpoint > pojoEndpoints = getPojoEndpoints ( unit ) ; final JSEArchiveMetaData . Builder builder = new JSEArchiveMetaData . Builder ( ) ; // set context root final String contextRoot = getContextRoot ( dep , jbossWebMD ) ; builder . setContextRoot ( contextRoot ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting context root: %s\" , contextRoot ) ; // set servlet url patterns mappings final Map < String , String > servletMappings = getServletUrlPatternsMappings ( jbossWebMD , pojoEndpoints ) ; builder . setServletMappings ( servletMappings ) ; // set servlet class names mappings final Map < String , String > servletClassNamesMappings = getServletClassMappings ( jbossWebMD , pojoEndpoints ) ; builder . setServletClassNames ( servletClassNamesMappings ) ; // set security domain final String securityDomain = jbossWebMD . getSecurityDomain ( ) ; builder . setSecurityDomain ( securityDomain ) ; // set wsdl location resolver final JBossWebservicesMetaData jbossWebservicesMD = WSHelper . getOptionalAttachment ( dep , JBossWebservicesMetaData . class ) ; if ( jbossWebservicesMD != null ) { final PublishLocationAdapter resolver = new PublishLocationAdapterImpl ( jbossWebservicesMD . getWebserviceDescriptions ( ) ) ; builder . setPublishLocationAdapter ( resolver ) ; } // set security meta data final List < JSESecurityMetaData > jseSecurityMDs = getSecurityMetaData ( jbossWebMD . getSecurityConstraints ( ) ) ; builder . setSecurityMetaData ( jseSecurityMDs ) ; // set config name and file setConfigNameAndFile ( builder , jbossWebMD , jbossWebservicesMD ) ; return builder . build ( ) ; }", "nl": "Builds universal JSE meta data model that is AS agnostic ."}}
{"translation": {"code": "public static JBossServletsMetaData getServlets ( final JBossWebMetaData jbossWebMD ) { JBossServletsMetaData servletsMD = jbossWebMD . getServlets ( ) ; if ( servletsMD == null ) { servletsMD = new JBossServletsMetaData ( ) ; jbossWebMD . setServlets ( servletsMD ) ; } return servletsMD ; }", "nl": "Gets servlets meta data from jboss web meta data . If not found it creates new servlets meta data and associates them with jboss web meta data ."}}
{"translation": {"code": "public static List < String > getUrlPatterns ( final String urlPattern ) { final List < String > linkedList = new LinkedList < String > ( ) ; linkedList . add ( urlPattern ) ; return linkedList ; }", "nl": "Creates URL pattern list from passed string ."}}
{"translation": {"code": "private Map < String , String > getServletClassMappings ( final JBossWebMetaData jbossWebMD , final List < POJOEndpoint > pojoEndpoints ) { final Map < String , String > mappings = new HashMap < String , String > ( ) ; final JBossServletsMetaData servlets = WebMetaDataHelper . getServlets ( jbossWebMD ) ; for ( final POJOEndpoint pojoEndpoint : pojoEndpoints ) { final String pojoName = pojoEndpoint . getName ( ) ; final String pojoClassName = pojoEndpoint . getClassName ( ) ; mappings . put ( pojoName , pojoClassName ) ; if ( ! pojoEndpoint . isDeclared ( ) ) { final String endpointName = pojoEndpoint . getName ( ) ; final String endpointClassName = pojoEndpoint . getClassName ( ) ; WebMetaDataHelper . newServlet ( endpointName , endpointClassName , servlets ) ; } } return mappings ; }", "nl": "Returns servlet name to servlet class mappings ."}}
{"translation": {"code": "public static UserDataConstraintMetaData newUserDataConstraint ( final String transportGuarantee , final SecurityConstraintMetaData securityConstraintMD ) { final UserDataConstraintMetaData userDataConstraintMD = new UserDataConstraintMetaData ( ) ; final TransportGuaranteeType transportGuaranteeValue = TransportGuaranteeType . valueOf ( transportGuarantee ) ; userDataConstraintMD . setTransportGuarantee ( transportGuaranteeValue ) ; securityConstraintMD . setUserDataConstraint ( userDataConstraintMD ) ; return userDataConstraintMD ; }", "nl": "Creates new user constraint meta data and associates it with security constraint meta data ."}}
{"translation": {"code": "public static JBossWebMetaData getJBossWebMetaData ( final DeploymentUnit unit ) { final WarMetaData warMetaData = getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; JBossWebMetaData result = null ; if ( warMetaData != null ) { result = warMetaData . getMergedJBossWebMetaData ( ) ; if ( result == null ) { result = warMetaData . getJBossWebMetaData ( ) ; } } else { result = getOptionalAttachment ( unit , WSAttachmentKeys . JBOSSWEB_METADATA_KEY ) ; } return result ; }", "nl": "Gets the JBossWebMetaData from the WarMetaData attached to the provided deployment unit if any ."}}
{"translation": {"code": "void modify ( final Deployment dep ) { final JBossWebMetaData jbossWebMD = WSHelper . getOptionalAttachment ( dep , JBossWebMetaData . class ) ; if ( jbossWebMD != null ) { this . configureEndpoints ( dep , jbossWebMD ) ; this . modifyContextRoot ( dep , jbossWebMD ) ; } }", "nl": "Modifies web meta data to configure webservice stack transport and properties ."}}
{"translation": {"code": "public static ParamValueMetaData newParamValue ( final String key , final String value , final List < ParamValueMetaData > paramsMD ) { final ParamValueMetaData paramValueMD = WebMetaDataHelper . newParamValue ( key , value ) ; paramsMD . add ( paramValueMD ) ; return paramValueMD ; }", "nl": "Creates new parameter meta data and associates it with parameters meta data ."}}
{"translation": {"code": "private void configureEndpoints ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { final String transportClassName = this . getTransportClassName ( dep ) ; WSLogger . ROOT_LOGGER . trace ( \"Modifying servlets\" ) ; // get a list of the endpoint bean class names final Set < String > epNames = new HashSet < String > ( ) ; for ( Endpoint ep : dep . getService ( ) . getEndpoints ( ) ) { epNames . add ( ep . getTargetBeanName ( ) ) ; } // fix servlet class names for endpoints for ( final ServletMetaData servletMD : jbossWebMD . getServlets ( ) ) { final String endpointClassName = ASHelper . getEndpointClassName ( servletMD ) ; if ( endpointClassName != null && endpointClassName . length ( ) > 0 ) { // exclude JSP if ( epNames . contains ( endpointClassName ) ) { // set transport servlet servletMD . setServletClass ( WSFServlet . class . getName ( ) ) ; WSLogger . ROOT_LOGGER . tracef ( \"Setting transport class: %s for endpoint: %s\" , transportClassName , endpointClassName ) ; final List < ParamValueMetaData > initParams = WebMetaDataHelper . getServletInitParams ( servletMD ) ; // configure transport class name WebMetaDataHelper . newParamValue ( WSFServlet . STACK_SERVLET_DELEGATE_CLASS , transportClassName , initParams ) ; // configure webservice endpoint WebMetaDataHelper . newParamValue ( Endpoint . SEPID_DOMAIN_ENDPOINT , endpointClassName , initParams ) ; } else if ( endpointClassName . startsWith ( \"org.apache.cxf\" ) ) { throw WSLogger . ROOT_LOGGER . invalidWSServlet ( endpointClassName ) ; } } } }", "nl": "Configures transport servlet class for every found webservice endpoint ."}}
{"translation": {"code": "private static ParamValueMetaData newParamValue ( final String key , final String value ) { final ParamValueMetaData paramMD = new ParamValueMetaData ( ) ; paramMD . setParamName ( key ) ; paramMD . setParamValue ( value ) ; return paramMD ; }", "nl": "Creates new parameter with specified key and value ."}}
{"translation": {"code": "private void modifyContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { final String contextRoot = dep . getService ( ) . getContextRoot ( ) ; if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { WSLogger . ROOT_LOGGER . tracef ( \"Setting context root: %s for deployment: %s\" , contextRoot , dep . getSimpleName ( ) ) ; } jbossWebMD . setContextRoot ( contextRoot ) ; }", "nl": "Modifies context root ."}}
{"translation": {"code": "private String getTransportClassName ( final Deployment dep ) { String transportClassName = ( String ) dep . getProperty ( WSConstants . STACK_TRANSPORT_CLASS ) ; if ( transportClassName == null ) throw WSLogger . ROOT_LOGGER . missingDeploymentProperty ( WSConstants . STACK_TRANSPORT_CLASS ) ; return transportClassName ; }", "nl": "Returns stack specific transport class name ."}}
{"translation": {"code": "private ArchiveDeployment newDeployment ( final DeploymentUnit unit ) { WSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit ) ; final ResourceRoot deploymentRoot = unit . getAttachment ( Attachments . DEPLOYMENT_ROOT ) ; final VirtualFile root = deploymentRoot != null ? deploymentRoot . getRoot ( ) : null ; final ClassLoader classLoader ; final Module module = unit . getAttachment ( Attachments . MODULE ) ; if ( module == null ) { classLoader = unit . getAttachment ( CLASSLOADER_KEY ) ; if ( classLoader == null ) { throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( unit ) ; } } else { classLoader = module . getClassLoader ( ) ; } ArchiveDeployment parentDep = null ; if ( unit . getParent ( ) != null ) { final Module parentModule = unit . getParent ( ) . getAttachment ( Attachments . MODULE ) ; if ( parentModule == null ) { throw WSLogger . ROOT_LOGGER . classLoaderResolutionFailed ( deploymentRoot ) ; } WSLogger . ROOT_LOGGER . tracef ( \"Creating new unified WS deployment model for %s\" , unit . getParent ( ) ) ; parentDep = this . newDeployment ( null , unit . getParent ( ) . getName ( ) , parentModule . getClassLoader ( ) , null ) ; } final UnifiedVirtualFile uvf = root != null ? new VirtualFileAdaptor ( root ) : new ResourceLoaderAdapter ( classLoader ) ; final ArchiveDeployment dep = this . newDeployment ( parentDep , unit . getName ( ) , classLoader , uvf ) ; //add an AnnotationInfo attachment that uses composite jandex index dep . addAttachment ( AnnotationsInfo . class , new JandexAnnotationsInfo ( unit ) ) ; return dep ; }", "nl": "Creates new Web Service deployment ."}}
{"translation": {"code": "public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; final JBossServiceXmlDescriptor serviceXmlDescriptor = deploymentUnit . getAttachment ( JBossServiceXmlDescriptor . ATTACHMENT_KEY ) ; if ( serviceXmlDescriptor == null ) { return ; // Skip deployments with out a service xml descriptor } moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_MODULES_ID , false , false , false , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , JBOSS_AS_SYSTEM_JMX_ID , true , false , false , false ) ) ; // depend on Properties editor module which uses ServiceLoader approach to load the appropriate org.jboss.common.beans.property.finder.PropertyEditorFinder moduleSpecification . addSystemDependency ( new ModuleDependency ( Module . getBootModuleLoader ( ) , PROPERTIES_EDITOR_MODULE_ID , false , false , true , false ) ) ; // All SARs require the ability to register MBeans. moduleSpecification . addPermissionFactory ( REGISTER_PERMISSION_FACTORY ) ; }", "nl": "Add dependencies for modules required for manged bean deployments if managed bean configurations are attached to the deployment ."}}
{"translation": {"code": "public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; //add jboss-invocation classes needed by the proxies ModuleDependency invocation = new ModuleDependency ( moduleLoader , JBOSS_INVOCATION_ID , false , false , false , false ) ; invocation . addImportFilter ( PathFilters . is ( \"org/jboss/invocation/proxy/classloading\" ) , true ) ; invocation . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; moduleSpecification . addSystemDependency ( invocation ) ; ModuleDependency ee = new ModuleDependency ( moduleLoader , JBOSS_AS_EE , false , false , false , false ) ; ee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/component/serialization\" ) , true ) ; ee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/concurrent\" ) , true ) ; ee . addImportFilter ( PathFilters . is ( \"org/jboss/as/ee/concurrent/handle\" ) , true ) ; ee . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; moduleSpecification . addSystemDependency ( ee ) ; // add dep for naming permission moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . create ( WILDFLY_NAMING ) , false , false , false , false ) ) ; //we always add all Java EE API modules, as the platform spec requires them to always be available //we do not just add the javaee.api module, as this breaks excludes for ( final ModuleIdentifier moduleIdentifier : JAVA_EE_API_MODULES ) { moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , moduleIdentifier , true , false , true , false ) ) ; } }", "nl": "Add the EE APIs as a dependency to all deployments"}}
{"translation": {"code": "private Object lookUpJNDI ( String contextName ) { Object result = null ; try { Context ctx = new InitialContext ( ) ; if ( contextName . startsWith ( SecurityConstants . JAAS_CONTEXT_ROOT ) ) result = ctx . lookup ( contextName ) ; else result = ctx . lookup ( SecurityConstants . JAAS_CONTEXT_ROOT + contextName ) ; } catch ( Exception e ) { SecurityLogger . ROOT_LOGGER . tracef ( \"Look up of JNDI for %s failed with %s\" , contextName , e . getLocalizedMessage ( ) ) ; return null ; } return result ; }", "nl": "Lookup a context in JNDI"}}
{"translation": {"code": "public synchronized void start ( final StartContext context ) { if ( started ) { throw WeldLogger . ROOT_LOGGER . alreadyRunning ( \"WeldContainer\" ) ; } started = true ; WeldLogger . DEPLOYMENT_LOGGER . startingWeldService ( deploymentName ) ; // set up injected services addWeldService ( SecurityServices . class , securityServicesSupplier . get ( ) ) ; TransactionServices transactionServices = weldTransactionServicesSupplier != null ? weldTransactionServicesSupplier . get ( ) : null ; if ( transactionServices != null ) { addWeldService ( TransactionServices . class , transactionServices ) ; } if ( ! deployment . getServices ( ) . contains ( ExecutorServices . class ) ) { addWeldService ( ExecutorServices . class , executorServicesSupplier . get ( ) ) ; } ModuleGroupSingletonProvider . addClassLoaders ( deployment . getModule ( ) . getClassLoader ( ) , deployment . getSubDeploymentClassLoaders ( ) ) ; ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( deployment . getModule ( ) . getClassLoader ( ) ) ; bootstrap . startContainer ( deploymentName , environment , deployment ) ; WeldProvider . containerInitialized ( Container . instance ( deploymentName ) , getBeanManager ( ) , deployment ) ; } finally { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; } weldBootstrapServiceConsumer . accept ( this ) ; }", "nl": "Starts the weld container"}}
{"translation": {"code": "@ Override public Class < ? > classForName ( String name ) { try { if ( classes . containsKey ( name ) ) { return classes . get ( name ) ; } final Class < ? > clazz = module . getClassLoader ( ) . loadClass ( name ) ; classes . put ( name , clazz ) ; return clazz ; } catch ( ClassNotFoundException | LinkageError e ) { throw new ResourceLoadingException ( e ) ; } }", "nl": "If the class name is found in additionalClasses then return it ."}}
{"translation": {"code": "@ Override public URL getResource ( String name ) { try { return module . getClassLoader ( ) . getResource ( name ) ; } catch ( Exception e ) { throw new ResourceLoadingException ( e ) ; } }", "nl": "Loads a resource from the module class loader"}}
{"translation": {"code": "@ Override public Collection < URL > getResources ( String name ) { try { final HashSet < URL > resources = new HashSet < URL > ( ) ; Enumeration < URL > urls = module . getClassLoader ( ) . getResources ( name ) ; while ( urls . hasMoreElements ( ) ) { resources . add ( urls . nextElement ( ) ) ; } return resources ; } catch ( Exception e ) { throw new ResourceLoadingException ( e ) ; } }", "nl": "Loads resources from the module class loader"}}
{"translation": {"code": "public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; addDependency ( moduleSpecification , moduleLoader , JAVAX_ENTERPRISE_API ) ; addDependency ( moduleSpecification , moduleLoader , JAVAX_INJECT_API ) ; if ( ! WeldDeploymentMarker . isPartOfWeldDeployment ( deploymentUnit ) ) { return ; // Skip if there are no beans.xml files in the deployment } addDependency ( moduleSpecification , moduleLoader , JAVAX_PERSISTENCE_API_ID ) ; addDependency ( moduleSpecification , moduleLoader , WELD_CORE_ID ) ; addDependency ( moduleSpecification , moduleLoader , WELD_PROBE_ID , true ) ; addDependency ( moduleSpecification , moduleLoader , WELD_API_ID ) ; addDependency ( moduleSpecification , moduleLoader , WELD_SPI_ID ) ; ModuleDependency weldSubsystemDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_ID , false , false , false , false ) ; weldSubsystemDependency . addImportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; weldSubsystemDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/injection\" ) , true ) ; weldSubsystemDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; weldSubsystemDependency . addExportFilter ( PathFilters . getMetaInfFilter ( ) , true ) ; moduleSpecification . addSystemDependency ( weldSubsystemDependency ) ; // Due to serialization of EJBs ModuleDependency weldEjbDependency = new ModuleDependency ( moduleLoader , JBOSS_AS_WELD_EJB_ID , true , false , false , false ) ; weldEjbDependency . addImportFilter ( PathFilters . is ( \"org/jboss/as/weld/ejb\" ) , true ) ; weldEjbDependency . addImportFilter ( PathFilters . acceptAll ( ) , false ) ; moduleSpecification . addSystemDependency ( weldEjbDependency ) ; }", "nl": "Add dependencies for modules required for weld deployments if managed weld configurations are attached to the deployment"}}
{"translation": {"code": "public void stop ( StopContext context ) { if ( store != null ) { try { store . close ( ) ; store = null ; } catch ( NamingException e ) { throw NamingLogger . ROOT_LOGGER . failedToDestroyRootContext ( e ) ; } } }", "nl": "Destroys the naming store ."}}
{"translation": {"code": "public void start ( final StartContext context ) throws StartException { if ( store == null ) { final ServiceRegistry serviceRegistry = context . getController ( ) . getServiceContainer ( ) ; final ServiceName serviceNameBase = context . getController ( ) . getName ( ) ; final ServiceTarget serviceTarget = context . getChildTarget ( ) ; store = readOnly ? new ServiceBasedNamingStore ( serviceRegistry , serviceNameBase ) : new WritableServiceBasedNamingStore ( serviceRegistry , serviceNameBase , serviceTarget ) ; } }", "nl": "Creates the naming store if not provided by the constructor ."}}
{"translation": {"code": "private static PersistenceProviderAdaptor getPersistenceProviderAdaptor ( final PersistenceUnitMetadata pu , final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , final DeploymentUnit deploymentUnit , final PersistenceProvider provider , final Platform platform ) throws DeploymentUnitProcessingException { String adapterClass = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_CLASS ) ; /**\n         * use adapter packaged in application deployment.\n         */ if ( persistenceProviderDeploymentHolder != null && adapterClass != null ) { List < PersistenceProviderAdaptor > persistenceProviderAdaptors = persistenceProviderDeploymentHolder . getAdapters ( ) ; for ( PersistenceProviderAdaptor persistenceProviderAdaptor : persistenceProviderAdaptors ) { if ( adapterClass . equals ( persistenceProviderAdaptor . getClass ( ) . getName ( ) ) ) { return persistenceProviderAdaptor ; } } } String adaptorModule = pu . getProperties ( ) . getProperty ( Configuration . ADAPTER_MODULE ) ; PersistenceProviderAdaptor adaptor ; adaptor = getPerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , provider ) ; if ( adaptor == null ) { try { // will load the persistence provider adaptor (integration classes).  if adaptorModule is null // the noop adaptor is returned (can be used against any provider but the integration classes // are handled externally via properties or code in the persistence provider). if ( adaptorModule != null ) { // legacy way of loading adapter module adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapterModule ( adaptorModule , platform , createManager ( deploymentUnit ) ) ; } else { adaptor = PersistenceProviderAdaptorLoader . loadPersistenceAdapter ( provider , platform , createManager ( deploymentUnit ) ) ; } } catch ( ModuleLoadException e ) { throw JpaLogger . ROOT_LOGGER . persistenceProviderAdaptorModuleLoadError ( e , adaptorModule ) ; } adaptor = savePerDeploymentSharedPersistenceProviderAdaptor ( deploymentUnit , adaptorModule , adaptor , provider ) ; } if ( adaptor == null ) { throw JpaLogger . ROOT_LOGGER . failedToGetAdapter ( pu . getPersistenceProviderClassName ( ) ) ; } return adaptor ; }", "nl": "Get the persistence provider adaptor . Will load the adapter module if needed ."}}
{"translation": {"code": "public static void pushCall ( Map < String , ExtendedEntityManager > entityManagers ) { currentSFSBCallStack ( ) . add ( entityManagers ) ; if ( entityManagers != null ) { /**\n             * JPA 2.0 spec section 7.9.1 Container Responsibilities:\n             * \"When a business method of the stateful session bean is invoked,\n             *  if the stateful session bean uses container managed transaction demarcation,\n             *  and the entity manager is not already associated with the current JTA transaction,\n             *  the container associates the entity manager with the current JTA transaction and\n             *  calls EntityManager.joinTransaction.\n             *  \"\n             */ for ( ExtendedEntityManager extendedEntityManager : entityManagers . values ( ) ) { extendedEntityManager . internalAssociateWithJtaTx ( ) ; } } }", "nl": "Push the passed SFSB context handle onto the invocation call stack"}}
{"translation": {"code": "@ Override public List < PersistenceProvider > getPersistenceProviders ( ) { List < PersistenceProvider > providersCopy = new ArrayList <> ( providers . size ( ) ) ; /**\n         * Add the application specified providers first so they are found before the global providers\n         */ synchronized ( persistenceProviderPerClassLoader ) { if ( persistenceProviderPerClassLoader . size ( ) > 0 ) { // get the deployment or subdeployment classloader ClassLoader deploymentClassLoader = findParentModuleCl ( WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ) ; ROOT_LOGGER . tracef ( \"get application level Persistence Provider for classloader %s\" , deploymentClassLoader ) ; // collect persistence providers associated with deployment/each sub-deployment List < Class < ? extends PersistenceProvider > > deploymentSpecificPersistenceProviders = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; ROOT_LOGGER . tracef ( \"got application level Persistence Provider list %s\" , deploymentSpecificPersistenceProviders ) ; if ( deploymentSpecificPersistenceProviders != null ) { for ( Class < ? extends PersistenceProvider > providerClass : deploymentSpecificPersistenceProviders ) { try { ROOT_LOGGER . tracef ( \"application has its own Persistence Provider %s\" , providerClass . getName ( ) ) ; providersCopy . add ( providerClass . newInstance ( ) ) ; } catch ( InstantiationException e ) { throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; } catch ( IllegalAccessException e ) { throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; } } } } } // add global persistence providers last (so application packaged providers have priority) for ( Class < ? > providerClass : providers ) { try { providersCopy . add ( ( PersistenceProvider ) providerClass . newInstance ( ) ) ; ROOT_LOGGER . tracef ( \"returning global (module) Persistence Provider %s\" , providerClass . getName ( ) ) ; } catch ( InstantiationException e ) { throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; } catch ( IllegalAccessException e ) { throw JpaLogger . ROOT_LOGGER . couldNotCreateInstanceProvider ( e , providerClass . getName ( ) ) ; } } return providersCopy ; }", "nl": "Return a new instance of each persistence provider class"}}
{"translation": {"code": "public void clearCachedDeploymentSpecificProviders ( Set < ClassLoader > deploymentClassLoaders ) { synchronized ( persistenceProviderPerClassLoader ) { for ( ClassLoader deploymentClassLoader : deploymentClassLoaders ) { persistenceProviderPerClassLoader . remove ( deploymentClassLoader ) ; } } }", "nl": "Cleared at application undeployment time to remove any persistence providers that were deployed with the application"}}
{"translation": {"code": "private void postParseSteps ( final VirtualFile persistence_xml , final PersistenceUnitMetadataHolder puHolder , final DeploymentUnit deploymentUnit ) { for ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { // set URLs List < URL > jarfilesUrls = new ArrayList < URL > ( ) ; if ( pu . getJarFiles ( ) != null ) { for ( String jar : pu . getJarFiles ( ) ) { jarfilesUrls . add ( getRelativeURL ( persistence_xml , jar ) ) ; } } pu . setJarFileUrls ( jarfilesUrls ) ; URL url = getPersistenceUnitURL ( persistence_xml ) ; pu . setPersistenceUnitRootUrl ( url ) ; String scopedPersistenceUnitName ; /**\n             * WFLY-5478 allow custom scoped persistence unit name hint in persistence unit definition.\n             * Specified scoped persistence unit name needs to be unique across application server deployments.\n             * Application is responsible for picking a unique name.\n             * Currently, a non-unique name will result in a DuplicateServiceException deployment failure:\n             *   org.jboss.msc.service.DuplicateServiceException: Service jboss.persistenceunit.my2lccustom#test_pu.__FIRST_PHASE__ is already registered\n             */ scopedPersistenceUnitName = Configuration . getScopedPersistenceUnitName ( pu ) ; if ( scopedPersistenceUnitName == null ) { scopedPersistenceUnitName = createBeanName ( deploymentUnit , pu . getPersistenceUnitName ( ) ) ; } else { ROOT_LOGGER . tracef ( \"persistence unit '%s' specified a custom scoped persistence unit name hint \" + \"(jboss.as.jpa.scopedname=%s).  The specified name *must* be unique across all application server deployments.\" , pu . getPersistenceUnitName ( ) , scopedPersistenceUnitName ) ; if ( scopedPersistenceUnitName . indexOf ( ' ' ) != - 1 ) { throw JpaLogger . ROOT_LOGGER . invalidScopedName ( scopedPersistenceUnitName , ' ' ) ; } } pu . setScopedPersistenceUnitName ( scopedPersistenceUnitName ) ; } }", "nl": "Some of this might need to move to the install phase"}}
{"translation": {"code": "private static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { if ( puList . size ( ) > 0 ) { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; final EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; final ModuleClassLoader classLoader = module . getClassLoader ( ) ; for ( PersistenceUnitMetadataHolder holder : puList ) { setAnnotationIndexes ( holder , deploymentUnit ) ; for ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { // only start the persistence unit if JPA_CONTAINER_MANAGED is true String jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; boolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; if ( deployPU ) { final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; final PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; final boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; if ( startEarly ) { if ( twoPhaseBootStrapCapable ) { deployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; } else if ( false == Configuration . needClassFileTransformer ( pu ) ) { // will start later when startEarly == false ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; } else { // we need class file transformer to work, don't allow cdi bean manager to be access since that // could cause application classes to be loaded (workaround by setting jboss.as.jpa.classtransformer to false).  WFLY-1463 final boolean allowCdiBeanManagerAccess = false ; deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; } } else { // !startEarly if ( twoPhaseBootStrapCapable ) { deployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; } else if ( false == Configuration . needClassFileTransformer ( pu ) ) { final boolean allowCdiBeanManagerAccess = true ; // PUs that have Configuration.JPA_CONTAINER_CLASS_TRANSFORMER = false will start during INSTALL phase deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; } } } else { ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; } } } } }", "nl": "Add one PU service per top level deployment that represents"}}
{"translation": {"code": "public static Map < String , ExtendedEntityManager > popCall ( ) { ArrayList < Map < String , ExtendedEntityManager > > stack = currentSFSBCallStack ( ) ; Map < String , ExtendedEntityManager > result = stack . remove ( stack . size ( ) - 1 ) ; stack . trimToSize ( ) ; return result ; }", "nl": "Pops the current SFSB invocation off the invocation call stack"}}
{"translation": {"code": "@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { // get hold of the deployment unit DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; final ModuleSpecification moduleSpecification = deploymentUnit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; //always add EE API moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_API , false , false , true , false ) ) ; // previously exported by EJB_API prior to WFLY-5922 TODO WFLY-5967 look into moving this to WS subsystem moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , JAX_RPC_API , false , false , true , false ) ) ; //we always give them the EJB client moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_CLIENT , false , false , true , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_NAMING_CLIENT , false , false , true , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_IIOP_CLIENT , false , false , false , false ) ) ; //we always have to add this, as even non-ejb deployments may still lookup IIOP ejb's moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , EJB_SUBSYSTEM , false , false , true , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_EJB , false , false , true , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_NAMING , false , false , true , false ) ) ; moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , HTTP_TRANSACTION , false , false , true , false ) ) ; if ( IIOPDeploymentMarker . isIIOPDeployment ( deploymentUnit ) ) { //needed for dynamic IIOP stubs moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , IIOP_OPENJDK , false , false , false , false ) ) ; } // fetch the EjbJarMetaData //TODO: remove the app client bit after the next EJB release if ( ! isEjbDeployment ( deploymentUnit ) && ! DeploymentTypeMarker . isType ( DeploymentType . APPLICATION_CLIENT , deploymentUnit ) ) { // nothing to do return ; } // FIXME: still not the best way to do it //this must be the first dep listed in the module if ( Boolean . getBoolean ( \"org.jboss.as.ejb3.EMBEDDED\" ) ) moduleSpecification . addSystemDependency ( new ModuleDependency ( moduleLoader , ModuleIdentifier . CLASSPATH , false , false , false , false ) ) ; }", "nl": "Adds Java EE module as a dependency to any deployment unit which is an EJB deployment"}}
{"translation": {"code": "public static void rebind ( final Context ctx , final String name , final Object value ) throws NamingException { final Name n = ctx . getNameParser ( \"\" ) . parse ( name ) ; rebind ( ctx , n , value ) ; }", "nl": "Rebind val to name in ctx and make sure that all intermediate contexts exist"}}
{"translation": {"code": "public void addComponent ( ComponentDescription description ) { final String componentName = description . getComponentName ( ) ; final String componentClassName = description . getComponentClassName ( ) ; if ( componentName == null ) { throw EeLogger . ROOT_LOGGER . nullVar ( \"componentName\" , \"module\" , moduleName ) ; } if ( componentClassName == null ) { throw EeLogger . ROOT_LOGGER . nullVar ( \"componentClassName\" , \"module\" , moduleName ) ; } if ( componentsByName . containsKey ( componentName ) ) { throw EeLogger . ROOT_LOGGER . componentAlreadyDefined ( componentName ) ; } componentsByName . put ( componentName , description ) ; List < ComponentDescription > list = componentsByClassName . get ( componentClassName ) ; if ( list == null ) { componentsByClassName . put ( componentClassName , list = new ArrayList < ComponentDescription > ( 1 ) ) ; } list . add ( description ) ; }", "nl": "Add a component to this module ."}}
{"translation": {"code": "public static boolean isJaxrsDeployment ( DeploymentUnit deploymentUnit ) { DeploymentUnit deployment = deploymentUnit . getParent ( ) == null ? deploymentUnit : deploymentUnit . getParent ( ) ; Boolean val = deployment . getAttachment ( ATTACHMENT_KEY ) ; return val != null && val ; }", "nl": "JAX - RS annotations are found in the deployment especially if it s an EAR one )"}}
{"translation": {"code": "public void addComponent ( final ComponentDescription description , final VirtualFile deploymentRoot ) { for ( final ViewDescription viewDescription : description . getViews ( ) ) { List < ViewInformation > viewComponents = componentsByViewName . get ( viewDescription . getViewClassName ( ) ) ; if ( viewComponents == null ) { viewComponents = new ArrayList < ViewInformation > ( 1 ) ; componentsByViewName . put ( viewDescription . getViewClassName ( ) , viewComponents ) ; } viewComponents . add ( new ViewInformation ( viewDescription , deploymentRoot , description . getComponentName ( ) ) ) ; } List < Description > components = componentsByName . get ( description . getComponentName ( ) ) ; if ( components == null ) { componentsByName . put ( description . getComponentName ( ) , components = new ArrayList < Description > ( 1 ) ) ; } components . add ( new Description ( description , deploymentRoot ) ) ; }", "nl": "Add a component to this application ."}}
{"translation": {"code": "public Set < ViewDescription > getComponents ( final String componentName , final String viewName , final VirtualFile deploymentRoot ) { final List < ViewInformation > info = componentsByViewName . get ( viewName ) ; if ( info == null ) { return Collections . < ViewDescription > emptySet ( ) ; } if ( componentName . contains ( \"#\" ) ) { final String [ ] parts = componentName . split ( \"#\" ) ; String path = parts [ 0 ] ; if ( ! path . startsWith ( \"../\" ) ) { path = \"../\" + path ; } final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; final String name = parts [ 1 ] ; final Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; for ( ViewInformation i : info ) { if ( i . beanName . equals ( name ) ) { //now we need to check the path if ( virtualPath . equals ( i . deploymentRoot ) ) { ret . add ( i . viewDescription ) ; } } } return ret ; } else { final Set < ViewDescription > all = new HashSet < ViewDescription > ( ) ; final Set < ViewDescription > thisDeployment = new HashSet < ViewDescription > ( ) ; for ( ViewInformation i : info ) { if ( i . beanName . equals ( componentName ) ) { all . add ( i . viewDescription ) ; if ( i . deploymentRoot . equals ( deploymentRoot ) ) { thisDeployment . add ( i . viewDescription ) ; } } } if ( all . size ( ) > 1 ) { return thisDeployment ; } return all ; } }", "nl": "Get all views in the application that have the given name and view type"}}
{"translation": {"code": "public synchronized < S extends Service > void addService ( Class < S > clazz , S service ) { for ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { bda . getServices ( ) . add ( clazz , service ) ; } }", "nl": "Adds a service to all bean deployment archives in the module"}}
{"translation": {"code": "public static void addClassLoaders ( ClassLoader topLevel , Set < ClassLoader > allClassLoaders ) { deploymentClassLoaders . put ( topLevel , allClassLoaders ) ; }", "nl": "Maps a top level class loader to all CL s in the deployment"}}
{"translation": {"code": "void create ( final Deployment dep ) { final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; WarMetaData warMD = ASHelper . getOptionalAttachment ( unit , WarMetaData . ATTACHMENT_KEY ) ; JBossWebMetaData jbossWebMD = warMD != null ? warMD . getMergedJBossWebMetaData ( ) : null ; if ( warMD == null ) { warMD = new WarMetaData ( ) ; } if ( jbossWebMD == null ) { jbossWebMD = new JBossWebMetaData ( ) ; warMD . setMergedJBossWebMetaData ( jbossWebMD ) ; unit . putAttachment ( WarMetaData . ATTACHMENT_KEY , warMD ) ; } createWebAppDescriptor ( dep , jbossWebMD ) ; createJBossWebAppDescriptor ( dep , jbossWebMD ) ; dep . addAttachment ( JBossWebMetaData . class , jbossWebMD ) ; }", "nl": "Creates web meta data for EJB deployments ."}}
{"translation": {"code": "private void createWebAppDescriptor ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { WSLogger . ROOT_LOGGER . trace ( \"Creating web.xml descriptor\" ) ; createServlets ( dep , jbossWebMD ) ; createServletMappings ( dep , jbossWebMD ) ; createSecurityConstraints ( dep , jbossWebMD ) ; createLoginConfig ( dep , jbossWebMD ) ; createSecurityRoles ( dep , jbossWebMD ) ; }", "nl": "Creates web . xml descriptor meta data ."}}
{"translation": {"code": "private String getAuthMethod ( final Deployment dep ) { for ( final Endpoint ejbEndpoint : dep . getService ( ) . getEndpoints ( ) ) { final String beanAuthMethod = ejb3SecurityAccessor . getAuthMethod ( ejbEndpoint ) ; final boolean hasBeanAuthMethod = beanAuthMethod != null ; if ( hasBeanAuthMethod ) { // First found auth-method defines war // login-config/auth-method return beanAuthMethod ; } } return null ; }", "nl": "Returns deployment authentication method ."}}
{"translation": {"code": "final EJBArchiveMetaData create ( final Deployment dep ) { if ( WSLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { WSLogger . ROOT_LOGGER . tracef ( \"Building JBoss agnostic meta data for EJB webservice deployment: %s\" , dep . getSimpleName ( ) ) ; } final EJBArchiveMetaData . Builder ejbArchiveMDBuilder = new EJBArchiveMetaData . Builder ( ) ; this . buildEnterpriseBeansMetaData ( dep , ejbArchiveMDBuilder ) ; this . buildWebservicesMetaData ( dep , ejbArchiveMDBuilder ) ; return ejbArchiveMDBuilder . build ( ) ; }", "nl": "Builds universal EJB meta data model that is AS agnostic ."}}
{"translation": {"code": "@ Override public Map < Class < ? extends Annotation > , Set < Class < ? > > > getAnnotatedClasses ( final Set uris ) { return annotations ; // TODO:  Should this be limited by URI }", "nl": "use a plain Set and it should work for both versions ."}}
{"translation": {"code": "protected Class < ? > processInjectionTargets ( final ResourceInjectionTarget resourceInjectionTarget , InjectionSource injectionSource , ClassLoader classLoader , DeploymentReflectionIndex deploymentReflectionIndex , ResourceInjectionMetaData entry , Class < ? > classType ) throws DeploymentUnitProcessingException { if ( entry . getInjectionTargets ( ) != null ) { for ( ResourceInjectionTargetMetaData injectionTarget : entry . getInjectionTargets ( ) ) { final String injectionTargetClassName = injectionTarget . getInjectionTargetClass ( ) ; final String injectionTargetName = injectionTarget . getInjectionTargetName ( ) ; final AccessibleObject fieldOrMethod = getInjectionTarget ( injectionTargetClassName , injectionTargetName , classLoader , deploymentReflectionIndex ) ; final Class < ? > injectionTargetType = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getType ( ) : ( ( Method ) fieldOrMethod ) . getParameterTypes ( ) [ 0 ] ; final String memberName = fieldOrMethod instanceof Field ? ( ( Field ) fieldOrMethod ) . getName ( ) : ( ( Method ) fieldOrMethod ) . getName ( ) ; if ( classType != null ) { if ( ! injectionTargetType . isAssignableFrom ( classType ) ) { boolean ok = false ; if ( classType . isPrimitive ( ) ) { if ( BOXED_TYPES . get ( classType ) . equals ( injectionTargetType ) ) { ok = true ; } } else if ( injectionTargetType . isPrimitive ( ) ) { if ( BOXED_TYPES . get ( injectionTargetType ) . equals ( classType ) ) { ok = true ; } } if ( ! ok ) { throw EeLogger . ROOT_LOGGER . invalidInjectionTarget ( injectionTarget . getInjectionTargetName ( ) , injectionTarget . getInjectionTargetClass ( ) , classType ) ; } classType = injectionTargetType ; } } else { classType = injectionTargetType ; } final InjectionTarget injectionTargetDescription = fieldOrMethod instanceof Field ? new FieldInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) : new MethodInjectionTarget ( injectionTargetClassName , memberName , classType . getName ( ) ) ; final ResourceInjectionConfiguration injectionConfiguration = new ResourceInjectionConfiguration ( injectionTargetDescription , injectionSource ) ; resourceInjectionTarget . addResourceInjection ( injectionConfiguration ) ; } } return classType ; }", "nl": "Processes the injection targets of a resource binding"}}
{"translation": {"code": "private String getClassLevelInjectionType ( final AnnotationInstance annotation ) { boolean isPC = annotation . name ( ) . local ( ) . equals ( \"PersistenceContext\" ) ; return isPC ? ENTITY_MANAGER_CLASS : ENTITY_MANAGERFACTORY_CLASS ; }", "nl": "Based on the the annotation type its either entitymanager or entitymanagerfactory"}}
{"translation": {"code": "public void addPreDestroyInterceptor ( InterceptorFactory interceptorFactory , int priority ) { preDestroyInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; }", "nl": "Adds a pre destroy interceptor"}}
{"translation": {"code": "public List < InterceptorFactory > getViewInterceptors ( Method method ) { OrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; if ( container == null ) { return Collections . emptyList ( ) ; } return container . getSortedItems ( ) ; }", "nl": "Get the view interceptors for a method . These interceptors are run sequentially on the server side of an invocation . The interceptor factories are used every time a new view instance is constructed called with a new factory context each time . The factory may return the same interceptor instance or a new interceptor instance as appropriate ."}}
{"translation": {"code": "public void addMethodInterceptor ( MethodIdentifier method , InterceptorDescription description ) { //we do not add method level interceptors to the set of interceptor classes, //as their around invoke annotations List < InterceptorDescription > interceptors = methodInterceptors . get ( method ) ; if ( interceptors == null ) { methodInterceptors . put ( method , interceptors = new ArrayList < InterceptorDescription > ( ) ) ; } final String name = description . getInterceptorClassName ( ) ; // add the interceptor class to the EEModuleDescription interceptors . add ( description ) ; this . allInterceptors = null ; }", "nl": "Add a method interceptor class name ."}}
{"translation": {"code": "public void addDependency ( ServiceName serviceName ) { if ( serviceName == null ) { throw EeLogger . ROOT_LOGGER . nullVar ( \"serviceName\" , \"component\" , componentName ) ; } dependencies . add ( serviceName ) ; }", "nl": "Add a dependency to this component . If the same dependency is added multiple times only the first will take effect ."}}
{"translation": {"code": "public List < InterceptorFactory > getClientInterceptors ( Method method ) { OrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; if ( container == null ) { return Collections . emptyList ( ) ; } return container . getSortedItems ( ) ; }", "nl": "Get the client interceptors for a method . These interceptors are run sequentially on the client side of an invocation . The interceptor factories are used every time a new client proxy instance is constructed called with a new factory context each time . The factory may return the same interceptor instance or a new interceptor instance as appropriate ."}}
{"translation": {"code": "public void addClientInterceptor ( InterceptorFactory interceptorFactory , int priority ) { for ( Method method : proxyFactory . getCachedMethods ( ) ) { addClientInterceptor ( method , interceptorFactory , priority ) ; } }", "nl": "Adds a client interceptor factory to all methods of a view"}}
{"translation": {"code": "public void addClientInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { OrderedItemContainer < InterceptorFactory > container = clientInterceptors . get ( method ) ; if ( container == null ) { clientInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; } container . add ( interceptorFactory , priority ) ; }", "nl": "Adds a client interceptor to the given method"}}
{"translation": {"code": "public List < InterceptorFactory > getComponentInterceptors ( Method method ) { Map < Method , OrderedItemContainer < List < InterceptorFactory > > > map = componentInterceptors ; OrderedItemContainer < List < InterceptorFactory > > interceptors = map . get ( method ) ; if ( interceptors == null ) { return Collections . emptyList ( ) ; } List < List < InterceptorFactory > > sortedItems = interceptors . getSortedItems ( ) ; List < InterceptorFactory > ret = new ArrayList <> ( ) ; for ( List < InterceptorFactory > item : sortedItems ) { ret . addAll ( item ) ; } return ret ; }", "nl": "Gets the interceptor list for a given method . This should not be called until all interceptors have been added ."}}
{"translation": {"code": "public ServiceName getServiceName ( ) { //TODO: need to set viewNameParts somewhere if ( ! viewNameParts . isEmpty ( ) ) { return componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewNameParts . toArray ( new String [ viewNameParts . size ( ) ] ) ) ; } else { return componentDescription . getServiceName ( ) . append ( \"VIEW\" ) . append ( viewClassName ) ; } }", "nl": "Get the service name for this view ."}}
{"translation": {"code": "public Set < InterceptorDescription > getAllInterceptors ( ) { if ( allInterceptors == null ) { allInterceptors = new HashSet < InterceptorDescription > ( ) ; allInterceptors . addAll ( classInterceptors ) ; if ( ! excludeDefaultInterceptors ) { allInterceptors . addAll ( defaultInterceptors ) ; } for ( List < InterceptorDescription > interceptors : methodInterceptors . values ( ) ) { allInterceptors . addAll ( interceptors ) ; } } return allInterceptors ; }", "nl": "Returns a combined map of class and method level interceptors"}}
{"translation": {"code": "public void setComponentCreateServiceFactory ( final ComponentCreateServiceFactory componentCreateServiceFactory ) { if ( componentCreateServiceFactory == null ) { throw EeLogger . ROOT_LOGGER . nullVar ( \"componentCreateServiceFactory\" , \"component\" , getComponentName ( ) ) ; } this . componentCreateServiceFactory = componentCreateServiceFactory ; }", "nl": "Set the component create service factory for this component ."}}
{"translation": {"code": "public V put ( K key , V value ) { if ( value == null ) throw new NullPointerException ( ) ; int hash = hashOf ( key ) ; return segmentFor ( hash ) . put ( key , hash , value , false ) ; }", "nl": "Maps the specified key to the specified value in this table . Neither the key nor the value can be null ."}}
{"translation": {"code": "private void resolve ( ) { if ( ! resolved ) { synchronized ( this ) { if ( ! resolved ) { final Set < ViewDescription > views = getViews ( ) ; final Set < EJBViewDescription > ejbsForViewName = new HashSet < EJBViewDescription > ( ) ; for ( final ViewDescription view : views ) { if ( view instanceof EJBViewDescription ) { final MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; // @EJB injection *shouldn't* consider the @WebService endpoint view or MDBs if ( viewType == MethodIntf . SERVICE_ENDPOINT || viewType == MethodIntf . MESSAGE_ENDPOINT ) { continue ; } ejbsForViewName . add ( ( EJBViewDescription ) view ) ; } } if ( ejbsForViewName . isEmpty ( ) ) { if ( beanName == null ) { error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , bindingName ) ; } else { error = EjbLogger . ROOT_LOGGER . ejbNotFound ( typeName , beanName , bindingName ) ; } } else if ( ejbsForViewName . size ( ) > 1 ) { if ( beanName == null ) { error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , bindingName , ejbsForViewName ) ; } else { error = EjbLogger . ROOT_LOGGER . moreThanOneEjbFound ( typeName , beanName , bindingName , ejbsForViewName ) ; } } else { final EJBViewDescription description = ejbsForViewName . iterator ( ) . next ( ) ; final EJBViewDescription ejbViewDescription = ( EJBViewDescription ) description ; //for remote interfaces we do not want to use a normal binding //we need to bind the remote proxy factory into JNDI instead to get the correct behaviour if ( ejbViewDescription . getMethodIntf ( ) == MethodIntf . REMOTE || ejbViewDescription . getMethodIntf ( ) == MethodIntf . HOME ) { final EJBComponentDescription componentDescription = ( EJBComponentDescription ) description . getComponentDescription ( ) ; final EEModuleDescription moduleDescription = componentDescription . getModuleDescription ( ) ; final String earApplicationName = moduleDescription . getEarApplicationName ( ) ; final Value < ClassLoader > viewClassLoader = new Value < ClassLoader > ( ) { @ Override public ClassLoader getValue ( ) throws IllegalStateException , IllegalArgumentException { final Module module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; return module != null ? module . getClassLoader ( ) : null ; } } ; remoteFactory = new RemoteViewManagedReferenceFactory ( earApplicationName , moduleDescription . getModuleName ( ) , moduleDescription . getDistinctName ( ) , componentDescription . getComponentName ( ) , description . getViewClassName ( ) , componentDescription . isStateful ( ) , viewClassLoader , appclient ) ; } final ServiceName serviceName = description . getServiceName ( ) ; resolvedViewName = serviceName ; } resolved = true ; } } } }", "nl": "Checks if this ejb injection has been resolved yet and if not resolves it ."}}
{"translation": {"code": "public void removeSecurityDomain ( String securityDomain ) { securityMgrMap . remove ( securityDomain ) ; auditMgrMap . remove ( securityDomain ) ; authMgrMap . remove ( securityDomain ) ; authzMgrMap . remove ( securityDomain ) ; idmMgrMap . remove ( securityDomain ) ; mappingMgrMap . remove ( securityDomain ) ; jsseMap . remove ( securityDomain ) ; }", "nl": "Removes one security domain from the maps"}}
{"translation": {"code": "public static EntityManager get ( String puScopedName ) { Map < String , EntityManager > map = nonTxStack . peek ( ) ; if ( map != null ) { return map . get ( puScopedName ) ; } return null ; }", "nl": "Return the transactional entity manager for the specified scoped persistence unit name"}}
{"translation": {"code": "public static void popCall ( ) { Map < String , EntityManager > emStack = nonTxStack . pop ( ) ; if ( emStack != null ) { for ( EntityManager entityManager : emStack . values ( ) ) { try { if ( entityManager . isOpen ( ) ) { entityManager . close ( ) ; } } catch ( RuntimeException safeToIgnore ) { if ( ROOT_LOGGER . isTraceEnabled ( ) ) { ROOT_LOGGER . trace ( \"Could not close (non-transactional) container managed entity manager.\" + \"  This shouldn't impact application functionality (only read \" + \"operations occur in non-transactional mode)\" , safeToIgnore ) ; } } } } }", "nl": "current session bean invocation is ending close any transactional entity managers created without a JTA transaction ."}}
{"translation": {"code": "protected static void addTxManagementInterceptorForView ( ViewDescription view ) { // add a Tx configurator view . getConfigurators ( ) . add ( new ViewConfigurator ( ) { @ Override public void configure ( DeploymentPhaseContext context , ComponentConfiguration componentConfiguration , ViewDescription description , ViewConfiguration configuration ) throws DeploymentUnitProcessingException { EJBComponentDescription ejbComponentDescription = ( EJBComponentDescription ) componentConfiguration . getComponentDescription ( ) ; // Add CMT interceptor factory if ( TransactionManagementType . CONTAINER . equals ( ejbComponentDescription . getTransactionManagementType ( ) ) ) { configuration . addViewInterceptor ( CMTTxInterceptor . FACTORY , InterceptorOrder . View . CMT_TRANSACTION_INTERCEPTOR ) ; } } } ) ; }", "nl": "Sets up the transaction management interceptor for all methods of the passed view ."}}
{"translation": {"code": "public static ServiceName contextServiceNameOfModule ( String app , String module ) { return MODULE_CONTEXT_SERVICE_NAME . append ( app , module ) ; }", "nl": "Get the base service name of a module s JNDI namespace ."}}
{"translation": {"code": "public static ServiceName contextServiceNameOfComponent ( String app , String module , String comp ) { return COMPONENT_CONTEXT_SERVICE_NAME . append ( app , module , comp ) ; }", "nl": "Get the base service name of a component s JNDI namespace ."}}
{"translation": {"code": "public static BindInfo bindInfoForEnvEntry ( String app , String module , String comp , boolean useCompNamespace , final String envEntryName ) { if ( envEntryName . startsWith ( \"java:\" ) ) { if ( useCompNamespace ) { return bindInfoFor ( app , module , comp , envEntryName ) ; } else { if ( envEntryName . startsWith ( \"java:comp\" ) ) { return bindInfoFor ( app , module , module , \"java:module\" + envEntryName . substring ( \"java:comp\" . length ( ) ) ) ; } else { return bindInfoFor ( app , module , module , envEntryName ) ; } } } else { if ( useCompNamespace ) { return bindInfoFor ( app , module , comp , \"java:comp/env/\" + envEntryName ) ; } else { return bindInfoFor ( app , module , module , \"java:module/env/\" + envEntryName ) ; } } }", "nl": "Get the service name of an environment entry"}}
{"translation": {"code": "private void addWeldIntegration ( final Iterable < ComponentIntegrator > componentIntegrators , final ComponentInterceptorSupport componentInterceptorSupport , final ServiceTarget target , final ComponentConfiguration configuration , final ComponentDescription description , final Class < ? > componentClass , final String beanName , final ServiceName weldServiceName , final ServiceName weldStartService , final ServiceName beanManagerService , final Set < Class < ? > > interceptorClasses , final ClassLoader classLoader , final String beanDeploymentArchiveId ) { final ServiceName serviceName = configuration . getComponentDescription ( ) . getServiceName ( ) . append ( \"WeldInstantiator\" ) ; final ServiceBuilder < ? > builder = target . addService ( serviceName ) ; builder . requires ( weldStartService ) ; configuration . setInstanceFactory ( WeldManagedReferenceFactory . INSTANCE ) ; configuration . getStartDependencies ( ) . add ( new DependencyConfigurator < ComponentStartService > ( ) { @ Override public void configureDependency ( final ServiceBuilder < ? > serviceBuilder , ComponentStartService service ) throws DeploymentUnitProcessingException { serviceBuilder . requires ( serviceName ) ; } } ) ; boolean isComponentIntegrationPerformed = false ; for ( ComponentIntegrator componentIntegrator : componentIntegrators ) { Supplier < ServiceName > bindingServiceNameSupplier = ( ) -> { if ( componentInterceptorSupport == null ) { throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; } return addWeldInterceptorBindingService ( target , configuration , componentClass , beanName , weldServiceName , weldStartService , beanDeploymentArchiveId , componentInterceptorSupport ) ; } ; DefaultInterceptorIntegrationAction integrationAction = ( bindingServiceName ) - > { if ( componentInterceptorSupport == null )  { throw WeldLogger . DEPLOYMENT_LOGGER . componentInterceptorSupportNotAvailable ( componentClass ) ; } addJsr299BindingsCreateInterceptor ( configuration , description , beanName , weldServiceName , builder , bindingServiceName , componentInterceptorSupport ) ; addCommonLifecycleInterceptionSupport ( configuration , builder , bindingServiceName , beanManagerService , componentInterceptorSupport ) ; configuration . addComponentInterceptor ( new UserInterceptorFactory ( factory ( InterceptionType . AROUND_INVOKE , builder , bindingServiceName , componentInterceptorSupport ) , factory ( InterceptionType . AROUND_TIMEOUT , builder , bindingServiceName , componentInterceptorSupport ) ) , InterceptorOrder . Component . CDI_INTERCEPTORS , false ) ; } ; if ( componentIntegrator . integrate ( beanManagerService , configuration , description , builder , bindingServiceNameSupplier , integrationAction , componentInterceptorSupport ) ) { isComponentIntegrationPerformed = true ; break ; } }", "nl": "As the weld based instantiator needs access to the bean manager it is installed as a service ."}}
{"translation": {"code": "public ConcurrentMap < Principal , DomainInfo > getCache ( ) { return new LRUCache <> ( 1000 , ( key , value ) -> { if ( value != null ) { value . logout ( ) ; } } ) ; }", "nl": "Returns a default cache implementation"}}
{"translation": {"code": "public ComponentInstance createInstance ( Object instance ) { BasicComponentInstance obj = constructComponentInstance ( new ImmediateManagedReference ( instance ) , true ) ; obj . constructionFinished ( ) ; return obj ; }", "nl": "Wraps an existing object instance in a ComponentInstance and run the post construct interceptor chain on it ."}}
{"translation": {"code": "private void processXmlManagedBeans ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { InputStream is = null ; try { is = facesConfig . openStream ( ) ; final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; StringBuilder className = null ; int indent = 0 ; boolean managedBean = false ; boolean managedBeanClass = false ; while ( true ) { int event = parser . next ( ) ; if ( event == XMLStreamConstants . END_DOCUMENT ) { parser . close ( ) ; break ; } if ( event == XMLStreamConstants . START_ELEMENT ) { indent ++ ; if ( indent == 2 ) { if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN ) ) { managedBean = true ; } } else if ( indent == 3 && managedBean ) { if ( parser . getLocalName ( ) . equals ( MANAGED_BEAN_CLASS ) ) { managedBeanClass = true ; className = new StringBuilder ( ) ; } } } else if ( event == XMLStreamConstants . END_ELEMENT ) { indent -- ; managedBeanClass = false ; if ( indent == 1 ) { managedBean = false ; } if ( className != null ) { managedBeanClasses . add ( className . toString ( ) . trim ( ) ) ; className = null ; } } else if ( managedBeanClass && event == XMLStreamConstants . CHARACTERS ) { className . append ( parser . getText ( ) ) ; } } } catch ( Exception e ) { JSFLogger . ROOT_LOGGER . managedBeansConfigParseFailed ( facesConfig ) ; } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException e ) { // Ignore } } } }", "nl": "Parse the faces config files looking for managed bean classes . The parser is quite simplistic as the only information we need is the managed - bean - class element"}}
{"translation": {"code": "public Set < ViewDescription > getComponentsForViewName ( final String viewType , final VirtualFile deploymentRoot ) { final List < ViewInformation > info = componentsByViewName . get ( viewType ) ; if ( info == null ) { return Collections . < ViewDescription > emptySet ( ) ; } final Set < ViewDescription > ret = new HashSet < ViewDescription > ( ) ; final Set < ViewDescription > currentDep = new HashSet < ViewDescription > ( ) ; for ( ViewInformation i : info ) { if ( deploymentRoot . equals ( i . deploymentRoot ) ) { currentDep . add ( i . viewDescription ) ; } ret . add ( i . viewDescription ) ; } if ( ! currentDep . isEmpty ( ) ) { return currentDep ; } return ret ; }", "nl": "Get all views that have the given type in the application"}}
{"translation": {"code": "private void processPhaseListeners ( final DeploymentUnit deploymentUnit , final Set < String > managedBeanClasses ) { for ( final VirtualFile facesConfig : getConfigurationFiles ( deploymentUnit ) ) { InputStream is = null ; try { is = facesConfig . openStream ( ) ; final XMLInputFactory inputFactory = XMLInputFactory . newInstance ( ) ; inputFactory . setXMLResolver ( NoopXMLResolver . create ( ) ) ; XMLStreamReader parser = inputFactory . createXMLStreamReader ( is ) ; StringBuilder phaseListenerName = null ; int indent = 0 ; boolean lifecycle = false ; boolean phaseListener = false ; while ( true ) { int event = parser . next ( ) ; if ( event == XMLStreamConstants . END_DOCUMENT ) { parser . close ( ) ; break ; } if ( event == XMLStreamConstants . START_ELEMENT ) { indent ++ ; if ( indent == 2 ) { if ( parser . getLocalName ( ) . equals ( LIFECYCLE ) ) { lifecycle = true ; } } else if ( indent == 3 && lifecycle ) { if ( parser . getLocalName ( ) . equals ( PHASE_LISTENER ) ) { phaseListener = true ; phaseListenerName = new StringBuilder ( ) ; } } } else if ( event == XMLStreamConstants . END_ELEMENT ) { indent -- ; phaseListener = false ; if ( indent == 1 ) { lifecycle = false ; } if ( phaseListenerName != null ) { managedBeanClasses . add ( phaseListenerName . toString ( ) . trim ( ) ) ; phaseListenerName = null ; } } else if ( phaseListener && event == XMLStreamConstants . CHARACTERS ) { phaseListenerName . append ( parser . getText ( ) ) ; } } } catch ( Exception e ) { JSFLogger . ROOT_LOGGER . phaseListenersConfigParseFailed ( facesConfig ) ; } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IOException e ) { // Ignore } } } }", "nl": "WFLY - 6617 According to JSF 2 . 2 spec it should be possible to inject beans using"}}
{"translation": {"code": "public ViewConfiguration createViewConfiguration ( final Class < ? > viewClass , final ComponentConfiguration componentConfiguration , final ProxyFactory < ? > proxyFactory ) { return new ViewConfiguration ( viewClass , componentConfiguration , getServiceName ( ) , proxyFactory ) ; }", "nl": "Creates view configuration . Allows for extensibility in EE sub components ."}}
{"translation": {"code": "public void addViewInterceptor ( Method method , InterceptorFactory interceptorFactory , int priority ) { OrderedItemContainer < InterceptorFactory > container = viewInterceptors . get ( method ) ; if ( container == null ) { viewInterceptors . put ( method , container = new OrderedItemContainer < InterceptorFactory > ( ) ) ; } container . add ( interceptorFactory , priority ) ; }", "nl": "Adds a view interceptor to the given method"}}
{"translation": {"code": "public void addViewInterceptor ( InterceptorFactory interceptorFactory , int priority ) { for ( Method method : proxyFactory . getCachedMethods ( ) ) { addViewInterceptor ( method , interceptorFactory , priority ) ; } }", "nl": "Adds an interceptor factory to all methods of a view"}}
{"translation": {"code": "public Set < ComponentDescription > getComponents ( final String componentName , final VirtualFile deploymentRoot ) { if ( componentName . contains ( \"#\" ) ) { final String [ ] parts = componentName . split ( \"#\" ) ; String path = parts [ 0 ] ; if ( ! path . startsWith ( \"../\" ) ) { path = \"../\" + path ; } final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; final String name = parts [ 1 ] ; final List < Description > info = componentsByName . get ( name ) ; if ( info == null ) { return Collections . emptySet ( ) ; } final Set < ComponentDescription > ret = new HashSet < ComponentDescription > ( ) ; for ( Description i : info ) { //now we need to check the path if ( virtualPath . equals ( i . deploymentRoot ) ) { ret . add ( i . componentDescription ) ; } } return ret ; } else { final List < Description > info = componentsByName . get ( componentName ) ; if ( info == null ) { return Collections . emptySet ( ) ; } final Set < ComponentDescription > all = new HashSet < ComponentDescription > ( ) ; final Set < ComponentDescription > thisDeployment = new HashSet < ComponentDescription > ( ) ; for ( Description i : info ) { all . add ( i . componentDescription ) ; if ( i . deploymentRoot . equals ( deploymentRoot ) ) { thisDeployment . add ( i . componentDescription ) ; } } //if there are multiple e if ( all . size ( ) > 1 ) { return thisDeployment ; } return all ; } }", "nl": "Get all components in the application that have the given name"}}
{"translation": {"code": "static void releaseLock ( final StatefulSessionComponentInstance instance ) { instance . getLock ( ) . unlock ( getLockOwner ( instance . getComponent ( ) . getTransactionSynchronizationRegistry ( ) ) ) ; ROOT_LOGGER . tracef ( \"Released lock: %s\" , instance . getLock ( ) ) ; }", "nl": "Releases the lock held by this thread on the stateful component instance ."}}
{"translation": {"code": "public void merge ( final List < ResteasyDeploymentData > deploymentData ) throws DeploymentUnitProcessingException { for ( ResteasyDeploymentData data : deploymentData ) { scannedApplicationClasses . addAll ( data . getScannedApplicationClasses ( ) ) ; if ( scanResources ) { scannedResourceClasses . addAll ( data . getScannedResourceClasses ( ) ) ; scannedJndiComponentResources . addAll ( data . getScannedJndiComponentResources ( ) ) ; } if ( scanProviders ) { scannedProviderClasses . addAll ( data . getScannedProviderClasses ( ) ) ; } } }", "nl": "Merges a list of additional JAX - RS deployment data with this lot of deployment data ."}}
{"translation": {"code": "private void registerSessionBeanInterceptors ( SessionBeanComponentDescription componentDescription , final DeploymentUnit deploymentUnit ) { // if it's a SFSB then setup appropriate interceptors if ( componentDescription . isStateful ( ) ) { // first setup the post construct and pre destroy component interceptors componentDescription . getConfigurators ( ) . addFirst ( new ComponentConfigurator ( ) { @ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { configuration . addPostConstructInterceptor ( SFSBPreCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_PRE_CREATE ) ; configuration . addPostConstructInterceptor ( SFSBCreateInterceptor . FACTORY , InterceptorOrder . ComponentPostConstruct . JPA_SFSB_CREATE ) ; configuration . addPreDestroyInterceptor ( SFSBDestroyInterceptor . FACTORY , InterceptorOrder . ComponentPreDestroy . JPA_SFSB_DESTROY ) ; configuration . addComponentInterceptor ( SFSBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SFSB_INTERCEPTOR , false ) ; //we need to serialized the entity manager state configuration . getInterceptorContextKeys ( ) . add ( SFSBInvocationInterceptor . CONTEXT_KEY ) ; } } ) ; } // register interceptor on stateful/stateless SB with transactional entity manager. if ( ( componentDescription . isStateful ( ) || componentDescription . isStateless ( ) ) ) { componentDescription . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration configuration ) throws DeploymentUnitProcessingException { configuration . addComponentInterceptor ( SBInvocationInterceptor . FACTORY , InterceptorOrder . Component . JPA_SESSION_BEAN_INTERCEPTOR , false ) ; } } ) ; } }", "nl": "Register our listeners on SFSB that will be created"}}
{"translation": {"code": "public static void beginSfsbCreation ( ) { SFSBCallStackThreadData data = CURRENT . get ( ) ; int no = data . creationBeanNestingLevel ; if ( no == 0 ) { data . creationTimeXPCRegistration = new HashMap < String , ExtendedEntityManager > ( ) ; // create new tracking structure (passing in parent levels tracking structure or null if toplevel) data . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( data . creationTimeInjectedXPCs , null ) ; } else { // create new tracking structure (passing in parent levels tracking structure or null if toplevel) SFSBInjectedXPCs parent = data . creationTimeInjectedXPCs ; data . creationTimeInjectedXPCs = new SFSBInjectedXPCs ( parent , parent . getTopLevel ( ) ) ; } data . creationBeanNestingLevel ++ ; }", "nl": "called from SFSBPreCreateInterceptor before bean creation"}}
{"translation": {"code": "public static void endSfsbCreation ( ) { SFSBCallStackThreadData data = CURRENT . get ( ) ; int no = data . creationBeanNestingLevel ; no -- ; data . creationBeanNestingLevel = no ; if ( no == 0 ) { // Completed creating top level bean, remove 'xpc creation tracking' thread local data . creationTimeXPCRegistration = null ; data . creationTimeInjectedXPCs = null ; } else { // finished creating a sub-bean, switch to parent level 'xpc creation tracking' data . creationTimeInjectedXPCs = data . creationTimeInjectedXPCs . getParent ( ) ; } }", "nl": "called from SFSBPreCreateInterceptor after bean creation"}}
{"translation": {"code": "public static BindInfo bindInfoFor ( final String jndiName ) { // TODO: handle non java: schemes String bindName ; if ( jndiName . startsWith ( \"java:\" ) ) { bindName = jndiName . substring ( 5 ) ; } else if ( ! jndiName . startsWith ( \"jboss\" ) && ! jndiName . startsWith ( \"global\" ) && ! jndiName . startsWith ( \"/\" ) ) { bindName = \"/\" + jndiName ; } else { bindName = jndiName ; } final ServiceName parentContextName ; if ( bindName . startsWith ( \"jboss/exported/\" ) ) { parentContextName = EXPORTED_CONTEXT_SERVICE_NAME ; bindName = bindName . substring ( 15 ) ; } else if ( bindName . startsWith ( \"jboss/\" ) ) { parentContextName = JBOSS_CONTEXT_SERVICE_NAME ; bindName = bindName . substring ( 6 ) ; } else if ( bindName . startsWith ( \"global/\" ) ) { parentContextName = GLOBAL_CONTEXT_SERVICE_NAME ; bindName = bindName . substring ( 7 ) ; } else if ( bindName . startsWith ( \"/\" ) ) { parentContextName = JAVA_CONTEXT_SERVICE_NAME ; bindName = bindName . substring ( 1 ) ; } else { throw NamingLogger . ROOT_LOGGER . illegalContextInName ( jndiName ) ; } return new BindInfo ( parentContextName , bindName ) ; }", "nl": "Get the service name of a NamingStore"}}
{"translation": {"code": "public EEModuleClassDescription getClassByName ( String name ) { for ( EEModuleDescription module : availableModules ) { final EEModuleClassDescription desc = module . getClassDescription ( name ) ; if ( desc != null ) { return desc ; } } return null ; }", "nl": "Look for a class description in all available modules ."}}
{"translation": {"code": "private static PersistenceProvider lookupProvider ( PersistenceUnitMetadata pu , PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder , DeploymentUnit deploymentUnit ) throws DeploymentUnitProcessingException { /**\n         * check if the deployment is already associated with the specified persistence provider\n         */ Map < String , PersistenceProvider > providerMap = persistenceProviderDeploymentHolder != null ? persistenceProviderDeploymentHolder . getProviders ( ) : null ; if ( providerMap != null ) { synchronized ( providerMap ) { if ( providerMap . containsKey ( pu . getPersistenceProviderClassName ( ) ) ) { ROOT_LOGGER . tracef ( \"deployment %s is using %s\" , deploymentUnit . getName ( ) , pu . getPersistenceProviderClassName ( ) ) ; return providerMap . get ( pu . getPersistenceProviderClassName ( ) ) ; } } } String configuredPersistenceProviderModule = pu . getProperties ( ) . getProperty ( Configuration . PROVIDER_MODULE ) ; String persistenceProviderClassName = pu . getPersistenceProviderClassName ( ) ; if ( persistenceProviderClassName == null ) { persistenceProviderClassName = Configuration . PROVIDER_CLASS_DEFAULT ; } /**\n         * locate persistence provider in specified static module\n         */ if ( configuredPersistenceProviderModule != null ) { List < PersistenceProvider > providers ; if ( Configuration . PROVIDER_MODULE_APPLICATION_SUPPLIED . equals ( configuredPersistenceProviderModule ) ) { try { // load the persistence provider from the application deployment final ModuleClassLoader classLoader = deploymentUnit . getAttachment ( Attachments . MODULE ) . getClassLoader ( ) ; PersistenceProvider provider = PersistenceProviderLoader . loadProviderFromDeployment ( classLoader , persistenceProviderClassName ) ; providers = new ArrayList <> ( ) ; providers . add ( provider ) ; PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; return provider ; } catch ( ClassNotFoundException e ) { throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; } catch ( InstantiationException e ) { throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; } catch ( IllegalAccessException e ) { throw JpaLogger . ROOT_LOGGER . cannotDeployApp ( e , persistenceProviderClassName ) ; } } else { try { providers = PersistenceProviderLoader . loadProviderModuleByName ( configuredPersistenceProviderModule ) ; PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; PersistenceProvider provider = getProviderByName ( pu , providers ) ; if ( provider != null ) { return provider ; } } catch ( ModuleLoadException e ) { throw JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , configuredPersistenceProviderModule , persistenceProviderClassName ) ; } } } // try to determine the static module name based on the persistence provider class name String providerNameDerivedFromClassName = Configuration . getProviderModuleNameFromProviderClassName ( persistenceProviderClassName ) ; // see if the providerNameDerivedFromClassName has been loaded yet PersistenceProvider provider = getProviderByName ( pu ) ; // if we haven't loaded the provider yet, try loading now if ( provider == null && providerNameDerivedFromClassName != null ) { try { List < PersistenceProvider > providers = PersistenceProviderLoader . loadProviderModuleByName ( providerNameDerivedFromClassName ) ; PersistenceProviderDeploymentHolder . savePersistenceProviderInDeploymentUnit ( deploymentUnit , providers , null ) ; provider = getProviderByName ( pu , providers ) ; } catch ( ModuleLoadException e ) { throw JpaLogger . ROOT_LOGGER . cannotLoadPersistenceProviderModule ( e , providerNameDerivedFromClassName , persistenceProviderClassName ) ; } } if ( provider == null ) throw JpaLogger . ROOT_LOGGER . persistenceProviderNotFound ( persistenceProviderClassName ) ; return provider ; }", "nl": "Look up the persistence provider"}}
{"translation": {"code": "protected void stopWebApp ( Deployment deployment ) throws Exception { WebDeploymentController context ; try { context = deployment . getAttachment ( WebDeploymentController . class ) ; context . stop ( ) ; } catch ( Exception e ) { throw WSLogger . ROOT_LOGGER . stopContextPhaseFailed ( e ) ; } try { context . destroy ( ) ; } catch ( Exception e ) { throw WSLogger . ROOT_LOGGER . destroyContextPhaseFailed ( e ) ; } }", "nl": "Stops the webapp serving the provided ws deployment"}}
{"translation": {"code": "protected Context doPublish ( ServiceTarget target , DeploymentUnit unit ) throws Exception { Deployment deployment = unit . getAttachment ( WSAttachmentKeys . DEPLOYMENT_KEY ) ; List < Endpoint > endpoints = deployment . getService ( ) . getEndpoints ( ) ; //If we're running in a Service, that will already have proper dependencies set on the installed endpoint services, //otherwise we need to explicitly wait for the endpoint services to be started before creating the webapp. if ( ! runningInService ) { final ServiceRegistry registry = unit . getServiceRegistry ( ) ; final StabilityMonitor monitor = new StabilityMonitor ( ) ; for ( Endpoint ep : endpoints ) { final ServiceName serviceName = EndpointService . getServiceName ( unit , ep . getShortName ( ) ) ; monitor . addController ( registry . getRequiredService ( serviceName ) ) ; } try { monitor . awaitStability ( ) ; } finally { monitor . clear ( ) ; } } deployment . addAttachment ( WebDeploymentController . class , startWebApp ( host , unit ) ) ; //TODO simplify and use findChild later in destroy()/stopWebApp() return new Context ( unit . getAttachment ( WSAttachmentKeys . JBOSSWEB_METADATA_KEY ) . getContextRoot ( ) , endpoints ) ; }", "nl": "Publish the webapp for the WS deployment unit"}}
{"translation": {"code": "protected void doDeploy ( ServiceTarget target , DeploymentUnit unit ) { List < DeploymentAspect > aspects = getDeploymentAspects ( ) ; ClassLoader origClassLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; Deployment dep = null ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( ClassLoaderProvider . getDefaultProvider ( ) . getServerIntegrationClassLoader ( ) ) ; dep = unit . getAttachment ( WSAttachmentKeys . DEPLOYMENT_KEY ) ; dep . addAttachment ( ServiceTarget . class , target ) ; DeploymentAspectManager dam = new DeploymentAspectManagerImpl ( ) ; dam . setDeploymentAspects ( aspects ) ; dam . deploy ( dep ) ; } finally { if ( dep != null ) { dep . removeAttachment ( ServiceTarget . class ) ; } WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origClassLoader ) ; } }", "nl": "Triggers the WS deployment aspects which process the deployment and install the endpoint services ."}}
{"translation": {"code": "public void addTimeoutViewInterceptor ( final Method method , InterceptorFactory factory , int priority ) { OrderedItemContainer < InterceptorFactory > interceptors = timeoutInterceptors . get ( method ) ; if ( interceptors == null ) { timeoutInterceptors . put ( method , interceptors = new OrderedItemContainer < InterceptorFactory > ( ) ) ; } interceptors . add ( factory , priority ) ; }", "nl": "Adds a timeout interceptor factory to every method on the component ."}}
{"translation": {"code": "public List < InterceptorFactory > getAroundTimeoutInterceptors ( Method method ) { Map < Method , OrderedItemContainer < InterceptorFactory > > map = timeoutInterceptors ; OrderedItemContainer < InterceptorFactory > interceptors = map . get ( method ) ; if ( interceptors == null ) { return Collections . emptyList ( ) ; } return interceptors . getSortedItems ( ) ; }", "nl": "Gets the around timeout interceptor list for a given method . This should not be called until all interceptors have been added ."}}
{"translation": {"code": "protected static Class < ? > getType ( ConfigVisitor visitor , String className ) { if ( className != null ) { try { return visitor . getModule ( ) . getClassLoader ( ) . loadClass ( className ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } } return null ; }", "nl": "Load class ."}}
{"translation": {"code": "static Type getComponentType ( ParameterizedType type , int index ) { Type [ ] tp = type . getActualTypeArguments ( ) ; if ( index + 1 > tp . length ) return null ; return tp [ index ] ; }", "nl": "Get component type ."}}
{"translation": {"code": "protected < U > U lookup ( Lookup < U > lookup , int start , int depth ) { int size ; synchronized ( indexes ) { size = indexes . size ( ) ; for ( int i = start ; i < depth && i < size ; i ++ ) { U result = lookup . lookup ( indexes . get ( i ) ) ; if ( result != null ) return result ; } } if ( currentClass == null ) return null ; synchronized ( indexes ) { ClassReflectionIndex cri = index . getClassIndex ( currentClass ) ; indexes . add ( cri ) ; currentClass = currentClass . getSuperclass ( ) ; } return lookup ( lookup , size , depth ) ; }", "nl": "Do lazy lookup ."}}
{"translation": {"code": "public static ServiceName toBeanName ( String name , BeanState state ) { if ( state == null ) state = BeanState . INSTALLED ; return JBOSS_POJO . append ( name ) . append ( state . name ( ) ) ; }", "nl": "Get MC bean name ."}}
{"translation": {"code": "public static ServiceName toInstancesName ( Class < ? > clazz , BeanState state ) { String clName ; ClassLoader classLoader = clazz . getClassLoader ( ) ; if ( classLoader != null ) clName = classLoader . toString ( ) ; else clName = \"SystemClassLoader\" ; if ( state == null ) state = BeanState . INSTALLED ; return JBOSS_POJO . append ( clName , clazz . getName ( ) , state . name ( ) ) ; }", "nl": "To instances name ."}}
{"translation": {"code": "public Object getValue ( Type type ) { if ( type == null || ( type instanceof Class ) ) { return getClassValue ( ( Class ) type ) ; } else if ( type instanceof ParameterizedType ) { ParameterizedType pt = ( ParameterizedType ) type ; return getPtValue ( pt ) ; } else { throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; } }", "nl": "Get value ."}}
{"translation": {"code": "protected static boolean simpleCheck ( String [ ] typeNames , Class < ? > [ ] typeInfos ) { return typeNames != null && typeInfos != null && typeNames . length == typeInfos . length ; }", "nl": "A simple null and length check ."}}
{"translation": {"code": "public static Class < ? > toClass ( Type type ) { if ( type instanceof Class ) { return ( Class ) type ; } else if ( type instanceof ParameterizedType ) { ParameterizedType pt = ( ParameterizedType ) type ; return toClass ( pt . getRawType ( ) ) ; } else { throw PojoLogger . ROOT_LOGGER . unknownType ( type ) ; } }", "nl": "Turn type into class ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public static Object convertValue ( Class < ? > clazz , Object value , boolean replaceProperties , boolean trim ) throws Throwable { if ( clazz == null ) return value ; if ( value == null ) return null ; Class < ? > valueClass = value . getClass ( ) ; // If we have a string, trim and replace any system properties when requested if ( valueClass == String . class ) { String string = ( String ) value ; if ( trim ) string = string . trim ( ) ; if ( replaceProperties ) value = PropertiesValueResolver . replaceProperties ( string ) ; } if ( clazz . isAssignableFrom ( valueClass ) ) return value ; // First see if this is an Enum if ( clazz . isEnum ( ) ) { Class < ? extends Enum > eclazz = clazz . asSubclass ( Enum . class ) ; return Enum . valueOf ( eclazz , value . toString ( ) ) ; } // Next look for a property editor if ( valueClass == String . class ) { PropertyEditor editor = PropertyEditorManager . findEditor ( clazz ) ; if ( editor != null ) { editor . setAsText ( ( String ) value ) ; return editor . getValue ( ) ; } } // Try a static clazz.valueOf(value) try { Method method = clazz . getMethod ( \"valueOf\" , valueClass ) ; int modifiers = method . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) && Modifier . isStatic ( modifiers ) && clazz . isAssignableFrom ( method . getReturnType ( ) ) ) return method . invoke ( null , value ) ; } catch ( Exception ignored ) { } if ( valueClass == String . class ) { try { Constructor constructor = clazz . getConstructor ( valueClass ) ; if ( Modifier . isPublic ( constructor . getModifiers ( ) ) ) return constructor . newInstance ( value ) ; } catch ( Exception ignored ) { } } return value ; }", "nl": "Convert a value"}}
{"translation": {"code": "public static String [ ] getTypes ( ValueConfig [ ] values ) { if ( values == null || values . length == 0 ) return NO_PARAMS_TYPES ; String [ ] types = new String [ values . length ] ; for ( int i = 0 ; i < types . length ; i ++ ) types [ i ] = values [ i ] . getType ( ) ; return types ; }", "nl": "Get types from values ."}}
{"translation": {"code": "@ Override protected void processAnnotations ( final DeploymentUnit deploymentUnit , final CompositeIndex compositeIndex ) throws DeploymentUnitProcessingException { if ( MetadataCompleteMarker . isMetadataComplete ( deploymentUnit ) ) { return ; } // Find and process any @Stateless bean annotations final List < AnnotationInstance > slsbAnnotations = compositeIndex . getAnnotations ( STATELESS_ANNOTATION ) ; if ( ! slsbAnnotations . isEmpty ( ) ) { processSessionBeans ( deploymentUnit , slsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATELESS ) ; } // Find and process any @Stateful bean annotations final List < AnnotationInstance > sfsbAnnotations = compositeIndex . getAnnotations ( STATEFUL_ANNOTATION ) ; if ( ! sfsbAnnotations . isEmpty ( ) ) { processSessionBeans ( deploymentUnit , sfsbAnnotations , SessionBeanComponentDescription . SessionBeanType . STATEFUL ) ; } // Find and process any @Singleton bean annotations final List < AnnotationInstance > sbAnnotations = compositeIndex . getAnnotations ( SINGLETON_ANNOTATION ) ; if ( ! sbAnnotations . isEmpty ( ) ) { processSessionBeans ( deploymentUnit , sbAnnotations , SessionBeanComponentDescription . SessionBeanType . SINGLETON ) ; } }", "nl": "Process annotations and merge any available metadata at the same time ."}}
{"translation": {"code": "public static synchronized ServiceName getDeploymentServiceName ( final String raName , final Activation raxml ) { if ( raName == null ) throw ConnectorLogger . ROOT_LOGGER . undefinedVar ( \"RaName\" ) ; ServiceName serviceName = null ; ModifiableResourceAdapter ra = ( ModifiableResourceAdapter ) raxml ; if ( ra != null && ra . getId ( ) != null ) { serviceName = getDeploymentServiceName ( raName , ra . getId ( ) ) ; } else { serviceName = getDeploymentServiceName ( raName , ( String ) null ) ; } ROOT_LOGGER . tracef ( \"ConnectorServices: getDeploymentServiceName(%s,%s) -> %s\" , raName , raxml , serviceName ) ; return serviceName ; }", "nl": "resource - adapter DMR resource"}}
{"translation": {"code": "private String addEarPrefixIfRelativeName ( final String configuredName , final DeploymentUnit deploymentUnit , final Class < ? > componentClass ) throws DeploymentUnitProcessingException { if ( ! configuredName . startsWith ( \"#\" ) ) { return configuredName ; } final DeploymentUnit parent = deploymentUnit . getParent ( ) ; if ( parent == null ) { throw EjbLogger . ROOT_LOGGER . relativeResourceAdapterNameInStandaloneModule ( deploymentUnit . getName ( ) , componentClass . getName ( ) , configuredName ) ; } return new StringBuilder ( ) . append ( parent . getName ( ) ) . append ( configuredName ) . toString ( ) ; }", "nl": "adds ear prefix to configured adapter name if it is specified in relative form"}}
{"translation": {"code": "private Map < String , TimerImpl > getWaitingOnTxCompletionTimers ( ) { Map < String , TimerImpl > timers = null ; if ( getTransaction ( ) != null ) { timers = ( Map < String , TimerImpl > ) tsr . getResource ( waitingOnTxCompletionKey ) ; } return timers == null ? Collections . < String , TimerImpl > emptyMap ( ) : timers ; }", "nl": "Returns an unmodifiable view of timers in the current transaction that are waiting for the transaction to finish"}}
{"translation": {"code": "public void setNextTimeout ( Date next ) { if ( next == null ) { setTimerState ( TimerState . EXPIRED , null ) ; } this . nextExpiration = next ; }", "nl": "Sets the next timeout of this timer"}}
{"translation": {"code": "protected void setTimerState ( TimerState state , Thread thread ) { assert ( ( state == TimerState . IN_TIMEOUT || state == TimerState . RETRY_TIMEOUT ) && thread != null ) || thread == null : \"Invalid to set timer state \" + state + \" with executing Thread \" + thread ; this . timerState = state ; this . executingThread = thread ; }", "nl": "Sets the state and timer task executing thread of this timer"}}
{"translation": {"code": "public static String statusAsString ( int status ) { if ( status >= Status . STATUS_ACTIVE && status <= Status . STATUS_ROLLING_BACK ) { return TxStatusStrings [ status ] ; } else { return \"STATUS_INVALID(\" + status + \")\" ; } }", "nl": "Converts a tx Status index to a String"}}
{"translation": {"code": "public T get ( ) { try { boolean acquired = semaphore . tryAcquire ( timeout , timeUnit ) ; if ( ! acquired ) throw EjbLogger . ROOT_LOGGER . failedToAcquirePermit ( timeout , timeUnit ) ; } catch ( InterruptedException e ) { throw EjbLogger . ROOT_LOGGER . acquireSemaphoreInterrupted ( ) ; } T bean = pool . poll ( ) ; if ( bean != null ) { //we found a bean instance in the pool, return it return bean ; } try { // Pool is empty, create an instance bean = create ( ) ; } finally { if ( bean == null ) { semaphore . release ( ) ; } } return bean ; }", "nl": "Get an instance without identity . Can be used by finders create - methods and activation"}}
{"translation": {"code": "private void incReadLockCount ( ) { Integer current = readLockCount . get ( ) ; int next ; if ( current == null ) next = 1 ; else next = current . intValue ( ) + 1 ; readLockCount . set ( new Integer ( next ) ) ; }", "nl": "Increments the read lock count held by the thread"}}
{"translation": {"code": "private void decReadLockCount ( ) { Integer current = readLockCount . get ( ) ; int next ; assert current != null : \"can't decrease, readLockCount is not set\" ; next = current . intValue ( ) - 1 ; if ( next == 0 ) readLockCount . remove ( ) ; else readLockCount . set ( new Integer ( next ) ) ; }", "nl": "Decrements the read lock count held by the thread"}}
{"translation": {"code": "protected void retryTimeout ( TimerImpl timer ) throws Exception { boolean callTimeout = false ; timer . lock ( ) ; try { if ( timer . isActive ( ) ) { EJB3_TIMER_LOGGER . retryingTimeout ( timer ) ; timer . setTimerState ( TimerState . RETRY_TIMEOUT , Thread . currentThread ( ) ) ; timerService . persistTimer ( timer , false ) ; callTimeout = true ; } else { EJB3_TIMER_LOGGER . timerNotActive ( timer ) ; } } finally { timer . unlock ( ) ; } if ( callTimeout ) { this . callTimeout ( timer ) ; } }", "nl": "After a timeout failed the timer need to retried . The method must lock the timer for state check and update but not during callTimeout run ."}}
{"translation": {"code": "protected void postTimeoutProcessing ( TimerImpl timer ) throws InterruptedException { timer . lock ( ) ; try { TimerState timerState = timer . getState ( ) ; if ( timerState != TimerState . CANCELED && timerState != TimerState . EXPIRED ) { if ( timer . getInterval ( ) == 0 ) { timerService . expireTimer ( timer ) ; } else { timer . setTimerState ( TimerState . ACTIVE , null ) ; } timerService . persistTimer ( timer , false ) ; } } finally { timer . unlock ( ) ; } }", "nl": "After running the timer calculate the new state or expire the timer and persist it if changed . The method must lock the timer for state check and updates if overridden ."}}
{"translation": {"code": "private String getDirectory ( String timedObjectId ) { String dirName = directories . get ( timedObjectId ) ; if ( dirName == null ) { dirName = baseDir . getAbsolutePath ( ) + File . separator + timedObjectId . replace ( File . separator , \"-\" ) ; File file = new File ( dirName ) ; if ( ! file . exists ( ) ) { if ( ! file . mkdirs ( ) ) { EJB3_TIMER_LOGGER . failToCreateDirectoryForPersistTimers ( file ) ; } } directories . put ( timedObjectId , dirName ) ; } return dirName ; }", "nl": "Gets the directory for a given timed object making sure it exists ."}}
{"translation": {"code": "private Map < String , TimerImpl > getTimers ( final String timedObjectId , final TimerServiceImpl timerService ) { return loadTimersFromFile ( timedObjectId , timerService ) ; }", "nl": "Gets the timer map loading from the persistent store if necessary . Should be called under lock"}}
{"translation": {"code": "public static String validateDescriptor ( String descriptor ) { if ( descriptor . length ( ) == 0 ) { throw EeLogger . ROOT_LOGGER . cannotBeEmpty ( \"descriptors\" ) ; } if ( descriptor . length ( ) > 1 ) { if ( descriptor . startsWith ( \"L\" ) ) { if ( ! descriptor . endsWith ( \";\" ) ) { throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; } } else if ( descriptor . startsWith ( \"[\" ) ) { } else { throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; } } else { char type = descriptor . charAt ( 0 ) ; switch ( type ) { case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : break ; default : throw EeLogger . ROOT_LOGGER . invalidDescriptor ( descriptor ) ; } } return descriptor ; }", "nl": "performs basic validation on a descriptor"}}
{"translation": {"code": "protected InjectionSource createInjectionSource ( final ServiceName serviceName , Value < ClassLoader > viewClassLoader , boolean appclient ) { return new ViewBindingInjectionSource ( serviceName ) ; }", "nl": "Create the injection source"}}
{"translation": {"code": "public static synchronized void addUrlContextFactory ( final String scheme , ObjectFactory factory ) { Map < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; factories . put ( scheme , factory ) ; urlContextFactories = Collections . unmodifiableMap ( factories ) ; }", "nl": "Add an ObjectFactory to handle requests for a specific URL scheme ."}}
{"translation": {"code": "private static Object getLockOwner ( final TransactionSynchronizationRegistry transactionSynchronizationRegistry ) { Object owner = transactionSynchronizationRegistry . getTransactionKey ( ) ; return owner != null ? owner : Thread . currentThread ( ) ; }", "nl": "Use either the active transaction or the current thread as the lock owner"}}
{"translation": {"code": "public static List < PersistenceProvider > loadProviderModuleByName ( String moduleName ) throws ModuleLoadException { final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; Module module = moduleLoader . loadModule ( ModuleIdentifier . fromString ( moduleName ) ) ; final ServiceLoader < PersistenceProvider > serviceLoader = module . loadService ( PersistenceProvider . class ) ; List < PersistenceProvider > result = new ArrayList <> ( ) ; if ( serviceLoader != null ) { for ( PersistenceProvider provider1 : serviceLoader ) { // persistence provider jar may contain multiple provider service implementations // save each provider PersistenceProviderResolverImpl . getInstance ( ) . addPersistenceProvider ( provider1 ) ; result . add ( provider1 ) ; } } return result ; }", "nl": "Loads the specified JPA persistence provider module"}}
{"translation": {"code": "public void registerEndpointHandlers ( final String endpointClass , final Set < String > endpointHandlers ) { if ( ( endpointClass == null ) || ( endpointHandlers == null ) ) { throw new IllegalArgumentException ( ) ; } endpointHandlersMap . put ( endpointClass , Collections . unmodifiableSet ( endpointHandlers ) ) ; }", "nl": "Registers endpoint and its associated WS handlers ."}}
{"translation": {"code": "public static String getEndpointName ( final ServletMetaData servletMD ) { final String endpointName = servletMD . getName ( ) ; return endpointName != null ? endpointName . trim ( ) : null ; }", "nl": "Returns endpoint name ."}}
{"translation": {"code": "public ServiceName getContextServiceName ( ) { if ( contextServiceName != null ) return contextServiceName ; if ( getNamingMode ( ) == ComponentNamingMode . CREATE ) { return ContextNames . contextServiceNameOfComponent ( getApplicationName ( ) , getModuleName ( ) , getComponentName ( ) ) ; } else if ( getNamingMode ( ) == ComponentNamingMode . USE_MODULE ) { return ContextNames . contextServiceNameOfModule ( getApplicationName ( ) , getModuleName ( ) ) ; } else { throw new IllegalStateException ( ) ; } }", "nl": "Get the context service name ."}}
{"translation": {"code": "public static String getContextRoot ( final Deployment dep , final JBossWebMetaData jbossWebMD ) { final DeploymentUnit unit = WSHelper . getRequiredAttachment ( dep , DeploymentUnit . class ) ; final JBossAppMetaData jbossAppMD = unit . getParent ( ) == null ? null : ASHelper . getOptionalAttachment ( unit . getParent ( ) , WSAttachmentKeys . JBOSS_APP_METADATA_KEY ) ; String contextRoot = null ; // prefer context root defined in application.xml over one defined in jboss-web.xml if ( jbossAppMD != null ) { final ModuleMetaData moduleMD = jbossAppMD . getModules ( ) . get ( dep . getSimpleName ( ) ) ; if ( moduleMD != null ) { final WebModuleMetaData webModuleMD = ( WebModuleMetaData ) moduleMD . getValue ( ) ; contextRoot = webModuleMD . getContextRoot ( ) ; } } if ( contextRoot == null ) { contextRoot = jbossWebMD != null ? jbossWebMD . getContextRoot ( ) : null ; } return contextRoot ; }", "nl": "Returns context root associated with webservice deployment ."}}
{"translation": {"code": "protected void addRemoteTransactionsDependency ( ) { this . getConfigurators ( ) . add ( new ComponentConfigurator ( ) { @ Override public void configure ( DeploymentPhaseContext context , ComponentDescription description , ComponentConfiguration componentConfiguration ) throws DeploymentUnitProcessingException { if ( this . hasRemoteView ( ( EJBComponentDescription ) description ) ) { // add a dependency on local transaction service componentConfiguration . getCreateDependencies ( ) . add ( ( sb , cs ) -> sb . requires ( TxnServices . JBOSS_TXN_REMOTE_TRANSACTION_SERVICE ) ) ; } } /**\n             * Returns true if the passed EJB component description has at least one remote view\n             * @param ejbComponentDescription\n             * @return\n             */ private boolean hasRemoteView ( final EJBComponentDescription ejbComponentDescription ) { final Set < ViewDescription > views = ejbComponentDescription . getViews ( ) ; for ( final ViewDescription view : views ) { if ( ! ( view instanceof EJBViewDescription ) ) { continue ; } final MethodIntf viewType = ( ( EJBViewDescription ) view ) . getMethodIntf ( ) ; if ( viewType == MethodIntf . REMOTE || viewType == MethodIntf . HOME ) { return true ; } } return false ; } } ) ; }", "nl": "Adds a dependency for the ComponentConfiguration on the remote transaction service if the EJB exposes at least one remote view"}}
{"translation": {"code": "private void handleStatelessSessionBean ( final EJBComponentDescription component , final Module module , final DeploymentReflectionIndex reflectionIndex ) throws ClassNotFoundException , DeploymentUnitProcessingException { final Class < ? > componentClass = ClassLoadingUtils . loadClass ( component . getComponentClassName ( ) , module ) ; final MethodIdentifier ejbCreateId = MethodIdentifier . getIdentifier ( void . class , \"ejbCreate\" ) ; final Method ejbCreate = ClassReflectionIndexUtil . findMethod ( reflectionIndex , componentClass , ejbCreateId ) ; if ( ejbCreate != null ) { final InterceptorClassDescription . Builder builder = InterceptorClassDescription . builder ( ) ; builder . setPostConstruct ( ejbCreateId ) ; component . addInterceptorMethodOverride ( ejbCreate . getDeclaringClass ( ) . getName ( ) , builder . build ( ) ) ; } final MethodIdentifier ejbRemoveId = MethodIdentifier . getIdentifier ( void . class , \"ejbRemove\" ) ; final Method ejbRemove = ClassReflectionIndexUtil . findMethod ( reflectionIndex , componentClass , ejbRemoveId ) ; if ( ejbRemove != null ) { final InterceptorClassDescription . Builder builder = InterceptorClassDescription . builder ( ) ; builder . setPreDestroy ( ejbRemoveId ) ; component . addInterceptorMethodOverride ( ejbRemove . getDeclaringClass ( ) . getName ( ) , builder . build ( ) ) ; } }", "nl": "Handles setting up the ejbCreate and ejbRemove methods for stateless session beans and MDB s"}}
{"translation": {"code": "public static List < EJBEndpoint > getJaxwsEjbs ( final DeploymentUnit unit ) { final JAXWSDeployment jaxwsDeployment = getOptionalAttachment ( unit , WSAttachmentKeys . JAXWS_ENDPOINTS_KEY ) ; return jaxwsDeployment != null ? jaxwsDeployment . getEjbEndpoints ( ) : Collections . < EJBEndpoint > emptyList ( ) ; }", "nl": "Gets list of JAXWS EJBs meta data ."}}
{"translation": {"code": "private boolean writeAttribute ( XMLExtendedStreamWriter writer , SimpleAttributeDefinition attribute , ModelNode node , boolean startWriten , String origin ) throws XMLStreamException { if ( attribute . isMarshallable ( node , false ) ) { if ( ! startWriten ) { startWriten = true ; writer . writeStartElement ( origin ) ; } attribute . marshallAsAttribute ( node , false , writer ) ; } return startWriten ; }", "nl": "todo attribute . marshallAsAttribute should return boolean"}}
{"translation": {"code": "public static List < POJOEndpoint > getJaxwsPojos ( final DeploymentUnit unit ) { final JAXWSDeployment jaxwsDeployment = unit . getAttachment ( WSAttachmentKeys . JAXWS_ENDPOINTS_KEY ) ; return jaxwsDeployment != null ? jaxwsDeployment . getPojoEndpoints ( ) : Collections . < POJOEndpoint > emptyList ( ) ; }", "nl": "Gets list of JAXWS POJOs meta data ."}}
{"translation": {"code": "private static ORB initAppletORB ( Object applet , Properties orbProp ) { try { Class < ? > appletClass = Class . forName ( \"java.applet.Applet\" , true , null ) ; if ( ! appletClass . isInstance ( applet ) ) { throw new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; } // invoke the static method ORB.init(applet, orbProp); Method method = ORB . class . getMethod ( \"init\" , appletClass , Properties . class ) ; return ( ORB ) method . invoke ( null , applet , orbProp ) ; } catch ( ClassNotFoundException e ) { // java.applet.Applet doesn't exist and the applet parameter is // non-null; so throw CCE throw new ClassCastException ( applet . getClass ( ) . getName ( ) ) ; } catch ( NoSuchMethodException e ) { throw new AssertionError ( e ) ; } catch ( InvocationTargetException e ) { Throwable cause = e . getCause ( ) ; if ( cause instanceof RuntimeException ) { throw ( RuntimeException ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } throw new AssertionError ( e ) ; } catch ( IllegalAccessException iae ) { throw new AssertionError ( iae ) ; } }", "nl": "This method returns a new ORB instance for the given applet without creating a static dependency on java . applet ."}}
{"translation": {"code": "protected boolean isMutator ( Method m ) { // JBAS-4473, look for set<name>() String name = m . getName ( ) ; if ( ! ( name . startsWith ( \"set\" ) && name . length ( ) > \"set\" . length ( ) ) ) return false ; if ( m . getReturnType ( ) != Void . TYPE ) return false ; if ( m . getParameterTypes ( ) . length != 1 ) return false ; return hasNonAppExceptions ( m ) ; }", "nl": "Check if a method is a mutator ."}}
{"translation": {"code": "protected void fixupCaseNames ( ) throws RMIIIOPViolationException { ArrayList entries = getContainedEntries ( ) ; boolean [ ] clash = new boolean [ entries . size ( ) ] ; String [ ] upperNames = new String [ entries . size ( ) ] ; for ( int i = 0 ; i < entries . size ( ) ; ++ i ) { AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; clash [ i ] = false ; upperNames [ i ] = aa . getIDLName ( ) . toUpperCase ( Locale . ENGLISH ) ; for ( int j = 0 ; j < i ; ++ j ) { if ( upperNames [ i ] . equals ( upperNames [ j ] ) ) { clash [ i ] = true ; clash [ j ] = true ; } } } for ( int i = 0 ; i < entries . size ( ) ; ++ i ) { if ( ! clash [ i ] ) continue ; AbstractAnalysis aa = ( AbstractAnalysis ) entries . get ( i ) ; boolean noUpper = true ; String name = aa . getIDLName ( ) ; StringBuffer b = new StringBuffer ( name ) ; b . append ( ' ' ) ; for ( int j = 0 ; j < name . length ( ) ; ++ j ) { if ( ! Character . isUpperCase ( name . charAt ( j ) ) ) continue ; if ( noUpper ) noUpper = false ; else b . append ( ' ' ) ; b . append ( j ) ; } aa . setIDLName ( b . toString ( ) ) ; } }", "nl": "Fixup names differing only in case . As specified in section 1 . 3 . 2 . 7 ."}}
{"translation": {"code": "public static boolean isAllFieldsPublic ( Class c ) { try { final Field [ ] list = c . getFields ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) if ( ! Modifier . isPublic ( list [ i ] . getModifiers ( ) ) ) return false ; } catch ( Exception e ) { return false ; } return true ; }", "nl": "Checks whether all the fields in the class are declared as public ."}}
{"translation": {"code": "private static boolean isReservedIDLKeyword ( String s ) { // TODO: faster lookup for ( int i = 0 ; i < reservedIDLKeywords . length ; ++ i ) if ( reservedIDLKeywords [ i ] . equals ( s ) ) return true ; return false ; }", "nl": "Determine if the argument is a reserved IDL keyword ."}}
{"translation": {"code": "public java . lang . Object lookupLink ( String name ) throws NamingException { return lookupLink ( new CompositeName ( name ) ) ; }", "nl": "Is mapped to resolve in the COS Naming api ."}}
{"translation": {"code": "protected void fixupOverloadedOperationNames ( ) throws RMIIIOPViolationException { for ( int i = 0 ; i < methods . length ; ++ i ) { if ( ( m_flags [ i ] & M_OVERLOADED ) == 0 ) continue ; // Find the operation OperationAnalysis oa = null ; String javaName = methods [ i ] . getName ( ) ; for ( int opIdx = 0 ; oa == null && opIdx < operations . length ; ++ opIdx ) if ( operations [ opIdx ] . getMethod ( ) . equals ( methods [ i ] ) ) oa = operations [ opIdx ] ; if ( oa == null ) continue ; // This method is not mapped. // Calculate new IDL name ParameterAnalysis [ ] params = oa . getParameters ( ) ; StringBuffer b = new StringBuffer ( oa . getIDLName ( ) ) ; if ( params . length == 0 ) b . append ( \"__\" ) ; for ( int j = 0 ; j < params . length ; ++ j ) { String s = params [ j ] . getTypeIDLName ( ) ; if ( s . startsWith ( \"::\" ) ) s = s . substring ( 2 ) ; if ( s . startsWith ( \"_\" ) ) { // remove leading underscore in IDL escaped identifier s = s . substring ( 1 ) ; } b . append ( ' ' ) ; while ( ! \"\" . equals ( s ) ) { int idx = s . indexOf ( \"::\" ) ; b . append ( ' ' ) ; if ( idx == - 1 ) { b . append ( s ) ; s = \"\" ; } else { b . append ( s . substring ( 0 , idx ) ) ; if ( s . length ( ) > idx + 2 && s . charAt ( idx + 2 ) == ' ' ) { // remove leading underscore in IDL escaped identifier s = s . substring ( idx + 3 ) ; } else { s = s . substring ( idx + 2 ) ; } } } } // Set new IDL name oa . setIDLName ( b . toString ( ) ) ; } }", "nl": "Fixup overloaded operation names . As specified in section 1 . 3 . 2 . 6 ."}}
{"translation": {"code": "protected String attributeWriteName ( String name ) { if ( name . startsWith ( \"set\" ) ) name = name . substring ( 3 ) ; else throw IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; return name ; }", "nl": "Convert an attribute write method name in Java format to an attribute name in Java format ."}}
{"translation": {"code": "public java . lang . Object addToEnvironment ( String propName , java . lang . Object propValue ) throws NamingException { if ( _env == null ) { _env = new Hashtable ( 7 , 0.75f ) ; } else { // copy-on-write _env = ( Hashtable ) _env . clone ( ) ; } return _env . put ( propName , propValue ) ; }", "nl": "Adds to the environment for the current context . Record change but do not reinitialize ORB ."}}
{"translation": {"code": "private static void initMethodHandles ( ) throws ClassNotFoundException { // Get javax.rmi.CORBA.Stub class corbaStubClass = Class . forName ( \"javax.rmi.CORBA.Stub\" ) ; // Get javax.rmi.CORBA.Stub.connect(org.omg.CORBA.ORB) method try { connectMethod = corbaStubClass . getMethod ( \"connect\" , new Class [ ] { org . omg . CORBA . ORB . class } ) ; } catch ( NoSuchMethodException e ) { throw IIOPLogger . ROOT_LOGGER . noMethodDefForStubConnect ( ) ; } // Get javax.rmi.PortableRemoteObject method Class proClass = Class . forName ( \"javax.rmi.PortableRemoteObject\" ) ; // Get javax.rmi.PortableRemoteObject(java.rmi.Remote) method try { toStubMethod = proClass . getMethod ( \"toStub\" , new Class [ ] { java . rmi . Remote . class } ) ; } catch ( NoSuchMethodException e ) { throw IIOPLogger . ROOT_LOGGER . noMethodDefForPortableRemoteObjectToStub ( ) ; } }", "nl": "Initializes reflection method handles for RMI - IIOP ."}}
{"translation": {"code": "protected String attributeReadName ( String name ) { if ( name . startsWith ( \"get\" ) ) name = name . substring ( 3 ) ; else if ( name . startsWith ( \"is\" ) ) name = name . substring ( 2 ) ; else throw IIOPLogger . ROOT_LOGGER . notAnAccessor ( name ) ; return name ; }", "nl": "Convert an attribute read method name in Java format to an attribute name in Java format ."}}
{"translation": {"code": "protected boolean hasNonAppExceptions ( Method m ) { Class [ ] ex = m . getExceptionTypes ( ) ; for ( int i = 0 ; i < ex . length ; ++ i ) if ( ! java . rmi . RemoteException . class . isAssignableFrom ( ex [ i ] ) ) return false ; return true ; }", "nl": "Check if a method throws anything checked other than java . rmi . RemoteException and its subclasses ."}}
{"translation": {"code": "public static ORB getOrb ( String server , int port , Hashtable env ) { // See if we can get info from environment Properties orbProp ; // Extract any org.omg.CORBA properties from environment if ( env != null ) { // Get all String properties orbProp = new Properties ( ) ; final Enumeration envProp = env . keys ( ) ; while ( envProp . hasMoreElements ( ) ) { String key = ( String ) envProp . nextElement ( ) ; Object val = env . get ( key ) ; if ( val instanceof String ) { orbProp . put ( key , val ) ; } } final Enumeration mainProps = orbProperties . keys ( ) ; while ( mainProps . hasMoreElements ( ) ) { String key = ( String ) mainProps . nextElement ( ) ; Object val = orbProperties . get ( key ) ; if ( val instanceof String ) { orbProp . put ( key , val ) ; } } } else { orbProp = orbProperties ; } if ( server != null ) { orbProp . put ( \"org.omg.CORBA.ORBInitialHost\" , server ) ; } if ( port >= 0 ) { orbProp . put ( \"org.omg.CORBA.ORBInitialPort\" , \"\" + port ) ; } // Get Applet from environment if ( env != null ) { Object applet = env . get ( Context . APPLET ) ; if ( applet != null ) { // Create ORBs for an applet return initAppletORB ( applet , orbProp ) ; } } // Create ORBs using orbProp for a standalone application return ORB . init ( new String [ 0 ] , orbProp ) ; }", "nl": "Get ORB using given server and port number and properties from environment ."}}
{"translation": {"code": "protected String escapeIRName ( String name ) { StringBuffer b = new StringBuffer ( ) ; for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . charAt ( i ) ; if ( c < 256 ) b . append ( c ) ; else b . append ( \"\\\\U\" ) . append ( toHexString ( ( int ) c ) ) ; } return b . toString ( ) ; }", "nl": "Escape non - ISO characters for an IR name ."}}
{"translation": {"code": "private static String getSignature ( Class cls ) { if ( cls . isArray ( ) ) return \"[\" + cls . getComponentType ( ) ; if ( cls . isPrimitive ( ) ) { if ( cls == Byte . TYPE ) return \"B\" ; if ( cls == Character . TYPE ) return \"C\" ; if ( cls == Double . TYPE ) return \"D\" ; if ( cls == Float . TYPE ) return \"F\" ; if ( cls == Integer . TYPE ) return \"I\" ; if ( cls == Long . TYPE ) return \"J\" ; if ( cls == Short . TYPE ) return \"S\" ; if ( cls == Boolean . TYPE ) return \"Z\" ; throw IIOPLogger . ROOT_LOGGER . unknownPrimitiveType ( cls . getName ( ) ) ; } return \"L\" + cls . getName ( ) . replace ( ' ' , ' ' ) + \";\" ; }", "nl": "Calculate the signature of a class according to the Java VM specification section 4 . 3 . 2 ."}}
{"translation": {"code": "private static NameComponent parseComponent ( String compStr ) throws InvalidNameException { NameComponent comp = new NameComponent ( ) ; int kindSep = - 1 ; int len = compStr . length ( ) ; int j = 0 ; char [ ] newStr = new char [ len ] ; boolean escaped = false ; // Find the kind separator for ( int i = 0 ; i < len && kindSep < 0 ; i ++ ) { if ( escaped ) { newStr [ j ++ ] = compStr . charAt ( i ) ; escaped = false ; } else if ( compStr . charAt ( i ) == escapeChar ) { if ( i + 1 >= len ) { throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; } else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { escaped = true ; } else { throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; } } else if ( compStr . charAt ( i ) == kindSeparator ) { kindSep = i ; } else { newStr [ j ++ ] = compStr . charAt ( i ) ; } } // Set id comp . id = new String ( newStr , 0 , j ) ; // Set kind if ( kindSep < 0 ) { comp . kind = \"\" ; // no kind separator } else { // unescape kind j = 0 ; escaped = false ; for ( int i = kindSep + 1 ; i < len ; i ++ ) { if ( escaped ) { newStr [ j ++ ] = compStr . charAt ( i ) ; escaped = false ; } else if ( compStr . charAt ( i ) == escapeChar ) { if ( i + 1 >= len ) { throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( compStr ) ; } else if ( isMeta ( compStr . charAt ( i + 1 ) ) ) { escaped = true ; } else { throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( compStr ) ; } } else { newStr [ j ++ ] = compStr . charAt ( i ) ; } } comp . kind = new String ( newStr , 0 , j ) ; } return comp ; }", "nl": "Return a NameComponent given its stringified form ."}}
{"translation": {"code": "public void insertValue ( Any any ) { if ( type == String . class ) any . insert_wstring ( ( String ) value ) ; // 1.3.5.10 Map to wstring else Util . insertAnyPrimitive ( any , value ) ; }", "nl": "Insert the constant value into the argument Any ."}}
{"translation": {"code": "public java . lang . Object removeFromEnvironment ( String propName ) throws NamingException { if ( _env != null && _env . get ( propName ) != null ) { // copy-on-write _env = ( Hashtable ) _env . clone ( ) ; return _env . remove ( propName ) ; } return null ; }", "nl": "Record change but do not reinitialize ORB"}}
{"translation": {"code": "public Object [ ] readParams ( InputStream in ) { int len = paramReaders . length ; Object [ ] params = new Object [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { params [ i ] = paramReaders [ i ] . read ( in ) ; } return params ; }", "nl": "Unmarshals the sequence of method parameters from an input stream ."}}
{"translation": {"code": "private ContainerAnalysis lookupDone ( Class cls ) { SoftReference ref = ( SoftReference ) workDone . get ( cls ) ; if ( ref == null ) return null ; ContainerAnalysis ret = ( ContainerAnalysis ) ref . get ( ) ; if ( ret == null ) workDone . remove ( cls ) ; // clear map entry if soft ref. was cleared. return ret ; }", "nl": "Lookup an analysis in the fully done map ."}}
{"translation": {"code": "private ContainerAnalysis createWorkInProgress ( final Class cls ) { final ContainerAnalysis analysis ; try { analysis = ( ContainerAnalysis ) constructor . newInstance ( cls ) ; } catch ( InstantiationException ex ) { throw new RuntimeException ( ex . toString ( ) ) ; } catch ( IllegalAccessException ex ) { throw new RuntimeException ( ex . toString ( ) ) ; } catch ( InvocationTargetException ex ) { throw new RuntimeException ( ex . toString ( ) ) ; } workInProgress . put ( new InProgressKey ( cls , Thread . currentThread ( ) ) , analysis ) ; return analysis ; }", "nl": "Create new work - in - progress ."}}
{"translation": {"code": "protected void calculateOperationAnalysisMap ( ) { operationAnalysisMap = new HashMap ( ) ; OperationAnalysis oa ; // Map the operations for ( int i = 0 ; i < operations . length ; ++ i ) { oa = operations [ i ] ; operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; } // Map the attributes for ( int i = 0 ; i < attributes . length ; ++ i ) { AttributeAnalysis attr = attributes [ i ] ; oa = attr . getAccessorAnalysis ( ) ; // Not having an accessor analysis means that // the attribute is not in a remote interface if ( oa != null ) { operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; oa = attr . getMutatorAnalysis ( ) ; if ( oa != null ) operationAnalysisMap . put ( oa . getIDLName ( ) , oa ) ; } } }", "nl": "Calculate the map that maps IDL operation names to operation analyses . Besides mapped operations this map also contains the attribute accessor and mutator operations ."}}
{"translation": {"code": "public void writeRetval ( OutputStream out , Object retVal ) { retvalWriter . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( retVal ) ) ; }", "nl": "Marshals into an output stream the return value of the method ."}}
{"translation": {"code": "protected byte [ ] getAnonymousObjectId ( long n ) { String s = anonOidPrefix + Long . toString ( n ) ; return s . getBytes ( StandardCharsets . UTF_8 ) ; }", "nl": "Generate the ID of the n - th anonymous object created in this IR ."}}
{"translation": {"code": "public org . omg . CORBA . Object referenceForLocator ( final EJBLocator < ? > locator ) { final EJBComponent ejbComponent = ejbComponentInjectedValue . getValue ( ) ; try { final String earApplicationName = ejbComponent . getEarApplicationName ( ) == null ? \"\" : ejbComponent . getEarApplicationName ( ) ; if ( locator . getBeanName ( ) . equals ( ejbComponent . getComponentName ( ) ) && locator . getAppName ( ) . equals ( earApplicationName ) && locator . getModuleName ( ) . equals ( ejbComponent . getModuleName ( ) ) && locator . getDistinctName ( ) . equals ( ejbComponent . getDistinctName ( ) ) ) { if ( locator instanceof EJBHomeLocator ) { return ( org . omg . CORBA . Object ) ejbHome ; } else if ( locator instanceof StatelessEJBLocator ) { return beanReferenceFactory . createReference ( beanRepositoryIds [ 0 ] ) ; } else if ( locator instanceof StatefulEJBLocator ) { final Marshaller marshaller = factory . createMarshaller ( configuration ) ; final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; marshaller . start ( new OutputStreamByteOutput ( stream ) ) ; marshaller . writeObject ( ( ( StatefulEJBLocator < ? > ) locator ) . getSessionId ( ) ) ; marshaller . finish ( ) ; return beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; } else if ( locator instanceof EntityEJBLocator ) { final Marshaller marshaller = factory . createMarshaller ( configuration ) ; final ByteArrayOutputStream stream = new ByteArrayOutputStream ( ) ; marshaller . start ( new OutputStreamByteOutput ( stream ) ) ; marshaller . writeObject ( ( ( EntityEJBLocator < ? > ) locator ) . getPrimaryKey ( ) ) ; marshaller . finish ( ) ; return beanReferenceFactory . createReferenceWithId ( stream . toByteArray ( ) , beanRepositoryIds [ 0 ] ) ; } throw EjbLogger . ROOT_LOGGER . unknownEJBLocatorType ( locator ) ; } else { throw EjbLogger . ROOT_LOGGER . incorrectEJBLocatorForBean ( locator , ejbComponent . getComponentName ( ) ) ; } } catch ( Exception e ) { throw EjbLogger . ROOT_LOGGER . couldNotCreateCorbaObject ( e , locator ) ; } }", "nl": "Returns a corba reference for the given locator"}}
{"translation": {"code": "public Name parse ( String name ) throws NamingException { Vector comps = insStringToStringifiedComps ( name ) ; return new CNCompoundName ( comps . elements ( ) ) ; }", "nl": "Returns a CompoundName given a string in INS syntax ."}}
{"translation": {"code": "public void writeException ( OutputStream out , Throwable e ) { int len = excepWriters . length ; for ( int i = 0 ; i < len ; i ++ ) { if ( excepWriters [ i ] . getExceptionClass ( ) . isInstance ( e ) ) { excepWriters [ i ] . write ( out , e ) ; return ; } } throw new UnknownException ( e ) ; }", "nl": "Marshals into an output stream an exception thrown by the method ."}}
{"translation": {"code": "public Object getStateToBind ( Object orig , Name name , Context ctx , Hashtable < ? , ? > env ) throws NamingException { if ( orig instanceof org . omg . CORBA . Object ) { // Already a CORBA object, just use it return null ; } if ( orig instanceof Remote ) { // Turn remote object into org.omg.CORBA.Object try { // Returns null if JRMP; let next factory try // CNCtx will eventually throw IllegalArgumentException if // no CORBA object gotten return CorbaUtils . remoteToCorba ( ( Remote ) orig , ( ( CNCtx ) ctx ) . _orb ) ; } catch ( ClassNotFoundException e ) { // RMI-IIOP library not available throw IIOPLogger . ROOT_LOGGER . unavailableRMIPackages ( ) ; } } return null ; // pass and let next state factory try }", "nl": "Returns the CORBA object for a Remote object . If input is not a Remote object or if Remote object uses JRMP return null . If the RMI - IIOP library is not available throw ConfigurationException ."}}
{"translation": {"code": "private boolean getMore ( ) throws NamingException { try { more = _bindingIter . next_n ( batchsize , _bindingList ) ; counter = 0 ; // reset } catch ( Exception e ) { more = false ; NamingException ne = IIOPLogger . ROOT_LOGGER . errorGettingBindingList ( ) ; ne . setRootCause ( e ) ; throw ne ; } return more ; }", "nl": "Get the next batch using _bindingIter . Update the more field ."}}
{"translation": {"code": "public java . lang . Object next ( ) throws NamingException { if ( more && counter >= _bindingList . value . length ) { getMore ( ) ; } if ( more && counter < _bindingList . value . length ) { org . omg . CosNaming . Binding bndg = _bindingList . value [ counter ] ; counter ++ ; return mapBinding ( bndg ) ; } else { throw new NoSuchElementException ( ) ; } }", "nl": "Returns the next binding in the list ."}}
{"translation": {"code": "public String getIDLModuleName ( ) { if ( idlModuleName == null ) { String pkgName = cls . getPackage ( ) . getName ( ) ; StringBuffer b = new StringBuffer ( ) ; while ( ! \"\" . equals ( pkgName ) ) { int idx = pkgName . indexOf ( ' ' ) ; String n = ( idx == - 1 ) ? pkgName : pkgName . substring ( 0 , idx ) ; b . append ( \"::\" ) . append ( Util . javaToIDLName ( n ) ) ; pkgName = ( idx == - 1 ) ? \"\" : pkgName . substring ( idx + 1 ) ; } idlModuleName = b . toString ( ) ; } return idlModuleName ; }", "nl": "Return the fully qualified IDL module name that this analysis should be placed in ."}}
{"translation": {"code": "protected String toHexString ( int i ) { String s = Integer . toHexString ( i ) . toUpperCase ( Locale . ENGLISH ) ; if ( s . length ( ) < 8 ) return \"00000000\" . substring ( 0 , 8 - s . length ( ) ) + s ; else return s ; }", "nl": "Convert an integer to a 16 - digit hex string ."}}
{"translation": {"code": "protected String toHexString ( long l ) { String s = Long . toHexString ( l ) . toUpperCase ( Locale . ENGLISH ) ; if ( s . length ( ) < 16 ) return \"0000000000000000\" . substring ( 0 , 16 - s . length ( ) ) + s ; else return s ; }", "nl": "Convert a long to a 16 - digit hex string ."}}
{"translation": {"code": "protected boolean isAccessor ( Method m ) { Class returnType = m . getReturnType ( ) ; // JBAS-4473, look for get<name>() String name = m . getName ( ) ; if ( ! ( name . startsWith ( \"get\" ) && name . length ( ) > \"get\" . length ( ) ) ) if ( ! ( name . startsWith ( \"is\" ) && name . length ( ) > \"is\" . length ( ) ) || ! ( returnType == Boolean . TYPE ) ) return false ; if ( returnType == Void . TYPE ) return false ; if ( m . getParameterTypes ( ) . length != 0 ) return false ; return hasNonAppExceptions ( m ) ; }", "nl": "Check if a method is an accessor ."}}
{"translation": {"code": "protected org . omg . CORBA . Object servantToReference ( Servant servant ) { byte [ ] id = getObjectId ( ) ; try { repository . poa . activate_object_with_id ( id , servant ) ; org . omg . CORBA . Object ref = repository . poa . id_to_reference ( id ) ; return ref ; } catch ( WrongPolicy ex ) { IIOPLogger . ROOT_LOGGER . debug ( \"Exception converting CORBA servant to reference\" , ex ) ; } catch ( ServantAlreadyActive ex ) { IIOPLogger . ROOT_LOGGER . debug ( \"Exception converting CORBA servant to reference\" , ex ) ; } catch ( ObjectAlreadyActive ex ) { IIOPLogger . ROOT_LOGGER . debug ( \"Exception converting CORBA servant to reference\" , ex ) ; } catch ( ObjectNotActive ex ) { IIOPLogger . ROOT_LOGGER . debug ( \"Exception converting CORBA servant to reference\" , ex ) ; } return null ; }", "nl": "Convert a servant to a reference ."}}
{"translation": {"code": "public void shutdown ( ) { POA poa = getPOA ( ) ; try { poa . deactivate_object ( poa . reference_to_id ( getReference ( ) ) ) ; } catch ( UserException ex ) { IIOPLogger . ROOT_LOGGER . warnCouldNotDeactivateIRObject ( ex ) ; } }", "nl": "Unexport this object ."}}
{"translation": {"code": "private javax . naming . Binding mapBinding ( org . omg . CosNaming . Binding bndg ) throws NamingException { java . lang . Object obj = _ctx . callResolve ( bndg . binding_name ) ; Name cname = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . cosNameToName ( bndg . binding_name ) ; try { obj = NamingManager . getObjectInstance ( obj , cname , _ctx , _env ) ; } catch ( NamingException e ) { throw e ; } catch ( Exception e ) { NamingException ne = IIOPLogger . ROOT_LOGGER . errorGeneratingObjectViaFactory ( ) ; ne . setRootCause ( e ) ; throw ne ; } // Use cname.toString() instead of bindingName because the name // in the binding should be a composite name String cnameStr = cname . toString ( ) ; javax . naming . Binding jbndg = new javax . naming . Binding ( cnameStr , obj ) ; NameComponent [ ] comps = _ctx . makeFullName ( bndg . binding_name ) ; String fullName = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . cosNameToInsString ( comps ) ; jbndg . setNameInNamespace ( fullName ) ; return jbndg ; }", "nl": "Constructs a JNDI Binding object from the COS Naming binding object ."}}
{"translation": {"code": "private static Vector insStringToStringifiedComps ( String str ) throws InvalidNameException { int len = str . length ( ) ; Vector components = new Vector ( 10 ) ; char [ ] id = new char [ len ] ; char [ ] kind = new char [ len ] ; int idCount , kindCount ; boolean idMode ; for ( int i = 0 ; i < len ; ) { idCount = kindCount = 0 ; // reset for new component idMode = true ; // always start off parsing id while ( i < len ) { if ( str . charAt ( i ) == compSeparator ) { break ; } else if ( str . charAt ( i ) == escapeChar ) { if ( i + 1 >= len ) { throw IIOPLogger . ROOT_LOGGER . unescapedCharacter ( str ) ; } else if ( isMeta ( str . charAt ( i + 1 ) ) ) { ++ i ; // skip escape and let meta through if ( idMode ) { id [ idCount ++ ] = str . charAt ( i ++ ) ; } else { kind [ kindCount ++ ] = str . charAt ( i ++ ) ; } } else { throw IIOPLogger . ROOT_LOGGER . invalidEscapedCharacter ( str ) ; } } else if ( idMode && str . charAt ( i ) == kindSeparator ) { // just look for the first kindSeparator ++ i ; // skip kind separator idMode = false ; } else { if ( idMode ) { id [ idCount ++ ] = str . charAt ( i ++ ) ; } else { kind [ kindCount ++ ] = str . charAt ( i ++ ) ; } } } components . addElement ( stringifyComponent ( new NameComponent ( new String ( id , 0 , idCount ) , new String ( kind , 0 , kindCount ) ) ) ) ; if ( i < len ) { ++ i ; // skip separator } } return components ; }", "nl": "Converts an INS - syntax string name into a Vector in which each element of the vector contains a stringified form of a NameComponent ."}}
{"translation": {"code": "ContainerAnalysis getAnalysis ( final Class cls ) throws RMIIIOPViolationException { ContainerAnalysis ret = null ; boolean created = false ; try { synchronized ( this ) { ret = lookupDone ( cls ) ; if ( ret != null ) { return ret ; } // is it work-in-progress? final ContainerAnalysis inProgress = workInProgress . get ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; if ( inProgress != null ) { return inProgress ; // return unfinished // Do not wait for the other thread: We may deadlock // Double work is better that deadlock... } ret = createWorkInProgress ( cls ) ; } created = true ; // Do the work doTheWork ( cls , ret ) ; } finally { // We did it synchronized ( this ) { if ( created ) { workInProgress . remove ( new InProgressKey ( cls , Thread . currentThread ( ) ) ) ; workDone . put ( cls , new SoftReference < ContainerAnalysis > ( ret ) ) ; ClassLoader classLoader = cls . getClassLoader ( ) ; if ( classLoader != null ) { Set < Class < ? > > classes = classesByLoader . get ( classLoader ) ; if ( classes == null ) { classesByLoader . put ( classLoader , classes = new HashSet < Class < ? > > ( ) ) ; } classes . add ( cls ) ; } } notifyAll ( ) ; } } return ret ; }", "nl": "Returns an analysis . If the calling thread is currently doing an analysis of this class an unfinished analysis is returned ."}}
{"translation": {"code": "private void addClass ( Class cls ) throws RMIIIOPViolationException , IRConstructionException { if ( cls . isPrimitive ( ) ) return ; // No need to add primitives. if ( cls . isArray ( ) ) { // Add array mapping addArray ( cls ) ; } else if ( cls . isInterface ( ) ) { if ( ! RmiIdlUtil . isAbstractValueType ( cls ) ) { // Analyse the interface InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; // Add analyzed interface (which may be abstract) addInterface ( ia ) ; } else { // Analyse the value ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; // Add analyzed value addValue ( va ) ; } } else if ( Exception . class . isAssignableFrom ( cls ) ) { // Exception type. // Analyse the exception ExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; // Add analyzed exception addException ( ea ) ; } else { // Got to be a value type. // Analyse the value ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; // Add analyzed value addValue ( va ) ; } }", "nl": "Map the class and add its IIOP mapping to the repository ."}}
{"translation": {"code": "public static String javaToIDLName ( String name ) { if ( name == null || \"\" . equals ( name ) || name . indexOf ( ' ' ) != - 1 ) throw IIOPLogger . ROOT_LOGGER . nameCannotBeNullEmptyOrQualified ( ) ; StringBuffer res = new StringBuffer ( name . length ( ) ) ; if ( name . charAt ( 0 ) == ' ' ) res . append ( ' ' ) ; // 1.3.2.3 for ( int i = 0 ; i < name . length ( ) ; ++ i ) { char c = name . charAt ( i ) ; if ( isLegalIDLIdentifierChar ( c ) ) res . append ( c ) ; else // 1.3.2.4 res . append ( ' ' ) . append ( toHexString ( ( int ) c ) ) ; } String s = res . toString ( ) ; if ( isReservedIDLKeyword ( s ) ) return \"_\" + s ; else return s ; }", "nl": "Map Java name to IDL name as per sections 1 . 3 . 2 . 3 1 . 3 . 2 . 4 and 1 . 3 . 2 . 2 . This only works for a single name component without a qualifying dot ."}}
{"translation": {"code": "public void destroySubcontext ( Name name ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; NamingContext the_nc = _nc ; NameComponent [ ] path = org . wildfly . iiop . openjdk . naming . jndi . CNNameParser . nameToCosName ( name ) ; if ( name . size ( ) > 0 ) { try { javax . naming . Context ctx = ( javax . naming . Context ) callResolve ( path ) ; CNCtx cnc = ( CNCtx ) ctx ; the_nc = cnc . _nc ; cnc . close ( ) ; //remove the reference to the context } catch ( ClassCastException e ) { throw new NotContextException ( name . toString ( ) ) ; } catch ( CannotProceedException e ) { javax . naming . Context cctx = getContinuationContext ( e ) ; cctx . destroySubcontext ( e . getRemainingName ( ) ) ; return ; } catch ( NameNotFoundException e ) { // If leaf is the one missing, return success // as per JNDI spec if ( e . getRootCause ( ) instanceof NotFound && leafNotFound ( ( NotFound ) e . getRootCause ( ) , path [ path . length - 1 ] ) ) { return ; // leaf missing OK } throw e ; } catch ( NamingException e ) { throw e ; } } callDestroy ( the_nc ) ; callUnbind ( path ) ; }", "nl": "Uses the callDestroy function to destroy the context . Destroys the current context if name is empty ."}}
{"translation": {"code": "private TypeCode getConstantTypeCode ( Class cls ) throws IRConstructionException { if ( cls == null ) throw IIOPLogger . ROOT_LOGGER . invalidNullClass ( ) ; TypeCode ret = constantTypeCodeMap . get ( cls ) ; if ( ret == null ) throw IIOPLogger . ROOT_LOGGER . badClassForConstant ( cls . getName ( ) ) ; return ret ; }", "nl": "Returns the TypeCode suitable for an IDL constant ."}}
{"translation": {"code": "private void addTypeCode ( Class cls , TypeCode typeCode ) throws IRConstructionException { if ( cls == null ) throw IIOPLogger . ROOT_LOGGER . invalidNullClass ( ) ; TypeCode tc = ( TypeCode ) typeCodeMap . get ( cls ) ; if ( tc != null ) throw IIOPLogger . ROOT_LOGGER . duplicateTypeCodeForClass ( cls . getName ( ) ) ; typeCodeMap . put ( cls , typeCode ) ; }", "nl": "Add a new IDL TypeCode for a mapped class ."}}
{"translation": {"code": "private void callUnbind ( NameComponent [ ] path ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; try { _nc . unbind ( path ) ; } catch ( NotFound e ) { // If leaf is the one missing, return success // as per JNDI spec if ( leafNotFound ( e , path [ path . length - 1 ] ) ) { // do nothing } else { throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; } } catch ( Exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; } }", "nl": "Calls the unbind api of COS Naming and uses the exception mapper class to map the exceptions"}}
{"translation": {"code": "public void bind ( String name , java . lang . Object obj ) throws NamingException { bind ( new CompositeName ( name ) , obj ) ; }", "nl": "Converts the String name into a CompositeName object and performs the bind operation . Uses callBindOrRebind . Throws an invalid name exception if the name is empty ."}}
{"translation": {"code": "public static String getTypeIDLName ( Class cls ) throws RMIIIOPViolationException { if ( cls . isPrimitive ( ) ) return PrimitiveAnalysis . getPrimitiveAnalysis ( cls ) . getIDLName ( ) ; if ( cls . isArray ( ) ) { // boxedRMI 1.3.6 Class componentClass = cls ; int sequence = 0 ; while ( componentClass . isArray ( ) ) { componentClass = componentClass . getComponentType ( ) ; ++ sequence ; } String idlName = getTypeIDLName ( componentClass ) ; int idx = idlName . lastIndexOf ( \"::\" ) ; String idlModule = idlName . substring ( 0 , idx + 2 ) ; String baseName = idlName . substring ( idx + 2 ) ; return \"::org::omg::boxedRMI\" + idlModule + \"seq\" + sequence + \"_\" + baseName ; } // special classes if ( cls == java . lang . String . class ) return \"::CORBA::WStringValue\" ; if ( cls == java . lang . Object . class ) return \"::java::lang::_Object\" ; if ( cls == java . lang . Class . class ) return \"::javax::rmi::CORBA::ClassDesc\" ; if ( cls == java . io . Serializable . class ) return \"::java::io::Serializable\" ; if ( cls == java . io . Externalizable . class ) return \"::java::io::Externalizable\" ; if ( cls == java . rmi . Remote . class ) return \"::java::rmi::Remote\" ; if ( cls == org . omg . CORBA . Object . class ) return \"::CORBA::Object\" ; // remote interface? if ( cls . isInterface ( ) && java . rmi . Remote . class . isAssignableFrom ( cls ) ) { InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; return ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; } // IDL interface? if ( cls . isInterface ( ) && org . omg . CORBA . Object . class . isAssignableFrom ( cls ) && org . omg . CORBA . portable . IDLEntity . class . isAssignableFrom ( cls ) ) { InterfaceAnalysis ia = InterfaceAnalysis . getInterfaceAnalysis ( cls ) ; return ia . getIDLModuleName ( ) + \"::\" + ia . getIDLName ( ) ; } // exception? if ( Throwable . class . isAssignableFrom ( cls ) ) { if ( Exception . class . isAssignableFrom ( cls ) && ! RuntimeException . class . isAssignableFrom ( cls ) ) { ExceptionAnalysis ea = ExceptionAnalysis . getExceptionAnalysis ( cls ) ; return ea . getIDLModuleName ( ) + \"::\" + ea . getIDLName ( ) ; } } // got to be value ValueAnalysis va = ValueAnalysis . getValueAnalysis ( cls ) ; return va . getIDLModuleName ( ) + \"::\" + va . getIDLName ( ) ; }", "nl": "Return the IDL type name for the given class . Here we use the mapping for parameter types and return values ."}}
{"translation": {"code": "public java . lang . Object lookup ( String name ) throws NamingException { return lookup ( new CompositeName ( name ) ) ; }", "nl": "Converts the String name into a CompositeName returns the object resolved by the COS Naming api resolve . Returns the current context if the name is empty . Returns either an org . omg . CORBA . Object or javax . naming . Context object ."}}
{"translation": {"code": "private ModuleDefImpl ensurePackageExists ( LocalContainer c , String previous , String remainder ) throws IRConstructionException { if ( \"\" . equals ( remainder ) ) return ( ModuleDefImpl ) c ; // done int idx = remainder . indexOf ( ' ' ) ; String base ; if ( idx == - 1 ) base = remainder ; else base = remainder . substring ( 0 , idx ) ; base = Util . javaToIDLName ( base ) ; if ( previous . equals ( \"\" ) ) previous = base ; else previous = previous + \"/\" + base ; if ( idx == - 1 ) remainder = \"\" ; else remainder = remainder . substring ( idx + 1 ) ; LocalContainer next = null ; LocalContained contained = ( LocalContained ) c . _lookup ( base ) ; if ( contained instanceof LocalContainer ) next = ( LocalContainer ) contained ; else if ( contained != null ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; if ( next == null ) { String id = \"IDL:\" + previous + \":1.0\" ; // Create module ModuleDefImpl m = new ModuleDefImpl ( id , base , \"1.0\" , c , impl ) ; c . add ( base , m ) ; if ( idx == - 1 ) return m ; // done next = ( LocalContainer ) c . _lookup ( base ) ; // Better be there now... } else // Check that next _is_ a module if ( next . def_kind ( ) != DefinitionKind . dk_Module ) throw IIOPLogger . ROOT_LOGGER . collisionWhileCreatingPackage ( ) ; return ensurePackageExists ( next , previous , remainder ) ; }", "nl": "Ensure that a package exists in the IR . This will create modules in the IR as needed ."}}
{"translation": {"code": "private String [ ] addInterfaces ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { InterfaceAnalysis [ ] interfaces = ca . getInterfaces ( ) ; List base_interfaces = new ArrayList ( ) ; for ( int i = 0 ; i < interfaces . length ; ++ i ) { InterfaceDefImpl idi = addInterface ( interfaces [ i ] ) ; base_interfaces . add ( idi . id ( ) ) ; } String [ ] strArr = new String [ base_interfaces . size ( ) ] ; return ( String [ ] ) base_interfaces . toArray ( strArr ) ; }", "nl": "Add a set of interfaces to the IR ."}}
{"translation": {"code": "private ValueMember [ ] getValueMembers ( ) { if ( valueMembers != null ) return valueMembers ; LocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; valueMembers = new ValueMember [ c . length ] ; for ( int i = 0 ; i < c . length ; ++ i ) { ValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; valueMembers [ i ] = new ValueMember ( vmdi . name ( ) , vmdi . id ( ) , ( ( LocalContained ) vmdi . defined_in ) . id ( ) , vmdi . version ( ) , vmdi . type ( ) , vmdi . type_def ( ) , vmdi . access ( ) ) ; } return valueMembers ; }", "nl": "Create the valueMembers array and return it ."}}
{"translation": {"code": "private String [ ] addAbstractBaseValuetypes ( ContainerAnalysis ca ) throws RMIIIOPViolationException , IRConstructionException { ValueAnalysis [ ] abstractValuetypes = ca . getAbstractBaseValuetypes ( ) ; List abstract_base_valuetypes = new ArrayList ( ) ; for ( int i = 0 ; i < abstractValuetypes . length ; ++ i ) { ValueDefImpl vdi = addValue ( abstractValuetypes [ i ] ) ; abstract_base_valuetypes . add ( vdi . id ( ) ) ; } String [ ] strArr = new String [ abstract_base_valuetypes . size ( ) ] ; return ( String [ ] ) abstract_base_valuetypes . toArray ( strArr ) ; }", "nl": "Add a set of abstract valuetypes to the IR ."}}
{"translation": {"code": "public static PrimitiveAnalysis getPrimitiveAnalysis ( final Class cls ) { if ( cls == null ) throw IIOPLogger . ROOT_LOGGER . cannotAnalyzeNullClass ( ) ; if ( cls == Void . TYPE ) return voidAnalysis ; if ( cls == Boolean . TYPE ) return booleanAnalysis ; if ( cls == Character . TYPE ) return charAnalysis ; if ( cls == Byte . TYPE ) return byteAnalysis ; if ( cls == Short . TYPE ) return shortAnalysis ; if ( cls == Integer . TYPE ) return intAnalysis ; if ( cls == Long . TYPE ) return longAnalysis ; if ( cls == Float . TYPE ) return floatAnalysis ; if ( cls == Double . TYPE ) return doubleAnalysis ; throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( cls . getName ( ) ) ; }", "nl": "Get a singleton instance representing one of the primitive types ."}}
{"translation": {"code": "void setIDLName ( String idlName ) { super . setIDLName ( idlName ) ; // If the first char is an uppercase letter and the second char is not // an uppercase letter, then convert the first char to lowercase. if ( idlName . charAt ( 0 ) >= 0x41 && idlName . charAt ( 0 ) <= 0x5a && ( idlName . length ( ) <= 1 || idlName . charAt ( 1 ) < 0x41 || idlName . charAt ( 1 ) > 0x5a ) ) { idlName = idlName . substring ( 0 , 1 ) . toLowerCase ( Locale . ENGLISH ) + idlName . substring ( 1 ) ; } if ( accessorAnalysis != null ) accessorAnalysis . setIDLName ( \"_get_\" + idlName ) ; if ( mutatorAnalysis != null ) mutatorAnalysis . setIDLName ( \"_set_\" + idlName ) ; }", "nl": "Set my unqualified IDL name . This also sets the names of the associated operations ."}}
{"translation": {"code": "private ValueMember [ ] getValueMembersForTypeCode ( ) { LocalContained [ ] c = _contents ( DefinitionKind . dk_ValueMember , false ) ; ValueMember [ ] vms = new ValueMember [ c . length ] ; for ( int i = 0 ; i < c . length ; ++ i ) { ValueMemberDefImpl vmdi = ( ValueMemberDefImpl ) c [ i ] ; vms [ i ] = new ValueMember ( vmdi . name ( ) , null , // ignore id null , // ignore defined_in null , // ignore version vmdi . type ( ) , null , // ignore type_def vmdi . access ( ) ) ; } return vms ; }", "nl": "Create a valueMembers array for TypeCode creation only and return it ."}}
{"translation": {"code": "private javax . naming . Context callBindNewContext ( NameComponent [ ] path ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( path . toString ( ) ) ; try { NamingContext nctx = _nc . bind_new_context ( path ) ; return new CNCtx ( _orb , nctx , _env , makeFullName ( path ) ) ; } catch ( Exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , path ) ; } }", "nl": "Calls the bind_new_context COS naming api to create a new subcontext ."}}
{"translation": {"code": "private InterfaceDefImpl addInterface ( InterfaceAnalysis ia ) throws RMIIIOPViolationException , IRConstructionException { InterfaceDefImpl iDef ; Class cls = ia . getCls ( ) ; // Lookup: Has it already been added? iDef = ( InterfaceDefImpl ) interfaceMap . get ( cls ) ; if ( iDef != null ) return iDef ; // Yes, just return it. // Get module to add interface to. ModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; // Add superinterfaces String [ ] base_interfaces = addInterfaces ( ia ) ; // Create the interface String base = cls . getName ( ) ; base = base . substring ( base . lastIndexOf ( ' ' ) + 1 ) ; base = Util . javaToIDLName ( base ) ; iDef = new InterfaceDefImpl ( ia . getRepositoryId ( ) , base , \"1.0\" , m , base_interfaces , impl ) ; addTypeCode ( cls , iDef . type ( ) ) ; m . add ( base , iDef ) ; interfaceMap . put ( cls , iDef ) ; // Remember we mapped this. // Fill in constants addConstants ( iDef , ia ) ; // Add attributes addAttributes ( iDef , ia ) ; // Fill in operations addOperations ( iDef , ia ) ; return iDef ; }", "nl": "Add an interface ."}}
{"translation": {"code": "private static String getSignature ( Method method ) { StringBuffer b = new StringBuffer ( \"(\" ) ; Class [ ] parameterTypes = method . getParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; ++ i ) b . append ( getSignature ( parameterTypes [ i ] ) ) ; b . append ( ' ' ) . append ( getSignature ( method . getReturnType ( ) ) ) ; return b . toString ( ) ; }", "nl": "Calculate the signature of a method according to the Java VM specification section 4 . 3 . 3 ."}}
{"translation": {"code": "private void callDestroy ( NamingContext nc ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( nc . toString ( ) ) ; try { nc . destroy ( ) ; } catch ( Exception e ) { throw org . wildfly . iiop . openjdk . naming . jndi . ExceptionMapper . mapException ( e , this , null ) ; } }", "nl": "Calls the destroy on the COS Naming Server"}}
{"translation": {"code": "public void writeParams ( OutputStream out , Object [ ] params ) { int len = params . length ; if ( len != paramWriters . length ) { throw IIOPLogger . ROOT_LOGGER . errorMashalingParams ( ) ; } for ( int i = 0 ; i < len ; i ++ ) { Object param = params [ i ] ; if ( param instanceof PortableRemoteObject ) { try { param = PortableRemoteObject . toStub ( ( Remote ) param ) ; } catch ( NoSuchObjectException e ) { throw new RuntimeException ( e ) ; } } paramWriters [ i ] . write ( out , RemoteObjectSubstitutionManager . writeReplaceRemote ( param ) ) ; } }", "nl": "Marshals the sequence of method parameters into an output stream ."}}
{"translation": {"code": "public Exception readException ( String id , InputStream in ) { ExceptionReader exceptionReader = ( ExceptionReader ) exceptionMap . get ( id ) ; if ( exceptionReader == null ) { return new UnexpectedException ( id ) ; } else { return exceptionReader . read ( in ) ; } }", "nl": "Unmarshals from an input stream an exception thrown by the method ."}}
{"translation": {"code": "static LocalIDLType getIDLType ( TypeCode typeCode , RepositoryImpl repository ) { TCKind tcKind = typeCode . kind ( ) ; if ( PrimitiveDefImpl . isPrimitiveTCKind ( tcKind ) ) return new PrimitiveDefImpl ( typeCode , repository ) ; if ( tcKind == TCKind . tk_sequence ) return repository . getSequenceImpl ( typeCode ) ; if ( tcKind == TCKind . tk_value || tcKind == TCKind . tk_value_box || tcKind == TCKind . tk_alias || tcKind == TCKind . tk_struct || tcKind == TCKind . tk_union || tcKind == TCKind . tk_enum || tcKind == TCKind . tk_objref ) { try { return ( LocalIDLType ) repository . _lookup_id ( typeCode . id ( ) ) ; } catch ( BadKind ex ) { throw IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; } } throw IIOPLogger . ROOT_LOGGER . badKindForTypeCode ( tcKind . value ( ) ) ; }", "nl": "Return the LocalIDLType for the given TypeCode ."}}
{"translation": {"code": "public NamingEnumeration listBindings ( Name name ) throws NamingException { if ( _nc == null ) throw IIOPLogger . ROOT_LOGGER . notANamingContext ( name . toString ( ) ) ; if ( name . size ( ) > 0 ) { try { java . lang . Object obj = lookup ( name ) ; if ( obj instanceof CNCtx ) { return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( ( CNCtx ) obj , true , _env ) ; } else { throw new NotContextException ( name . toString ( ) ) ; } } catch ( NamingException ne ) { throw ne ; } catch ( BAD_PARAM e ) { NamingException ne = new NotContextException ( name . toString ( ) ) ; ne . setRootCause ( e ) ; throw ne ; } } return new org . wildfly . iiop . openjdk . naming . jndi . CNBindingEnumeration ( this , false , _env ) ; }", "nl": "Returns a BindingEnumeration object which has a list of name class pairs . Lists the current context if the name is empty ."}}
{"translation": {"code": "public static void insertAnyPrimitive ( Any any , Object primitive ) { Class type = primitive . getClass ( ) ; if ( type == Boolean . class ) any . insert_boolean ( ( ( Boolean ) primitive ) . booleanValue ( ) ) ; else if ( type == Character . class ) any . insert_wchar ( ( ( Character ) primitive ) . charValue ( ) ) ; else if ( type == Byte . class ) any . insert_octet ( ( ( Byte ) primitive ) . byteValue ( ) ) ; else if ( type == Short . class ) any . insert_short ( ( ( Short ) primitive ) . shortValue ( ) ) ; else if ( type == Integer . class ) any . insert_long ( ( ( Integer ) primitive ) . intValue ( ) ) ; else if ( type == Long . class ) any . insert_longlong ( ( ( Long ) primitive ) . longValue ( ) ) ; else if ( type == Float . class ) any . insert_float ( ( ( Float ) primitive ) . floatValue ( ) ) ; else if ( type == Double . class ) any . insert_double ( ( ( Double ) primitive ) . doubleValue ( ) ) ; else throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; }", "nl": "Insert a java primitive into an Any . The primitive is assumed to be wrapped in one of the primitive wrapper classes ."}}
{"translation": {"code": "public static ResolveResult createUsingURL ( String url , Hashtable env ) throws NamingException { CNCtx ctx = new CNCtx ( ) ; if ( env != null ) { env = ( Hashtable ) env . clone ( ) ; } ctx . _env = env ; String rest = ctx . initUsingUrl ( env != null ? ( org . omg . CORBA . ORB ) env . get ( \"java.naming.corba.orb\" ) : null , url , env ) ; // rest is the INS name // Return the parsed form to prevent subsequent lookup // from parsing the string as a composite name // The caller should be aware that a toString() of the name // will yield its INS syntax, rather than a composite syntax return new ResolveResult ( ctx , parser . parse ( rest ) ) ; }", "nl": "This method is used by the iiop and iiopname URL Context factories ."}}
{"translation": {"code": "private ValueDefImpl addValue ( ValueAnalysis va ) throws RMIIIOPViolationException , IRConstructionException { ValueDefImpl vDef ; Class cls = va . getCls ( ) ; // Lookup: Has it already been added? vDef = ( ValueDefImpl ) valueMap . get ( cls ) ; if ( vDef != null ) return vDef ; // Yes, just return it. // Get module to add value to. ModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; // Add implemented interfaces String [ ] supported_interfaces = addInterfaces ( va ) ; // Add abstract base valuetypes String [ ] abstract_base_valuetypes = addAbstractBaseValuetypes ( va ) ; // Add superclass ValueDefImpl superValue = null ; ValueAnalysis superAnalysis = va . getSuperAnalysis ( ) ; if ( superAnalysis != null ) superValue = addValue ( superAnalysis ) ; // Create the value String base = cls . getName ( ) ; base = base . substring ( base . lastIndexOf ( ' ' ) + 1 ) ; base = Util . javaToIDLName ( base ) ; TypeCode baseTypeCode ; if ( superValue == null ) baseTypeCode = orb . get_primitive_tc ( TCKind . tk_null ) ; else baseTypeCode = superValue . type ( ) ; vDef = new ValueDefImpl ( va . getRepositoryId ( ) , base , \"1.0\" , m , va . isAbstractValue ( ) , va . isCustom ( ) , supported_interfaces , abstract_base_valuetypes , baseTypeCode , impl ) ; addTypeCode ( cls , vDef . type ( ) ) ; m . add ( base , vDef ) ; valueMap . put ( cls , vDef ) ; // Remember we mapped this. // Fill in constants. addConstants ( vDef , va ) ; // Add value members ValueMemberAnalysis [ ] vmas = va . getMembers ( ) ; for ( int i = 0 ; i < vmas . length ; ++ i ) { ValueMemberDefImpl vmDef ; String vmid = va . getMemberRepositoryId ( vmas [ i ] . getJavaName ( ) ) ; String vmName = vmas [ i ] . getIDLName ( ) ; Class vmCls = vmas [ i ] . getCls ( ) ; TypeCode typeCode = getTypeCode ( vmCls ) ; boolean vmPublic = vmas [ i ] . isPublic ( ) ; vmDef = new ValueMemberDefImpl ( vmid , vmName , \"1.0\" , typeCode , vmPublic , vDef , impl ) ; vDef . add ( vmName , vmDef ) ; } // Add attributes addAttributes ( vDef , va ) ; // TODO: Fill in operations. return vDef ; }", "nl": "Add a value type ."}}
{"translation": {"code": "static String primitiveTypeIDLName ( Class type ) { if ( type == Void . TYPE ) return \"void\" ; if ( type == Boolean . TYPE ) return \"boolean\" ; if ( type == Character . TYPE ) return \"wchar\" ; if ( type == Byte . TYPE ) return \"octet\" ; if ( type == Short . TYPE ) return \"short\" ; if ( type == Integer . TYPE ) return \"long\" ; if ( type == Long . TYPE ) return \"long long\" ; if ( type == Float . TYPE ) return \"float\" ; if ( type == Double . TYPE ) return \"double\" ; throw IIOPLogger . ROOT_LOGGER . notAPrimitive ( type . getName ( ) ) ; }", "nl": "Handle mappings for primitive types as per section 1 . 3 . 3 ."}}
{"translation": {"code": "public javax . naming . Context createSubcontext ( String name ) throws NamingException { return createSubcontext ( new CompositeName ( name ) ) ; }", "nl": "Uses the callBindNewContext convenience function to create a new context . Throws an invalid name exception if the name is empty ."}}
{"translation": {"code": "private ExceptionDefImpl addException ( ExceptionAnalysis ea ) throws RMIIIOPViolationException , IRConstructionException { ExceptionDefImpl eDef ; Class cls = ea . getCls ( ) ; // Lookup: Has it already been added? eDef = ( ExceptionDefImpl ) exceptionMap . get ( cls ) ; if ( eDef != null ) return eDef ; // Yes, just return it. // 1.3.7.1: map to value ValueDefImpl vDef = addValue ( ea ) ; // 1.3.7.2: map to exception ModuleDefImpl m = ensurePackageExists ( cls . getPackage ( ) . getName ( ) ) ; String base = cls . getName ( ) ; base = base . substring ( base . lastIndexOf ( ' ' ) + 1 ) ; if ( base . endsWith ( \"Exception\" ) ) base = base . substring ( 0 , base . length ( ) - 9 ) ; base = Util . javaToIDLName ( base + \"Ex\" ) ; StructMember [ ] members = new StructMember [ 1 ] ; members [ 0 ] = new StructMember ( \"value\" , vDef . type ( ) , null /*ignored*/ ) ; TypeCode typeCode = orb . create_exception_tc ( ea . getExceptionRepositoryId ( ) , base , members ) ; eDef = new ExceptionDefImpl ( ea . getExceptionRepositoryId ( ) , base , \"1.0\" , typeCode , vDef , m , impl ) ; m . add ( base , eDef ) ; exceptionMap . put ( cls , eDef ) ; // Remember we mapped this. return eDef ; }", "nl": "Add an exception type ."}}
{"translation": {"code": "protected ComponentView getComponentView ( ) { ComponentView cv = componentView ; // we need to check both, otherwise it is possible for // componentView to be initialized before reference if ( cv == null ) { synchronized ( this ) { cv = componentView ; if ( cv == null ) { cv = getMSCService ( componentViewName , ComponentView . class ) ; if ( cv == null ) { throw WSLogger . ROOT_LOGGER . cannotFindComponentView ( componentViewName ) ; } if ( reference == null ) { try { reference = cv . createInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } componentView = cv ; } } } return cv ; }", "nl": "Gets endpoint container lazily ."}}
{"translation": {"code": "protected Method getComponentViewMethod ( final Method seiMethod , final Collection < Method > viewMethods ) { for ( final Method viewMethod : viewMethods ) { if ( matches ( seiMethod , viewMethod ) ) { return viewMethod ; } } throw new IllegalStateException ( ) ; }", "nl": "Translates SEI method to component view method ."}}
{"translation": {"code": "private boolean matches ( final Method seiMethod , final Method viewMethod ) { if ( ! seiMethod . getName ( ) . equals ( viewMethod . getName ( ) ) ) return false ; final Class < ? > [ ] sourceParams = seiMethod . getParameterTypes ( ) ; final Class < ? > [ ] targetParams = viewMethod . getParameterTypes ( ) ; if ( sourceParams . length != targetParams . length ) return false ; for ( int i = 0 ; i < sourceParams . length ; i ++ ) { if ( ! sourceParams [ i ] . equals ( targetParams [ i ] ) ) return false ; } return true ; }", "nl": "Compares two methods if they are identical ."}}
{"translation": {"code": "protected void buildEnterpriseBeanMetaData ( final List < EJBMetaData > wsEjbsMD , final EJBEndpoint ejbEndpoint , final JBossWebservicesMetaData jbossWebservicesMD ) { final SLSBMetaData . Builder wsEjbMDBuilder = new SLSBMetaData . Builder ( ) ; // set EJB name and class wsEjbMDBuilder . setEjbName ( ejbEndpoint . getName ( ) ) ; wsEjbMDBuilder . setEjbClass ( ejbEndpoint . getClassName ( ) ) ; final JBossPortComponentMetaData portComponentMD = getPortComponent ( ejbEndpoint . getName ( ) , jbossWebservicesMD ) ; if ( portComponentMD != null ) { // set port component meta data wsEjbMDBuilder . setPortComponentName ( portComponentMD . getPortComponentName ( ) ) ; wsEjbMDBuilder . setPortComponentURI ( portComponentMD . getPortComponentURI ( ) ) ; } // set security meta data // auth method final String authMethod = getAuthMethod ( ejbEndpoint , portComponentMD ) ; // transport guarantee final String transportGuarantee = getTransportGuarantee ( ejbEndpoint , portComponentMD ) ; // secure wsdl access final boolean secureWsdlAccess = isSecureWsdlAccess ( ejbEndpoint , portComponentMD ) ; final String realmName = getRealmName ( ejbEndpoint , portComponentMD ) ; // propagate wsEjbMDBuilder . setSecurityMetaData ( new EJBSecurityMetaData ( authMethod , realmName , transportGuarantee , secureWsdlAccess ) ) ; wsEjbsMD . add ( wsEjbMDBuilder . build ( ) ) ; }", "nl": "Builds JBoss agnostic EJB meta data ."}}
{"translation": {"code": "public JdrReport collect ( ) throws OperationFailedException { JdrRunner runner = new JdrRunner ( true ) ; serverEnvironment = serverEnvironmentValue . getValue ( ) ; runner . setJbossHomeDir ( serverEnvironment . getHomeDir ( ) . getAbsolutePath ( ) ) ; runner . setReportLocationDir ( serverEnvironment . getServerTempDir ( ) . getAbsolutePath ( ) ) ; runner . setControllerClient ( controllerClient ) ; runner . setHostControllerName ( serverEnvironment . getHostControllerName ( ) ) ; runner . setServerName ( serverEnvironment . getServerName ( ) ) ; return runner . collect ( ) ; }", "nl": "Collect a JDR report ."}}
{"translation": {"code": "public JdrReport standaloneCollect ( CLI cli , String protocol , String host , int port ) throws OperationFailedException { return new JdrRunner ( cli , protocol , host , port , null , null ) . collect ( ) ; }", "nl": "Collect a JDR report when run outside the Application Server ."}}
{"translation": {"code": "private static void setAnnotationIndexes ( final PersistenceUnitMetadataHolder puHolder , DeploymentUnit deploymentUnit ) { final Map < URL , Index > annotationIndexes = new HashMap <> ( ) ; do { for ( ResourceRoot root : DeploymentUtils . allResourceRoots ( deploymentUnit ) ) { final Index index = root . getAttachment ( Attachments . ANNOTATION_INDEX ) ; if ( index != null ) { try { ROOT_LOGGER . tracef ( \"adding '%s' to annotation index map\" , root . getRoot ( ) . toURL ( ) ) ; annotationIndexes . put ( root . getRoot ( ) . toURL ( ) , index ) ; } catch ( MalformedURLException e ) { throw new RuntimeException ( e ) ; } } } deploymentUnit = deploymentUnit . getParent ( ) ; // get annotation indexes for top level also } while ( deploymentUnit != null ) ; for ( PersistenceUnitMetadata pu : puHolder . getPersistenceUnits ( ) ) { pu . setAnnotationIndex ( annotationIndexes ) ; // hold onto the annotation index for Persistence Provider use during deployment } }", "nl": "Setup the annotation index map"}}
{"translation": {"code": "@ Override public void deploy ( DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit unit = phaseContext . getDeploymentUnit ( ) ; final List < KernelDeploymentXmlDescriptor > kdXmlDescriptors = unit . getAttachment ( KernelDeploymentXmlDescriptor . ATTACHMENT_KEY ) ; if ( kdXmlDescriptors == null || kdXmlDescriptors . isEmpty ( ) ) return ; for ( KernelDeploymentXmlDescriptor kdxd : kdXmlDescriptors ) { if ( kdxd . getBeanFactoriesCount ( ) > 0 ) { final ModuleSpecification moduleSpecification = unit . getAttachment ( Attachments . MODULE_SPECIFICATION ) ; final ModuleLoader moduleLoader = Module . getBootModuleLoader ( ) ; ModuleDependency dependency = new ModuleDependency ( moduleLoader , POJO_MODULE , false , false , false , false ) ; PathFilter filter = PathFilters . isChildOf ( BaseBeanFactory . class . getPackage ( ) . getName ( ) ) ; dependency . addImportFilter ( filter , true ) ; dependency . addImportFilter ( PathFilters . rejectAll ( ) , false ) ; moduleSpecification . addSystemDependency ( dependency ) ; return ; } } }", "nl": "Add POJO module if we have any bean factories ."}}
{"translation": {"code": "static void parseCoreEnvironmentElement ( final XMLExtendedStreamReader reader , final ModelNode operation ) throws XMLStreamException { final int count = reader . getAttributeCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { requireNoNamespaceAttribute ( reader , i ) ; final String value = reader . getAttributeValue ( i ) ; final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; switch ( attribute ) { case NODE_IDENTIFIER : TransactionSubsystemRootResourceDefinition . NODE_IDENTIFIER . parseAndSetParameter ( value , operation , reader ) ; break ; case PATH : case RELATIVE_TO : throw TransactionLogger . ROOT_LOGGER . unsupportedAttribute ( attribute . getLocalName ( ) , reader . getLocation ( ) ) ; default : throw unexpectedAttribute ( reader , i ) ; } } // elements final EnumSet < Element > required = EnumSet . of ( Element . PROCESS_ID ) ; final EnumSet < Element > encountered = EnumSet . noneOf ( Element . class ) ; while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { final Element element = Element . forName ( reader . getLocalName ( ) ) ; required . remove ( element ) ; switch ( element ) { case PROCESS_ID : { if ( ! encountered . add ( element ) ) { throw duplicateNamedElement ( reader , reader . getLocalName ( ) ) ; } parseProcessIdEnvironmentElement ( reader , operation ) ; break ; } default : throw unexpectedElement ( reader ) ; } } if ( ! required . isEmpty ( ) ) { throw missingRequiredElement ( reader , required ) ; } }", "nl": "Handle the core - environment element and children"}}
{"translation": {"code": "static void parseProcessIdEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode coreEnvironmentAdd ) throws XMLStreamException { // no attributes if ( reader . getAttributeCount ( ) > 0 ) { throw unexpectedAttribute ( reader , 0 ) ; } // elements boolean encountered = false ; while ( reader . hasNext ( ) && reader . nextTag ( ) != END_ELEMENT ) { final Element element = Element . forName ( reader . getLocalName ( ) ) ; switch ( element ) { case UUID : if ( encountered ) { throw unexpectedElement ( reader ) ; } encountered = true ; if ( reader . getAttributeCount ( ) > 0 ) { throw unexpectedAttribute ( reader , 0 ) ; } coreEnvironmentAdd . get ( TransactionSubsystemRootResourceDefinition . PROCESS_ID_UUID . getName ( ) ) . set ( true ) ; requireNoContent ( reader ) ; break ; case SOCKET : { if ( encountered ) { throw unexpectedElement ( reader ) ; } encountered = true ; parseSocketProcessIdElement ( reader , coreEnvironmentAdd ) ; break ; } default : throw unexpectedElement ( reader ) ; } } if ( ! encountered ) { throw missingOneOf ( reader , EnumSet . of ( Element . UUID , Element . SOCKET ) ) ; } }", "nl": "Handle the process - id child elements"}}
{"translation": {"code": "public static Object instantiateBean ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , DeploymentReflectionIndex index , Module module ) throws Throwable { Joinpoint instantiateJoinpoint = null ; ValueConfig [ ] parameters = new ValueConfig [ 0 ] ; String [ ] types = Configurator . NO_PARAMS_TYPES ; ConstructorConfig ctorConfig = beanConfig . getConstructor ( ) ; if ( ctorConfig != null ) { parameters = ctorConfig . getParameters ( ) ; types = Configurator . getTypes ( parameters ) ; String factoryClass = ctorConfig . getFactoryClass ( ) ; FactoryConfig factory = ctorConfig . getFactory ( ) ; if ( factoryClass != null || factory != null ) { String factoryMethod = ctorConfig . getFactoryMethod ( ) ; if ( factoryMethod == null ) throw PojoLogger . ROOT_LOGGER . missingFactoryMethod ( beanConfig ) ; if ( factoryClass != null ) { // static factory Class < ? > factoryClazz = Class . forName ( factoryClass , false , module . getClassLoader ( ) ) ; Method method = Configurator . findMethod ( index , factoryClazz , factoryMethod , types , true , true , true ) ; MethodJoinpoint mj = new MethodJoinpoint ( method ) ; mj . setTarget ( new ImmediateValue < Object > ( null ) ) ; // null, since this is static call mj . setParameters ( parameters ) ; instantiateJoinpoint = mj ; } else if ( factory != null ) { ReflectionJoinpoint rj = new ReflectionJoinpoint ( factory . getBeanInfo ( ) , factoryMethod , types ) ; // null type is ok, as this should be plain injection rj . setTarget ( new ImmediateValue < Object > ( factory . getValue ( null ) ) ) ; rj . setParameters ( parameters ) ; instantiateJoinpoint = rj ; } } } // plain bean's ctor if ( instantiateJoinpoint == null ) { if ( beanInfo == null ) throw new StartException ( PojoLogger . ROOT_LOGGER . missingBeanInfo ( beanConfig ) ) ; Constructor ctor = ( types . length == 0 ) ? beanInfo . getConstructor ( ) : beanInfo . findConstructor ( types ) ; ConstructorJoinpoint constructorJoinpoint = new ConstructorJoinpoint ( ctor ) ; constructorJoinpoint . setParameters ( parameters ) ; instantiateJoinpoint = constructorJoinpoint ; } return instantiateJoinpoint . dispatch ( ) ; }", "nl": "Instantiate bean ."}}
{"translation": {"code": "public static void dispatchLifecycleJoinpoint ( BeanInfo beanInfo , Object bean , LifecycleConfig config , String defaultMethod ) throws Throwable { if ( config != null && config . isIgnored ( ) ) return ; Joinpoint joinpoint = createJoinpoint ( beanInfo , bean , config , defaultMethod ) ; if ( joinpoint != null ) joinpoint . dispatch ( ) ; }", "nl": "Dispatch lifecycle joinpoint ."}}
{"translation": {"code": "public static void configure ( BeanMetaDataConfig beanConfig , BeanInfo beanInfo , Module module , Object bean , boolean nullify ) throws Throwable { Set < PropertyConfig > properties = beanConfig . getProperties ( ) ; if ( properties != null ) { List < PropertyConfig > used = new ArrayList < PropertyConfig > ( ) ; for ( PropertyConfig pc : properties ) { try { configure ( beanInfo , module , bean , pc , nullify ) ; used . add ( pc ) ; } catch ( Throwable t ) { if ( nullify == false ) { for ( PropertyConfig upc : used ) { try { configure ( beanInfo , module , bean , upc , true ) ; } catch ( Throwable ignored ) { } } throw new StartException ( t ) ; } } } } }", "nl": "Configure bean ."}}
{"translation": {"code": "private String getDomain ( final String oldSecurityDomain , final String nextSecurityDomain ) { if ( nextSecurityDomain == null ) { return oldSecurityDomain ; } if ( oldSecurityDomain == null ) { return nextSecurityDomain ; } ensureSameDomains ( oldSecurityDomain , nextSecurityDomain ) ; return oldSecurityDomain ; }", "nl": "Returns security domain value . This method checks domain is the same for every EJB 3 endpoint ."}}
{"translation": {"code": "private void ensureSameDomains ( final String oldSecurityDomain , final String newSecurityDomain ) { final boolean domainsDiffer = ! oldSecurityDomain . equals ( newSecurityDomain ) ; if ( domainsDiffer ) throw WSLogger . ROOT_LOGGER . multipleSecurityDomainsDetected ( oldSecurityDomain , newSecurityDomain ) ; }", "nl": "This method ensures both passed domains contain the same value ."}}
{"translation": {"code": "public < T > void putPrivateData ( final Class < T > type , T data ) { privateData . put ( type , data ) ; }", "nl": "Attaches arbitrary private data to this view instance"}}
{"translation": {"code": "protected static void unexpectedElement ( final XMLExtendedStreamReader reader ) throws XMLStreamException { throw EeLogger . ROOT_LOGGER . unexpectedElement ( reader . getName ( ) , reader . getLocation ( ) ) ; }", "nl": "Throws a XMLStreamException for the unexpected element that was encountered during the parse"}}
{"translation": {"code": "public void addMessageDestination ( final String name , final String resolvedName , final VirtualFile deploymentRoot ) { List < MessageDestinationMapping > components = messageDestinationJndiMapping . get ( name ) ; if ( components == null ) { messageDestinationJndiMapping . put ( name , components = new ArrayList < MessageDestinationMapping > ( 1 ) ) ; } components . add ( new MessageDestinationMapping ( resolvedName , deploymentRoot ) ) ; }", "nl": "Add a message destination to the application"}}
{"translation": {"code": "public Set < String > resolveMessageDestination ( final String messageDestName , final VirtualFile deploymentRoot ) { if ( messageDestName . contains ( \"#\" ) ) { final String [ ] parts = messageDestName . split ( \"#\" ) ; String path = parts [ 0 ] ; if ( ! path . startsWith ( \"../\" ) ) { path = \"../\" + path ; } final VirtualFile virtualPath = deploymentRoot . getChild ( path ) ; final String name = parts [ 1 ] ; final Set < String > ret = new HashSet < String > ( ) ; final List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( name ) ; if ( data != null ) { for ( final MessageDestinationMapping i : data ) { //now we need to check the path if ( virtualPath . equals ( i . deploymentRoot ) ) { ret . add ( i . jndiName ) ; } } } return ret ; } else { final Set < String > all = new HashSet < String > ( ) ; final Set < String > thisDeployment = new HashSet < String > ( ) ; final List < MessageDestinationMapping > data = messageDestinationJndiMapping . get ( messageDestName ) ; if ( data != null ) { for ( final MessageDestinationMapping i : data ) { all . add ( i . jndiName ) ; if ( i . deploymentRoot . equals ( deploymentRoot ) ) { thisDeployment . add ( i . jndiName ) ; } } } if ( all . size ( ) > 1 ) { return thisDeployment ; } return all ; } }", "nl": "Resolves a message destination name into a JNDI name"}}
{"translation": {"code": "public static Class < ? > makeStubClass ( final Class < ? > myClass ) { final String stubClassName = myClass + \"_Stub\" ; ClassLoader cl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; if ( cl == null ) { cl = myClass . getClassLoader ( ) ; } if ( cl == null ) { throw EjbLogger . ROOT_LOGGER . couldNotFindClassLoaderForStub ( stubClassName ) ; } Class < ? > theClass ; try { theClass = cl . loadClass ( stubClassName ) ; } catch ( ClassNotFoundException e ) { try { final ClassFile clazz = IIOPStubCompiler . compile ( myClass , stubClassName ) ; theClass = clazz . define ( cl , myClass . getProtectionDomain ( ) ) ; } catch ( Throwable ex ) { //there is a possibility that another thread may have defined the same class in the meantime try { theClass = cl . loadClass ( stubClassName ) ; } catch ( ClassNotFoundException e1 ) { EjbLogger . ROOT_LOGGER . dynamicStubCreationFailed ( stubClassName , ex ) ; throw ex ; } } } return theClass ; }", "nl": "Makes a dynamic stub class if it does not already exist ."}}
{"translation": {"code": "public static Transaction getCurrentTransaction ( ) { Transaction tx = null ; if ( piCurrent != null ) { // A non-null piCurrent means that a TxServerInterceptor was // installed: check if there is a transaction propagation context try { Any any = piCurrent . get_slot ( slotId ) ; if ( any . type ( ) . kind ( ) . value ( ) != TCKind . _tk_null ) { // Yes, there is a TPC: add the foreign transaction marker tx = ForeignTransaction . INSTANCE ; } } catch ( InvalidSlot e ) { throw IIOPLogger . ROOT_LOGGER . errorGettingSlotInTxInterceptor ( e ) ; } } return tx ; }", "nl": "Returns the transaction associated with the transaction propagation context that arrived in the current IIOP request ."}}
{"translation": {"code": "private static PersistenceProviderAdaptor savePerDeploymentSharedPersistenceProviderAdaptor ( DeploymentUnit deploymentUnit , String adaptorModule , PersistenceProviderAdaptor adaptor , PersistenceProvider provider ) { if ( deploymentUnit . getParent ( ) != null ) { deploymentUnit = deploymentUnit . getParent ( ) ; } synchronized ( deploymentUnit ) { Map < String , PersistenceProviderAdaptor > map = deploymentUnit . getAttachment ( providerAdaptorMapKey ) ; String key ; if ( adaptorModule != null ) { key = adaptorModule ; // handle legacy adapter module } else { key = provider . getClass ( ) . getName ( ) ; } PersistenceProviderAdaptor current = map . get ( key ) ; // saved if not already set by another thread if ( current == null ) { map . put ( key , adaptor ) ; current = adaptor ; } return current ; } }", "nl": "Will save the PersistenceProviderAdaptor at the top level application deployment unit level for sharing with other persistence units"}}
{"translation": {"code": "public static MethodIntf of ( final InterceptorContext invocation ) { //for timer invocations there is no view, so the methodInf is attached directly //to the context. Otherwise we retrieve it from the invoked view MethodIntf methodIntf = invocation . getPrivateData ( MethodIntf . class ) ; if ( methodIntf == null ) { final ComponentView componentView = invocation . getPrivateData ( ComponentView . class ) ; if ( componentView != null ) { methodIntf = componentView . getPrivateData ( MethodIntf . class ) ; } else { methodIntf = MethodIntf . BEAN ; } } return methodIntf ; }", "nl": "centralize this hack"}}
{"translation": {"code": "public Object handleForLocator ( final EJBLocator < ? > locator ) { final org . omg . CORBA . Object reference = referenceForLocator ( locator ) ; if ( locator instanceof EJBHomeLocator ) { return new HomeHandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; } return new HandleImplIIOP ( orb . getValue ( ) . object_to_string ( reference ) ) ; }", "nl": "Gets a handle for the given ejb locator ."}}
{"translation": {"code": "private TimerImpl mostRecentEntityVersion ( final TimerImpl timerImpl ) { try { final int status = ContextTransactionManager . getInstance ( ) . getStatus ( ) ; if ( status == Status . STATUS_UNKNOWN || status == Status . STATUS_NO_TRANSACTION ) { return timerImpl ; } final String key = timerTransactionKey ( timerImpl ) ; TimerImpl existing = ( TimerImpl ) transactionSynchronizationRegistry . getValue ( ) . getResource ( key ) ; return existing != null ? existing : timerImpl ; } catch ( SystemException e ) { throw new RuntimeException ( e ) ; } }", "nl": "Returns either the loaded entity or the most recent version of the entity that has been persisted in this transaction ."}}
{"translation": {"code": "public static void checkAllowed ( final MethodType methodType ) { final InterceptorContext context = CurrentInvocationContext . get ( ) ; if ( context == null ) { return ; } final Component component = context . getPrivateData ( Component . class ) ; if ( ! ( component instanceof EJBComponent ) ) { return ; } final InvocationType invocationType = context . getPrivateData ( InvocationType . class ) ; ( ( EJBComponent ) component ) . getAllowedMethodsInformation ( ) . realCheckPermission ( methodType , invocationType ) ; }", "nl": "Checks that the current method"}}
{"translation": {"code": "private void checkTransactionSync ( MethodType methodType ) { //first we have to check the synchronization status //as the sync is not affected by the current invocation final CurrentSynchronizationCallback . CallbackType currentSync = CurrentSynchronizationCallback . get ( ) ; if ( currentSync != null ) { if ( deniedSyncMethods . contains ( new DeniedSyncMethodKey ( currentSync , methodType ) ) ) { throwException ( methodType , currentSync ) ; } } }", "nl": "transaction sync is not affected by the current invocation as multiple ejb methods may be invoked from afterCompletion"}}
{"translation": {"code": "public void addPrePassivateInterceptor ( InterceptorFactory interceptorFactory , int priority ) { prePassivateInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; }", "nl": "Adds a pre passivate interceptor"}}
{"translation": {"code": "public static synchronized void removeUrlContextFactory ( final String scheme , ObjectFactory factory ) { Map < String , ObjectFactory > factories = new HashMap < String , ObjectFactory > ( urlContextFactories ) ; ObjectFactory f = factories . get ( scheme ) ; if ( f == factory ) { factories . remove ( scheme ) ; urlContextFactories = Collections . unmodifiableMap ( factories ) ; return ; } else { throw new IllegalArgumentException ( ) ; } }", "nl": "Remove an ObjectFactory from the map of registered ones . To make sure that not anybody can remove an ObjectFactory both the scheme as well as the actual object factory itself need to be supplied . So you can only remove the factory if you have the factory object ."}}
{"translation": {"code": "public static ExtendedEntityManager [ ] getDeferredEntityManagers ( ) { List < ExtendedEntityManager > store = deferToPostConstruct . get ( ) ; try { if ( store . isEmpty ( ) ) { return EMPTY ; } else { return store . toArray ( new ExtendedEntityManager [ store . size ( ) ] ) ; } } finally { store . clear ( ) ; } }", "nl": "Called by postconstruct interceptor"}}
{"translation": {"code": "static String getJndiName ( final ModelNode modelNode , OperationContext context ) throws OperationFailedException { final String rawJndiName = MailSessionDefinition . JNDI_NAME . resolveModelAttribute ( context , modelNode ) . asString ( ) ; return getJndiName ( rawJndiName ) ; }", "nl": "Extracts the raw JNDI_NAME value from the given model node and depending on the value and the value of any USE_JAVA_CONTEXT child node converts the raw name into a compliant jndi name ."}}
{"translation": {"code": "private ClassLoader findParentModuleCl ( ClassLoader classLoader ) { ClassLoader c = classLoader ; while ( c != null && ! ( c instanceof ModuleClassLoader ) ) { c = c . getParent ( ) ; } return c ; }", "nl": "If a custom CL is in use we want to get the module CL it delegates to"}}
{"translation": {"code": "public void addDeploymentSpecificPersistenceProvider ( PersistenceProvider persistenceProvider , Set < ClassLoader > deploymentClassLoaders ) { synchronized ( persistenceProviderPerClassLoader ) { for ( ClassLoader deploymentClassLoader : deploymentClassLoaders ) { List < Class < ? extends PersistenceProvider > > list = persistenceProviderPerClassLoader . get ( deploymentClassLoader ) ; ROOT_LOGGER . tracef ( \"getting persistence provider list (%s) for deployment (%s)\" , list , deploymentClassLoader ) ; if ( list == null ) { list = new ArrayList <> ( ) ; persistenceProviderPerClassLoader . put ( deploymentClassLoader , list ) ; ROOT_LOGGER . tracef ( \"saving new persistence provider list (%s) for deployment (%s)\" , list , deploymentClassLoader ) ; } list . add ( persistenceProvider . getClass ( ) ) ; ROOT_LOGGER . tracef ( \"added new persistence provider (%s) to provider list (%s)\" , persistenceProvider . getClass ( ) . getName ( ) , list ) ; } } }", "nl": "Set at application deployment time to the persistence providers packaged in the application"}}
{"translation": {"code": "private static Set < ClassLoader > allDeploymentModuleClassLoaders ( DeploymentUnit deploymentUnit ) { Set < ClassLoader > deploymentClassLoaders = new HashSet < ClassLoader > ( ) ; final DeploymentUnit topDeploymentUnit = DeploymentUtils . getTopDeploymentUnit ( deploymentUnit ) ; final Module toplevelModule = topDeploymentUnit . getAttachment ( Attachments . MODULE ) ; if ( toplevelModule != null ) { deploymentClassLoaders . add ( toplevelModule . getClassLoader ( ) ) ; final List < DeploymentUnit > subDeployments = topDeploymentUnit . getAttachmentList ( Attachments . SUB_DEPLOYMENTS ) ; for ( DeploymentUnit subDeploymentUnit : subDeployments ) { final Module subDeploymentModule = subDeploymentUnit . getAttachment ( Attachments . MODULE ) ; if ( subDeploymentModule != null ) { deploymentClassLoaders . add ( subDeploymentModule . getClassLoader ( ) ) ; } } } return deploymentClassLoaders ; }", "nl": "returns the toplevel deployment module classloader and all subdeployment classloaders"}}
{"translation": {"code": "public static Map < String , ExtendedEntityManager > currentSFSBCallStackInvocation ( ) { ArrayList < Map < String , ExtendedEntityManager > > stack = CURRENT . get ( ) . invocationStack ; if ( stack != null && stack . size ( ) > 0 ) { return stack . get ( stack . size ( ) - 1 ) ; } return null ; }", "nl": "return for just the current entity manager invocation"}}
{"translation": {"code": "void refreshParticipant ( OperationContext context ) { context . addStep ( refreshHandler , OperationContext . Stage . MODEL , true ) ; }", "nl": "refresh the attributes of this participant ( the status attribute should have changed to PREPARED"}}
{"translation": {"code": "private void parseXTSEnvironmentElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { processAttributes ( reader , ( index , attribute ) -> { final String value = reader . getAttributeValue ( index ) ; switch ( attribute ) { case URL : ENVIRONMENT_URL . parseAndSetParameter ( value , subsystem , reader ) ; break ; default : throw ParseUtils . unexpectedAttribute ( reader , index ) ; } } ) ; // Handle elements ParseUtils . requireNoContent ( reader ) ; }", "nl": "Handle the xts - environment element"}}
{"translation": {"code": "protected static void checkOnlyOneOfElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { if ( ! seen . contains ( element1 ) && ! seen . contains ( element2 ) ) { throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . required ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; } if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; } }", "nl": "Check one and only one of the 2 elements has been defined"}}
{"translation": {"code": "private static String defaultPersistenceUnitName ( String persistenceUnitName , PersistenceUnitMetadataHolder holder ) { if ( ( persistenceUnitName == null || persistenceUnitName . length ( ) == 0 ) ) { for ( PersistenceUnitMetadata persistenceUnit : holder . getPersistenceUnits ( ) ) { String defaultPU = persistenceUnit . getProperties ( ) . getProperty ( Configuration . JPA_DEFAULT_PERSISTENCE_UNIT ) ; if ( Boolean . TRUE . toString ( ) . equals ( defaultPU ) ) { persistenceUnitName = persistenceUnit . getPersistenceUnitName ( ) ; } } } return persistenceUnitName ; }", "nl": "if no persistence unit name is specified return name of default persistence unit"}}
{"translation": {"code": "private String computeMaskedPassword ( ) throws Exception { // Create the PBE secret key SecretKeyFactory factory = SecretKeyFactory . getInstance ( VAULT_ENC_ALGORITHM ) ; char [ ] password = \"somearbitrarycrazystringthatdoesnotmatter\" . toCharArray ( ) ; PBEParameterSpec cipherSpec = new PBEParameterSpec ( salt . getBytes ( CHARSET ) , iterationCount ) ; PBEKeySpec keySpec = new PBEKeySpec ( password ) ; SecretKey cipherKey = factory . generateSecret ( keySpec ) ; String maskedPass = PBEUtils . encode64 ( keystorePassword . getBytes ( CHARSET ) , VAULT_ENC_ALGORITHM , cipherKey , cipherSpec ) ; return PicketBoxSecurityVault . PASS_MASK_PREFIX + maskedPass ; }", "nl": "Method to compute masked password based on class attributes ."}}
{"translation": {"code": "private void initSecurityVault ( ) throws Exception { try { this . vault = SecurityVaultFactory . get ( ) ; this . vault . init ( getVaultOptionsMap ( ) ) ; handshake ( ) ; } catch ( SecurityVaultException e ) { throw SecurityLogger . ROOT_LOGGER . securityVaultException ( e ) ; } }", "nl": "Initialize the underlying vault ."}}
{"translation": {"code": "public void startVaultSession ( String vaultAlias ) throws Exception { if ( vaultAlias == null ) { throw SecurityLogger . ROOT_LOGGER . vaultAliasNotSpecified ( ) ; } this . keystoreMaskedPassword = ( org . jboss . security . Util . isPasswordCommand ( keystorePassword ) ) ? keystorePassword : computeMaskedPassword ( ) ; this . vaultAlias = vaultAlias ; initSecurityVault ( ) ; }", "nl": "Start the vault with given alias ."}}
{"translation": {"code": "private void attributeCreatedDisplay ( String vaultBlock , String attributeName ) { System . out . println ( SecurityLogger . ROOT_LOGGER . vaultAttributeCreateDisplay ( vaultBlock , attributeName , securedAttributeConfigurationString ( vaultBlock , attributeName ) ) ) ; }", "nl": "Display info about stored secured attribute ."}}
{"translation": {"code": "private void initOptions ( ) { options = new Options ( ) ; options . addOption ( \"k\" , KEYSTORE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineKeyStoreURL ( ) ) ; options . addOption ( \"p\" , KEYSTORE_PASSWORD_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineKeyStorePassword ( ) ) ; options . addOption ( \"e\" , ENC_DIR_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineEncryptionDirectory ( ) ) ; options . addOption ( \"s\" , SALT_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineSalt ( ) ) ; options . addOption ( \"i\" , ITERATION_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineIterationCount ( ) ) ; options . addOption ( \"v\" , ALIAS_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineVaultKeyStoreAlias ( ) ) ; options . addOption ( \"b\" , VAULT_BLOCK_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineVaultBlock ( ) ) ; options . addOption ( \"a\" , ATTRIBUTE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineAttributeName ( ) ) ; options . addOption ( \"t\" , CREATE_KEYSTORE_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineAutomaticallyCreateKeystore ( ) ) ; OptionGroup og = new OptionGroup ( ) ; Option x = new Option ( \"x\" , SEC_ATTR_VALUE_PARAM , true , SecurityLogger . ROOT_LOGGER . cmdLineSecuredAttribute ( ) ) ; Option c = new Option ( \"c\" , CHECK_SEC_ATTR_EXISTS_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineCheckAttribute ( ) ) ; Option r = new Option ( \"r\" , REMOVE_SEC_ATTR_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineRemoveSecuredAttribute ( ) ) ; Option h = new Option ( \"h\" , HELP_PARAM , false , SecurityLogger . ROOT_LOGGER . cmdLineHelp ( ) ) ; og . addOption ( x ) ; og . addOption ( c ) ; og . addOption ( r ) ; og . addOption ( h ) ; og . setRequired ( true ) ; options . addOptionGroup ( og ) ; }", "nl": "Build options for non - interactive VaultTool usage scenario ."}}
{"translation": {"code": "public void vaultConfigurationDisplay ( ) { final String configuration = vaultConfiguration ( ) ; System . out . println ( SecurityLogger . ROOT_LOGGER . vaultConfigurationTitle ( ) ) ; System . out . println ( \"********************************************\" ) ; System . out . println ( \"For standalone mode:\" ) ; System . out . println ( configuration ) ; System . out . println ( \"********************************************\" ) ; System . out . println ( \"For domain mode:\" ) ; System . out . println ( \"/host=the_host\" + configuration ) ; System . out . println ( \"********************************************\" ) ; }", "nl": "Display info about vault itself in form of AS7 configuration file ."}}
{"translation": {"code": "static Map < String , ExtendedEntityManager > getCurrentCall ( ) { ArrayList < Map < String , ExtendedEntityManager > > stack = currentSFSBCallStack ( ) ; Map < String , ExtendedEntityManager > result = null ; if ( stack != null ) { result = stack . get ( stack . size ( ) - 1 ) ; } return result ; }", "nl": "gets the current SFSB invocation off the invocation call stack"}}
{"translation": {"code": "protected static void checkNotBothElements ( XMLExtendedStreamReader reader , Set < Element > seen , Element element1 , Element element2 ) throws XMLStreamException { if ( seen . contains ( element1 ) && seen . contains ( element2 ) ) { throw new XMLStreamException ( MessagingLogger . ROOT_LOGGER . onlyOneRequired ( element1 . getLocalName ( ) , element2 . getLocalName ( ) ) , reader . getLocation ( ) ) ; } }", "nl": "Check that not both elements have been defined"}}
{"translation": {"code": "public static boolean needClassFileTransformer ( PersistenceUnitMetadata pu ) { boolean result = true ; String provider = pu . getPersistenceProviderClassName ( ) ; if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) { result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_CLASS_TRANSFORMER ) ) ; } else if ( isHibernateProvider ( provider ) ) { result = ( Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_USE_CLASS_ENHANCER ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_DIRTY_TRACKING ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_LAZY_INITIALIZATION ) ) || Boolean . TRUE . toString ( ) . equals ( pu . getProperties ( ) . getProperty ( HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT ) ) ) ; } return result ; }", "nl": "Determine if class file transformer is needed for the specified persistence unit"}}
{"translation": {"code": "@ Override protected Credential parseCredential ( XMLStreamReader reader ) throws XMLStreamException , ParserException , ValidateException { String userName = null ; String password = null ; String securityDomain = null ; boolean elytronEnabled = false ; String authenticationContext = null ; while ( reader . hasNext ( ) ) { switch ( reader . nextTag ( ) ) { case END_ELEMENT : { if ( DataSource . Tag . forName ( reader . getLocalName ( ) ) == DataSource . Tag . SECURITY || Recovery . Tag . forName ( reader . getLocalName ( ) ) == Recovery . Tag . RECOVER_CREDENTIAL ) { return new CredentialImpl ( userName , password , elytronEnabled ? authenticationContext : securityDomain , elytronEnabled , null ) ; } else { if ( Credential . Tag . forName ( reader . getLocalName ( ) ) == Credential . Tag . UNKNOWN ) { throw new ParserException ( bundle . unexpectedEndTag ( reader . getLocalName ( ) ) ) ; } } break ; } case START_ELEMENT : { switch ( Credential . Tag . forName ( reader . getLocalName ( ) ) ) { case PASSWORD : { password = elementAsString ( reader ) ; if ( propertyResolver != null && password != null ) { String resolvedPassword = propertyResolver . resolve ( password ) ; if ( resolvedPassword != null ) password = resolvedPassword ; } break ; } case USER_NAME : { userName = elementAsString ( reader ) ; break ; } case SECURITY_DOMAIN : { securityDomain = elementAsString ( reader ) ; break ; } case ELYTRON_ENABLED : { Boolean value = elementAsBoolean ( reader ) ; elytronEnabled = value == null ? true : value ; break ; } case AUTHENTICATION_CONTEXT : { authenticationContext = elementAsString ( reader ) ; break ; } default : throw new ParserException ( bundle . unexpectedElement ( reader . getLocalName ( ) ) ) ; } break ; } } } throw new ParserException ( bundle . unexpectedEndOfDocument ( ) ) ; }", "nl": "parse credential tag"}}
{"translation": {"code": "String computeSlot ( String jsfVersion ) { if ( jsfVersion == null ) return defaultSlot ; if ( JsfVersionMarker . JSF_2_0 . equals ( jsfVersion ) ) return defaultSlot ; return jsfVersion ; }", "nl": "If needed convert old JSFVersionMarker values to slot values ."}}
{"translation": {"code": "private void checkVersionIntegrity ( ) { activeVersions . addAll ( allVersions ) ; for ( String version : allVersions ) { if ( ! apiIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , API_MODULE ) ; activeVersions . remove ( version ) ; } if ( ! implIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , IMPL_MODULE ) ; activeVersions . remove ( version ) ; } if ( ! injectionIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , INJECTION_MODULE ) ; activeVersions . remove ( version ) ; } } }", "nl": "make sure that each version has api impl and injection"}}
{"translation": {"code": "private void loadIdsManually ( ) { implIds . put ( \"main\" , ModuleIdentifier . create ( IMPL_MODULE ) ) ; apiIds . put ( \"main\" , ModuleIdentifier . create ( API_MODULE ) ) ; injectionIds . put ( \"main\" , ModuleIdentifier . create ( INJECTION_MODULE ) ) ; allVersions . add ( \"main\" ) ; activeVersions . add ( \"main\" ) ; }", "nl": "just provide the default implementations"}}
{"translation": {"code": "@ Override public void stop ( final StopContext context ) { final WeldBootstrapService bootstrapService = bootstrapSupplier . get ( ) ; if ( ! bootstrapService . isStarted ( ) ) { throw WeldLogger . ROOT_LOGGER . notStarted ( \"WeldContainer\" ) ; } WeldLogger . DEPLOYMENT_LOGGER . stoppingWeldService ( bootstrapService . getDeploymentName ( ) ) ; ClassLoader oldTccl = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; WeldProvider . containerShutDown ( Container . instance ( bootstrapService . getDeploymentName ( ) ) ) ; bootstrapService . getBootstrap ( ) . shutdown ( ) ; } finally { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( oldTccl ) ; ModuleGroupSingletonProvider . removeClassLoader ( bootstrapService . getDeployment ( ) . getModule ( ) . getClassLoader ( ) ) ; } bootstrapService . setStarted ( false ) ; }", "nl": "Stops the container Executed in WeldStartService to shutdown the runtime before NamingService is closed ."}}
{"translation": {"code": "public static void skip ( InputStream is , long amount ) throws IOException { long leftToSkip = amount ; long amountSkipped = 0 ; while ( leftToSkip > 0 && amountSkipped >= 0 ) { amountSkipped = is . skip ( leftToSkip ) ; leftToSkip -= amountSkipped ; } }", "nl": "Ensure InputStream actually skips ahead the required number of bytes"}}
{"translation": {"code": "public void addLog ( String content , String logName ) throws Exception { String name = \"sos_logs/\" + logName ; this . add ( new ByteArrayInputStream ( content . getBytes ( StandardCharsets . UTF_8 ) ) , name ) ; }", "nl": "Adds content to the zipfile in a file named logName"}}
{"translation": {"code": "private void checkDatabase ( ) { String loadTimer = sql ( LOAD_TIMER ) ; Connection connection = null ; Statement statement = null ; PreparedStatement preparedStatement = null ; ResultSet resultSet = null ; try { //test for the existence of the table by running the load timer query connection = dataSource . getConnection ( ) ; if ( connection . getTransactionIsolation ( ) < Connection . TRANSACTION_READ_COMMITTED ) { EjbLogger . EJB3_TIMER_LOGGER . wrongTransactionIsolationConfiguredForTimer ( ) ; } preparedStatement = connection . prepareStatement ( loadTimer ) ; preparedStatement . setString ( 1 , \"NON-EXISTENT\" ) ; preparedStatement . setString ( 2 , \"NON-EXISTENT\" ) ; preparedStatement . setString ( 3 , \"NON-EXISTENT\" ) ; resultSet = preparedStatement . executeQuery ( ) ; } catch ( SQLException e ) { //the query failed, assume it is because the table does not exist if ( connection != null ) { try { String createTable = sql ( CREATE_TABLE ) ; String [ ] statements = createTable . split ( \";\" ) ; for ( final String sql : statements ) { try { statement = connection . createStatement ( ) ; statement . executeUpdate ( sql ) ; } finally { safeClose ( statement ) ; } } } catch ( SQLException e1 ) { EjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e1 ) ; } } else { EjbLogger . EJB3_TIMER_LOGGER . couldNotCreateTable ( e ) ; } } finally { safeClose ( resultSet ) ; safeClose ( preparedStatement ) ; safeClose ( statement ) ; safeClose ( connection ) ; } }", "nl": "Checks whether the database transaction configuration is appropriate and create the timer table if necessary ."}}
{"translation": {"code": "public String vaultConfiguration ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"/core-service=vault:add(vault-options=[\" ) ; sb . append ( \"(\\\"KEYSTORE_URL\\\" => \\\"\" ) . append ( keystoreURL ) . append ( \"\\\")\" ) . append ( \",\" ) ; sb . append ( \"(\\\"KEYSTORE_PASSWORD\\\" => \\\"\" ) . append ( keystoreMaskedPassword ) . append ( \"\\\")\" ) . append ( \",\" ) ; sb . append ( \"(\\\"KEYSTORE_ALIAS\\\" => \\\"\" ) . append ( vaultAlias ) . append ( \"\\\")\" ) . append ( \",\" ) ; sb . append ( \"(\\\"SALT\\\" => \\\"\" ) . append ( salt ) . append ( \"\\\")\" ) . append ( \",\" ) ; sb . append ( \"(\\\"ITERATION_COUNT\\\" => \\\"\" ) . append ( iterationCount ) . append ( \"\\\")\" ) . append ( \",\" ) ; sb . append ( \"(\\\"ENC_FILE_DIR\\\" => \\\"\" ) . append ( encryptionDirectory ) . append ( \"\\\")\" ) ; sb . append ( \"])\" ) ; return sb . toString ( ) ; }", "nl": "Returns vault configuration string in user readable form ."}}
{"translation": {"code": "public Set < InterceptorDescription > getAllContainerInterceptors ( ) { if ( this . allContainerInterceptors == null ) { this . allContainerInterceptors = new HashSet < InterceptorDescription > ( ) ; this . allContainerInterceptors . addAll ( this . classLevelContainerInterceptors ) ; if ( ! this . excludeDefaultContainerInterceptors ) { this . allContainerInterceptors . addAll ( this . defaultContainerInterceptors ) ; } for ( List < InterceptorDescription > interceptors : this . methodLevelContainerInterceptors . values ( ) ) { this . allContainerInterceptors . addAll ( interceptors ) ; } } return this . allContainerInterceptors ; }", "nl": "Returns a combined map of class and method level container interceptors"}}
{"translation": {"code": "public static String getJndiName ( final OperationContext context , final ModelNode modelNode ) throws OperationFailedException { final String rawJndiName = JNDI_NAME . resolveModelAttribute ( context , modelNode ) . asString ( ) ; return cleanJndiName ( rawJndiName , modelNode . hasDefined ( USE_JAVA_CONTEXT . getName ( ) ) && modelNode . get ( USE_JAVA_CONTEXT . getName ( ) ) . asBoolean ( ) ) ; }", "nl": "Extracts the raw JNDINAME value from the given model node and depending on the value and the value of any USE_JAVA_CONTEXT child node converts the raw name into a compliant jndi name ."}}
{"translation": {"code": "@ SuppressWarnings ( \"unchecked\" ) public void inject ( Object object , String propertyName , Object propertyValue ) throws NoSuchMethodException , IllegalAccessException , InvocationTargetException { inject ( object , propertyName , propertyValue , null , false ) ; }", "nl": "Inject a value into an object property"}}
{"translation": {"code": "private Set < String > getAllComponentClasses ( DeploymentUnit deploymentUnit , CompositeIndex index , WarMetaData metaData , TldsMetaData tldsMetaData ) { final Set < String > classes = new HashSet < String > ( ) ; getAllComponentClasses ( metaData . getMergedJBossWebMetaData ( ) , classes ) ; if ( tldsMetaData == null ) return classes ; if ( tldsMetaData . getSharedTlds ( deploymentUnit ) != null ) for ( TldMetaData tldMetaData : tldsMetaData . getSharedTlds ( deploymentUnit ) ) { getAllComponentClasses ( tldMetaData , classes ) ; } if ( tldsMetaData . getTlds ( ) != null ) for ( Map . Entry < String , TldMetaData > tldMetaData : tldsMetaData . getTlds ( ) . entrySet ( ) ) { getAllComponentClasses ( tldMetaData . getValue ( ) , classes ) ; } getAllAsyncListenerClasses ( index , classes ) ; return classes ; }", "nl": "Gets all classes that are eligible for injection etc"}}
{"translation": {"code": "void processManagement ( final DeploymentUnit unit , JBossWebMetaData metaData ) { final DeploymentResourceSupport deploymentResourceSupport = unit . getAttachment ( Attachments . DEPLOYMENT_RESOURCE_SUPPORT ) ; for ( final JBossServletMetaData servlet : metaData . getServlets ( ) ) { try { final String name = servlet . getName ( ) ; final ModelNode node = deploymentResourceSupport . getDeploymentSubModel ( UndertowExtension . SUBSYSTEM_NAME , PathElement . pathElement ( \"servlet\" , name ) ) ; node . get ( \"servlet-class\" ) . set ( servlet . getServletClass ( ) ) ; node . get ( \"servlet-name\" ) . set ( servlet . getServletName ( ) ) ; } catch ( Exception e ) { // Should a failure in creating the mgmt view also make to the deployment to fail? continue ; } } }", "nl": "todo move to UndertowDeploymentService and use all registered servlets from Deployment instead of just one found by metadata"}}
{"translation": {"code": "public void deploy ( final DeploymentPhaseContext phaseContext ) throws DeploymentUnitProcessingException { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; if ( ! DeploymentTypeMarker . isType ( DeploymentType . WAR , deploymentUnit ) ) { return ; // Skip non web deployments } WarMetaData warMetaData = deploymentUnit . getAttachment ( WarMetaData . ATTACHMENT_KEY ) ; assert warMetaData != null ; Map < String , WebMetaData > annotationsMetaData = warMetaData . getAnnotationsMetaData ( ) ; if ( annotationsMetaData == null ) { annotationsMetaData = new HashMap < String , WebMetaData > ( ) ; warMetaData . setAnnotationsMetaData ( annotationsMetaData ) ; } Map < ResourceRoot , Index > indexes = AnnotationIndexUtils . getAnnotationIndexes ( deploymentUnit ) ; // Process lib/*.jar for ( final Entry < ResourceRoot , Index > entry : indexes . entrySet ( ) ) { final Index jarIndex = entry . getValue ( ) ; annotationsMetaData . put ( entry . getKey ( ) . getRootName ( ) , processAnnotations ( jarIndex ) ) ; } Map < ModuleIdentifier , CompositeIndex > additionalModelAnnotations = deploymentUnit . getAttachment ( Attachments . ADDITIONAL_ANNOTATION_INDEXES_BY_MODULE ) ; if ( additionalModelAnnotations != null ) { final List < WebMetaData > additional = new ArrayList < WebMetaData > ( ) ; for ( Entry < ModuleIdentifier , CompositeIndex > entry : additionalModelAnnotations . entrySet ( ) ) { for ( Index index : entry . getValue ( ) . getIndexes ( ) ) { additional . add ( processAnnotations ( index ) ) ; } } warMetaData . setAdditionalModuleAnnotationsMetadata ( additional ) ; } }", "nl": "Process web annotations ."}}
{"translation": {"code": "static RunAs popRunAsIdentity ( final SecurityContext sc ) { if ( WildFlySecurityManager . isChecking ( ) ) { return AccessController . doPrivileged ( new PrivilegedAction < RunAs > ( ) { @ Override public RunAs run ( ) { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } } ) ; } else { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs principal = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( null ) ; return principal ; } }", "nl": "Removes the run as identity"}}
{"translation": {"code": "static RunAs setRunAsIdentity ( final RunAs principal , final SecurityContext sc ) { if ( WildFlySecurityManager . isChecking ( ) ) { return WildFlySecurityManager . doUnchecked ( new PrivilegedAction < RunAs > ( ) { @ Override public RunAs run ( ) { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs old = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( principal ) ; return old ; } } ) ; } else { if ( sc == null ) { throw UndertowLogger . ROOT_LOGGER . noSecurityContext ( ) ; } RunAs old = sc . getOutgoingRunAs ( ) ; sc . setOutgoingRunAs ( principal ) ; return old ; } }", "nl": "Sets the run as identity"}}
{"translation": {"code": "private List < ResourceRoot > createResourceRoots ( final VirtualFile deploymentRoot , final DeploymentUnit deploymentUnit ) throws IOException , DeploymentUnitProcessingException { final List < ResourceRoot > entries = new ArrayList < ResourceRoot > ( ) ; // WEB-INF classes final VirtualFile webinfClasses = deploymentRoot . getChild ( WEB_INF_CLASSES ) ; if ( webinfClasses . exists ( ) ) { final ResourceRoot webInfClassesRoot = new ResourceRoot ( webinfClasses . getName ( ) , webinfClasses , null ) ; ModuleRootMarker . mark ( webInfClassesRoot ) ; entries . add ( webInfClassesRoot ) ; } // WEB-INF lib Map < String , MountedDeploymentOverlay > overlays = deploymentUnit . getAttachment ( Attachments . DEPLOYMENT_OVERLAY_LOCATIONS ) ; final VirtualFile webinfLib = deploymentRoot . getChild ( WEB_INF_LIB ) ; if ( webinfLib . exists ( ) ) { final List < VirtualFile > archives = webinfLib . getChildren ( DEFAULT_WEB_INF_LIB_FILTER ) ; for ( final VirtualFile archive : archives ) { try { String relativeName = archive . getPathNameRelativeTo ( deploymentRoot ) ; MountedDeploymentOverlay overlay = overlays . get ( relativeName ) ; Closeable closable = null ; if ( overlay != null ) { overlay . remountAsZip ( false ) ; } else if ( archive . isFile ( ) ) { closable = VFS . mountZip ( archive , archive , TempFileProviderService . provider ( ) ) ; } else { closable = null ; } final ResourceRoot webInfArchiveRoot = new ResourceRoot ( archive . getName ( ) , archive , new MountHandle ( closable ) ) ; ModuleRootMarker . mark ( webInfArchiveRoot ) ; entries . add ( webInfArchiveRoot ) ; } catch ( IOException e ) { throw new DeploymentUnitProcessingException ( UndertowLogger . ROOT_LOGGER . failToProcessWebInfLib ( archive ) , e ) ; } } } return entries ; }", "nl": "Create the resource roots for a . war deployment"}}
{"translation": {"code": "private void parseDefaultContextPropagationElement ( XMLExtendedStreamReader reader , ModelNode subsystem ) throws XMLStreamException { processAttributes ( reader , ( index , attribute ) -> { final String value = reader . getAttributeValue ( index ) ; switch ( attribute ) { case ENABLED : if ( value == null || ( ! value . toLowerCase ( ) . equals ( \"true\" ) && ! value . toLowerCase ( ) . equals ( \"false\" ) ) ) { throw ParseUtils . invalidAttributeValue ( reader , index ) ; } DEFAULT_CONTEXT_PROPAGATION . parseAndSetParameter ( value , subsystem , reader ) ; break ; default : throw ParseUtils . unexpectedAttribute ( reader , index ) ; } } ) ; // Handle elements ParseUtils . requireNoContent ( reader ) ; }", "nl": "Handle the enable - client - handler element ."}}
{"translation": {"code": "public static String [ ] getCanonicalParameterTypes ( Method viewMethod ) { Class < ? > [ ] parameterTypes = viewMethod . getParameterTypes ( ) ; if ( parameterTypes == null ) { return NO_STRINGS ; } String [ ] canonicalNames = new String [ parameterTypes . length ] ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { canonicalNames [ i ] = parameterTypes [ i ] . getCanonicalName ( ) ; } return canonicalNames ; }", "nl": "This method returns the class names of the parameters of the given method in canonical form . In case of a method without parameters it will return an empty array ."}}
{"translation": {"code": "private static void waitForService ( final ServiceController < ? > controller ) throws OperationFailedException { if ( controller . getState ( ) == ServiceController . State . UP ) return ; final StabilityMonitor monitor = new StabilityMonitor ( ) ; monitor . addController ( controller ) ; try { monitor . awaitStability ( 100 , MILLISECONDS ) ; } catch ( final InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw SecurityLogger . ROOT_LOGGER . interruptedWaitingForSecurityDomain ( controller . getName ( ) . getSimpleName ( ) ) ; } finally { monitor . removeController ( controller ) ; } if ( controller . getState ( ) != ServiceController . State . UP ) { throw SecurityLogger . ROOT_LOGGER . requiredSecurityDomainServiceNotAvailable ( controller . getName ( ) . getSimpleName ( ) ) ; } }", "nl": "Wait for the required service to start up and fail otherwise . This method is necessary when a runtime operation uses a service that might have been created within a composite operation ."}}
{"translation": {"code": "public static Resource createManagementStatisticsResource ( final ManagementAdaptor managementAdaptor , final String scopedPersistenceUnitName , final DeploymentUnit deploymentUnit ) { synchronized ( existingResourceDescriptionResolver ) { final EntityManagerFactoryLookup entityManagerFactoryLookup = new EntityManagerFactoryLookup ( ) ; final Statistics statistics = managementAdaptor . getStatistics ( ) ; if ( false == existingResourceDescriptionResolver . contains ( managementAdaptor . getVersion ( ) ) ) { // setup statistics (this used to be part of JPA subsystem startup) ResourceDescriptionResolver resourceDescriptionResolver = new StandardResourceDescriptionResolver ( statistics . getResourceBundleKeyPrefix ( ) , statistics . getResourceBundleName ( ) , statistics . getClass ( ) . getClassLoader ( ) ) { private ResourceDescriptionResolver fallback = JPAExtension . getResourceDescriptionResolver ( ) ; //add a fallback in case provider doesn't have all properties properly defined @ Override public String getResourceAttributeDescription ( String attributeName , Locale locale , ResourceBundle bundle ) { if ( bundle . containsKey ( getBundleKey ( attributeName ) ) ) { return super . getResourceAttributeDescription ( attributeName , locale , bundle ) ; } else { return fallback . getResourceAttributeDescription ( attributeName , locale , fallback . getResourceBundle ( locale ) ) ; } } } ; PathElement subsystemPE = PathElement . pathElement ( ModelDescriptionConstants . SUBSYSTEM , JPAExtension . SUBSYSTEM_NAME ) ; ManagementResourceRegistration deploymentResourceRegistration = deploymentUnit . getAttachment ( DeploymentModelUtils . MUTABLE_REGISTRATION_ATTACHMENT ) ; ManagementResourceRegistration deploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( subsystemPE ) ) ; ManagementResourceRegistration subdeploymentSubsystemRegistration = deploymentResourceRegistration . getSubModel ( PathAddress . pathAddress ( PathElement . pathElement ( ModelDescriptionConstants . SUBDEPLOYMENT ) , subsystemPE ) ) ; ManagementResourceRegistration providerResource = deploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; providerResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; providerResource = subdeploymentSubsystemRegistration . registerSubModel ( new ManagementResourceDefinition ( PathElement . pathElement ( managementAdaptor . getIdentificationLabel ( ) ) , resourceDescriptionResolver , statistics , entityManagerFactoryLookup ) ) ; providerResource . registerReadOnlyAttribute ( PersistenceUnitServiceHandler . SCOPED_UNIT_NAME , null ) ; existingResourceDescriptionResolver . add ( managementAdaptor . getVersion ( ) ) ; } // create (per deployment) dynamic Resource implementation that can reflect the deployment specific names (e.g. jpa entity classname/Hibernate region name) return new DynamicManagementStatisticsResource ( statistics , scopedPersistenceUnitName , managementAdaptor . getIdentificationLabel ( ) , entityManagerFactoryLookup ) ; } }", "nl": "Create single instance of management statistics resource per managementAdaptor version ."}}
{"translation": {"code": "private EntityManager getOrCreateTransactionScopedEntityManager ( final EntityManagerFactory emf , final String scopedPuName , final Map properties , final SynchronizationType synchronizationType ) { EntityManager entityManager = TransactionUtil . getTransactionScopedEntityManager ( puScopedName , transactionSynchronizationRegistry ) ; if ( entityManager == null ) { entityManager = createEntityManager ( emf , properties , synchronizationType ) ; if ( ROOT_LOGGER . isDebugEnabled ( ) ) { ROOT_LOGGER . debugf ( \"%s: created entity manager session %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; } TransactionUtil . registerSynchronization ( entityManager , scopedPuName , transactionSynchronizationRegistry , transactionManager ) ; TransactionUtil . putEntityManagerInTransactionRegistry ( scopedPuName , entityManager , transactionSynchronizationRegistry ) ; } else { testForMixedSynchronizationTypes ( emf , entityManager , puScopedName , synchronizationType , properties ) ; if ( ROOT_LOGGER . isDebugEnabled ( ) ) { ROOT_LOGGER . debugf ( \"%s: reuse entity manager session already in tx %s\" , TransactionUtil . getEntityManagerDetails ( entityManager , scopedPuName ) , TransactionUtil . getTransaction ( transactionManager ) . toString ( ) ) ; } } return entityManager ; }", "nl": "get or create a Transactional entity manager . Only call while a transaction is active in the current thread ."}}
{"translation": {"code": "private List < ValidationProvider < ? > > loadProviders ( ClassLoader classLoader ) { @ SuppressWarnings ( \"rawtypes\" ) Iterator < ValidationProvider > providerIterator = ServiceLoader . load ( ValidationProvider . class , classLoader ) . iterator ( ) ; LinkedList < ValidationProvider < ? > > providers = new LinkedList < ValidationProvider < ? > > ( ) ; while ( providerIterator . hasNext ( ) ) { try { ValidationProvider < ? > provider = providerIterator . next ( ) ; // put Hibernate Validator to the beginning of the list if ( provider . getClass ( ) . getName ( ) . equals ( \"org.hibernate.validator.HibernateValidator\" ) ) { providers . addFirst ( provider ) ; } else { providers . add ( provider ) ; } } catch ( ServiceConfigurationError e ) { // ignore, because it can happen when multiple // providers are present and some of them are not class loader // compatible with our API. } } return providers ; }", "nl": "Retrieves the providers from the given loader using the service loader mechanism ."}}
{"translation": {"code": "private void addCDIFlag ( WarMetaData warMetaData , DeploymentUnit deploymentUnit ) { JBossWebMetaData webMetaData = warMetaData . getMergedJBossWebMetaData ( ) ; if ( webMetaData == null ) { webMetaData = new JBossWebMetaData ( ) ; warMetaData . setMergedJBossWebMetaData ( webMetaData ) ; } List < ParamValueMetaData > contextParams = webMetaData . getContextParams ( ) ; if ( contextParams == null ) { contextParams = new ArrayList < ParamValueMetaData > ( ) ; } boolean isCDI = false ; final CapabilityServiceSupport support = deploymentUnit . getAttachment ( Attachments . CAPABILITY_SERVICE_SUPPORT ) ; if ( support . hasCapability ( WELD_CAPABILITY_NAME ) ) { isCDI = support . getOptionalCapabilityRuntimeAPI ( WELD_CAPABILITY_NAME , WeldCapability . class ) . get ( ) . isPartOfWeldDeployment ( deploymentUnit ) ; } ParamValueMetaData param = new ParamValueMetaData ( ) ; param . setParamName ( IS_CDI_PARAM ) ; param . setParamValue ( Boolean . toString ( isCDI ) ) ; contextParams . add ( param ) ; webMetaData . setContextParams ( contextParams ) ; }", "nl": "a CDI ViewHandler ."}}
{"translation": {"code": "public static DeploymentUnit getRootDeploymentUnit ( DeploymentUnit deploymentUnit ) { if ( deploymentUnit . getParent ( ) == null ) { return deploymentUnit ; } return deploymentUnit . getParent ( ) ; }", "nl": "Returns the parent of the given deployment unit if such a parent exists . If the given deployment unit is the parent deployment unit it is returned ."}}
{"translation": {"code": "private boolean argumentMatches ( String classType , String propertyType ) { return ( classType . equals ( propertyType ) ) || ( classType . equals ( \"java.lang.Byte\" ) && propertyType . equals ( \"byte\" ) ) || ( classType . equals ( \"java.lang.Short\" ) && propertyType . equals ( \"short\" ) ) || ( classType . equals ( \"java.lang.Integer\" ) && propertyType . equals ( \"int\" ) ) || ( classType . equals ( \"java.lang.Long\" ) && propertyType . equals ( \"long\" ) ) || ( classType . equals ( \"java.lang.Float\" ) && propertyType . equals ( \"float\" ) ) || ( classType . equals ( \"java.lang.Double\" ) && propertyType . equals ( \"double\" ) ) || ( classType . equals ( \"java.lang.Boolean\" ) && propertyType . equals ( \"boolean\" ) ) || ( classType . equals ( \"java.lang.Character\" ) && propertyType . equals ( \"char\" ) ) ; }", "nl": "Compare the type of a class with the actual value"}}
{"translation": {"code": "public static boolean allowTwoPhaseBootstrap ( PersistenceUnitMetadata pu ) { boolean result = true ; if ( EE_DEFAULT_DATASOURCE . equals ( pu . getJtaDataSourceName ( ) ) ) { result = false ; } if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) { result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_TWO_PHASE_BOOTSTRAP ) ) ; } return result ; }", "nl": "Determine if two phase persistence unit start is allowed"}}
{"translation": {"code": "public void addAroundConstructInterceptor ( InterceptorFactory interceptorFactory , int priority ) { aroundConstructInterceptors . add ( Collections . singletonList ( interceptorFactory ) , priority ) ; }", "nl": "Adds an around - construct interceptor"}}
{"translation": {"code": "@ Override public void handleRequest ( HttpServerExchange exchange ) throws Exception { runningCount . increment ( ) ; exchange . addExchangeCompleteListener ( new ExchangeCompletionListener ( ) { @ Override public void exchangeEvent ( HttpServerExchange exchange , NextListener nextListener ) { runningCount . decrement ( ) ; // Proceed to next listener must be called! nextListener . proceed ( ) ; } } ) ; wrappedHandler . handleRequest ( exchange ) ; }", "nl": "Increments the counter and registers a listener to decrement the counter upon exchange complete event ."}}
{"translation": {"code": "protected static String resolveRuntimeName ( final OperationContext context , final PathElement address ) { final ModelNode runtimeName = context . readResourceFromRoot ( PathAddress . pathAddress ( address ) , false ) . getModel ( ) . get ( ModelDescriptionConstants . RUNTIME_NAME ) ; return runtimeName . asString ( ) ; }", "nl": "Resolves runtime name of model resource ."}}
{"translation": {"code": "public SetupContextHandle saveContext ( ContextService contextService , Map < String , String > contextObjectProperties ) { final List < SetupContextHandle > handles = new ArrayList <> ( factoryOrderedList . size ( ) ) ; for ( ContextHandleFactory factory : factoryOrderedList ) { handles . add ( factory . saveContext ( contextService , contextObjectProperties ) ) ; } return new ChainedSetupContextHandle ( this , handles ) ; }", "nl": "Saves the current invocation context on a chained context handle ."}}
{"translation": {"code": "public synchronized void addFactory ( ContextHandleFactory factory ) { final String factoryName = factory . getName ( ) ; if ( factoryMap . containsKey ( factoryName ) ) { throw EeLogger . ROOT_LOGGER . factoryAlreadyExists ( this , factoryName ) ; } factoryMap . put ( factoryName , factory ) ; final Comparator < ContextHandleFactory > comparator = new Comparator < ContextHandleFactory > ( ) { @ Override public int compare ( ContextHandleFactory o1 , ContextHandleFactory o2 ) { return Integer . compare ( o1 . getChainPriority ( ) , o2 . getChainPriority ( ) ) ; } } ; SortedSet < ContextHandleFactory > sortedSet = new TreeSet <> ( comparator ) ; sortedSet . addAll ( factoryMap . values ( ) ) ; factoryOrderedList = new ArrayList <> ( sortedSet ) ; }", "nl": "Adds a new factory ."}}
{"translation": {"code": "private static List < ServiceName > getServerConfigDependencies ( OperationContext context , boolean appclient ) { final List < ServiceName > serviceNames = new ArrayList < ServiceName > ( ) ; final Resource subsystemResource = context . readResourceFromRoot ( PathAddress . pathAddress ( WSExtension . SUBSYSTEM_PATH ) , false ) ; readConfigServiceNames ( serviceNames , subsystemResource , Constants . CLIENT_CONFIG ) ; readConfigServiceNames ( serviceNames , subsystemResource , Constants . ENDPOINT_CONFIG ) ; if ( ! appclient ) { serviceNames . add ( CommonWebServer . SERVICE_NAME ) ; } return serviceNames ; }", "nl": "Process the model to figure out the name of the services the server config service has to depend on"}}
{"translation": {"code": "private static void rejectDefinedAttributeWithDefaultValue ( ResourceTransformationDescriptionBuilder builder , AttributeDefinition ... attrs ) { for ( AttributeDefinition attr : attrs ) { builder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeValueChecker ( attr . getDefaultValue ( ) ) , attr ) . addRejectCheck ( DEFINED , attr ) ; } }", "nl": "Reject the attributes if they are defined or discard them if they are undefined or set to their default value ."}}
{"translation": {"code": "public static boolean allowDefaultDataSourceUse ( PersistenceUnitMetadata pu ) { boolean result = true ; if ( pu . getProperties ( ) . containsKey ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) { result = Boolean . parseBoolean ( pu . getProperties ( ) . getProperty ( Configuration . JPA_ALLOW_DEFAULT_DATA_SOURCE_USE ) ) ; } return result ; }", "nl": "Determine if the default data - source should be used"}}
{"translation": {"code": "static int getPatternType ( String urlPattern ) { int type = EXACT ; if ( urlPattern . startsWith ( \"*.\" ) ) type = EXTENSION ; else if ( urlPattern . startsWith ( \"/\" ) && urlPattern . endsWith ( \"/*\" ) ) type = PREFIX ; else if ( urlPattern . equals ( \"/\" ) ) type = DEFAULT ; return type ; }", "nl": "Determine the url - pattern type"}}
{"translation": {"code": "private boolean updateServerConfig ( String attributeName , String value , boolean isRevert ) throws OperationFailedException , DisabledOperationException { final ServerConfigImpl config = ( ServerConfigImpl ) ServerConfigFactoryImpl . getConfig ( ) ; try { if ( MODIFY_WSDL_ADDRESS . equals ( attributeName ) ) { final boolean modifyWSDLAddress = value != null && Boolean . parseBoolean ( value ) ; config . setModifySOAPAddress ( modifyWSDLAddress , isRevert ) ; } else if ( WSDL_HOST . equals ( attributeName ) ) { final String host = value != null ? value : null ; try { config . setWebServiceHost ( host , isRevert ) ; } catch ( final UnknownHostException e ) { throw new OperationFailedException ( e . getMessage ( ) , e ) ; } } else if ( WSDL_PORT . equals ( attributeName ) ) { final int port = value != null ? Integer . parseInt ( value ) : - 1 ; config . setWebServicePort ( port , isRevert ) ; } else if ( WSDL_SECURE_PORT . equals ( attributeName ) ) { final int securePort = value != null ? Integer . parseInt ( value ) : - 1 ; config . setWebServiceSecurePort ( securePort , isRevert ) ; } else if ( WSDL_PATH_REWRITE_RULE . equals ( attributeName ) ) { final String path = value != null ? value : null ; config . setWebServicePathRewriteRule ( path , isRevert ) ; } else if ( WSDL_URI_SCHEME . equals ( attributeName ) ) { if ( value == null || value . equals ( \"http\" ) || value . equals ( \"https\" ) ) { config . setWebServiceUriScheme ( value , isRevert ) ; } else { throw new IllegalArgumentException ( attributeName + \" = \" + value ) ; } } else if ( STATISTICS_ENABLED . equals ( attributeName ) ) { final boolean enabled = value != null ? Boolean . parseBoolean ( value ) : false ; config . setStatisticsEnabled ( enabled ) ; } else { throw new IllegalArgumentException ( attributeName ) ; } } catch ( DisabledOperationException doe ) { // the WS stack rejected the runtime update if ( ! isRevert ) { return false ; } else { throw doe ; } } return true ; }", "nl": "Returns true if the update operation succeeds in modifying the runtime false otherwise ."}}
{"translation": {"code": "protected DeploymentUnit doPrepare ( String context , ClassLoader loader , Map < String , String > urlPatternToClassNameMap , JBossWebMetaData jbwmd , WebservicesMetaData metadata , JBossWebservicesMetaData jbwsMetadata ) { ClassLoader origClassLoader = WildFlySecurityManager . getCurrentContextClassLoaderPrivileged ( ) ; WSEndpointDeploymentUnit unit = new WSEndpointDeploymentUnit ( loader , context , urlPatternToClassNameMap , jbwmd , metadata , jbwsMetadata ) ; try { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( ClassLoaderProvider . getDefaultProvider ( ) . getServerIntegrationClassLoader ( ) ) ; WSDeploymentBuilder . getInstance ( ) . build ( unit ) ; return unit ; } finally { WildFlySecurityManager . setCurrentContextClassLoaderPrivileged ( origClassLoader ) ; } }", "nl": "Prepare the ws Deployment and return a DeploymentUnit containing it"}}
{"translation": {"code": "private static void renameAttribute ( ResourceTransformationDescriptionBuilder builder , AttributeDefinition attribute , AttributeDefinition alias ) { builder . getAttributeBuilder ( ) . addRename ( attribute , alias . getName ( ) ) ; }", "nl": "Rename an attribute"}}
{"translation": {"code": "private void makeTopLevelBdasVisibleFromStaticModules ( ) { for ( BeanDeploymentArchiveImpl bda : beanDeploymentArchives ) { if ( bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . EXTERNAL ) || bda . getBeanArchiveType ( ) . equals ( BeanDeploymentArchiveImpl . BeanArchiveType . SYNTHETIC ) ) { for ( BeanDeploymentArchiveImpl topLevelBda : rootBeanDeploymentModule . getBeanDeploymentArchives ( ) ) { bda . addBeanDeploymentArchive ( topLevelBda ) ; } } } }", "nl": "Adds additional edges to the accessibility graph that allow static CDI - enabled modules to inject beans from top - level deployment units"}}
{"translation": {"code": "protected synchronized VirtualFile getResteasySpringVirtualFile ( ) throws DeploymentUnitProcessingException { if ( resourceRoot != null ) { return resourceRoot ; } try { Module module = Module . getBootModuleLoader ( ) . loadModule ( MODULE ) ; URL fileUrl = module . getClassLoader ( ) . getResource ( JAR_LOCATION ) ; if ( fileUrl == null ) { throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } File dir = new File ( fileUrl . toURI ( ) ) ; File file = null ; for ( String jar : dir . list ( ) ) { if ( jar . endsWith ( \".jar\" ) ) { file = new File ( dir , jar ) ; break ; } } if ( file == null ) { throw JaxrsLogger . JAXRS_LOGGER . noSpringIntegrationJar ( ) ; } VirtualFile vf = VFS . getChild ( file . toURI ( ) ) ; final Closeable mountHandle = VFS . mountZip ( file , vf , TempFileProviderService . provider ( ) ) ; Service < Closeable > mountHandleService = new Service < Closeable > ( ) { public void start ( StartContext startContext ) throws StartException { } public void stop ( StopContext stopContext ) { VFSUtils . safeClose ( mountHandle ) ; } public Closeable getValue ( ) throws IllegalStateException , IllegalArgumentException { return mountHandle ; } } ; ServiceBuilder < Closeable > builder = serviceTarget . addService ( ServiceName . JBOSS . append ( SERVICE_NAME ) , mountHandleService ) ; builder . setInitialMode ( ServiceController . Mode . ACTIVE ) . install ( ) ; resourceRoot = vf ; return resourceRoot ; } catch ( Exception e ) { throw new DeploymentUnitProcessingException ( e ) ; } }", "nl": "Lookup Seam integration resource loader ."}}
{"translation": {"code": "public List < Resource > list ( String path ) { try { final List < Resource > ret = new ArrayList <> ( ) ; Resource res = deploymentResourceManager . getResource ( path ) ; if ( res != null ) { for ( Resource child : res . list ( ) ) { ret . add ( new ServletResource ( this , child ) ) ; } } String p = path ; if ( p . startsWith ( \"/\" ) ) { p = p . substring ( 1 ) ; } if ( overlays != null ) { for ( VirtualFile overlay : overlays ) { VirtualFile child = overlay . getChild ( p ) ; if ( child . exists ( ) ) { VirtualFileResource vfsResource = new VirtualFileResource ( overlay . getPhysicalFile ( ) , child , path ) ; for ( Resource c : vfsResource . list ( ) ) { ret . add ( new ServletResource ( this , c ) ) ; } } } } return ret ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; //this method really should have thrown IOException } }", "nl": "Lists all children of a particular path taking overlays into account"}}
{"translation": {"code": "public static void popIdentity ( final ContextStateCache stateCache ) { RemotingContext . setConnection ( stateCache . getConnection ( ) ) ; SecurityContextAssociation . setSecurityContext ( stateCache . getSecurityContext ( ) ) ; }", "nl": "Pop the identity previously associated and restore internal state to it s previous value ."}}
{"translation": {"code": "protected String requestURI ( HttpServerExchange request ) { String uri = request . getRelativePath ( ) ; if ( uri == null || uri . equals ( \"/\" ) ) { uri = \"\" ; } return uri ; }", "nl": "Get the canonical request URI from the request mapping data requestPath"}}
{"translation": {"code": "public static EJBEndpoint getWebserviceMetadataEJBEndpoint ( final JAXWSDeployment jaxwsDeployment , final String className ) { java . util . List < EJBEndpoint > ejbEndpointList = jaxwsDeployment . getEjbEndpoints ( ) ; for ( EJBEndpoint ejbEndpoint : ejbEndpointList ) { if ( className . equals ( ejbEndpoint . getClassName ( ) ) ) { return ejbEndpoint ; } } return null ; }", "nl": "Returns an EJBEndpoint based upon fully qualified classname ."}}
{"translation": {"code": "public static JBossPortComponentMetaData getJBossWebserviceMetaDataPortComponent ( final DeploymentUnit unit , final String name ) { if ( name != null ) { final JBossWebservicesMetaData jbossWebserviceMetaData = unit . getAttachment ( JBOSS_WEBSERVICES_METADATA_KEY ) ; if ( jbossWebserviceMetaData != null ) { JBossPortComponentMetaData [ ] portComponent = jbossWebserviceMetaData . getPortComponents ( ) ; if ( portComponent != null ) { for ( JBossPortComponentMetaData component : portComponent ) { if ( name . equals ( component . getEjbName ( ) ) ) { return component ; } } } } } return null ; }", "nl": "Return a named port - component from the jboss - webservices . xml"}}
{"translation": {"code": "public static ModelNode createCompositeOperation ( List < ModelNode > operations ) { ModelNode operation = Util . createOperation ( ModelDescriptionConstants . COMPOSITE , PathAddress . EMPTY_ADDRESS ) ; ModelNode steps = operation . get ( ModelDescriptionConstants . STEPS ) ; for ( ModelNode step : operations ) { steps . add ( step ) ; } return operation ; }", "nl": "Creates a composite operation using the specified operation steps ."}}
{"translation": {"code": "public static ModelNode createReadAttributeOperation ( PathAddress address , Attribute attribute ) { return createAttributeOperation ( ModelDescriptionConstants . READ_ATTRIBUTE_OPERATION , address , attribute ) ; }", "nl": "Creates a read - attribute operation using the specified address and name ."}}
{"translation": {"code": "public static ModelNode createWriteAttributeOperation ( PathAddress address , Attribute attribute , ModelNode value ) { ModelNode operation = createAttributeOperation ( ModelDescriptionConstants . WRITE_ATTRIBUTE_OPERATION , address , attribute ) ; operation . get ( ModelDescriptionConstants . VALUE ) . set ( value ) ; return operation ; }", "nl": "Creates a write - attribute operation using the specified address name and value ."}}
{"translation": {"code": "private void extractDialects ( ) { for ( Object prop : sql . keySet ( ) ) { int dot = ( ( String ) prop ) . indexOf ( ' ' ) ; if ( dot > 0 ) { databaseDialects . add ( ( ( String ) prop ) . substring ( dot + 1 ) ) ; } } }", "nl": "Read the properties from the timer - sql and extract the database dialects ."}}
{"translation": {"code": "private void investigateDialect ( ) { Connection connection = null ; if ( database == null ) { // no database dialect from configuration guessing from MetaData try { connection = dataSource . getConnection ( ) ; DatabaseMetaData metaData = connection . getMetaData ( ) ; String dbProduct = metaData . getDatabaseProductName ( ) ; database = identifyDialect ( dbProduct ) ; if ( database == null ) { EjbLogger . EJB3_TIMER_LOGGER . debug ( \"Attempting to guess on driver name.\" ) ; database = identifyDialect ( metaData . getDriverName ( ) ) ; } } catch ( Exception e ) { EjbLogger . EJB3_TIMER_LOGGER . debug ( \"Unable to read JDBC metadata.\" , e ) ; } finally { safeClose ( connection ) ; } if ( database == null ) { EjbLogger . EJB3_TIMER_LOGGER . jdbcDatabaseDialectDetectionFailed ( databaseDialects . toString ( ) ) ; } else { EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Detect database dialect as '%s'.  If this is incorrect, please specify the correct dialect using the 'database' attribute in your configuration.  Supported database dialect strings are %s\" , database , databaseDialects ) ; } } else { EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Database dialect '%s' read from configuration, adjusting it to match the final database valid value.\" , database ) ; database = identifyDialect ( database ) ; EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"New Database dialect is '%s'.\" , database ) ; } }", "nl": "Check the connection MetaData and driver name to guess which database dialect to use ."}}
{"translation": {"code": "private String identifyDialect ( String name ) { String unified = null ; if ( name != null ) { if ( name . toLowerCase ( ) . contains ( \"postgres\" ) ) { unified = \"postgresql\" ; } else if ( name . toLowerCase ( ) . contains ( \"mysql\" ) ) { unified = \"mysql\" ; } else if ( name . toLowerCase ( ) . contains ( \"mariadb\" ) ) { unified = \"mariadb\" ; } else if ( name . toLowerCase ( ) . contains ( \"db2\" ) ) { unified = \"db2\" ; } else if ( name . toLowerCase ( ) . contains ( \"hsql\" ) || name . toLowerCase ( ) . contains ( \"hypersonic\" ) ) { unified = \"hsql\" ; } else if ( name . toLowerCase ( ) . contains ( \"h2\" ) ) { unified = \"h2\" ; } else if ( name . toLowerCase ( ) . contains ( \"oracle\" ) ) { unified = \"oracle\" ; } else if ( name . toLowerCase ( ) . contains ( \"microsoft\" ) ) { unified = \"mssql\" ; } else if ( name . toLowerCase ( ) . contains ( \"jconnect\" ) ) { unified = \"sybase\" ; } } EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Check dialect for '%s', result is '%s'\" , name , unified ) ; return unified ; }", "nl": "Use the given name and check for different database types to have a unified identifier for the dialect"}}
{"translation": {"code": "private static void buildTransformers2_1_0 ( ResourceTransformationDescriptionBuilder builder ) { ResourceTransformationDescriptionBuilder hornetqServer = builder . addChildResource ( pathElement ( HORNETQ_SERVER ) ) ; ResourceTransformationDescriptionBuilder addressSetting = hornetqServer . addChildResource ( AddressSettingDefinition . PATH ) ; rejectDefinedAttributeWithDefaultValue ( addressSetting , MAX_REDELIVERY_DELAY , REDELIVERY_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder bridge = hornetqServer . addChildResource ( BridgeDefinition . PATH ) ; bridge . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer . addChildResource ( ClusterConnectionDefinition . PATH ) ; clusterConnection . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder connectionFactory = hornetqServer . addChildResource ( ConnectionFactoryDefinition . PATH ) ; connectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer . addChildResource ( PooledConnectionFactoryDefinition . PATH ) ; pooledConnectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; }", "nl": "Transformation for WildFly 8 . 1 . 0 . Final"}}
{"translation": {"code": "public static < E extends Enum < E > > E asEnum ( ModelNode value , Class < E > targetClass ) { return Enum . valueOf ( targetClass , value . asString ( ) ) ; }", "nl": "Returns the value of the node as an Enum value ."}}
{"translation": {"code": "public SessionID createSessionRemote ( ) { ControlPoint controlPoint = getControlPoint ( ) ; if ( controlPoint == null ) { return createSession ( ) ; } else { try { RunResult result = controlPoint . beginRequest ( ) ; if ( result == RunResult . REJECTED ) { throw EjbLogger . ROOT_LOGGER . containerSuspended ( ) ; } try { return createSession ( ) ; } finally { controlPoint . requestComplete ( ) ; } } catch ( EJBComponentUnavailableException | ComponentIsStoppedException e ) { throw e ; } catch ( Exception e ) { throw new EJBException ( e ) ; } } }", "nl": "creates a session using the global request controller ."}}
{"translation": {"code": "static Method getMethod ( final Class < ? > c , final String name , final Class < ? > ... params ) throws NoSuchMethodException { if ( System . getSecurityManager ( ) == null ) return c . getMethod ( name , params ) ; Method result = AccessController . doPrivileged ( new PrivilegedAction < Method > ( ) { public Method run ( ) { try { return c . getMethod ( name , params ) ; } catch ( NoSuchMethodException e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new NoSuchMethodException ( ) ; }", "nl": "Get the method"}}
{"translation": {"code": "static Constructor < ? > getConstructor ( final Class < ? > c , final Class < ? > ... params ) throws NoSuchMethodException { if ( System . getSecurityManager ( ) == null ) return c . getConstructor ( params ) ; Constructor < ? > result = AccessController . doPrivileged ( new PrivilegedAction < Constructor < ? > > ( ) { public Constructor < ? > run ( ) { try { return c . getConstructor ( params ) ; } catch ( NoSuchMethodException e ) { return null ; } } } ) ; if ( result != null ) return result ; throw new NoSuchMethodException ( ) ; }", "nl": "Get the constructor"}}
{"translation": {"code": "static Field [ ] getDeclaredFields ( final Class < ? > c ) { if ( System . getSecurityManager ( ) == null ) return c . getDeclaredFields ( ) ; return AccessController . doPrivileged ( new PrivilegedAction < Field [ ] > ( ) { public Field [ ] run ( ) { return c . getDeclaredFields ( ) ; } } ) ; }", "nl": "Get the declared fields"}}
{"translation": {"code": "static Method [ ] getDeclaredMethods ( final Class < ? > c ) { if ( System . getSecurityManager ( ) == null ) return c . getDeclaredMethods ( ) ; return AccessController . doPrivileged ( new PrivilegedAction < Method [ ] > ( ) { public Method [ ] run ( ) { return c . getDeclaredMethods ( ) ; } } ) ; }", "nl": "Get the declared methods"}}