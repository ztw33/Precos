{"translation": {"code": "public static PathAddress getPathAddress ( ModelNode operation ) { return PathAddress . pathAddress ( operation . require ( ModelDescriptionConstants . OP_ADDR ) ) ; }", "nl": "Returns the address of the specified operation"}}
{"translation": {"code": "private String resolveAttribute ( SimpleAttributeDefinition attr , OperationContext context , ModelNode model ) throws OperationFailedException { final ModelNode node = attr . resolveModelAttribute ( context , model ) ; return node . isDefined ( ) ? node . asString ( ) : null ; }", "nl": "Return null if the resolved attribute is not defined"}}
{"translation": {"code": "protected final T getActiveMQComponentControl ( final OperationContext context , final ModelNode operation , final boolean forWrite ) throws OperationFailedException { final ServiceName artemisServiceName = MessagingServices . getActiveMQServiceName ( PathAddress . pathAddress ( operation . get ( ModelDescriptionConstants . OP_ADDR ) ) ) ; ServiceController < ? > artemisService = context . getServiceRegistry ( forWrite ) . getService ( artemisServiceName ) ; ActiveMQServer server = ActiveMQServer . class . cast ( artemisService . getValue ( ) ) ; PathAddress address = PathAddress . pathAddress ( operation . require ( OP_ADDR ) ) ; T control = getActiveMQComponentControl ( server , address ) ; if ( control == null ) { throw ControllerLogger . ROOT_LOGGER . managementResourceNotFound ( address ) ; } return control ; }", "nl": "Gets the runtime ActiveMQ control object that can help service this request ."}}
{"translation": {"code": "static String getActiveMQServerName ( Map < String , String > properties ) { return properties . getOrDefault ( SERVER , DEFAULT ) ; }", "nl": "The JMS connection factory can specify another server to deploy its destinations by passing a property server = &lt ; name of the server > . Otherwise default is used by default ."}}
{"translation": {"code": "static AbstractAddStepHandler createAddOperation ( final String childType , final boolean allowSibling , Collection < ? extends AttributeDefinition > attributes ) { return new ActiveMQReloadRequiredHandlers . AddStepHandler ( attributes ) { @ Override public void execute ( OperationContext context , ModelNode operation ) throws OperationFailedException { super . execute ( context , operation ) ; if ( ! allowSibling ) { context . addStep ( checkNoOtherSibling ( childType ) , MODEL ) ; } } } ; }", "nl": "Create an ADD operation that can check that there is no other sibling when the resource is added ."}}
{"translation": {"code": "static ModelNode convertSecurityRole ( final ModelNode camelCase ) { final ModelNode result = new ModelNode ( ) ; result . setEmptyList ( ) ; if ( camelCase . isDefined ( ) ) { for ( ModelNode role : camelCase . asList ( ) ) { final ModelNode roleNode = result . add ( ) ; for ( Property prop : role . asPropertyList ( ) ) { String key = prop . getName ( ) ; if ( \"createDurableQueue\" . equals ( key ) ) { key = SecurityRoleDefinition . CREATE_DURABLE_QUEUE . getName ( ) ; } else if ( \"deleteDurableQueue\" . equals ( key ) ) { key = SecurityRoleDefinition . DELETE_DURABLE_QUEUE . getName ( ) ; } else if ( \"createNonDurableQueue\" . equals ( key ) ) { key = SecurityRoleDefinition . CREATE_NON_DURABLE_QUEUE . getName ( ) ; } else if ( \"deleteNonDurableQueue\" . equals ( key ) ) { key = SecurityRoleDefinition . DELETE_NON_DURABLE_QUEUE . getName ( ) ; } roleNode . get ( key ) . set ( prop . getValue ( ) ) ; } } } return result ; }", "nl": "Utility for converting camel case based ActiveMQ formats to WildFly standards ."}}
{"translation": {"code": "private void setNodeName ( final TimerState timerState , PreparedStatement statement , int paramIndex ) throws SQLException { if ( timerState == TimerState . IN_TIMEOUT || timerState == TimerState . RETRY_TIMEOUT ) { statement . setString ( paramIndex , nodeName ) ; } else { statement . setNull ( paramIndex , Types . VARCHAR ) ; } }", "nl": "Set the node name for persistence if the state is IN_TIMEOUT or RETRY_TIMEOUT to show which node is current active for the timer ."}}
{"translation": {"code": "public void registerInterposedSynchronization ( Synchronization synchronization ) throws IllegalStateException , SystemException { int status = ContextTransactionSynchronizationRegistry . getInstance ( ) . getTransactionStatus ( ) ; switch ( status ) { case javax . transaction . Status . STATUS_ACTIVE : case javax . transaction . Status . STATUS_PREPARING : break ; case Status . STATUS_MARKED_ROLLBACK : // do nothing; we can pretend like it was registered, but it'll never be run anyway. return ; default : throw TransactionLogger . ROOT_LOGGER . syncsnotallowed ( status ) ; } if ( synchronization . getClass ( ) . getName ( ) . startsWith ( \"org.jboss.jca\" ) ) { if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.jcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; } jcaSyncs . add ( synchronization ) ; } else { if ( TransactionLogger . ROOT_LOGGER . isTraceEnabled ( ) ) { TransactionLogger . ROOT_LOGGER . trace ( \"JCAOrderedLastSynchronizationList.preJcaSyncs.add - Class: \" + synchronization . getClass ( ) + \" HashCode: \" + synchronization . hashCode ( ) + \" toString: \" + synchronization ) ; } preJcaSyncs . add ( synchronization ) ; } }", "nl": "This is only allowed at various points of the transaction lifecycle ."}}
{"translation": {"code": "public void registerEndpointConfig ( final String endpointClass , final EndpointConfig config ) { if ( ( endpointClass == null ) || ( config == null ) ) { throw new IllegalArgumentException ( ) ; } endpointConfigMap . put ( endpointClass , config ) ; }", "nl": "Registers endpoint and its config ."}}
{"translation": {"code": "public String getName ( ) { final String s = log . getName ( ) ; final int i = s . lastIndexOf ( \".\" ) ; return i != - 1 ? s . substring ( i + 1 , s . length ( ) ) : s ; }", "nl": "Use the short class name as the default for the service name ."}}
{"translation": {"code": "private void sendStateChangeNotification ( int oldState , int newState , String msg , Throwable t ) { long now = System . currentTimeMillis ( ) ; AttributeChangeNotification stateChangeNotification = new AttributeChangeNotification ( this , getNextNotificationSequenceNumber ( ) , now , msg , \"State\" , \"java.lang.Integer\" , new Integer ( oldState ) , new Integer ( newState ) ) ; stateChangeNotification . setUserData ( t ) ; sendNotification ( stateChangeNotification ) ; }", "nl": "Helper for sending out state change notifications"}}
{"translation": {"code": "public void shutdown ( ) { int value ; int oldValue ; //set the shutdown bit do { oldValue = invocationCount ; value = SHUTDOWN_FLAG | oldValue ; //the component has already been shutdown if ( oldValue == value ) { return ; } } while ( ! updater . compareAndSet ( this , oldValue , value ) ) ; synchronized ( lock ) { value = invocationCount ; while ( value != SHUTDOWN_FLAG ) { try { lock . wait ( ) ; } catch ( InterruptedException e ) { throw new RuntimeException ( e ) ; } value = invocationCount ; if ( ( value & SHUTDOWN_FLAG ) == 0 ) { return ; //component has been restarted } } } }", "nl": "Upon calling this method the EJB will be set to a shutdown state and no further invocations will be allowed . It will then wait for all active invocation to finish and then return ."}}
{"translation": {"code": "public static ModelNode createUndefineAttributeOperation ( PathAddress address , Attribute attribute ) { return createAttributeOperation ( ModelDescriptionConstants . UNDEFINE_ATTRIBUTE_OPERATION , address , attribute ) ; }", "nl": "Creates an undefine - attribute operation using the specified address and name ."}}
{"translation": {"code": "public static ModelNode createAddOperation ( PathAddress address , Map < Attribute , ModelNode > parameters ) { ModelNode operation = Util . createAddOperation ( address ) ; for ( Map . Entry < Attribute , ModelNode > entry : parameters . entrySet ( ) ) { operation . get ( entry . getKey ( ) . getName ( ) ) . set ( entry . getValue ( ) ) ; } return operation ; }", "nl": "Creates an add operation using the specified address and parameters"}}
{"translation": {"code": "private static void subst ( final StringBuilder stringBuilder , final String from , final String to ) { int begin = 0 , end = 0 ; while ( ( end = stringBuilder . indexOf ( from , end ) ) != - 1 ) { stringBuilder . delete ( end , end + from . length ( ) ) ; stringBuilder . insert ( end , to ) ; // update positions begin = end + to . length ( ) ; end = begin ; } }", "nl": "Substitute sub - strings inside of a string ."}}
{"translation": {"code": "public static void addCacheDependencies ( Classification cacheType , Properties properties ) { for ( EventListener eventListener : eventListeners ) { eventListener . addCacheDependencies ( cacheType , properties ) ; } }", "nl": "add cache dependencies"}}
{"translation": {"code": "private void addMessagingActiveMQExtension ( OperationContext context , Map < PathAddress , ModelNode > migrationOperations , boolean describe ) { Resource root = context . readResourceFromRoot ( PathAddress . EMPTY_ADDRESS , false ) ; if ( root . getChildrenNames ( EXTENSION ) . contains ( MESSAGING_ACTIVEMQ_EXTENSION ) ) { // extension is already added, do nothing return ; } PathAddress extensionAddress = pathAddress ( EXTENSION , MESSAGING_ACTIVEMQ_EXTENSION ) ; OperationEntry addEntry = context . getRootResourceRegistration ( ) . getOperationEntry ( extensionAddress , ADD ) ; ModelNode addOperation = createAddOperation ( extensionAddress ) ; addOperation . get ( MODULE ) . set ( MESSAGING_ACTIVEMQ_MODULE ) ; if ( describe ) { migrationOperations . put ( extensionAddress , addOperation ) ; } else { context . addStep ( context . getResult ( ) . get ( extensionAddress . toString ( ) ) , addOperation , addEntry . getOperationHandler ( ) , MODEL ) ; } }", "nl": "It s possible that the extension is already present . In that case this method does nothing ."}}
{"translation": {"code": "public static ServiceName jobOperatorServiceName ( final String deploymentRuntimeName , final String subdeploymentName ) { return Services . deploymentUnitName ( deploymentRuntimeName , subdeploymentName ) . append ( \"batch\" ) . append ( \"job-operator\" ) ; }", "nl": "Creates the service name used for the job operator registered for the deployment ."}}
{"translation": {"code": "public static ModelNode createAddOperation ( PathAddress address , int index ) { return createAddOperation ( address , index , Collections . emptyMap ( ) ) ; }", "nl": "Creates an indexed add operation using the specified address and index"}}
{"translation": {"code": "private void init ( final ClassLoader classLoader ) { // Load the user defined resolvers for ( JobXmlResolver resolver : ServiceLoader . load ( JobXmlResolver . class , classLoader ) ) { jobXmlResolvers . add ( resolver ) ; for ( String jobXml : resolver . getJobXmlNames ( classLoader ) ) { addJob ( jobXml , resolver . resolveJobName ( jobXml , classLoader ) ) ; } } // Load the default names for ( Map . Entry < String , VirtualFile > entry : jobXmlFiles . entrySet ( ) ) { try { // Parsing the entire job XML seems excessive to just get the job name. There are two reasons for this: //  1) If an error occurs during parsing there's no real need to consider this a valid job //  2) Using the implementation parser seems less error prone for future-proofing final Job job = JobParser . parseJob ( entry . getValue ( ) . openStream ( ) , classLoader , new XMLResolver ( ) { // this is essentially what JBeret does, but it's ugly. JBeret might need an API to handle this @ Override public Object resolveEntity ( final String publicID , final String systemID , final String baseURI , final String namespace ) throws XMLStreamException { try { return ( jobXmlFiles . containsKey ( systemID ) ? jobXmlFiles . get ( systemID ) . openStream ( ) : null ) ; } catch ( IOException e ) { throw new XMLStreamException ( e ) ; } } } ) ; addJob ( entry . getKey ( ) , job . getId ( ) ) ; } catch ( XMLStreamException | IOException e ) { // Report the possible error as we don't want to fail the deployment. The job may never be run. BatchLogger . LOGGER . invalidJobXmlFile ( entry . getKey ( ) ) ; } } }", "nl": "Initializes the state of an instance"}}
{"translation": {"code": "private void migrateGenericTransport ( ModelNode addOperation ) { String factoryClass = addOperation . get ( FACTORY_CLASS . getName ( ) ) . asString ( ) ; final String newFactoryClass ; switch ( factoryClass ) { case HORNETQ_NETTY_ACCEPTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_ACCEPTOR_FACTORY ; break ; case HORNETQ_NETTY_CONNECTOR_FACTORY : newFactoryClass = ARTEMIS_NETTY_CONNECTOR_FACTORY ; break ; default : newFactoryClass = factoryClass ; } addOperation . get ( FACTORY_CLASS . getName ( ) ) . set ( newFactoryClass ) ; }", "nl": "For generic acceptor and connectors migrate their factory - class attribute if they are using the default Netty ones ."}}
{"translation": {"code": "private String parseConnectionAttributes_5_0 ( final XMLExtendedStreamReader reader , final ModelNode connectionDefinitionNode ) throws XMLStreamException { String poolName = null ; String jndiName = null ; int attributeSize = reader . getAttributeCount ( ) ; for ( int i = 0 ; i < attributeSize ; i ++ ) { ConnectionDefinition . Attribute attribute = ConnectionDefinition . Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; String value = reader . getAttributeValue ( i ) ; switch ( attribute ) { case ENABLED : { ENABLED . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case CONNECTABLE : { CONNECTABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case TRACKING : { TRACKING . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case JNDI_NAME : { jndiName = value ; JNDINAME . parseAndSetParameter ( jndiName , connectionDefinitionNode , reader ) ; break ; } case POOL_NAME : { poolName = value ; break ; } case USE_JAVA_CONTEXT : { USE_JAVA_CONTEXT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case USE_CCM : { USE_CCM . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case SHARABLE : { SHARABLE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case ENLISTMENT : { ENLISTMENT . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case CLASS_NAME : { CLASS_NAME . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case MCP : { MCP . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; } case ENLISTMENT_TRACE : ENLISTMENT_TRACE . parseAndSetParameter ( value , connectionDefinitionNode , reader ) ; break ; default : throw ParseUtils . unexpectedAttribute ( reader , i ) ; } } if ( poolName == null || poolName . trim ( ) . equals ( \"\" ) ) { if ( jndiName != null && jndiName . trim ( ) . length ( ) != 0 ) { if ( jndiName . contains ( \"/\" ) ) { poolName = jndiName . substring ( jndiName . lastIndexOf ( \"/\" ) + 1 ) ; } else { poolName = jndiName . substring ( jndiName . lastIndexOf ( \":\" ) + 1 ) ; } } else { throw ParseUtils . missingRequired ( reader , EnumSet . of ( ConnectionDefinition . Attribute . JNDI_NAME ) ) ; } } return poolName ; }", "nl": "Parses connection attributes for version 5 . 0"}}
{"translation": {"code": "private static boolean isTypeMatched ( Class < ? > clz ) { if ( clz . equals ( String . class ) ) { return true ; } else if ( clz . equals ( byte . class ) || clz . equals ( Byte . class ) ) { return true ; } else if ( clz . equals ( short . class ) || clz . equals ( Short . class ) ) { return true ; } else if ( clz . equals ( int . class ) || clz . equals ( Integer . class ) ) { return true ; } else if ( clz . equals ( long . class ) || clz . equals ( Long . class ) ) { return true ; } else if ( clz . equals ( float . class ) || clz . equals ( Float . class ) ) { return true ; } else if ( clz . equals ( double . class ) || clz . equals ( Double . class ) ) { return true ; } else if ( clz . equals ( boolean . class ) || clz . equals ( Boolean . class ) ) { return true ; } else if ( clz . equals ( char . class ) || clz . equals ( Character . class ) ) { return true ; } else if ( clz . equals ( InetAddress . class ) ) { return true ; } else if ( clz . equals ( Class . class ) ) { return true ; } else if ( clz . equals ( Properties . class ) ) { return true ; } return false ; }", "nl": "Check whether the types that JCA Injection knows ."}}
{"translation": {"code": "private boolean parameterIsAllowed ( String name , String resourceType ) { switch ( resourceType ) { case REMOTE_ACCEPTOR : case HTTP_ACCEPTOR : case REMOTE_CONNECTOR : case HTTP_CONNECTOR : // WFLY-5667 - for now remove only use-nio. Revisit this code when Artemis offers an API // to know which parameters are ignored. if ( \"use-nio\" . equals ( name ) ) { return false ; } else { return true ; } default : // accept any parameter for other resources. return true ; } }", "nl": "Check if the name of the parameter is allowed for the given resourceType ."}}
{"translation": {"code": "static boolean targetsPooledConnectionFactory ( String server , String resourceAdapter , ServiceRegistry serviceRegistry ) { // if the resourceAdapter is not defined, the default behaviour is to create a pooled-connection-factory. if ( resourceAdapter == null || resourceAdapter . isEmpty ( ) ) { return true ; } ServiceName activeMQServiceName = MessagingServices . getActiveMQServiceName ( server ) ; ServiceName pcfName = JMSServices . getPooledConnectionFactoryBaseServiceName ( activeMQServiceName ) . append ( resourceAdapter ) ; return serviceRegistry . getServiceNames ( ) . contains ( pcfName ) ; }", "nl": "Return whether the definition targets an existing pooled connection factory or use a JCA - based ConnectionFactory ."}}
{"translation": {"code": "public String getActions ( ) { final String actionString = this . actionString ; if ( actionString != null ) { return actionString ; } int actionBits = this . actionBits ; if ( actionBits == ACTION_ALL ) { return this . actionString = \"*\" ; } int m = Integer . lowestOneBit ( actionBits ) ; if ( m != 0 ) { StringBuilder b = new StringBuilder ( ) ; b . append ( getAction ( m ) ) ; actionBits &= ~ m ; while ( actionBits != 0 ) { m = Integer . lowestOneBit ( actionBits ) ; b . append ( ' ' ) . append ( getAction ( m ) ) ; actionBits &= ~ m ; } return this . actionString = b . toString ( ) ; } else { return this . actionString = \"\" ; } }", "nl": "Get the actions string . The actions string will be a canonical version of the one passed in at construction ."}}
{"translation": {"code": "public boolean implies ( final JndiPermission permission ) { return permission != null && ( ( actionBits & permission . actionBits ) == permission . actionBits ) && impliesPath ( permission . getName ( ) ) ; }", "nl": "Determine if this permission implies the other permission ."}}
{"translation": {"code": "private ConnectionFactory getConnectionFactory ( ) { ConnectionFactory cachedCF = connectionFactory ; if ( cachedCF == null ) { cachedCF = ( ConnectionFactory ) lookup ( info . getConnectionFactoryLookup ( ) ) ; connectionFactory = cachedCF ; } return cachedCF ; }", "nl": "lookup the connectionFactory and cache it ."}}
{"translation": {"code": "private boolean isInTransaction ( ) { TransactionSynchronizationRegistry tsr = getTransactionSynchronizationRegistry ( ) ; boolean inTx = tsr . getTransactionStatus ( ) == Status . STATUS_ACTIVE ; return inTx ; }", "nl": "check whether there is an active transaction ."}}
{"translation": {"code": "public static < T extends AutoCloseable > Consumer < T > close ( ) { return value -> { try { value . close ( ) ; } catch ( Throwable e ) { ClusteringLogger . ROOT_LOGGER . failedToClose ( e , value ) ; } } ; }", "nl": "Returns a consumer that closes its input ."}}
{"translation": {"code": "public void invoke ( final Endpoint endpoint , final Invocation wsInvocation ) throws Exception { try { if ( ! EndpointState . STARTED . equals ( endpoint . getState ( ) ) ) { throw WSLogger . ROOT_LOGGER . endpointAlreadyStopped ( endpoint . getShortName ( ) ) ; } SecurityDomainContext securityDomainContext = endpoint . getSecurityDomainContext ( ) ; securityDomainContext . runAs ( ( Callable < Void > ) ( ) -> { invokeInternal ( endpoint , wsInvocation ) ; return null ; } ) ; } catch ( Throwable t ) { handleInvocationException ( t ) ; } finally { onAfterInvocation ( wsInvocation ) ; } }", "nl": "Invokes WS endpoint ."}}
{"translation": {"code": "public boolean cancel ( boolean setFlag ) { final AtomicInteger stateRef = this . stateRef ; int oldVal , newVal ; do { oldVal = stateRef . get ( ) ; if ( oldVal == ST_WAITING ) { newVal = ST_CANCELLED ; } else if ( oldVal == ST_CANCELLED ) { if ( ! setFlag ) { return true ; } newVal = ST_CANCELLED_FLAG_SET ; } else if ( oldVal == ST_CANCELLED_FLAG_SET ) { // do nothing return true ; } else if ( oldVal == ST_STARTED ) { if ( ! setFlag ) { return false ; } newVal = ST_STARTED_FLAG_SET ; } else { assert oldVal == ST_STARTED_FLAG_SET ; return false ; } } while ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; return newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; }", "nl": "Attempt to cancel the corresponding invocation ."}}
{"translation": {"code": "public boolean runIfNotCancelled ( ) { final AtomicInteger stateRef = this . stateRef ; int oldVal ; do { oldVal = stateRef . get ( ) ; if ( oldVal == ST_CANCELLED || oldVal == ST_CANCELLED_FLAG_SET ) { return false ; } else if ( oldVal != ST_WAITING ) { throw Assert . unreachableCode ( ) ; } } while ( ! stateRef . compareAndSet ( oldVal , ST_STARTED ) ) ; return true ; }", "nl": "Attempt to determine whether the invocation should proceed or whether it should be cancelled . This method should only be called once per flag instance ."}}
{"translation": {"code": "@ SuppressWarnings ( \"deprecation\" ) static void addTransformations ( ModelVersion version , ResourceTransformationDescriptionBuilder builder ) { if ( JGroupsModel . VERSION_5_0_0 . requiresTransformation ( version ) ) { builder . getAttributeBuilder ( ) . setDiscard ( DiscardAttributeChecker . UNDEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . STATISTICS_ENABLED . getDefinition ( ) ) . end ( ) ; } if ( JGroupsModel . VERSION_3_0_0 . requiresTransformation ( version ) ) { AttributeConverter typeConverter = new AttributeConverter . DefaultAttributeConverter ( ) { @ Override protected void convertAttribute ( PathAddress address , String name , ModelNode value , TransformationContext context ) { if ( ! value . isDefined ( ) ) { value . set ( address . getLastElement ( ) . getValue ( ) ) ; } } } ; builder . getAttributeBuilder ( ) . setDiscard ( new DiscardAttributeChecker . DiscardAttributeValueChecker ( Attribute . MODULE . getDefinition ( ) . getDefaultValue ( ) ) , Attribute . MODULE . getDefinition ( ) ) . addRejectCheck ( RejectAttributeChecker . DEFINED , Attribute . MODULE . getDefinition ( ) ) . setValueConverter ( typeConverter , DeprecatedAttribute . TYPE . getDefinition ( ) ) . end ( ) ; builder . addRawOperationTransformationOverride ( MapOperations . MAP_GET_DEFINITION . getName ( ) , new SimpleOperationTransformer ( new LegacyPropertyMapGetOperationTransformer ( ) ) ) ; for ( String opName : Operations . getAllWriteAttributeOperationNames ( ) ) { builder . addOperationTransformationOverride ( opName ) . inheritResourceAttributeDefinitions ( ) . setCustomOperationTransformer ( new LegacyPropertyWriteOperationTransformer ( ) ) ; } } PropertyResourceDefinition . buildTransformation ( version , builder ) ; }", "nl": "Builds transformations common to both stack protocols and transport ."}}
{"translation": {"code": "@ Override public void resume ( ) { this . suspended = false ; localTransactionContextInjectedValue . getValue ( ) . resumeRequests ( ) ; ServerActivityCallback listener = listenerUpdater . get ( this ) ; if ( listener != null ) { listenerUpdater . compareAndSet ( this , listener , null ) ; } deploymentRepositoryInjectedValue . getValue ( ) . resume ( ) ; }", "nl": "Notifies local transaction context that server is resumed and restarts deployment controller ."}}
{"translation": {"code": "@ Override public void suspended ( ServerActivityCallback listener ) { this . suspended = true ; listenerUpdater . set ( this , listener ) ; localTransactionContextInjectedValue . getValue ( ) . suspendRequests ( ) ; final int activeInvocationCount = activeInvocationCountUpdater . get ( this ) ; if ( activeInvocationCount == 0 ) { if ( gracefulTxnShutdown ) { if ( activeTransactionCountUpdater . get ( this ) == 0 ) { this . doneSuspended ( ) ; } else { EjbLogger . ROOT_LOGGER . suspensionWaitingActiveTransactions ( activeInvocationCount ) ; } } else { this . doneSuspended ( ) ; } } }", "nl": "Notifies local transaction context that server is suspended and only completes suspension if there are no active invocations nor transactions ."}}
{"translation": {"code": "public void invocationComplete ( ) { int activeInvocations = activeInvocationCountUpdater . decrementAndGet ( this ) ; if ( suspended && activeInvocations == 0 && ( ! gracefulTxnShutdown || ( activeTransactionCountUpdater . get ( this ) == 0 ) ) ) { doneSuspended ( ) ; } }", "nl": "Notifies handler that an active invocation is complete ."}}
{"translation": {"code": "private static String deriveUsefulInfo ( HttpServletRequest httpRequest ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"[\" ) . append ( httpRequest . getContextPath ( ) ) ; sb . append ( \":cookies=\" ) . append ( Arrays . toString ( httpRequest . getCookies ( ) ) ) . append ( \":headers=\" ) ; // Append Header information Enumeration < ? > en = httpRequest . getHeaderNames ( ) ; while ( en . hasMoreElements ( ) ) { String headerName = ( String ) en . nextElement ( ) ; sb . append ( headerName ) . append ( \"=\" ) ; // Ensure HTTP Basic Password is not logged if ( ! headerName . contains ( \"authorization\" ) ) { sb . append ( httpRequest . getHeader ( headerName ) ) . append ( \",\" ) ; } } sb . append ( \"]\" ) ; // Append Request parameter information sb . append ( \"[parameters=\" ) ; Enumeration < ? > enparam = httpRequest . getParameterNames ( ) ; while ( enparam . hasMoreElements ( ) ) { String paramName = ( String ) enparam . nextElement ( ) ; String [ ] paramValues = httpRequest . getParameterValues ( paramName ) ; int len = paramValues != null ? paramValues . length : 0 ; for ( int i = 0 ; i < len ; i ++ ) { sb . append ( paramValues [ i ] ) . append ( \"::\" ) ; } sb . append ( \",\" ) ; } sb . append ( \"][attributes=\" ) ; // Append Request attribute information Enumeration < ? > enu = httpRequest . getAttributeNames ( ) ; while ( enu . hasMoreElements ( ) ) { String attrName = ( String ) enu . nextElement ( ) ; sb . append ( attrName ) . append ( \"=\" ) ; sb . append ( httpRequest . getAttribute ( attrName ) ) . append ( \",\" ) ; } sb . append ( \"]\" ) ; return sb . toString ( ) ; }", "nl": "Obtain debug information from the servlet request object"}}
{"translation": {"code": "private void processAttributes ( final XMLExtendedStreamReader reader , AttributeProcessor < Integer , Attribute > attributeProcessorCallback ) throws XMLStreamException { final int count = reader . getAttributeCount ( ) ; for ( int i = 0 ; i < count ; i ++ ) { ParseUtils . requireNoNamespaceAttribute ( reader , i ) ; // final String value = reader.getAttributeValue(i); final Attribute attribute = Attribute . forName ( reader . getAttributeLocalName ( i ) ) ; attributeProcessorCallback . process ( i , attribute ) ; } }", "nl": "Iterating over all attributes got from the reader parameter ."}}
{"translation": {"code": "public void handleRestorationCalculation ( ) { if ( nextExpiration == null ) { return ; } //next expiration in the future, we don't care if ( nextExpiration . getTime ( ) >= System . currentTimeMillis ( ) ) { return ; } //just set the next expiration to 1ms in the past //this means it will run to catch up the missed expiration //and then the next calculated expiration will be in the future nextExpiration = new Date ( System . currentTimeMillis ( ) - 1 ) ; }", "nl": "Makes sure that the timer is only run once after being restored ."}}
{"translation": {"code": "private static PersistentResourceXMLDescription . PersistentResourceXMLBuilder listenerBuilder ( PersistentResourceDefinition resource ) { return builder ( resource . getPathElement ( ) ) // xsd socket-optionsType . addAttributes ( ListenerResourceDefinition . RECEIVE_BUFFER , ListenerResourceDefinition . SEND_BUFFER , ListenerResourceDefinition . BACKLOG , ListenerResourceDefinition . KEEP_ALIVE , ListenerResourceDefinition . READ_TIMEOUT , ListenerResourceDefinition . WRITE_TIMEOUT , ListenerResourceDefinition . MAX_CONNECTIONS ) // xsd listener-type . addAttributes ( ListenerResourceDefinition . SOCKET_BINDING , ListenerResourceDefinition . WORKER , ListenerResourceDefinition . BUFFER_POOL , ListenerResourceDefinition . ENABLED , ListenerResourceDefinition . RESOLVE_PEER_ADDRESS , ListenerResourceDefinition . MAX_ENTITY_SIZE , ListenerResourceDefinition . BUFFER_PIPELINED_DATA , ListenerResourceDefinition . MAX_HEADER_SIZE , ListenerResourceDefinition . MAX_PARAMETERS , ListenerResourceDefinition . MAX_HEADERS , ListenerResourceDefinition . MAX_COOKIES , ListenerResourceDefinition . ALLOW_ENCODED_SLASH , ListenerResourceDefinition . DECODE_URL , ListenerResourceDefinition . URL_CHARSET , ListenerResourceDefinition . ALWAYS_SET_KEEP_ALIVE , ListenerResourceDefinition . MAX_BUFFERED_REQUEST_SIZE , ListenerResourceDefinition . RECORD_REQUEST_START_TIME , ListenerResourceDefinition . ALLOW_EQUALS_IN_COOKIE_VALUE , ListenerResourceDefinition . NO_REQUEST_TIMEOUT , ListenerResourceDefinition . REQUEST_PARSE_TIMEOUT , ListenerResourceDefinition . DISALLOWED_METHODS , ListenerResourceDefinition . SECURE , ListenerResourceDefinition . RFC6265_COOKIE_VALIDATION , ListenerResourceDefinition . ALLOW_UNESCAPED_CHARACTERS_IN_URL ) ; }", "nl": "Registers attributes common across listener types"}}
{"translation": {"code": "private String inferDestinationName ( String address ) { if ( address . startsWith ( JMS_QUEUE_PREFIX ) ) { return address . substring ( JMS_QUEUE_PREFIX . length ( ) ) ; } else if ( address . startsWith ( JMS_TOPIC_PREFIX ) ) { return address . substring ( JMS_TOPIC_PREFIX . length ( ) ) ; } else { return address ; } }", "nl": "Infer the name of the JMS destination based on the queue s address ."}}
{"translation": {"code": "private void validateDefaultValues ( List < ParamDetail > detailList , HashMap < String , List < Validator > > paramConverterMap ) throws DeploymentUnitProcessingException { for ( ParamDetail detail : detailList ) { // check param converter for specific return type List < Validator > validators = paramConverterMap . get ( detail . parameter . getName ( ) ) ; if ( validators == null ) { // check for paramConverterProvider validators = paramConverterMap . get ( Object . class . getName ( ) ) ; } boolean isCheckClazzMethods = true ; if ( validators != null ) { for ( Validator v : validators ) { if ( ! v . isLazyLoad ( ) ) { try { Object obj = v . verify ( detail ) ; if ( obj != null ) { isCheckClazzMethods = false ; break ; } } catch ( Exception e ) { JAXRS_LOGGER . paramConverterFailed ( detail . defaultValue . value ( ) , detail . parameter . getSimpleName ( ) , detail . method . toString ( ) , v . toString ( ) , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ; } } } } if ( isCheckClazzMethods ) { Class baseType = detail . parameter ; Method valueOf = null ; // constructor rule try { Constructor < ? > ctor = baseType . getConstructor ( String . class ) ; if ( Modifier . isPublic ( ctor . getModifiers ( ) ) ) { continue ; // success move to next detail } } catch ( NoSuchMethodException ignored ) { } // method fromValue(String.class) rule try { Method fromValue = baseType . getDeclaredMethod ( \"fromValue\" , String . class ) ; if ( Modifier . isPublic ( fromValue . getModifiers ( ) ) ) { for ( Annotation ann : baseType . getAnnotations ( ) ) { if ( ann . annotationType ( ) . getName ( ) . equals ( \"javax.xml.bind.annotation.XmlEnum\" ) ) { valueOf = fromValue ; } } validateBaseType ( fromValue , detail . defaultValue . value ( ) , detail ) ; continue ; // success move to next detail } } catch ( NoSuchMethodException ignoredA ) { } // method fromString(String.class) rule Method fromString = null ; try { fromString = baseType . getDeclaredMethod ( \"fromString\" , String . class ) ; if ( Modifier . isStatic ( fromString . getModifiers ( ) ) ) { validateBaseType ( fromString , detail . defaultValue . value ( ) , detail ) ; continue ; // success move to next detail } } catch ( NoSuchMethodException ignoredB ) { } // method valueof(String.class) rule try { valueOf = baseType . getDeclaredMethod ( \"valueOf\" , String . class ) ; if ( Modifier . isStatic ( valueOf . getModifiers ( ) ) ) { validateBaseType ( valueOf , detail . defaultValue . value ( ) , detail ) ; continue ; // success move to next detail } } catch ( NoSuchMethodException ignored ) { } } } }", "nl": "Process all parameter DefaulValue objects . Flag all parameters with missing and invalid converters ."}}
{"translation": {"code": "public static void mark ( DeploymentUnit unit ) { unit . putAttachment ( MARKER , Boolean . TRUE ) ; if ( unit . getParent ( ) != null ) { mark ( unit . getParent ( ) ) ; } }", "nl": "Mark this deployment and the top level deployment as being a weld deployment ."}}