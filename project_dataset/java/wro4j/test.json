{"translation": {"code": "public String rewrite ( final String cssUri , final String imageUrl ) { notNull ( cssUri ) ; notNull ( imageUrl ) ; if ( StringUtils . isEmpty ( imageUrl ) ) { return imageUrl ; } if ( ServletContextUriLocator . isValid ( cssUri ) ) { if ( ServletContextUriLocator . isValid ( imageUrl ) ) { return prependContextPath ( imageUrl ) ; } // Treat WEB-INF special case if ( ServletContextUriLocator . isProtectedResource ( cssUri ) ) { return context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; } // Compute the folder where the final css is located. This is important for computing image location after url // rewriting. // Prefix of the path to the overwritten image url. This will be of the following type: \"../\" or \"../..\" depending // on the depth of the aggregatedFolderPath. final String aggregatedPathPrefix = computeAggregationPathPrefix ( context . aggregatedFolderPath ) ; LOG . debug ( \"computed aggregatedPathPrefix {}\" , aggregatedPathPrefix ) ; String newImageLocation = computeNewImageLocation ( aggregatedPathPrefix + cssUri , imageUrl ) ; if ( newImageLocation . startsWith ( ServletContextUriLocator . PREFIX ) ) { newImageLocation = prependContextPath ( newImageLocation ) ; } LOG . debug ( \"newImageLocation: {}\" , newImageLocation ) ; return newImageLocation ; } if ( ClasspathUriLocator . isValid ( cssUri ) ) { final String proxyUrl = context . proxyPrefix + computeNewImageLocation ( cssUri , imageUrl ) ; final String contextRelativeUrl = prependContextPath ( imageUrl ) ; //final String contextRelativeUrl = context.contextPath + imageUrl; // leave imageUrl unchanged if it is a servlet context relative resource return ( ServletContextUriLocator . isValid ( imageUrl ) ? contextRelativeUrl : proxyUrl ) ; } if ( UrlUriLocator . isValid ( cssUri ) ) { final String computedCssUri = ServletContextUriLocator . isValid ( imageUrl ) ? computeCssUriForExternalServer ( cssUri ) : cssUri ; return computeNewImageLocation ( computedCssUri , imageUrl ) ; } throw new WroRuntimeException ( \"Could not replace imageUrl: \" + imageUrl + \", contained at location: \" + cssUri ) ; }", "nl": "Computes the url of the image to be replaced in a css resource ."}}
{"translation": {"code": "private String computeNewImageLocation ( final String cssUri , final String imageUrl ) { LOG . debug ( \"cssUri: {}, imageUrl {}\" , cssUri , imageUrl ) ; final String cleanImageUrl = cleanImageUrl ( imageUrl ) ; // TODO move to ServletContextUriLocator as a helper method? // for the following input: /a/b/c/1.css => /a/b/c/ int idxLastSeparator = cssUri . lastIndexOf ( ServletContextUriLocator . PREFIX ) ; if ( idxLastSeparator == - 1 ) { if ( ClasspathUriLocator . isValid ( cssUri ) ) { idxLastSeparator = cssUri . lastIndexOf ( ClasspathUriLocator . PREFIX ) ; // find the index of ':' character used by classpath prefix if ( idxLastSeparator >= 0 ) { idxLastSeparator += ClasspathUriLocator . PREFIX . length ( ) - 1 ; } } if ( idxLastSeparator < 0 ) { throw new IllegalStateException ( \"Invalid cssUri: \" + cssUri + \". Should contain at least one '/' character!\" ) ; } } final String cssUriFolder = cssUri . substring ( 0 , idxLastSeparator + 1 ) ; // remove '/' from imageUrl if it starts with one. final String processedImageUrl = cleanImageUrl . startsWith ( ServletContextUriLocator . PREFIX ) ? cleanImageUrl . substring ( 1 ) : cleanImageUrl ; final String computedImageLocation = cleanPath ( cssUriFolder + processedImageUrl ) ; LOG . debug ( \"computedImageLocation: {}\" , computedImageLocation ) ; return computedImageLocation ; }", "nl": "Concatenates cssUri and imageUrl after few changes are applied to both input parameters ."}}
{"translation": {"code": "public static final String cleanImageUrl ( final String imageUrl ) { notNull ( imageUrl ) ; return imageUrl . replace ( ' ' , ' ' ) . replace ( ' ' , ' ' ) . trim ( ) ; }", "nl": "Cleans the image url by trimming result and removing \\ or \\ characters if such exists ."}}
{"translation": {"code": "public String processAndMerge ( final List < Resource > resources , final boolean minimize ) throws IOException { return processAndMerge ( resources , ProcessingCriteria . create ( ProcessingType . ALL , minimize ) ) ; }", "nl": "Apply preProcessors on resources and merge them after all preProcessors are applied ."}}
{"translation": {"code": "protected final void extendPluginClasspath ( ) throws MojoExecutionException { // this code is inspired from http://teleal.org/weblog/Extending%20the%20Maven%20plugin%20classpath.html final List < String > classpathElements = new ArrayList < String > ( ) ; try { classpathElements . addAll ( mavenProject . getRuntimeClasspathElements ( ) ) ; } catch ( final DependencyResolutionRequiredException e ) { throw new MojoExecutionException ( \"Could not get compile classpath elements\" , e ) ; } final ClassLoader classLoader = createClassLoader ( classpathElements ) ; Thread . currentThread ( ) . setContextClassLoader ( classLoader ) ; }", "nl": "Update the classpath ."}}
{"translation": {"code": "private String runInParallel ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { LOG . debug ( \"Running preProcessing in Parallel\" ) ; final StringBuffer result = new StringBuffer ( ) ; final List < Callable < String > > callables = new ArrayList < Callable < String > > ( ) ; for ( final Resource resource : resources ) { callables . add ( new Callable < String > ( ) { public String call ( ) throws Exception { LOG . debug ( \"Callable started for resource: {} ...\" , resource ) ; return applyPreProcessors ( resource , criteria ) ; } } ) ; } final ExecutorService exec = getExecutorService ( ) ; final List < Future < String > > futures = new ArrayList < Future < String > > ( ) ; for ( final Callable < String > callable : callables ) { // decorate with ContextPropagatingCallable in order to allow spawn threads to access the Context final Callable < String > decoratedCallable = new ContextPropagatingCallable < String > ( callable ) ; futures . add ( exec . submit ( decoratedCallable ) ) ; } for ( final Future < String > future : futures ) { try { result . append ( future . get ( ) ) ; } catch ( final Exception e ) { // propagate original cause final Throwable cause = e . getCause ( ) ; if ( cause instanceof WroRuntimeException ) { throw ( WroRuntimeException ) cause ; } else if ( cause instanceof IOException ) { throw ( IOException ) cause ; } else { throw new WroRuntimeException ( \"Problem during parallel pre processing\" , e ) ; } } } return result . toString ( ) ; }", "nl": "runs the pre processors in parallel ."}}
{"translation": {"code": "private boolean isTargetGroup ( final Group group ) { notNull ( group ) ; final String targetGroups = getTargetGroups ( ) ; // null, means all groups are target groups return targetGroups == null || targetGroups . contains ( group . getName ( ) ) ; }", "nl": "Check if the provided group is a target group ."}}
{"translation": {"code": "public void persist ( ) { OutputStream os = null ; try { os = new FileOutputStream ( fallbackStorageFile ) ; fallbackStorage . store ( os , \"Generated\" ) ; LOG . debug ( \"fallback storage written to {}\" , fallbackStorageFile ) ; } catch ( final IOException e ) { LOG . warn ( \"Cannot persist fallback storage: {}.\" , fallbackStorageFile , e ) ; } finally { IOUtils . closeQuietly ( os ) ; } }", "nl": "Persist the fallbackStorage to the fallbackStorageFile . This method should be invoked only once during build since it is relatively expensive . Not invoking it would break the incremental build feature ."}}
{"translation": {"code": "private void reloadCacheWithNewValue ( final Long newValue ) { final long newValueAsPrimitive = newValue == null ? getCacheUpdatePeriod ( ) : newValue ; LOG . debug ( \"invoking {} listeners\" , cacheUpdatePeriodListeners . size ( ) ) ; for ( final PropertyChangeListener listener : cacheUpdatePeriodListeners ) { final PropertyChangeEvent event = new PropertyChangeEvent ( this , \"cache\" , getCacheUpdatePeriod ( ) , newValueAsPrimitive ) ; listener . propertyChange ( event ) ; } }", "nl": "Notify all listeners about cachePeriod property changed . If passed newValue is null the oldValue is taken as new value . This is the case when the reloadCache is invoked ."}}
{"translation": {"code": "private void forEachCssImportApply ( final Function < String , ChangeStatus > func , final Resource resource , final Reader reader ) throws IOException { final ResourcePreProcessor processor = createCssImportProcessor ( func ) ; InjectorBuilder . create ( getManagerFactory ( ) ) . build ( ) . inject ( processor ) ; processor . process ( resource , reader , new StringWriter ( ) ) ; }", "nl": "Invokes the provided function for each detected css import ."}}
{"translation": {"code": "public static ResourceChangeHandler create ( final WroManagerFactory managerFactory , final Log log ) { notNull ( managerFactory , \"WroManagerFactory was not set\" ) ; notNull ( log , \"Log was not set\" ) ; return new ResourceChangeHandler ( ) . setManagerFactory ( managerFactory ) . setLog ( log ) ; }", "nl": "Factory method which requires all mandatory fields ."}}
{"translation": {"code": "private boolean isHandlerRequest ( final HttpServletRequest request ) { String apiHandlerValue = request . getParameter ( PATH_API ) ; return PATH_HANDLER . equals ( apiHandlerValue ) && retrieveCacheKey ( request ) != null ; }", "nl": "Checks if the provided url is a resource proxy request ."}}
{"translation": {"code": "private String extractPath ( final String uri ) { return DefaultWildcardStreamLocator . stripQueryPath ( uri . replace ( PREFIX , StringUtils . EMPTY ) ) ; }", "nl": "Replaces the protocol specific prefix and removes the query path if it exist since it should not be accepted ."}}
{"translation": {"code": "private WroManagerFactory createCustomManagerFactory ( ) throws MojoExecutionException { WroManagerFactory factory = null ; try { final Class < ? > wroManagerFactoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerFactory . trim ( ) ) ; factory = ( WroManagerFactory ) wroManagerFactoryClass . newInstance ( ) ; } catch ( final Exception e ) { throw new MojoExecutionException ( \"Invalid wroManagerFactoryClass, called: \" + wroManagerFactory , e ) ; } return factory ; }", "nl": "Creates a custom instance of Manager factory . The wroManagerFactory parameter value is used to identify the manager class ."}}