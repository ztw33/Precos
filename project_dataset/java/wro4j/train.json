{"translation": {"code": "public static void unset ( ) { final String correlationId = CORRELATION_ID . get ( ) ; if ( correlationId != null ) { CONTEXT_MAP . remove ( correlationId ) ; } CORRELATION_ID . remove ( ) ; }", "nl": "Remove context from the local thread ."}}
{"translation": {"code": "private static String replace ( final String inString , final String oldPattern , final String newPattern ) { if ( ! hasLength ( inString ) || ! hasLength ( oldPattern ) || newPattern == null ) { return inString ; } final StringBuffer sbuf = new StringBuffer ( ) ; // output StringBuffer we'll build up int pos = 0 ; // our position in the old string int index = inString . indexOf ( oldPattern ) ; // the index of an occurrence we've found, or -1 final int patLen = oldPattern . length ( ) ; while ( index >= 0 ) { sbuf . append ( inString . substring ( pos , index ) ) ; sbuf . append ( newPattern ) ; pos = index + patLen ; index = inString . indexOf ( oldPattern , pos ) ; } sbuf . append ( inString . substring ( pos ) ) ; // remember to append any characters to the right of a match return sbuf . toString ( ) ; }", "nl": "Replace all occurrences of a substring within a string with another string ."}}
{"translation": {"code": "private static String deleteAny ( final String inString , final String charsToDelete ) { if ( ! hasLength ( inString ) || ! hasLength ( charsToDelete ) ) { return inString ; } final StringBuffer out = new StringBuffer ( ) ; for ( int i = 0 ; i < inString . length ( ) ; i ++ ) { final char c = inString . charAt ( i ) ; if ( charsToDelete . indexOf ( c ) == - 1 ) { out . append ( c ) ; } } return out . toString ( ) ; }", "nl": "Delete any character in a given String ."}}
{"translation": {"code": "private void identifyDuplicateGroupNames ( final Collection < Group > groups ) { LOG . debug ( \"identifyDuplicateGroupNames\" ) ; final List < String > groupNames = new ArrayList < String > ( ) ; for ( final Group group : groups ) { if ( groupNames . contains ( group . getName ( ) ) ) { throw new WroRuntimeException ( \"Duplicate group name detected: \" + group . getName ( ) ) ; } groupNames . add ( group . getName ( ) ) ; } }", "nl": "Identify duplicate group names ."}}
{"translation": {"code": "public boolean isMinimized ( final HttpServletRequest request ) { Validate . notNull ( request ) ; final String minimizeAsString = request . getParameter ( PARAM_MINIMIZE ) ; return ! ( Context . get ( ) . getConfig ( ) . isDebug ( ) && \"false\" . equalsIgnoreCase ( minimizeAsString ) ) ; }", "nl": "The minimization is can be switched off only in debug mode ."}}
{"translation": {"code": "public static String getPathInfoFromLocation ( final HttpServletRequest request , final String location ) { if ( StringUtils . isEmpty ( location ) ) { throw new IllegalArgumentException ( \"Location cannot be empty string!\" ) ; } final String contextPath = request . getContextPath ( ) ; if ( contextPath != null ) { if ( startsWithIgnoreCase ( location , contextPath ) ) { return location . substring ( contextPath . length ( ) ) ; } else { return location ; } } final String noSlash = location . substring ( 1 ) ; final int nextSlash = noSlash . indexOf ( ' ' ) ; if ( nextSlash == - 1 ) { return \"\" ; } return noSlash . substring ( nextSlash ) ; }", "nl": "Retrieve pathInfo from a given location ."}}
{"translation": {"code": "public static String getServletPathFromLocation ( final HttpServletRequest request , final String location ) { return location . replace ( getPathInfoFromLocation ( request , location ) , StringUtils . EMPTY ) ; }", "nl": "Retrieve servletPath from a given location ."}}
{"translation": {"code": "private void processGroups ( final Document document ) { // handle imports\r final NodeList groupNodeList = document . getElementsByTagName ( TAG_GROUP ) ; for ( int i = 0 ; i < groupNodeList . getLength ( ) ; i ++ ) { final Element groupElement = ( Element ) groupNodeList . item ( i ) ; final String name = groupElement . getAttribute ( ATTR_GROUP_NAME ) ; allGroupElements . put ( name , groupElement ) ; } }", "nl": "Initialize the map"}}
{"translation": {"code": "private void parseResource ( final Element resourceElement , final Collection < Resource > resources ) { final String tagName = resourceElement . getTagName ( ) ; final String uri = resourceElement . getTextContent ( ) ; if ( TAG_GROUP_REF . equals ( tagName ) ) { // uri in this case is the group name\r resources . addAll ( getResourcesForGroup ( uri ) ) ; } if ( getResourceType ( resourceElement ) != null ) { final Resource resource = createResource ( resourceElement ) ; LOG . debug ( \"\\t\\tadding resource: {}\" , resource ) ; resources . add ( resource ) ; } }", "nl": "Creates a resource from a given resourceElement . It can be css js . If resource tag name is group - ref the method will start a recursive computation ."}}
{"translation": {"code": "protected Group createGroup ( final Element element ) { final String name = element . getAttribute ( ATTR_GROUP_NAME ) ; final Group group = new Group ( name ) ; final List < Resource > resources = new ArrayList < Resource > ( ) ; final NodeList resourceNodeList = element . getChildNodes ( ) ; for ( int i = 0 ; i < resourceNodeList . getLength ( ) ; i ++ ) { final Node node = resourceNodeList . item ( i ) ; if ( node instanceof Element ) { final Element resourceElement = ( Element ) node ; parseResource ( resourceElement , resources ) ; } } group . setResources ( resources ) ; return group ; }", "nl": "Creates a group and all its associated resources ."}}
{"translation": {"code": "private Collection < Resource > parseGroup ( final Element element ) { final String name = element . getAttribute ( ATTR_GROUP_NAME ) ; final String isAbstractAsString = element . getAttribute ( ATTR_GROUP_ABSTRACT ) ; final boolean isAbstractGroup = StringUtils . isNotEmpty ( isAbstractAsString ) && Boolean . valueOf ( isAbstractAsString ) ; if ( groupsInProcess . contains ( name ) ) { throw new RecursiveGroupDefinitionException ( \"Infinite Recursion detected for the group: \" + name + \". Recursion path: \" + groupsInProcess ) ; } LOG . debug ( \"\\tadding group: {}\" , name ) ; groupsInProcess . add ( name ) ; // skip if this group is already parsed\r final Group parsedGroup = new WroModelInspector ( model ) . getGroupByName ( name ) ; if ( parsedGroup != null ) { // remove before returning\r // this group is parsed, remove from unparsed groups collection\r groupsInProcess . remove ( name ) ; return parsedGroup . getResources ( ) ; } final Group group = createGroup ( element ) ; // this group is parsed, remove from unparsed collection\r groupsInProcess . remove ( name ) ; if ( ! isAbstractGroup ) { // add only non abstract groups\r model . addGroup ( group ) ; } return group . getResources ( ) ; }", "nl": "Recursive method . Add the parsed element group to the group collection . If the group contains group - ref element parse recursively this group ."}}
{"translation": {"code": "public final boolean hasResourcesOfType ( final ResourceType resourceType ) { notNull ( resourceType , \"ResourceType cannot be null!\" ) ; for ( final Resource resource : resources ) { if ( resourceType . equals ( resource . getType ( ) ) ) { return true ; } } return false ; }", "nl": "Check if the group has at least one resource of some type ."}}
{"translation": {"code": "private Map < String , String > extractVariables ( final String variablesBody ) { final Map < String , String > map = new HashMap < String , String > ( ) ; final Matcher m = PATTERN_VARIABLES_BODY . matcher ( variablesBody ) ; LOG . debug ( \"parsing variables body\" ) ; while ( m . find ( ) ) { final String key = m . group ( 1 ) ; final String value = m . group ( 2 ) ; if ( map . containsKey ( key ) ) { LOG . warn ( \"A duplicate variable name found with name: {} and value: {}.\" , key , value ) ; } map . put ( key , value ) ; } return map ; }", "nl": "Extract variables map from variables body ."}}
{"translation": {"code": "private String parseCss ( final String css ) { // map containing variables & their values\r final Map < String , String > map = new HashMap < String , String > ( ) ; final StringBuffer sb = new StringBuffer ( ) ; final Matcher m = PATTERN_VARIABLES_DEFINITION . matcher ( css ) ; while ( m . find ( ) ) { final String variablesBody = m . group ( 1 ) ; // LOG.debug(\"variables body: \" + variablesBody);\r // extract variables\r map . putAll ( extractVariables ( variablesBody ) ) ; // remove variables definition\r m . appendReplacement ( sb , \"\" ) ; } m . appendTail ( sb ) ; // LOG.debug(\"replaced variables: \" + result);\r return replaceVariables ( sb . toString ( ) , map ) ; }", "nl": "Parse css find all defined variables & replace them ."}}
{"translation": {"code": "private String replaceVariables ( final String css , final Map < String , String > variables ) { final StringBuffer sb = new StringBuffer ( ) ; final Matcher m = PATTERN_VARIABLE_HOLDER . matcher ( css ) ; while ( m . find ( ) ) { final String oldMatch = m . group ( ) ; final String variableName = m . group ( 1 ) ; final String variableValue = variables . get ( variableName ) ; if ( variableValue != null ) { final String newReplacement = oldMatch . replace ( oldMatch , variableValue ) ; m . appendReplacement ( sb , newReplacement . trim ( ) ) ; } else { LOG . warn ( \"No variable with name \" + variableName + \" was found!\" ) ; } } m . appendTail ( sb ) ; return sb . toString ( ) ; }", "nl": "Replace variables from css with provided variables map ."}}
{"translation": {"code": "private ServletRequest getWrappedServletRequest ( final HttpServletRequest request , final String location ) { final HttpServletRequest wrappedRequest = new HttpServletRequestWrapper ( request ) { @ Override public String getRequestURI ( ) { return getContextPath ( ) + location ; } @ Override public String getPathInfo ( ) { return WroUtil . getPathInfoFromLocation ( this , location ) ; } @ Override public String getServletPath ( ) { return WroUtil . getServletPathFromLocation ( this , location ) ; } } ; // add an attribute to mark this request as included from wro\r wrappedRequest . setAttribute ( ATTRIBUTE_INCLUDED_BY_DISPATCHER , Boolean . TRUE ) ; return wrappedRequest ; }", "nl": "Build a wrapped servlet request which will be used for dispatching ."}}
{"translation": {"code": "void triggerWildcardExpander ( final Collection < File > allFiles , final WildcardContext wildcardContext ) throws IOException { LOG . debug ( \"wildcard resources: {}\" , allFiles ) ; if ( allFiles . isEmpty ( ) ) { final String message = String . format ( \"No resource found for wildcard: %s\" , wildcardContext . getWildcard ( ) ) ; LOG . warn ( message ) ; throw new IOException ( message ) ; } if ( wildcardExpanderHandler != null ) { try { wildcardExpanderHandler . apply ( allFiles ) ; } catch ( final IOException e ) { // preserve exception type if the exception is already an IOException\r throw e ; } catch ( final Exception e ) { LOG . debug ( \"wildcard expanding error. Reporting original exception\" , e ) ; throw new IOException ( \"Exception during expanding wildcard: \" + e . getMessage ( ) ) ; } } }", "nl": "Uses the wildcardExpanderHandler to process all found files and directories ."}}
{"translation": {"code": "public TaskInfo [ ] getTaskInfo ( ) { if ( ! this . keepTaskList ) { throw new UnsupportedOperationException ( \"Task info is not being kept!\" ) ; } return ( TaskInfo [ ] ) this . taskList . toArray ( new TaskInfo [ this . taskList . size ( ) ] ) ; }", "nl": "Return an array of the data for tasks performed ."}}
{"translation": {"code": "public static void set ( final Context context , final WroConfiguration config ) { notNull ( context ) ; notNull ( config ) ; context . setConfig ( config ) ; final String correlationId = generateCorrelationId ( ) ; CORRELATION_ID . set ( correlationId ) ; CONTEXT_MAP . put ( correlationId , context ) ; }", "nl": "Associate a context with the CURRENT request cycle ."}}
{"translation": {"code": "public static String encodeObject ( final java . io . Serializable serializableObject ) throws java . io . IOException { return encodeObject ( serializableObject , NO_OPTIONS ) ; }", "nl": "Serializes an object and returns the Base64 - encoded version of that serialized object ."}}
{"translation": {"code": "private String applyPostProcessors ( final CacheKey cacheKey , final String content ) throws IOException { final Collection < ResourcePostProcessor > processors = processorsFactory . getPostProcessors ( ) ; LOG . debug ( \"appying post processors: {}\" , processors ) ; if ( processors . isEmpty ( ) ) { return content ; } final Resource resource = Resource . create ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; Reader reader = new StringReader ( content . toString ( ) ) ; Writer writer = null ; for ( final ResourcePostProcessor processor : processors ) { final ResourcePreProcessor decoratedProcessor = decorateProcessor ( processor , cacheKey . isMinimize ( ) ) ; writer = new StringWriter ( ) ; decoratedProcessor . process ( resource , reader , writer ) ; reader = new StringReader ( writer . toString ( ) ) ; } return writer . toString ( ) ; }", "nl": "Apply resourcePostProcessors ."}}
{"translation": {"code": "private ScriptableObject createContext ( final ScriptableObject initialScope ) { final Context context = getContext ( ) ; context . setOptimizationLevel ( - 1 ) ; // TODO redirect errors from System.err to LOG.error()\r context . setErrorReporter ( new ToolErrorReporter ( false ) ) ; context . setLanguageVersion ( Context . VERSION_1_8 ) ; InputStream script = null ; final ScriptableObject scriptCommon = ( ScriptableObject ) context . initStandardObjects ( initialScope ) ; try { script = new AutoCloseInputStream ( getClass ( ) . getResourceAsStream ( \"commons.js\" ) ) ; context . evaluateReader ( scriptCommon , new InputStreamReader ( script ) , \"commons.js\" , 1 , null ) ; } catch ( final IOException e ) { throw new RuntimeException ( \"Problem while evaluationg commons script.\" , e ) ; } finally { IOUtils . closeQuietly ( script ) ; } return scriptCommon ; }", "nl": "Initialize the context ."}}
{"translation": {"code": "public Object evaluate ( final Reader reader , final String sourceName ) throws IOException { notNull ( reader ) ; try { return evaluate ( IOUtils . toString ( reader ) , sourceName ) ; } finally { reader . close ( ) ; } }", "nl": "Evaluates a script from a reader ."}}
{"translation": {"code": "public Object evaluate ( final String script , final String sourceName ) { notNull ( script ) ; // make sure we have a context associated with current thread\r try { return getContext ( ) . evaluateString ( scope , script , sourceName , 1 , null ) ; } catch ( final RhinoException e ) { final String message = RhinoUtils . createExceptionMessage ( e ) ; LOG . error ( \"JavaScriptException occured: {}\" , message ) ; throw new WroRuntimeException ( message ) ; } finally { // Rhino throws an exception when trying to exit twice. Make sure we don't get any exception\r if ( Context . getCurrentContext ( ) != null ) { Context . exit ( ) ; } } }", "nl": "Evaluates a script ."}}
{"translation": {"code": "public static Transformer < String > baseNameSuffixTransformer ( final String suffix ) { return new Transformer < String > ( ) { public String transform ( final String input ) { final String baseName = FilenameUtils . getBaseName ( input ) ; final String extension = FilenameUtils . getExtension ( input ) ; return baseName + suffix + \".\" + extension ; } } ; }", "nl": "Appends a suffix to the source baseName ."}}
{"translation": {"code": "public void merge ( final WroModel importedModel ) { Validate . notNull ( importedModel , \"imported model cannot be null!\" ) ; LOG . debug ( \"merging importedModel: {}\" , importedModel ) ; for ( final String groupName : new WroModelInspector ( importedModel ) . getGroupNames ( ) ) { if ( new WroModelInspector ( this ) . getGroupNames ( ) . contains ( groupName ) ) { throw new WroRuntimeException ( \"Duplicate group name detected: \" + groupName ) ; } final Group importedGroup = new WroModelInspector ( importedModel ) . getGroupByName ( groupName ) ; addGroup ( importedGroup ) ; } }", "nl": "Merge this model with another model . This is useful for supporting model imports ."}}
{"translation": {"code": "JarFile open ( final File jarFile ) throws IOException { isTrue ( jarFile . exists ( ) , \"The JAR file must exists.\" ) ; return new JarFile ( jarFile ) ; }", "nl": "Opens the specified JAR file and returns a valid handle ."}}
{"translation": {"code": "@ Override public InputStream locateStream ( final String uri , final File folder ) throws IOException { notNull ( folder ) ; final File jarPath = getJarFile ( folder ) ; if ( isSupported ( jarPath ) ) { return locateStreamFromJar ( uri , jarPath ) ; } return super . locateStream ( uri , folder ) ; }", "nl": "Finds the specified URI pattern inside a JAR file . If the specified file isn t a valid JAR default strategy will be used instead ."}}
{"translation": {"code": "public final SimpleUriLocatorFactory addLocator ( final UriLocator ... locators ) { for ( final UriLocator locator : locators ) { uriLocators . add ( locator ) ; } return this ; }", "nl": "Allow adding more than one uriLocators ."}}
{"translation": {"code": "public final InputStream locate ( final String uri ) throws IOException { final UriLocator uriLocator = getInstance ( uri ) ; if ( uriLocator == null ) { throw new WroRuntimeException ( \"No locator is capable of handling uri: \" + uri ) ; } LOG . debug ( \"[OK] locating {} using locator: {}\" , uri , uriLocator . getClass ( ) . getSimpleName ( ) ) ; return new AutoCloseInputStream ( uriLocator . locate ( uri ) ) ; }", "nl": "Locates an InputStream for the given uri ."}}
{"translation": {"code": "private Collection < Field > getAllFields ( final Object object ) { final Collection < Field > fields = new ArrayList < Field > ( ) ; fields . addAll ( Arrays . asList ( object . getClass ( ) . getDeclaredFields ( ) ) ) ; // inspect super classes\r Class < ? > superClass = object . getClass ( ) . getSuperclass ( ) ; while ( superClass != null ) { fields . addAll ( Arrays . asList ( superClass . getDeclaredFields ( ) ) ) ; superClass = superClass . getSuperclass ( ) ; } return fields ; }", "nl": "Return all fields for given object also those from the super classes ."}}
{"translation": {"code": "private InputStream createAutoDetectedStream ( final String defaultFileName ) throws IOException { try { Validate . notNull ( wroFile , \"Cannot call this method if wroFile is null!\" ) ; if ( autoDetectWroFile ) { final File file = new File ( wroFile . getParentFile ( ) , defaultFileName ) ; LOG . debug ( \"\\tloading autodetected wro file: \" + file ) ; return new FileInputStream ( file ) ; } LOG . debug ( \"loading wroFile: \" + wroFile ) ; return new FileInputStream ( wroFile ) ; } catch ( final FileNotFoundException e ) { // When auto detect is turned on, do not skip trying.. because the auto detection assume that the wro file name\r // can be wrong.\r if ( autoDetectWroFile ) { throw e ; } throw new WroRuntimeException ( \"The wroFile doesn't exist. Skip trying with other wro model factories\" , e ) ; } }", "nl": "Handles the resource model auto detection ."}}
{"translation": {"code": "protected InputStream getModelResourceAsStream ( ) throws IOException { final ServletContext servletContext = context . getServletContext ( ) ; // Don't allow NPE, throw a more detailed exception\r if ( servletContext == null ) { throw new WroRuntimeException ( \"No servletContext is available. Probably you are running this code outside of the request cycle!\" ) ; } final String resourceLocation = \"/WEB-INF/\" + getDefaultModelFilename ( ) ; final InputStream stream = servletContext . getResourceAsStream ( resourceLocation ) ; if ( stream == null ) { throw new IOException ( \"Invalid resource requested: \" + resourceLocation ) ; } return stream ; }", "nl": "Override this method in order to provide different xml definition file name ."}}
{"translation": {"code": "public ModelTransformerFactory setTransformers ( final List < Transformer < WroModel > > modelTransformers ) { Validate . notNull ( modelTransformers ) ; this . modelTransformers = modelTransformers ; return this ; }", "nl": "Set a list of transformers to apply on decorated model factory ."}}
{"translation": {"code": "public BaseWroManagerFactory addModelTransformer ( final Transformer < WroModel > modelTransformer ) { if ( modelTransformers == null ) { modelTransformers = new ArrayList < Transformer < WroModel > > ( ) ; } this . modelTransformers . add ( modelTransformer ) ; return this ; }", "nl": "Add a single model transformer ."}}
{"translation": {"code": "public String [ ] splitOptions ( final String optionAsString ) { return optionAsString == null ? ArrayUtils . EMPTY_STRING_ARRAY : optionAsString . split ( \"(?ims),(?![^\\\\[\\\\]]*\\\\])\" ) ; }", "nl": "Split multiple options into an array of options ."}}
{"translation": {"code": "private synchronized ProcessorDecorator decorateProcessor ( final ResourcePostProcessor processor , final boolean minimize ) { final ProcessorDecorator decorated = new DefaultProcessorDecorator ( processor , minimize ) { @ Override public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { try { callbackRegistry . onBeforePostProcess ( ) ; super . process ( resource , reader , writer ) ; } finally { callbackRegistry . onAfterPostProcess ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }", "nl": "This method is synchronized to ensure that processor is injected before it is being used by other thread ."}}
{"translation": {"code": "public String process ( final String content ) { if ( isEmpty ( content ) ) { return StringUtils . EMPTY ; } try { synchronized ( this ) { return engineInitializer . get ( ) . eval ( buildUpdateScript ( content ) ) . toString ( ) ; } } catch ( final ScriptException e ) { throw new WroRuntimeException ( e . getMessage ( ) , e ) ; } }", "nl": "Transforms a sass content into css using Sass ruby engine . This method is synchronized because the engine itself is not thread - safe ."}}
{"translation": {"code": "private void onError ( final int sc , final String msg ) { LOG . debug ( \"Error detected with code: {} and message: {}\" , sc , msg ) ; final OutputStream emptyStream = new ByteArrayOutputStream ( ) ; printWriter = new PrintWriter ( emptyStream ) ; servletOutputStream = new DelegatingServletOutputStream ( emptyStream ) ; }", "nl": "Use an empty stream to avoid container writing unwanted message when a resource is missing ."}}
{"translation": {"code": "@ Override public void sendRedirect ( final String location ) throws IOException { try { LOG . debug ( \"redirecting to: {}\" , location ) ; final InputStream is = externalResourceLocator . locate ( location ) ; IOUtils . copy ( is , servletOutputStream ) ; is . close ( ) ; servletOutputStream . close ( ) ; } catch ( final IOException e ) { LOG . warn ( \"{}: Invalid response for location: {}\" , e . getClass ( ) . getName ( ) , location ) ; throw e ; } }", "nl": "By default redirect does not allow writing to output stream its content . In order to support this use - case we need to open a new connection and read the content manually ."}}
{"translation": {"code": "private void doProcess ( final String requestUri , final Reader reader , final Writer writer ) throws IOException { Reader input = reader ; Writer output = null ; LOG . debug ( \"processing resource: {}\" , requestUri ) ; try { final StopWatch stopWatch = new StopWatch ( ) ; final Injector injector = InjectorBuilder . create ( new BaseWroManagerFactory ( ) ) . build ( ) ; final List < ResourcePreProcessor > processors = getProcessorsList ( ) ; if ( processors == null || processors . isEmpty ( ) ) { IOUtils . copy ( reader , writer ) ; } else { for ( final ResourcePreProcessor processor : processors ) { stopWatch . start ( \"Using \" + processor . getClass ( ) . getSimpleName ( ) ) ; // inject all required properties injector . inject ( processor ) ; output = new StringWriter ( ) ; LOG . debug ( \"Using {} processor\" , processor ) ; processor . process ( createResource ( requestUri ) , input , output ) ; input = new StringReader ( output . toString ( ) ) ; stopWatch . stop ( ) ; } LOG . debug ( stopWatch . prettyPrint ( ) ) ; if ( output != null ) { writer . write ( output . toString ( ) ) ; } } } finally { reader . close ( ) ; writer . close ( ) ; } }", "nl": "Applies configured processor on the intercepted stream ."}}
{"translation": {"code": "public final boolean isEligible ( final boolean minimize , final ResourceType searchedType ) { Validate . notNull ( searchedType ) ; final SupportedResourceType supportedType = getSupportedResourceType ( ) ; final boolean isTypeSatisfied = supportedType == null || ( supportedType != null && searchedType == supportedType . value ( ) ) ; final boolean isMinimizedSatisfied = minimize == true || ! isMinimize ( ) ; return isTypeSatisfied && isMinimizedSatisfied ; }", "nl": "Indicates if the processor is eligible for usage based on provided criteria ."}}
{"translation": {"code": "private static ResourcePreProcessor toPreProcessor ( final ResourcePostProcessor postProcessor ) { return new AbstractProcessorDecoratorSupport < ResourcePostProcessor > ( postProcessor ) { public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { postProcessor . process ( reader , writer ) ; } @ Override protected boolean isMinimizeInternal ( ) { return isMinimizeForProcessor ( postProcessor ) ; } @ Override protected SupportedResourceType getSupportedResourceTypeInternal ( ) { return getSupportedResourceTypeForProcessor ( postProcessor ) ; } @ Override public String toString ( ) { return postProcessor . toString ( ) ; } } ; }", "nl": "Transforms a post processor into pre processor ."}}
{"translation": {"code": "private ReadWriteLock getLockForKey ( final K key ) { final ReadWriteLock lock = locks . putIfAbsent ( key , new ReentrantReadWriteLock ( ) ) ; return lock == null ? locks . get ( key ) : lock ; }", "nl": "Ensure that the returned lock will never be null ."}}
{"translation": {"code": "private WroManagerFactory initFactory ( final Properties properties ) { WroManagerFactory factory = null ; final String wroManagerClassName = properties . getProperty ( ConfigConstants . managerFactoryClassName . name ( ) ) ; if ( StringUtils . isEmpty ( wroManagerClassName ) ) { // If no context param was specified we return the default factory factory = newManagerFactory ( ) ; } else { // Try to find the specified factory class Class < ? > factoryClass = null ; try { factoryClass = Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( wroManagerClassName ) ; factory = ( WroManagerFactory ) factoryClass . newInstance ( ) ; } catch ( final Exception e ) { throw new WroRuntimeException ( \"Exception while loading WroManagerFactory class:\" + wroManagerClassName , e ) ; } } // add properties if required if ( factory instanceof ConfigurableWroManagerFactory ) { ( ( ConfigurableWroManagerFactory ) factory ) . addConfigProperties ( properties ) ; } return factory ; }", "nl": "Initialized inner factory based on provided configuration ."}}
{"translation": {"code": "final void setAttribute ( final Attribute attribute , final Object object ) { Validate . notNull ( attribute ) ; LOG . debug ( \"setting attribute: {} with value: {}\" , attribute , object ) ; Validate . isTrue ( attribute . isValid ( object ) , object + \" is not of valid subType for attribute: \" + attribute ) ; servletContext . setAttribute ( getAttributeName ( attribute ) , object ) ; }", "nl": "Sets the attribute into the servlet context . The name of the attribute will be computed for you ."}}
{"translation": {"code": "public String compile ( final String content , final String optionalArgument ) { final RhinoScriptBuilder builder = initScriptBuilder ( ) ; final String argStr = createArgStr ( optionalArgument ) + createArgStr ( getArguments ( ) ) ; final String compileScript = String . format ( \"%s(%s%s);\" , getCompileCommand ( ) , WroUtil . toJSMultiLineString ( content ) , argStr ) ; return ( String ) builder . evaluate ( compileScript , getCompileCommand ( ) ) ; }", "nl": "Compiles the javascript template into plain javascript ."}}
{"translation": {"code": "public void addRequire ( final String require ) { if ( require != null && require . trim ( ) . length ( ) > 0 ) { requires . add ( require . trim ( ) ) ; } }", "nl": "Adds a ruby require to the ruby script to be run by this RubySassEngine . It s safe to add the same require twice ."}}
{"translation": {"code": "public Function < Collection < File > , Void > createExpanderHandler ( final Group group , final Resource resource , final String baseNameFolder ) { LOG . debug ( \"createExpanderHandler using baseNameFolder: {}\\n for resource {}\" , baseNameFolder , resource ) ; return new Function < Collection < File > , Void > ( ) { public Void apply ( final Collection < File > files ) { if ( baseNameFolder == null ) { // replacing group with empty list since the original uri has no associated resources. // No BaseNameFolder found LOG . warn ( \"The resource {} is probably invalid, removing it from the group.\" , resource ) ; group . replace ( resource , new ArrayList < Resource > ( ) ) ; } else { final List < Resource > expandedResources = new ArrayList < Resource > ( ) ; LOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; for ( final File file : files ) { final String resourcePath = getFullPathNoEndSeparator ( resource ) ; LOG . debug ( \"\\tresourcePath: {}\" , resourcePath ) ; LOG . debug ( \"\\tfile path: {}\" , file . getPath ( ) ) ; final String computedResourceUri = resourcePath + StringUtils . removeStart ( file . getPath ( ) , baseNameFolder ) . replace ( ' ' , ' ' ) ; final Resource expandedResource = Resource . create ( computedResourceUri , resource . getType ( ) ) ; LOG . debug ( \"\\texpanded resource: {}\" , expandedResource ) ; expandedResources . add ( expandedResource ) ; } LOG . debug ( \"\\treplace resource {}\" , resource ) ; group . replace ( resource , expandedResources ) ; } return null ; } /**\n       * This method fixes the problem when a resource in a group uses deep wildcard and starts at the root.\n       * <p/>\n       * Find more details <a href=\"https://github.com/alexo/wro4j/pull/44\">here</a>.\n       */ private String getFullPathNoEndSeparator ( final Resource resource1 ) { final String result = FilenameUtils . getFullPathNoEndSeparator ( resource1 . getUri ( ) ) ; if ( result != null && 1 == result . length ( ) && 0 == FilenameUtils . indexOfLastSeparator ( result ) ) { return \"\" ; } return result ; } } ; }", "nl": "create the handler which expand the resources containing wildcard ."}}
{"translation": {"code": "private void processResource ( final Group group , final Resource resource ) { final UriLocator uriLocator = locatorFactory . getInstance ( resource . getUri ( ) ) ; if ( uriLocator instanceof WildcardUriLocatorSupport ) { final WildcardStreamLocator wildcardStreamLocator = ( ( WildcardUriLocatorSupport ) uriLocator ) . getWildcardStreamLocator ( ) ; // TODO should we probably handle the situation when wildcard is present, but the implementation is not // expandedHandledAware? if ( wildcardStreamLocator . hasWildcard ( resource . getUri ( ) ) && wildcardStreamLocator instanceof WildcardExpanderHandlerAware ) { final WildcardExpanderHandlerAware expandedHandler = ( WildcardExpanderHandlerAware ) wildcardStreamLocator ; LOG . debug ( \"Expanding resource: {}\" , resource . getUri ( ) ) ; final String baseNameFolder = computeBaseNameFolder ( resource , uriLocator , expandedHandler ) ; LOG . debug ( \"baseNameFolder: {}\" , baseNameFolder ) ; expandedHandler . setWildcardExpanderHandler ( createExpanderHandler ( group , resource , baseNameFolder ) ) ; try { // trigger the wildcard replacement uriLocator . locate ( resource . getUri ( ) ) ; } catch ( final IOException e ) { // log only LOG . debug ( \"[FAIL] problem while trying to expand wildcard for the following resource uri: {}\" , resource . getUri ( ) ) ; } finally { // remove the handler, it is not needed anymore expandedHandler . setWildcardExpanderHandler ( null ) ; } } } }", "nl": "Process each resource and replace it with a collection of resources if it contains wildcard ."}}
{"translation": {"code": "public static boolean matchesUrl ( final HttpServletRequest request , final String path ) { final Pattern pattern = Pattern . compile ( \".*\" + path + \"[/]?\" , Pattern . CASE_INSENSITIVE ) ; if ( request . getRequestURI ( ) != null ) { final Matcher m = pattern . matcher ( request . getRequestURI ( ) ) ; return m . matches ( ) ; } return false ; }", "nl": "Utility used to verify that requestURI matches provided path"}}
{"translation": {"code": "private Map < String , ResourcePostProcessor > toPostProcessors ( final Map < String , ResourcePreProcessor > preProcessorsMap ) { final Map < String , ResourcePostProcessor > map = new HashMap < String , ResourcePostProcessor > ( ) ; for ( final Entry < String , ResourcePreProcessor > entry : preProcessorsMap . entrySet ( ) ) { map . put ( entry . getKey ( ) , new ProcessorDecorator ( entry . getValue ( ) ) ) ; } return map ; }", "nl": "Creates a map of postProcessors form a map of preProcessors . This method will be removed in 1 . 5 . 0 release when there will be no differences between pre & post processor interface ."}}
{"translation": {"code": "private void parseProperties ( final String propertiesAsString ) { //should work also \\r?\\n final String [ ] propertyEntries = propertiesAsString . split ( \"\\\\r?\\\\n\" ) ; for ( final String entry : propertyEntries ) { readPropertyEntry ( entry ) ; } }", "nl": "parse the properties from the provided string containing a raw properties"}}
{"translation": {"code": "public Properties load ( final InputStream inputStream ) throws IOException { Validate . notNull ( inputStream ) ; final String rawContent = IOUtils . toString ( inputStream , CharEncoding . UTF_8 ) ; parseProperties ( rawContent . replaceAll ( REGEX_COMMENTS , \"\" ) ) ; return this . properties ; }", "nl": "Load the properties from the stream . The implementation will handle comments properly by removing them before properties are loaded ."}}
{"translation": {"code": "public static String loadRegexpWithKey ( final String key ) { InputStream stream = null ; try { stream = WroUtil . class . getResourceAsStream ( \"regexp.properties\" ) ; final Properties props = new RegexpProperties ( ) . load ( stream ) ; return props . getProperty ( key ) ; } catch ( final IOException e ) { throw new WroRuntimeException ( \"Could not load pattern with key: \" + key + \" from property file\" , e ) ; } finally { closeQuietly ( stream ) ; } }", "nl": "Load the regular expression stored in in regexp . properties resource file ."}}
{"translation": {"code": "public final void process ( ) throws IOException { // reschedule cache & model updates final WroConfiguration config = Context . get ( ) . getConfig ( ) ; cacheSchedulerHelper . scheduleWithPeriod ( config . getCacheUpdatePeriod ( ) ) ; modelSchedulerHelper . scheduleWithPeriod ( config . getModelUpdatePeriod ( ) ) ; resourceBundleProcessor . serveProcessedBundle ( ) ; }", "nl": "Perform processing of the uri ."}}
{"translation": {"code": "private Properties getConfigProperties ( ) { if ( configProperties == null ) { configProperties = newConfigProperties ( ) ; if ( additionalConfigProperties != null ) { configProperties . putAll ( additionalConfigProperties ) ; } } return configProperties ; }", "nl": "Use this method rather than accessing the field directly because it will create a default one if none is provided ."}}
{"translation": {"code": "private void updatePropertiesWithConfiguration ( final Properties props , final String key ) { final FilterConfig filterConfig = Context . get ( ) . getFilterConfig ( ) ; // first, retrieve value from init-param for backward compatibility final String valuesAsString = filterConfig . getInitParameter ( key ) ; if ( valuesAsString != null ) { props . setProperty ( key , valuesAsString ) ; } else { // retrieve value from configProperties file final String value = getConfigProperties ( ) . getProperty ( key ) ; if ( value != null ) { props . setProperty ( key , value ) ; } } }", "nl": "Add to properties a new key with value extracted either from filterConfig or from configurable properties file . This method helps to ensure backward compatibility of the filterConfig vs configProperties configuration ."}}
{"translation": {"code": "public void serveProcessedBundle ( ) throws IOException { final WroConfiguration configuration = context . getConfig ( ) ; final HttpServletRequest request = context . getRequest ( ) ; final HttpServletResponse response = context . getResponse ( ) ; OutputStream os = null ; try { final CacheKey cacheKey = getSafeCacheKey ( request ) ; initAggregatedFolderPath ( request , cacheKey . getType ( ) ) ; final CacheValue cacheValue = cacheStrategy . get ( cacheKey ) ; // TODO move ETag check in wroManagerFactory final String ifNoneMatch = request . getHeader ( HttpHeader . IF_NONE_MATCH . toString ( ) ) ; // enclose etag value in quotes to be compliant with the RFC final String etagValue = String . format ( \"\\\"%s\\\"\" , cacheValue . getHash ( ) ) ; if ( etagValue != null && etagValue . equals ( ifNoneMatch ) ) { LOG . debug ( \"ETag hash detected: {}. Sending {} status code\" , etagValue , HttpServletResponse . SC_NOT_MODIFIED ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; // because we cannot return null, return a stream containing nothing. // TODO close output stream? return ; } /**\n       * Set contentType before actual content is written, solves <br/>\n       * <a href=\"http://code.google.com/p/wro4j/issues/detail?id=341\">issue341</a>\n       */ response . setContentType ( cacheKey . getType ( ) . getContentType ( ) + \"; charset=\" + configuration . getEncoding ( ) ) ; // set ETag header response . setHeader ( HttpHeader . ETAG . toString ( ) , etagValue ) ; os = response . getOutputStream ( ) ; if ( cacheValue . getRawContent ( ) != null ) { // use gziped response if supported & Set content length based on gzip flag if ( isGzipAllowed ( ) ) { response . setContentLength ( cacheValue . getGzippedContent ( ) . length ) ; // add gzip header and gzip response response . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; response . setHeader ( \"Vary\" , \"Accept-Encoding\" ) ; IOUtils . write ( cacheValue . getGzippedContent ( ) , os ) ; } else { //using getRawContent().length() is not the same and can return 2Bytes smaller size. response . setContentLength ( cacheValue . getRawContent ( ) . getBytes ( configuration . getEncoding ( ) ) . length ) ; IOUtils . write ( cacheValue . getRawContent ( ) , os , configuration . getEncoding ( ) ) ; } } } finally { if ( os != null ) { IOUtils . closeQuietly ( os ) ; } } }", "nl": "Write to stream the content of the processed resource bundle ."}}
{"translation": {"code": "private void initAggregatedFolderPath ( final HttpServletRequest request , final ResourceType type ) { if ( ResourceType . CSS == type && context . getAggregatedFolderPath ( ) == null ) { final String requestUri = request . getRequestURI ( ) ; final String cssFolder = StringUtils . removeEnd ( requestUri , FilenameUtils . getName ( requestUri ) ) ; final String aggregatedFolder = StringUtils . removeStart ( cssFolder , request . getContextPath ( ) ) ; LOG . debug ( \"set aggregatedFolderPath: {}\" , aggregatedFolder ) ; Context . get ( ) . setAggregatedFolderPath ( aggregatedFolder ) ; } }", "nl": "Set the aggregatedFolderPath if required ."}}
{"translation": {"code": "private void generateDataURI ( final byte [ ] bytes , final Writer out , final String mimeType ) throws IOException { // create the output final StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( DATA_URI_PREFIX ) ; // add MIME type buffer . append ( mimeType ) ; // output base64-encoding buffer . append ( \";base64,\" ) ; buffer . append ( Base64 . encodeBytes ( bytes ) ) ; // output to writer out . write ( buffer . toString ( ) ) ; }", "nl": "Generates a data URI from a byte array and outputs to the given writer ."}}
{"translation": {"code": "public String generateDataURI ( final InputStream inputStream , final String fileName ) throws IOException { final StringWriter writer = new StringWriter ( ) ; final byte [ ] bytes = IOUtils . toByteArray ( inputStream ) ; inputStream . close ( ) ; final String mimeType = getMimeType ( fileName ) ; // actually write generateDataURI ( bytes , writer , mimeType ) ; return writer . toString ( ) ; }", "nl": "Generate the dataUri as string associated to the passed InputStream with encoding & type based on provided fileName ."}}
{"translation": {"code": "private void processRequest ( final HttpServletRequest request , final HttpServletResponse response ) throws ServletException , IOException { setResponseHeaders ( response ) ; // process the uri using manager wroManagerFactory . create ( ) . process ( ) ; }", "nl": "Perform actual processing ."}}
{"translation": {"code": "private void registerChangeListeners ( ) { wroConfiguration . registerCacheUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( final PropertyChangeEvent event ) { // reset cache headers when any property is changed in order to avoid browser caching headersConfigurer = newResponseHeadersConfigurer ( ) ; wroManagerFactory . onCachePeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; } } ) ; wroConfiguration . registerModelUpdatePeriodChangeListener ( new PropertyChangeListener ( ) { public void propertyChange ( final PropertyChangeEvent event ) { headersConfigurer = newResponseHeadersConfigurer ( ) ; wroManagerFactory . onModelPeriodChanged ( valueAsLong ( event . getNewValue ( ) ) ) ; } } ) ; LOG . debug ( \"Cache & Model change listeners were registered\" ) ; }", "nl": "Register property change listeners ."}}
{"translation": {"code": "private WroConfiguration createConfiguration ( ) { // Extract config from servletContext (if already configured) // TODO use a named helper final WroConfiguration configAttribute = ServletContextAttributeHelper . create ( filterConfig ) . getWroConfiguration ( ) ; if ( configAttribute != null ) { setConfiguration ( configAttribute ) ; } return getWroConfigurationFactory ( ) . create ( ) ; }", "nl": "Creates configuration by looking up in servletContext attributes . If none is found a new one will be created using the configuration factory ."}}
{"translation": {"code": "private List < String > getAliasList ( final String aliasCsv ) { LOG . debug ( \"configured aliases: {}\" , aliasCsv ) ; final List < String > list = new ArrayList < String > ( ) ; if ( ! StringUtils . isEmpty ( aliasCsv ) ) { final String [ ] tokens = aliasCsv . split ( TOKEN_DELIMITER ) ; for ( final String token : tokens ) { list . add ( token . trim ( ) ) ; } } return list ; }", "nl": "Creates a list of aliases based on provided string containing comma separated values of aliases ."}}
{"translation": {"code": "public static String createItemsAsString ( final String ... items ) { final StringBuffer sb = new StringBuffer ( ) ; for ( int i = 0 ; i < items . length ; i ++ ) { sb . append ( items [ i ] ) ; if ( i < items . length - 1 ) { sb . append ( TOKEN_DELIMITER ) ; } } return sb . toString ( ) ; }", "nl": "Creates a comma separated list of items ."}}
{"translation": {"code": "public final void setConfiguration ( final WroConfiguration config ) { notNull ( config ) ; wroConfigurationFactory = new ObjectFactory < WroConfiguration > ( ) { public WroConfiguration create ( ) { return config ; } } ; }", "nl": "Once set this configuration will be used instead of the one built by the factory ."}}
{"translation": {"code": "private void checkResourceChange ( final Resource resource , final Group group , final Callback callback , final AtomicBoolean isChanged ) throws Exception { if ( isChanged ( resource , group . getName ( ) ) ) { isChanged . compareAndSet ( false , true ) ; callback . onResourceChanged ( resource ) ; lifecycleCallback . onResourceChanged ( resource ) ; } }", "nl": "Will check if a given resource was changed and will invoke the appropriate callback ."}}
{"translation": {"code": "public void check ( final CacheKey cacheKey , final Callback callback ) { notNull ( cacheKey ) ; LOG . debug ( \"started\" ) ; final StopWatch watch = new StopWatch ( ) ; watch . start ( \"detect changes\" ) ; try { final Group group = new WroModelInspector ( modelFactory . create ( ) ) . getGroupByName ( cacheKey . getGroupName ( ) ) ; if ( isGroupChanged ( group . collectResourcesOfType ( cacheKey . getType ( ) ) , callback ) ) { callback . onGroupChanged ( cacheKey ) ; cacheStrategy . put ( cacheKey , null ) ; } resourceChangeDetector . reset ( ) ; } catch ( final Exception e ) { onException ( e ) ; } finally { watch . stop ( ) ; LOG . debug ( \"resource watcher info: {}\" , watch . prettyPrint ( ) ) ; } }", "nl": "Check if resources from a group were changed . If a change is detected the changeListener will be invoked ."}}
{"translation": {"code": "private void parseHeader ( final String header ) { LOG . debug ( \"parseHeader: {}\" , header ) ; final String headerName = header . substring ( 0 , header . indexOf ( \":\" ) ) ; if ( ! headersMap . containsKey ( headerName ) ) { final String value = header . substring ( header . indexOf ( \":\" ) + 1 ) ; headersMap . put ( headerName , StringUtils . trim ( value ) ) ; } }", "nl": "Parse header value & puts the found values in headersMap field ."}}
{"translation": {"code": "private static void addNoCacheHeaders ( final Map < String , String > map ) { map . put ( HttpHeader . PRAGMA . toString ( ) , \"no-cache\" ) ; map . put ( HttpHeader . CACHE_CONTROL . toString ( ) , \"no-cache\" ) ; map . put ( HttpHeader . EXPIRES . toString ( ) , \"0\" ) ; }", "nl": "Populates the map with headers used to disable cache ."}}
{"translation": {"code": "public static WroModelFactory decorate ( final WroModelFactory decorated , final List < Transformer < WroModel > > modelTransformers ) { return decorated instanceof DefaultWroModelFactoryDecorator ? decorated : new DefaultWroModelFactoryDecorator ( decorated , modelTransformers ) ; }", "nl": "Factory method which takes care of redundant decoration ."}}
{"translation": {"code": "private Process createProcess ( final File sourceFile ) throws IOException { notNull ( sourceFile ) ; final String [ ] commandLine = getCommandLine ( sourceFile . getPath ( ) ) ; LOG . debug ( \"CommandLine arguments: {}\" , Arrays . asList ( commandLine ) ) ; return new ProcessBuilder ( commandLine ) . redirectErrorStream ( true ) . start ( ) ; }", "nl": "Creates process responsible for running lessc shell command by reading the file content from the sourceFilePath"}}
{"translation": {"code": "public static PathPatternProcessorDecorator exclude ( final Object processor , final String ... patterns ) { return new PathPatternProcessorDecorator ( processor , false , patterns ) ; }", "nl": "Decorates a processor which will not be applied on provided patterns ."}}
{"translation": {"code": "public static PathPatternProcessorDecorator include ( final Object processor , final String ... patterns ) { return new PathPatternProcessorDecorator ( processor , true , patterns ) ; }", "nl": "Decorates a processor which will be applied on provided patterns ."}}
{"translation": {"code": "public static void safeCopy ( final Reader reader , final Writer writer ) throws IOException { try { IOUtils . copy ( reader , writer ) ; } finally { IOUtils . closeQuietly ( reader ) ; IOUtils . closeQuietly ( writer ) ; } }", "nl": "Copy and close the reader and writer streams ."}}
{"translation": {"code": "public static File createTempFile ( final String extension ) { try { final String fileName = String . format ( \"wro4j-%s.%s\" , UUID . randomUUID ( ) . toString ( ) , extension ) ; final File file = new File ( createTempDirectory ( ) , fileName ) ; file . createNewFile ( ) ; return file ; } catch ( final IOException e ) { throw WroRuntimeException . wrap ( e ) ; } }", "nl": "Creates a temp file which has a certain extension ."}}
{"translation": {"code": "private List < T > filter ( final Collection < T > collection ) { final List < T > nullFreeList = new ArrayList < T > ( ) ; if ( collection != null ) { for ( final T item : collection ) { if ( item != null ) { nullFreeList . add ( item ) ; } } } return nullFreeList ; }", "nl": "This filtering is required in order to ensure that no nulls are passed ( which happens when using gson for deserializing json collection ."}}
{"translation": {"code": "public LintReport < T > addReport ( final ResourceLintReport < T > resourceLintReport ) { Validate . notNull ( resourceLintReport ) ; reports . add ( resourceLintReport ) ; return this ; }", "nl": "Add a single lint report to underlying collection ."}}
{"translation": {"code": "private Property [ ] parseProperties ( final String contents ) { final String [ ] parts = contents . split ( \";\" ) ; final List < Property > resultsAsList = new ArrayList < Property > ( ) ; for ( String part : parts ) { try { // ignore empty parts if ( ! StringUtils . isEmpty ( part . trim ( ) ) ) { resultsAsList . add ( new Property ( part ) ) ; } } catch ( final Exception e ) { LOG . warn ( e . getMessage ( ) , e ) ; } } return resultsAsList . toArray ( new Property [ resultsAsList . size ( ) ] ) ; }", "nl": "Parses out the properties of a selector s body ."}}
{"translation": {"code": "private Collection < Resource > getResourcesForGroup ( final String groupName ) { final WroModelInspector modelInspector = new WroModelInspector ( model ) ; final Group foundGroup = modelInspector . getGroupByName ( groupName ) ; if ( foundGroup == null ) { final Element groupElement = allGroupElements . get ( groupName ) ; if ( groupElement == null ) { throw new WroRuntimeException ( \"Invalid group-ref: \" + groupName ) ; } return parseGroup ( groupElement ) ; } return foundGroup . getResources ( ) ; }", "nl": "Search for all resources for a group with a given name ."}}
{"translation": {"code": "private GenericObjectPool < T > createObjectPool ( final ObjectFactory < T > objectFactory ) { final GenericObjectPool < T > pool = newObjectPool ( objectFactory ) ; notNull ( pool ) ; return pool ; }", "nl": "Ensure that a not null pool will be created ."}}
{"translation": {"code": "private String computeAbsoluteUrl ( final String relativeResourceUri , final String importUrl ) { final String folder = WroUtil . getFullPath ( relativeResourceUri ) ; // remove '../' & normalize the path. return StringUtils . cleanPath ( folder + importUrl ) ; }", "nl": "Computes absolute url of the imported resource ."}}
{"translation": {"code": "private List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { // it should be sorted final List < Resource > imports = new ArrayList < Resource > ( ) ; final String css = cssContent ; final List < String > foundImports = findImports ( css ) ; for ( final String importUrl : foundImports ) { final Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; // check if already exist if ( imports . contains ( importedResource ) ) { LOG . debug ( \"[WARN] Duplicate imported resource: {}\" , importedResource ) ; } else { imports . add ( importedResource ) ; onImportDetected ( importedResource . getUri ( ) ) ; } } return imports ; }", "nl": "Find a set of imported resources inside a given resource ."}}
{"translation": {"code": "protected void onException ( final Exception e ) { // not using ERROR log intentionally, since this error is not that important LOG . info ( \"Could not check for resource changes because: {}\" , e . getMessage ( ) ) ; LOG . debug ( \"[FAIL] detecting resource change \" , e ) ; }", "nl": "Invoked when exception occurs ."}}
{"translation": {"code": "public void updateHashForGroup ( final String hash , final String groupName ) { notNull ( groupName ) ; this . currentHash = hash ; if ( isChangedHash ( ) ) { LOG . debug ( \"Group {} has changed\" , groupName ) ; //remove all persisted groups. Starting over.. groups . clear ( ) ; } }", "nl": "Updates the hash associated with the resource for a give groupName ."}}
{"translation": {"code": "public boolean checkChangeForGroup ( final String uri , final String groupName ) throws IOException { notNull ( uri ) ; notNull ( groupName ) ; LOG . debug ( \"group={}, uri={}\" , groupName , uri ) ; final ResourceChangeInfo resourceInfo = changeInfoMap . get ( uri ) ; if ( resourceInfo . isCheckRequiredForGroup ( groupName ) ) { final InputStream inputStream = locatorFactory . locate ( uri ) ; try { final String currentHash = hashStrategy . getHash ( inputStream ) ; resourceInfo . updateHashForGroup ( currentHash , groupName ) ; } finally { IOUtils . closeQuietly ( inputStream ) ; } } return resourceInfo . isChanged ( groupName ) ; }", "nl": "Check if an uri from a particular group has changed ."}}
{"translation": {"code": "@ Override public String compile ( final String content , final String name ) { final String precompiledFunction = super . compile ( content , \"\" ) ; return String . format ( \"(function() {Ember.TEMPLATES[%s] = Ember.Handlebars.template(%s)})();\" , name , precompiledFunction ) ; }", "nl": "visible for testing the init of a HandlebarsJs template"}}
{"translation": {"code": "private String getCompilationCommand ( final String input ) { return String . format ( \"compilerWrapper.compile(%s, %s)\" , WroUtil . toJSMultiLineString ( input ) , ecmaScriptVersion ) ; }", "nl": "Creates compilation command for provided typescript input ."}}
{"translation": {"code": "private Process createProcess ( final File sourceFile , final File destFile ) throws IOException { notNull ( sourceFile ) ; final String [ ] commandLine = getCommandLine ( sourceFile . getPath ( ) , destFile . getPath ( ) ) ; LOG . debug ( \"CommandLine arguments: {}\" , Arrays . asList ( commandLine ) ) ; final Process process = new ProcessBuilder ( commandLine ) . redirectErrorStream ( true ) . start ( ) ; //Gobblers responsible for reading stream to avoid blocking of the process when the buffer is full. final StreamGobbler errorGobbler = new StreamGobbler ( process . getErrorStream ( ) , \"ERROR\" ) ; // any output? final StreamGobbler outputGobbler = new StreamGobbler ( process . getInputStream ( ) , \"OUTPUT\" ) ; // kick them off errorGobbler . start ( ) ; outputGobbler . start ( ) ; return process ; }", "nl": "Creates process responsible for running tsc shell command by reading the file content from the sourceFilePath"}}
{"translation": {"code": "private void doGzipResponse ( final HttpServletRequest req , final HttpServletResponse response , final FilterChain chain ) throws IOException , ServletException { LOG . debug ( \"Applying gzip on resource: \" + req . getRequestURI ( ) ) ; response . setHeader ( HttpHeader . CONTENT_ENCODING . toString ( ) , \"gzip\" ) ; final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final CountingOutputStream countingStream = new CountingOutputStream ( new GZIPOutputStream ( new BufferedOutputStream ( baos ) ) ) ; // final GZIPOutputStream gzout = new GZIPOutputStream(new BufferedOutputStream(baos)); // Perform gzip operation in-memory before sending response final HttpServletResponseWrapper wrappedResponse = new RedirectedStreamServletResponseWrapper ( countingStream , response ) ; chain . doFilter ( req , wrappedResponse ) ; // close underlying stream countingStream . close ( ) ; response . setContentLength ( countingStream . getCount ( ) ) ; // avoid NO CONTENT error thrown by jetty when gzipping empty response if ( countingStream . getCount ( ) > 0 ) { IOUtils . write ( baos . toByteArray ( ) , response . getOutputStream ( ) ) ; } }", "nl": "Performs actual gzip of the filtered content ."}}
{"translation": {"code": "public void logSummary ( ) { final String message = totalFoundErrors == 0 ? \"No lint errors found.\" : String . format ( \"Found %s errors in %s files.\" , totalFoundErrors , totalResourcesWithErrors ) ; log . info ( \"----------------------------------------\" ) ; log . info ( String . format ( \"Total resources: %s\" , totalResources ) ) ; log . info ( message ) ; log . info ( \"----------------------------------------\\n\" ) ; }", "nl": "Logs the summary as it was collected at this point ."}}
{"translation": {"code": "public synchronized void onProcessingResource ( final Resource resource ) { totalResources ++ ; log . debug ( \"processing resource: \" + resource . getUri ( ) ) ; if ( isLogRequired ( ) ) { log . info ( \"Processed until now: \" + getTotalResources ( ) + \". Last processed: \" + resource . getUri ( ) ) ; updateLastInvocation ( ) ; } }", "nl": "A method which should be invoked on each new resource processing having as a side effect an increment of the counter holding the number of total processed resources ."}}