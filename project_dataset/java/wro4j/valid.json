{"translation": {"code": "private boolean isMinimized ( final HttpServletRequest request ) { return context . getConfig ( ) . isMinimizeEnabled ( ) ? groupExtractor . isMinimized ( request ) : false ; }", "nl": "Uses isMinimizeEnabled configuration to compute minimize value ."}}
{"translation": {"code": "private String applyPreProcessors ( final Resource resource , final ProcessingCriteria criteria ) throws IOException { final Collection < ResourcePreProcessor > processors = processorsFactory . getPreProcessors ( ) ; LOG . debug ( \"applying preProcessors: {}\" , processors ) ; String resourceContent = null ; try { resourceContent = getResourceContent ( resource ) ; } catch ( final IOException e ) { LOG . debug ( \"Invalid resource found: {}\" , resource ) ; if ( Context . get ( ) . getConfig ( ) . isIgnoreMissingResources ( ) ) { return StringUtils . EMPTY ; } else { LOG . error ( \"Cannot ignore missing resource:  {}\" , resource ) ; throw e ; } } if ( ! processors . isEmpty ( ) ) { Writer writer = null ; for ( final ResourcePreProcessor processor : processors ) { final ResourcePreProcessor decoratedProcessor = decoratePreProcessor ( processor , criteria ) ; writer = new StringWriter ( ) ; final Reader reader = new StringReader ( resourceContent ) ; // decorate and process decoratedProcessor . process ( resource , reader , writer ) ; // use the outcome for next input resourceContent = writer . toString ( ) ; } } // add explicitly new line at the end to avoid unexpected comment issue return String . format ( \"%s%n\" , resourceContent ) ; }", "nl": "Apply a list of preprocessors on a resource ."}}
{"translation": {"code": "public String processAndMerge ( final List < Resource > resources , final ProcessingCriteria criteria ) throws IOException { notNull ( criteria ) ; LOG . debug ( \"criteria: {}\" , criteria ) ; callbackRegistry . onBeforeMerge ( ) ; try { notNull ( resources ) ; LOG . debug ( \"process and merge resources: {}\" , resources ) ; final StringBuffer result = new StringBuffer ( ) ; if ( shouldRunInParallel ( resources ) ) { result . append ( runInParallel ( resources , criteria ) ) ; } else { for ( final Resource resource : resources ) { LOG . debug ( \"\\tmerging resource: {}\" , resource ) ; result . append ( applyPreProcessors ( resource , criteria ) ) ; } } return result . toString ( ) ; } finally { callbackRegistry . onAfterMerge ( ) ; } }", "nl": "Apply preProcessors on resources and merge them ."}}
{"translation": {"code": "private void persistResourceFingerprints ( final List < String > groupNames ) { final WroModelInspector modelInspector = new WroModelInspector ( getModel ( ) ) ; for ( final String groupName : groupNames ) { final Group group = modelInspector . getGroupByName ( groupName ) ; if ( group != null ) { for ( final Resource resource : group . getResources ( ) ) { getResourceChangeHandler ( ) . remember ( resource ) ; } } } }", "nl": "Store digest for all resources contained inside the list of provided groups ."}}
{"translation": {"code": "private String rename ( final String group , final InputStream input ) throws Exception { try { final String newName = getManagerFactory ( ) . create ( ) . getNamingStrategy ( ) . rename ( group , input ) ; groupNames . setProperty ( group , newName ) ; return newName ; } catch ( final IOException e ) { throw new MojoExecutionException ( \"Error occured during renaming\" , e ) ; } }", "nl": "Encodes a version using some logic ."}}
{"translation": {"code": "private File computeDestinationFolder ( final ResourceType resourceType ) throws MojoExecutionException { File folder = destinationFolder ; if ( resourceType == ResourceType . JS ) { if ( jsDestinationFolder != null ) { folder = jsDestinationFolder ; } } if ( resourceType == ResourceType . CSS ) { if ( cssDestinationFolder != null ) { folder = cssDestinationFolder ; } } getLog ( ) . info ( \"folder: \" + folder ) ; if ( folder == null ) { throw new MojoExecutionException ( \"Couldn't compute destination folder for resourceType: \" + resourceType + \". That means that you didn't define one of the following parameters: \" + \"destinationFolder, cssDestinationFolder, jsDestinationFolder\" ) ; } if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } return folder ; }", "nl": "Computes the destination folder based on resource type ."}}
{"translation": {"code": "private void processGroup ( final String group , final File parentFoder ) throws Exception { ByteArrayOutputStream resultOutputStream = null ; InputStream resultInputStream = null ; try { getLog ( ) . info ( \"processing group: \" + group ) ; // mock request final HttpServletRequest request = Mockito . mock ( HttpServletRequest . class ) ; Mockito . when ( request . getContextPath ( ) ) . thenReturn ( normalizeContextPath ( contextPath ) ) ; Mockito . when ( request . getRequestURI ( ) ) . thenReturn ( group ) ; // mock response final HttpServletResponse response = Mockito . mock ( HttpServletResponse . class ) ; resultOutputStream = new ByteArrayOutputStream ( ) ; Mockito . when ( response . getOutputStream ( ) ) . thenReturn ( new DelegatingServletOutputStream ( resultOutputStream ) ) ; // init context final WroConfiguration config = Context . get ( ) . getConfig ( ) ; // the maven plugin should ignore empty groups, since it will try to process all types of resources. config . setIgnoreEmptyGroup ( true ) ; Context . set ( Context . webContext ( request , response , Mockito . mock ( FilterConfig . class ) ) , config ) ; Context . get ( ) . setAggregatedFolderPath ( getAggregatedPathResolver ( ) . resolve ( ) ) ; // perform processing getManagerFactory ( ) . create ( ) . process ( ) ; // encode version & write result to file resultInputStream = new UnclosableBufferedInputStream ( resultOutputStream . toByteArray ( ) ) ; final File destinationFile = new File ( parentFoder , rename ( group , resultInputStream ) ) ; final File parentFolder = destinationFile . getParentFile ( ) ; if ( ! parentFolder . exists ( ) ) { // make directories if required parentFolder . mkdirs ( ) ; } destinationFile . createNewFile ( ) ; // allow the same stream to be read again resultInputStream . reset ( ) ; getLog ( ) . debug ( \"Created file: \" + destinationFile . getName ( ) ) ; final OutputStream fos = new FileOutputStream ( destinationFile ) ; // use reader to detect encoding IOUtils . copy ( resultInputStream , fos ) ; fos . close ( ) ; // delete empty files if ( destinationFile . length ( ) == 0 ) { getLog ( ) . debug ( \"No content found for group: \" + group ) ; destinationFile . delete ( ) ; } else { getLog ( ) . info ( \"file size: \" + destinationFile . getName ( ) + \" -> \" + destinationFile . length ( ) + \" bytes\" ) ; getLog ( ) . info ( destinationFile . getAbsolutePath ( ) + \" (\" + destinationFile . length ( ) + \" bytes\" + \")\" ) ; } } finally { // instruct the build about the change in context of incremental build if ( getBuildContext ( ) != null ) { getBuildContext ( ) . refresh ( parentFoder ) ; } if ( resultOutputStream != null ) { resultOutputStream . close ( ) ; } if ( resultInputStream != null ) { resultInputStream . close ( ) ; } } }", "nl": "Process a single group ."}}
{"translation": {"code": "private synchronized ResourcePreProcessor decoratePreProcessor ( final ResourcePreProcessor processor , final ProcessingCriteria criteria ) { final ResourcePreProcessor decorated = new DefaultProcessorDecorator ( processor , criteria ) { @ Override public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { try { callbackRegistry . onBeforePreProcess ( ) ; super . process ( resource , reader , writer ) ; } finally { callbackRegistry . onAfterPreProcess ( ) ; } } } ; injector . inject ( decorated ) ; return decorated ; }", "nl": "Decorates preProcessor with mandatory decorators . This method is synchronized to ensure that processor is injected before it is being used by other thread ."}}
{"translation": {"code": "@ Override public InputStream locate ( final String uri ) throws IOException { validState ( standaloneContext != null , \"Locator was not initialized properly. StandaloneContext missing.\" ) ; Exception lastException = null ; final String [ ] contextFolders = standaloneContext . getContextFolders ( ) ; for ( final String contextFolder : contextFolders ) { try { return locateStreamWithContextFolder ( uri , contextFolder ) ; } catch ( final IOException e ) { lastException = e ; LOG . debug ( \"Could not locate: {} using contextFolder: {}\" , uri , contextFolder ) ; } } final String exceptionMessage = String . format ( \"No valid resource '%s' found inside any of contextFolders: %s\" , uri , Arrays . toString ( standaloneContext . getContextFolders ( ) ) ) ; throw new IOException ( exceptionMessage , lastException ) ; }", "nl": "This implementation will try to locate the provided resource inside contextFolder configured by standaloneContext . If a resource cannot be located the next contextFolder from the list will be tried . The first successful result will be returned ."}}
{"translation": {"code": "private void reloadModelWithNewValue ( final Long newValue ) { final long newValueAsPrimitive = newValue == null ? getModelUpdatePeriod ( ) : newValue ; for ( final PropertyChangeListener listener : modelUpdatePeriodListeners ) { final PropertyChangeEvent event = new PropertyChangeEvent ( this , \"model\" , getModelUpdatePeriod ( ) , newValueAsPrimitive ) ; listener . propertyChange ( event ) ; } }", "nl": "Notify all listeners about cachePeriod property changed . If passed newValue is null the oldValue is taken as new value . This is the case when the reloadModel is invoked ."}}
{"translation": {"code": "public void remember ( final Resource resource ) { final WroManager manager = getManagerFactory ( ) . create ( ) ; final HashStrategy hashStrategy = manager . getHashStrategy ( ) ; final UriLocatorFactory locatorFactory = manager . getUriLocatorFactory ( ) ; if ( rememberedSet . contains ( resource . getUri ( ) ) ) { // only calculate fingerprints and check imports if not already done getLog ( ) . debug ( \"Resource with uri '\" + resource . getUri ( ) + \"' has already been updated in this run.\" ) ; } else { try { final String fingerprint = hashStrategy . getHash ( locatorFactory . locate ( resource . getUri ( ) ) ) ; getBuildContextHolder ( ) . setValue ( resource . getUri ( ) , fingerprint ) ; rememberedSet . add ( resource . getUri ( ) ) ; getLog ( ) . debug ( \"Persist fingerprint for resource '\" + resource . getUri ( ) + \"' : \" + fingerprint ) ; if ( resource . getType ( ) == ResourceType . CSS ) { final Reader reader = new InputStreamReader ( locatorFactory . locate ( resource . getUri ( ) ) ) ; getLog ( ) . debug ( \"Check @import directive from \" + resource ) ; // persist fingerprints in imported resources. persistFingerprintsForCssImports ( resource , reader ) ; } } catch ( final IOException e ) { getLog ( ) . debug ( \"could not check fingerprint of resource: \" + resource ) ; } } }", "nl": "Will persist the information regarding the provided resource in some internal store . This information will be used later to check if the resource is changed ."}}
{"translation": {"code": "public static String createHandlerRequestPath ( final CacheKey cacheKey , final HttpServletRequest request ) { final String handlerQueryPath = getRequestHandlerPath ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; return request . getServletPath ( ) + handlerQueryPath ; }", "nl": "Computes the servlet context relative url to call this handler using a server - side invocation . Hides the details about creating a valid url and providing the authorization key required to invoke this handler ."}}
{"translation": {"code": "public InputStream locate ( final String uri ) throws IOException { final UriLocator locator = getInstance ( uri ) ; if ( locator == null ) { return getDecoratedObject ( ) . locate ( uri ) ; } return locator . locate ( uri ) ; }", "nl": "This implementation shows the problem with current design of locator implementation . Needs to be changed ."}}