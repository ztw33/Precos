{"translation": {"code": "def alexa ( self ) -> list : alexa_controls = [ control . alexa ( ) for control in self . controls ] return alexa_controls", "nl": "Returns list of Amazon Alexa compatible states of the RichMessage instance nested controls ."}}
{"translation": {"code": "def _verify_request ( self , signature_chain_url : str , signature : str , request_body : bytes ) -> bool : if signature_chain_url not in self . valid_certificates . keys ( ) : amazon_cert : X509 = verify_cert ( signature_chain_url ) if amazon_cert : amazon_cert_lifetime : timedelta = self . config [ 'amazon_cert_lifetime' ] expiration_timestamp = datetime . utcnow ( ) + amazon_cert_lifetime validated_cert = ValidatedCert ( cert = amazon_cert , expiration_timestamp = expiration_timestamp ) self . valid_certificates [ signature_chain_url ] = validated_cert log . info ( f'Certificate {signature_chain_url} validated' ) else : log . error ( f'Certificate {signature_chain_url} validation failed' ) return False else : validated_cert : ValidatedCert = self . valid_certificates [ signature_chain_url ] amazon_cert : X509 = validated_cert . cert if verify_signature ( amazon_cert , signature , request_body ) : result = True else : log . error ( f'Failed signature verification for request: {request_body.decode(\"utf-8\", \"replace\")}' ) result = False return result", "nl": "Conducts series of Alexa request verifications against Amazon Alexa requirements ."}}
{"translation": {"code": "def verify_cert ( signature_chain_url : str ) -> Optional [ crypto . X509 ] : try : certs_chain_get = requests . get ( signature_chain_url ) except requests . exceptions . ConnectionError as e : log . error ( f'Amazon signature chain get error: {e}' ) return None certs_chain_txt = certs_chain_get . text certs_chain = extract_certs ( certs_chain_txt ) amazon_cert : crypto . X509 = certs_chain . pop ( 0 ) # verify signature chain url sc_url_verification = verify_sc_url ( signature_chain_url ) if not sc_url_verification : log . error ( f'Amazon signature url {signature_chain_url} was not verified' ) # verify not expired expired_verification = not amazon_cert . has_expired ( ) if not expired_verification : log . error ( f'Amazon certificate ({signature_chain_url}) expired' ) # verify subject alternative names sans_verification = verify_sans ( amazon_cert ) if not sans_verification : log . error ( f'Subject alternative names verification for ({signature_chain_url}) certificate failed' ) # verify certs chain chain_verification = verify_certs_chain ( certs_chain , amazon_cert ) if not chain_verification : log . error ( f'Certificates chain verification for ({signature_chain_url}) certificate failed' ) result = ( sc_url_verification and expired_verification and sans_verification and chain_verification ) return amazon_cert if result else None", "nl": "Conducts series of Alexa SSL certificate verifications against Amazon Alexa requirements ."}}
{"translation": {"code": "def extract_certs ( certs_txt : str ) -> List [ crypto . X509 ] : pattern = r'-----BEGIN CERTIFICATE-----.+?-----END CERTIFICATE-----' certs_txt = re . findall ( pattern , certs_txt , flags = re . DOTALL ) certs = [ crypto . load_certificate ( crypto . FILETYPE_PEM , cert_txt ) for cert_txt in certs_txt ] return certs", "nl": "Extracts pycrypto X509 objects from SSL certificates chain string ."}}
{"translation": {"code": "def verify_signature ( amazon_cert : crypto . X509 , signature : str , request_body : bytes ) -> bool : signature = base64 . b64decode ( signature ) try : crypto . verify ( amazon_cert , signature , request_body , 'sha1' ) result = True except crypto . Error : result = False return result", "nl": "Verifies Alexa request signature ."}}
{"translation": {"code": "def _handle_unsupported ( self , request : dict ) -> dict : response = { 'response' : { 'shouldEndSession' : False , 'outputSpeech' : { 'type' : 'PlainText' , 'text' : self . config [ 'unsupported_message' ] } , 'card' : { 'type' : 'Simple' , 'content' : self . config [ 'unsupported_message' ] } } } response = self . _generate_response ( response , request ) return response", "nl": "Handles all unsupported types of Alexa requests . Returns standard message ."}}
{"translation": {"code": "def alexa ( self ) -> dict : response = { 'response' : { 'shouldEndSession' : False , 'outputSpeech' : { 'type' : 'PlainText' , 'text' : self . content } , 'card' : { 'type' : 'Simple' , 'content' : self . content } } } return response", "nl": "Returns Amazon Alexa compatible state of the PlainText instance ."}}
{"translation": {"code": "def _generate_response ( self , response : dict , request : dict ) -> dict : response_template = deepcopy ( self . response_template ) response_template [ 'sessionAttributes' ] [ 'sessionId' ] = request [ 'session' ] [ 'sessionId' ] for key , value in response_template . items ( ) : if key not in response . keys ( ) : response [ key ] = value return response", "nl": "Populates generated response with additional data conforming Alexa response specification ."}}
{"translation": {"code": "def _handle_launch ( self , request : dict ) -> dict : response = { 'response' : { 'shouldEndSession' : False , 'outputSpeech' : { 'type' : 'PlainText' , 'text' : self . config [ 'start_message' ] } , 'card' : { 'type' : 'Simple' , 'content' : self . config [ 'start_message' ] } } } response = self . _generate_response ( response , request ) return response", "nl": "Handles LaunchRequest Alexa request ."}}
{"translation": {"code": "def check_gpu_existence ( ) : global _gpu_available if _gpu_available is None : sess_config = tf . ConfigProto ( ) sess_config . gpu_options . allow_growth = True try : with tf . Session ( config = sess_config ) : device_list = device_lib . list_local_devices ( ) _gpu_available = any ( device . device_type == 'GPU' for device in device_list ) except AttributeError as e : log . warning ( f'Got an AttributeError `{e}`, assuming documentation building' ) _gpu_available = False return _gpu_available", "nl": "r Return True if at least one GPU is available"}}
{"translation": {"code": "def update_dict_recursive ( editable_dict : dict , editing_dict : dict ) -> None : for k , v in editing_dict . items ( ) : if isinstance ( v , collections . Mapping ) : update_dict_recursive ( editable_dict . get ( k , { } ) , v ) else : editable_dict [ k ] = v", "nl": "Updates dict recursively"}}
{"translation": {"code": "def prettify_metrics ( metrics : List [ Tuple [ str , float ] ] , precision : int = 4 ) -> OrderedDict : prettified_metrics = OrderedDict ( ) for key , value in metrics : value = round ( value , precision ) prettified_metrics [ key ] = value return prettified_metrics", "nl": "Prettifies the dictionary of metrics ."}}
{"translation": {"code": "def path_set_md5 ( url ) : scheme , netloc , path , query_string , fragment = urlsplit ( url ) path += '.md5' return urlunsplit ( ( scheme , netloc , path , query_string , fragment ) )", "nl": "Given a file URL return a md5 query of the file"}}
{"translation": {"code": "def get_momentum_variable ( self ) : optimizer = self . get_optimizer ( ) if hasattr ( optimizer , 'rho' ) : return optimizer . rho elif hasattr ( optimizer , 'beta_1' ) : return optimizer . beta_1 return None", "nl": "Extract values of momentum variables from optimizer"}}