{"translation": {"code": "def run ( self ) -> None : while True : request = self . input_queue . get ( ) response = self . _handle_request ( request ) self . output_queue . put ( response )", "nl": "Thread run method implementation ."}}
{"translation": {"code": "def _del_conversation ( self , conversation_key : str ) -> None : if conversation_key in self . conversations . keys ( ) : del self . conversations [ conversation_key ] log . info ( f'Deleted conversation, key: {conversation_key}' )", "nl": "Deletes Conversation instance ."}}
{"translation": {"code": "def _refresh_valid_certs ( self ) -> None : self . timer = Timer ( REFRESH_VALID_CERTS_PERIOD_SECS , self . _refresh_valid_certs ) self . timer . start ( ) expired_certificates = [ ] for valid_cert_url , valid_cert in self . valid_certificates . items ( ) : valid_cert : ValidatedCert = valid_cert cert_expiration_time : datetime = valid_cert . expiration_timestamp if datetime . utcnow ( ) > cert_expiration_time : expired_certificates . append ( valid_cert_url ) for expired_cert_url in expired_certificates : del self . valid_certificates [ expired_cert_url ] log . info ( f'Validation period of {expired_cert_url} certificate expired' )", "nl": "Conducts cleanup of periodical certificates with expired validation ."}}
{"translation": {"code": "def _handle_request ( self , request : dict ) -> dict : request_body : bytes = request [ 'request_body' ] signature_chain_url : str = request [ 'signature_chain_url' ] signature : str = request [ 'signature' ] alexa_request : dict = request [ 'alexa_request' ] if not self . _verify_request ( signature_chain_url , signature , request_body ) : return { 'error' : 'failed certificate/signature check' } timestamp_str = alexa_request [ 'request' ] [ 'timestamp' ] timestamp_datetime = datetime . strptime ( timestamp_str , '%Y-%m-%dT%H:%M:%SZ' ) now = datetime . utcnow ( ) delta = now - timestamp_datetime if now >= timestamp_datetime else timestamp_datetime - now if abs ( delta . seconds ) > REQUEST_TIMESTAMP_TOLERANCE_SECS : log . error ( f'Failed timestamp check for request: {request_body.decode(\"utf-8\", \"replace\")}' ) return { 'error' : 'failed request timestamp check' } conversation_key = alexa_request [ 'session' ] [ 'user' ] [ 'userId' ] if conversation_key not in self . conversations . keys ( ) : if self . config [ 'multi_instance' ] : conv_agent = self . _init_agent ( ) log . info ( 'New conversation instance level agent initiated' ) else : conv_agent = self . agent self . conversations [ conversation_key ] = Conversation ( config = self . config , agent = conv_agent , conversation_key = conversation_key , self_destruct_callback = lambda : self . _del_conversation ( conversation_key ) ) log . info ( f'Created new conversation, key: {conversation_key}' ) conversation = self . conversations [ conversation_key ] response = conversation . handle_request ( alexa_request ) return response", "nl": "Processes Alexa requests from skill server and returns responses to Alexa ."}}
{"translation": {"code": "def verify_sc_url ( url : str ) -> bool : parsed = urlsplit ( url ) scheme : str = parsed . scheme netloc : str = parsed . netloc path : str = parsed . path try : port = parsed . port except ValueError : port = None result = ( scheme . lower ( ) == 'https' and netloc . lower ( ) . split ( ':' ) [ 0 ] == 's3.amazonaws.com' and path . startswith ( '/echo.api/' ) and ( port == 443 or port is None ) ) return result", "nl": "Verify signature certificate URL against Amazon Alexa requirements ."}}
{"translation": {"code": "def _start_timer ( self ) -> None : self . timer = Timer ( self . config [ 'conversation_lifetime' ] , self . self_destruct_callback ) self . timer . start ( )", "nl": "Initiates self - destruct timer ."}}
{"translation": {"code": "def handle_request ( self , request : dict ) -> dict : request_type = request [ 'request' ] [ 'type' ] request_id = request [ 'request' ] [ 'requestId' ] log . debug ( f'Received request. Type: {request_type}, id: {request_id}' ) if request_type in self . handled_requests . keys ( ) : response : dict = self . handled_requests [ request_type ] ( request ) else : response : dict = self . handled_requests [ '_unsupported' ] ( request ) log . warning ( f'Unsupported request type: {request_type}, request id: {request_id}' ) self . _rearm_self_destruct ( ) return response", "nl": "Routes Alexa requests to appropriate handlers ."}}
{"translation": {"code": "def _act ( self , utterance : str ) -> list : if self . stateful : utterance = [ [ utterance ] , [ self . key ] ] else : utterance = [ [ utterance ] ] agent_response : list = self . agent ( * utterance ) return agent_response", "nl": "Infers DeepPavlov agent with raw user input extracted from Alexa request ."}}
{"translation": {"code": "def _handle_intent ( self , request : dict ) -> dict : intent_name = self . config [ 'intent_name' ] slot_name = self . config [ 'slot_name' ] request_id = request [ 'request' ] [ 'requestId' ] request_intent : dict = request [ 'request' ] [ 'intent' ] if intent_name != request_intent [ 'name' ] : log . error ( f\"Wrong intent name received: {request_intent['name']} in request {request_id}\" ) return { 'error' : 'wrong intent name' } if slot_name not in request_intent [ 'slots' ] . keys ( ) : log . error ( f'No slot named {slot_name} found in request {request_id}' ) return { 'error' : 'no slot found' } utterance = request_intent [ 'slots' ] [ slot_name ] [ 'value' ] agent_response = self . _act ( utterance ) if not agent_response : log . error ( f'Some error during response generation for request {request_id}' ) return { 'error' : 'error during response generation' } prediction : RichMessage = agent_response [ 0 ] prediction : list = prediction . alexa ( ) if not prediction : log . error ( f'Some error during response generation for request {request_id}' ) return { 'error' : 'error during response generation' } response = self . _generate_response ( prediction [ 0 ] , request ) return response", "nl": "Handles IntentRequest Alexa request ."}}
{"translation": {"code": "def verify_certs_chain ( certs_chain : List [ crypto . X509 ] , amazon_cert : crypto . X509 ) -> bool : store = crypto . X509Store ( ) # add certificates from Amazon provided certs chain for cert in certs_chain : store . add_cert ( cert ) # add CA certificates default_verify_paths = ssl . get_default_verify_paths ( ) default_verify_file = default_verify_paths . cafile default_verify_file = Path ( default_verify_file ) . resolve ( ) if default_verify_file else None default_verify_path = default_verify_paths . capath default_verify_path = Path ( default_verify_path ) . resolve ( ) if default_verify_path else None ca_files = [ ca_file for ca_file in default_verify_path . iterdir ( ) ] if default_verify_path else [ ] if default_verify_file : ca_files . append ( default_verify_file ) for ca_file in ca_files : ca_file : Path if ca_file . is_file ( ) : with ca_file . open ( 'r' , encoding = 'ascii' ) as crt_f : ca_certs_txt = crt_f . read ( ) ca_certs = extract_certs ( ca_certs_txt ) for cert in ca_certs : store . add_cert ( cert ) # add CA certificates (Windows) ssl_context = ssl . create_default_context ( ) der_certs = ssl_context . get_ca_certs ( binary_form = True ) pem_certs = '\\n' . join ( [ ssl . DER_cert_to_PEM_cert ( der_cert ) for der_cert in der_certs ] ) ca_certs = extract_certs ( pem_certs ) for ca_cert in ca_certs : store . add_cert ( ca_cert ) store_context = crypto . X509StoreContext ( store , amazon_cert ) try : store_context . verify_certificate ( ) result = True except crypto . X509StoreContextError : result = False return result", "nl": "Verifies if Amazon and additional certificates creates chain of trust to a root CA ."}}
{"translation": {"code": "def _get_best ( values : List [ float ] , losses : List [ float ] , max_loss_div : float = 0.9 , min_val_div : float = 10.0 ) -> float : assert len ( values ) == len ( losses ) , \"lengths of values and losses should be equal\" min_ind = np . argmin ( losses ) for i in range ( min_ind - 1 , 0 , - 1 ) : if ( losses [ i ] * max_loss_div > losses [ min_ind ] ) or ( values [ i ] * min_val_div < values [ min_ind ] ) : return values [ i + 1 ] return values [ min_ind ] / min_val_div", "nl": "Find the best value according to given losses"}}
{"translation": {"code": "def from_str ( cls , label : str ) -> int : label_norm = label . replace ( '1' , 'one' ) . upper ( ) if label_norm in cls . __members__ : return DecayType [ label_norm ] else : raise NotImplementedError", "nl": "Convert given string label of decay type to special index"}}
{"translation": {"code": "def set_query_parameter ( url , param_name , param_value ) : scheme , netloc , path , query_string , fragment = urlsplit ( url ) query_params = parse_qs ( query_string ) query_params [ param_name ] = [ param_value ] new_query_string = urlencode ( query_params , doseq = True ) return urlunsplit ( ( scheme , netloc , path , new_query_string , fragment ) )", "nl": "Given a URL set or replace a query parameter and return the modified URL ."}}
{"translation": {"code": "def _update_graph_variables ( self , learning_rate : float = None , momentum : float = None ) : if learning_rate is not None : K . set_value ( self . get_learning_rate_variable ( ) , learning_rate ) # log.info(f\"Learning rate = {learning_rate}\") if momentum is not None : K . set_value ( self . get_momentum_variable ( ) , momentum )", "nl": "Update graph variables setting giving learning_rate and momentum"}}