{"translation": {"code": "def delete_uneeded ( self ) : # We get the structure we have to apply. structure = self . _get_structure ( ) # We get the list of key which is implicitly the list of directory we do not bave to delete. list_of_key = list ( structure . keys ( ) ) # We move to the content of the parent as we know that we are creating only one directory. # Note: if one day we will have to create multiple directory, we will have to change # the following. structure = structure [ list_of_key [ 0 ] ] # We also set the parent directory as we are going to construct its childen. parent_path = list_of_key [ 0 ] if not parent_path . endswith ( PyFunceble . directory_separator ) : parent_path += PyFunceble . directory_separator for root , _ , _ in PyFunceble . walk ( parent_path ) : # We loop through each directories of the parent path. # We fix the path in order to avoid issues. root = Directory ( root ) . fix_path ( ) if root . replace ( parent_path , \"\" ) not in structure : # The currently read directory is not in our structure. # We delete it. PyFunceble . rmtree ( root )", "nl": "Delete the directory which are not registered into our structure ."}}
{"translation": {"code": "def _get_content ( cls , file ) : if PyFunceble . path . isfile ( file ) : return Dict ( ) . from_json ( File ( file ) . read ( ) ) return { }", "nl": "Get and return the content of the given log file ."}}
{"translation": {"code": "def stay_safe ( ) : # pragma: no cover random = int ( choice ( str ( int ( time ( ) ) ) ) ) if not CONFIGURATION [ \"quiet\" ] and random % 3 == 0 : print ( \"\\n\" + Fore . GREEN + Style . BRIGHT + \"Thanks for using PyFunceble!\" ) print ( Fore . YELLOW + Style . BRIGHT + \"Share your experience on \" + Fore . CYAN + \"Twitter\" + Fore . YELLOW + \" with \" + Fore . CYAN + \"#PyFunceble\" + Fore . YELLOW + \"!\" ) print ( Fore . GREEN + Style . BRIGHT + \"Have a feedback, an issue or an improvement idea ?\" ) print ( Fore . YELLOW + Style . BRIGHT + \"Let us know on \" + Fore . CYAN + \"GitHub\" + Fore . YELLOW + \"!\" )", "nl": "Print a friendly message ."}}
{"translation": {"code": "def get ( cls ) : if PyFunceble . INTERN [ \"to_test_type\" ] == \"domain\" : # We are testing for domain or ip. if Check ( ) . is_domain_valid ( ) or Check ( ) . is_ip_valid ( ) : # * The domain is valid. # or # * The IP is valid. # We handle and return the valid status. return SyntaxStatus ( PyFunceble . STATUS [ \"official\" ] [ \"valid\" ] ) . handle ( ) elif PyFunceble . INTERN [ \"to_test_type\" ] == \"url\" : # We are testing for URL. if Check ( ) . is_url_valid ( ) : # * The url is valid. # We handle and return the valid status. return SyntaxStatus ( PyFunceble . STATUS [ \"official\" ] [ \"valid\" ] ) . handle ( ) else : raise Exception ( \"Unknow test type.\" ) # We handle and return the invalid status. return SyntaxStatus ( PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] ) . handle ( )", "nl": "Execute the logic behind the Syntax handling ."}}
{"translation": {"code": "def url_syntax_check ( url ) : # pragma: no cover if url and isinstance ( url , str ) : # The given URL is not empty nor None. # and # * The given URL is a string. # We silently load the configuration. load_config ( True ) return Check ( url ) . is_url_valid ( ) # We return None, there is nothing to check. return None", "nl": "Check the syntax of the given URL ."}}
{"translation": {"code": "def url ( self , url_to_test = None , last_url = None ) : # We print the header. self . _print_header ( ) if url_to_test : # An url to test is given. # We set the url we are going to test. PyFunceble . INTERN [ \"to_test\" ] = url_to_test else : # An URL to test is not given. # We set the url we are going to test to None. PyFunceble . INTERN [ \"to_test\" ] = None if PyFunceble . INTERN [ \"to_test\" ] : # An URL to test is given. if PyFunceble . CONFIGURATION [ \"syntax\" ] : # The syntax mode is activated. # We get the status from Syntax. status = self . syntax_status . get ( ) else : # The syntax mode is not activated. # We get the status from URL. status = self . url_status . get ( ) # We run the file decision logic. self . _file_decision ( PyFunceble . INTERN [ \"to_test\" ] , last_url , status ) if PyFunceble . CONFIGURATION [ \"simple\" ] : # The simple mode is activated. # We print the URL informations. print ( PyFunceble . INTERN [ \"to_test\" ] , status ) # We return the URL we tested and its status. return PyFunceble . INTERN [ \"to_test\" ] , status # We return None, there is nothing to test. return None", "nl": "Manage the case that we want to test only a given url ."}}
{"translation": {"code": "def syntax_check ( domain ) : # pragma: no cover if domain and isinstance ( domain , str ) : # * The given domain is not empty nor None. # and # * The given domain is a string. # We silently load the configuration. load_config ( True ) return Check ( domain ) . is_domain_valid ( ) # We return None, there is nothing to check. return None", "nl": "Check the syntax of the given domain ."}}
{"translation": {"code": "def _load ( self ) : if \"PYFUNCEBLE_AUTO_CONFIGURATION\" not in PyFunceble . environ : # The auto configuration environment variable is not set. while True : # We infinitly loop until we get a reponse which is `y|Y` or `n|N`. # We ask the user if we should install and load the default configuration. response = input ( PyFunceble . Style . BRIGHT + PyFunceble . Fore . RED + \"A configuration key is missing.\\n\" + PyFunceble . Fore . RESET + \"Try to merge upstream configuration file into %s ? [y/n] \" % ( PyFunceble . Style . BRIGHT + self . path_to_config + PyFunceble . Style . RESET_ALL ) ) if isinstance ( response , str ) : # The response is a string if response . lower ( ) == \"y\" : # The response is a `y` or `Y`. # We merge the old values inside the new one. self . _merge_values ( ) # And we save. self . _save ( ) print ( PyFunceble . Style . BRIGHT + PyFunceble . Fore . GREEN + \"Done!\\n\" \"Please try again, if it happens again,\" \" please fill a new issue.\" ) # And we break the loop as we got a satisfied response. break elif response . lower ( ) == \"n\" : # The response is a `n` or `N`. # We inform the user that something went wrong. raise Exception ( \"Configuration key still missing.\" ) else : # The auto configuration environment variable is set. # We merge the old values inside the new one. self . _merge_values ( ) # And we save. self . _save ( )", "nl": "Execute the logic behind the merging ."}}
{"translation": {"code": "def merge ( self , to_merge , strict = True ) : # We initiate a variable which will save the # result result = [ ] if strict : # We are in strict mode. for index , element in enumerate ( to_merge ) : # We loop through each element of the list to merge # to the main dict. try : if isinstance ( element , dict ) and isinstance ( self . main_list [ index ] , dict ) : # The currently read element is a dict. # We merge its content into the main dict # and append into the result. result . append ( Dict ( self . main_list [ index ] ) . merge ( element ) ) elif isinstance ( element , list ) and isinstance ( self . main_list [ index ] , list ) : # The currently read element is a list. # We loop through this method. result . append ( List ( self . main_list [ index ] ) . merge ( element ) ) else : # The currently read element is not a list # nor a dict. # We append the element to the result. result . append ( element ) except IndexError : # pragma: no cover # The index does not exist. # Which means that for example one list is bigger # than the other one. # We append the element to the result. result . append ( element ) else : # We are not is strict mode. # We initiate the result with the main list. result = self . main_list for element in to_merge : # We loop through the element to merge. if element not in result : # The currently read element is not # in the result. # We append it to the result result . append ( element ) # We return the result. return result", "nl": "Merge to_merge into the given main list ."}}
{"translation": {"code": "def merge ( self , to_merge , strict = True ) : # We initiate a variable which will save our result. result = { } for element in to_merge : # We loop throught the given dict to merge. if element in self . main_dictionnary : # The currently read element is in the main dict. if isinstance ( to_merge [ element ] , dict ) and isinstance ( self . main_dictionnary [ element ] , dict ) : # They are in both side dict. # We merge the dict tree and save into result. result [ element ] = Dict ( self . main_dictionnary [ element ] ) . merge ( to_merge [ element ] ) elif isinstance ( to_merge [ element ] , list ) and isinstance ( self . main_dictionnary [ element ] , list ) : # They are in both side list. # We merge the lists and save into result. result [ element ] = List ( self . main_dictionnary [ element ] ) . merge ( to_merge [ element ] , strict ) else : # They are not list, not dict. # We append the currently read element to the result. result . update ( { element : to_merge [ element ] } ) else : # The currently read element is not into the main # dict. # We append the currently read element to the result. result . update ( { element : to_merge [ element ] } ) for element in self . main_dictionnary : # We loop through each element of the main dict. if element not in result : # The currently read element is not into # the result. # We append it to the result. result [ element ] = self . main_dictionnary [ element ] # We return the result. return result", "nl": "Merge the content of to_merge into the given main dictionnary ."}}
{"translation": {"code": "def _merge_values ( self ) : to_remove = [ ] self . new_config = Dict ( Dict ( self . upstream_config ) . merge ( PyFunceble . CONFIGURATION ) ) . remove_key ( to_remove )", "nl": "Simply merge the older into the new one ."}}
{"translation": {"code": "def _handle_options ( self , options ) : # We initiate a variable which will save our result result = [ ] # We initiate the regex which will be used to extract the domain listed # under the option domain= regex_domain_option = r\"domain=(.*)\" for option in options : # We loop through the list of option. try : # We try to extract the list of domains from the currently read # option. domains = Regex ( option , regex_domain_option , return_data = True , rematch = True , group = 0 ) . match ( ) [ - 1 ] if domains : # We could extract something. if self . aggressive : # pragma: no cover result . extend ( [ x for x in domains . split ( \"|\" ) if x and not x . startswith ( \"~\" ) ] ) else : # We return True. return True except TypeError : pass # We return the result. return result", "nl": "Handle the data from the options ."}}
{"translation": {"code": "def _extract_base ( self , element ) : if isinstance ( element , list ) : # The given element is a list. # We get the base of each element of the list. return [ self . _extract_base ( x ) for x in element ] # We get the base if it is an URL. base = self . checker . is_url_valid ( url = element , return_base = True ) if base : # It is an URL. # We return the extracted base. return base if \"/\" in element : # / is in the given element. # We return the first element before the # first / return element . split ( \"/\" ) [ 0 ] # / is not in the given element. # We return the given element. return element", "nl": "Extract the base of the given element ."}}