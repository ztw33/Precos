{"translation": {"code": "def get ( self ) : # pragma: no cover # We get the status of the domain validation. domain_validation = self . checker . is_domain_valid ( ) # We get the status of the IPv4 validation. ip_validation = self . checker . is_ip_valid ( ) if \"current_test_data\" in PyFunceble . INTERN : # The end-user want more information whith his test. # We update some index. PyFunceble . INTERN [ \"current_test_data\" ] . update ( { \"domain_syntax_validation\" : domain_validation , \"ip4_syntax_validation\" : ip_validation , } ) if ( domain_validation and not ip_validation or domain_validation or PyFunceble . CONFIGURATION [ \"local\" ] ) : # * The element is a valid domain. # and # * The element is not ahe valid IPv4. # or # * The element is a valid domain. # * We get the HTTP status code of the currently tested element. # and # * We try to get the element status from the IANA database. PyFunceble . INTERN . update ( { \"http_code\" : HTTPCode ( ) . get ( ) , \"referer\" : Referer ( ) . get ( ) } ) if not PyFunceble . INTERN [ \"referer\" ] : # We could not get the referer. # We parse the referer status into the upstream call. return PyFunceble . INTERN [ \"referer\" ] # The WHOIS record status is not into our list of official status. if PyFunceble . INTERN [ \"referer\" ] and not self . checker . is_subdomain ( ) : # * The iana database comparison status is not None. # and # * The domain we are testing is not a subdomain. # We try to extract the expiration date from the WHOIS record. # And we return the matched status. return self . _extract ( ) # The iana database comparison status is None. # We log our whois record if the debug mode is activated. Logs ( ) . whois ( self . whois_record ) # And we return None, we could not extract the expiration date. return None if ( ip_validation and not domain_validation or ip_validation or PyFunceble . CONFIGURATION [ \"local\" ] ) : # * The element is a valid IPv4. # and # * The element is not a valid domain. # or # * The element is a valid IPv4. # We get the HTTP status code. PyFunceble . INTERN [ \"http_code\" ] = HTTPCode ( ) . get ( ) # We log our whois record if the debug mode is activated. Logs ( ) . whois ( self . whois_record ) # And we return None, there is no expiration date to look for. return None # The validation was not passed. # We log our whois record if the debug mode is activated. Logs ( ) . whois ( self . whois_record ) # And we return False, the domain could not pass the IP and domains syntax validation. return False", "nl": "Execute the logic behind the meaning of ExpirationDate + return the matched status ."}}
{"translation": {"code": "def get ( self ) : # We initiate a variable which will save the result we are going # to return. result = { } if self . algorithm in self . valid_algorithms : # * The parsed path exist. # and # * The parsed algorithm is in the list of valid algorithms. if self . algorithm == \"all\" : # The parsed algorithm is `all`. # We remove `all` (the first element of the list) from # the list of valid algorithms because we are going to # loop through the list of valid algorithms. del self . valid_algorithms [ 0 ] for algo in self . valid_algorithms : # We loop through the list of valid algorithms. if self . path and path . isfile ( self . path ) : # The file path exist. # We save the hash into the result variable. result [ algo ] = self . _hash_file ( algo ) elif self . data : # * The path does not exist. # and # * The given data is not empty. # We save the hash into the result variable. result [ algo ] = self . _hash_data ( algo ) else : # pragma: no cover # All other case are met. # We return None. return None else : # The parsed algorithm is a specific one. if self . path and path . isfile ( self . path ) : # The file path exist. # We save the hash into the result variable. result [ self . algorithm ] = self . _hash_file ( self . algorithm ) elif self . data : # * The path does not exist. # and # * The given data is not empty. # We save the hash into the result variable. result [ self . algorithm ] = self . _hash_data ( self . algorithm ) else : # All the other case are met. # We return None. return None else : # pragma: no cover # The parsed algorithm is not in the list of valid algorithms. return None if self . algorithm != \"all\" and self . only_hash : # * The parsed algorithm is not equal to `all`. # and # * We only have to return the selected hash. # We return the selected algorithm. return result [ self . algorithm ] # * The parsed algorithm is equal to `all`. # or # * We do not have to return the selected hash. # We return all hashes. return result", "nl": "Return the hash of the given file"}}
{"translation": {"code": "def _hash_file ( self , algo ) : # We het the algorithm function. hash_data = getattr ( hashlib , algo ) ( ) with open ( self . path , \"rb\" ) as file : # We open an read the parsed path. # We read the content. content = file . read ( ) # We parse the content to the hash algorithm. hash_data . update ( content ) # And we extract and return the hash. return hash_data . hexdigest ( )", "nl": "Get the hash of the given file"}}
{"translation": {"code": "def almost_everything ( self , clean_all = False ) : # We get the list of file to delete. to_delete = self . file_to_delete ( ) if clean_all : # pragma: no cover to_delete . extend ( self . databases_to_delete ( ) ) for file in to_delete : # We loop through the list of file to delete. # And we delete the currently read file. File ( file ) . delete ( ) if clean_all : # pragma: no cover Load ( PyFunceble . CURRENT_DIRECTORY )", "nl": "Delete almost all discovered files ."}}
{"translation": {"code": "def file_to_delete ( cls ) : # We initiate the directory we have to look for. directory = PyFunceble . OUTPUT_DIRECTORY + PyFunceble . OUTPUTS [ \"parent_directory\" ] if not directory . endswith ( PyFunceble . directory_separator ) : # pragma: no cover # For safety, if it does not ends with the directory separator, we append it # to its end. directory += PyFunceble . directory_separator # We initiate a variable which will save the list of file to delete. result = [ ] for root , _ , files in PyFunceble . walk ( directory ) : # We walk in the directory and get all files and sub-directories. for file in files : # If there is files in the current sub-directory, we loop # through the list of files. if file not in [ \".gitignore\" , \".keep\" ] : # The file is not into our list of file we do not have to delete. if root . endswith ( PyFunceble . directory_separator ) : # The root ends with the directory separator. # We construct the path and append the full path to the result. result . append ( root + file ) else : # The root directory does not ends with the directory separator. # We construct the path by appending the directory separator # between the root and the filename and append the full path to # the result. result . append ( root + PyFunceble . directory_separator + file ) # pragma: no cover # We return our list of file to delete. return result", "nl": "Return the list of file to delete ."}}
{"translation": {"code": "def format_execution_time ( self , start = None , end = None ) : # We return the formatted execution time. return \":\" . join ( list ( self . _calculate ( start , end ) . values ( ) ) )", "nl": "Format the calculated time into a human readable format ."}}
{"translation": {"code": "def _calculate ( cls , start = None , end = None ) : if start and end : # The start and end time is explicitly given. # We get the difference between the ending and the starting time. time_difference = int ( end ) - int ( start ) else : # The start and end time is not explicitly given. # We get the difference between the ending and the starting time. time_difference = PyFunceble . INTERN [ \"end\" ] - PyFunceble . INTERN [ \"start\" ] # We initiate an OrderedDict. # Indeed, we use an ordered dict because we want the structuration and the # order to stay always the same. # As a dictionnary is always unordered, we can use it. Otherwise the time will # not be shown correctly. data = PyFunceble . OrderedDict ( ) # We calculate and append the day to our data. data [ \"days\" ] = str ( time_difference // ( 24 * 60 * 60 ) ) . zfill ( 2 ) # We calculate and append the hours to our data. data [ \"hours\" ] = str ( ( time_difference // ( 60 * 60 ) ) % 24 ) . zfill ( 2 ) # We calculate and append the minutes to our data. data [ \"minutes\" ] = str ( ( time_difference % 3600 ) // 60 ) . zfill ( 2 ) # We calculate and append the minutes to our data. data [ \"seconds\" ] = str ( time_difference % 60 ) . zfill ( 2 ) # We finaly return our data. return data", "nl": "calculate the difference between starting and ending time ."}}
{"translation": {"code": "def data ( self ) : #  pragma: no cover  pylint: disable=inconsistent-return-statements if isinstance ( self . data_to_print , list ) : # The data to print is a list. # We initiate the data we are going to print. to_print = { } # We initiate the size we are going to print. to_print_size = [ ] # We initiate a variable which will list the list of # alone case. alone_cases = [ \"Percentage\" , \"HTTP\" ] # we initiate a variable which will list the list of # template which does not need a header. without_header = [ \"FullHosts\" , \"PlainDomain\" ] if self . template . lower ( ) == \"json\" : # The template is the json template. if not PyFunceble . CONFIGURATION [ \"no_files\" ] and self . output : # * We are allowed to generate file. # and # * The given output is not empty. # We print the json file. return self . _json_print ( ) # We return nothing. return None if self . template not in alone_cases and self . template not in without_header : # * The template is not in the list of alone case. # and # * THe template is not in the list of template without header. # We get the template we should use. # Note: We basically only need the self.currently_used_header to be filled. self . header ( True ) # And we get the size from the header. to_print_size = self . _size_from_header ( self . currently_used_header ) elif self . template in without_header : # The template is in the list of template which does not need a header. for data in self . data_to_print : # We loop through the list of data to print. # And we construct the (spacement) size of the data to print. to_print_size . append ( str ( len ( data ) ) ) else : # We get the size from the given template name. to_print_size = self . _size_from_header ( self . headers [ self . template ] ) # We construct and format the data to print. to_print = self . _data_constructor ( to_print_size ) # We print the before header section. self . _before_header ( ) for data in self . _header_constructor ( to_print , False ) : # We loop through the formatted data. if self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"generic\" ] or self . template in [ \"Less\" , \"Percentage\" ] : # * The template is in the list of generic status. # or # * The template is in a specific list. if not self . only_on_file : # We are authorized to print on screen. # We colorify the data to print. colorified_data = self . _colorify ( data ) # And we print the data. print ( colorified_data ) if not PyFunceble . CONFIGURATION [ \"no_files\" ] and self . output : # * We are authorized to print on any file. # and # * The output is given. # We write our data into the printed file. File ( self . output ) . write ( data + \"\\n\" ) else : # This should never happend. If it's happens then there's a big issue # around data_to_print. raise Exception ( \"Please review Prints().data()\" )", "nl": "Management and input of data to the table ."}}
{"translation": {"code": "def _colorify ( self , data ) : if self . template in [ \"Generic\" , \"Less\" ] : # The template is in the list of template that need the coloration. if ( self . data_to_print [ 1 ] . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"up\" ] or self . data_to_print [ 1 ] . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"valid\" ] ) : # The status is in the list of up status. # We print the data with a green background. data = PyFunceble . Fore . BLACK + PyFunceble . Back . GREEN + data elif self . data_to_print [ 1 ] . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"down\" ] : # The status is in the list of down status. # We print the data with a red background. data = PyFunceble . Fore . BLACK + PyFunceble . Back . RED + data else : # The status is not in the list of up and down status. # We print the data with a cyan background. data = PyFunceble . Fore . BLACK + PyFunceble . Back . CYAN + data # We return the data. return data", "nl": "Retun colored string ."}}
{"translation": {"code": "def _size_from_header ( cls , header ) : # We initiate the result we are going to return. result = [ ] for data in header : # We lopp through the header. # And we append the size to our result. result . append ( header [ data ] ) # We return the result. return result", "nl": "Get the size of each columns from the header ."}}
{"translation": {"code": "def _data_constructor ( self , size ) : # We initiate a variable which will save what we are going to # return. result = PyFunceble . OrderedDict ( ) if len ( self . data_to_print ) == len ( size ) : # The length of the data to print is equal to the length of the given size. for i in range ( len ( self . data_to_print ) ) : # We loop until our iterator is less or equal to the length of the data # to print. # We initiate the result index and its size. result [ self . data_to_print [ i ] ] = size [ i ] else : # This should never happend. If it's happens then there is something # wrong from the inputed data. raise Exception ( \"Inputed: \" + str ( len ( self . data_to_print ) ) + \"; Size: \" + str ( len ( size ) ) ) # We return the constructed result. return result", "nl": "Construct the table of data according to given size ."}}
{"translation": {"code": "def header ( self , do_not_print = False ) : # pragma: no cover pylint: disable=too-many-branches if ( not PyFunceble . CONFIGURATION [ \"header_printed\" ] or self . template == \"Percentage\" or do_not_print ) : # * The header has not been already printed. # or # * The template is the `Percentage template`. # or # * We are authorized to print something. if ( self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"generic\" ] or self . template == \"Generic_File\" ) : # * The template is into the list of generic status. # or # * The template is equal to `Generic_File`. # The data to print is the Generic header. to_print = self . headers [ \"Generic\" ] if ( self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"generic\" ] and PyFunceble . HTTP_CODE [ \"active\" ] ) : # * The template is in the list of generic status. # and # * the http status code extraction is activated. # We remove the Analyze Date colomn from the data to print. to_print = Dict ( to_print ) . remove_key ( \"Analyze Date\" ) elif self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"up\" ] : # The template is in the list of up status. # We informations to print is the up header. to_print = self . headers [ PyFunceble . STATUS [ \"official\" ] [ \"up\" ] ] elif self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"valid\" ] : # The template is in the list of valid status. # We informations to print is the valid header. to_print = self . headers [ PyFunceble . STATUS [ \"official\" ] [ \"valid\" ] ] elif self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"down\" ] : # The template is in the list of down status. # We informations to print is the down header. to_print = self . headers [ PyFunceble . STATUS [ \"official\" ] [ \"down\" ] ] elif self . template . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"invalid\" ] : # The template is in the list of invalid status. # We informations to print is the invalid header. to_print = self . headers [ PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] ] elif ( self . template == \"Less\" or self . template == \"Percentage\" or self . template == \"HTTP\" ) : # pylint: disable=line-too-long # * The template is equal to `Less`. # or # * The template is equal to `Percentage`. # or # * The template is equal to `HTTP`. # We get the header with the help of the template name. to_print = self . headers [ self . template ] if self . template == \"Less\" and not PyFunceble . HTTP_CODE [ \"active\" ] : # * The template is equal to `Less`. # and # * The http status code extraction is deactivated. # We append the source index to the header. to_print [ \"Source\" ] = 10 if not PyFunceble . HTTP_CODE [ \"active\" ] : # * The http status code extraction is deactivated. # We remove the HTTP Code index from the data to print. to_print = Dict ( to_print ) . remove_key ( \"HTTP Code\" ) # We update the currently used header. self . currently_used_header = to_print if not do_not_print : # We are not authorized to print anything. # We generate the before header. self . _before_header ( ) for formatted_template in self . _header_constructor ( to_print ) : # We loop through the formatted template. if not self . only_on_file : # We do not have to print only on file. # We print on screen the formatted header template. print ( formatted_template ) if not PyFunceble . CONFIGURATION [ \"no_files\" ] and self . output : # An output destination is given. # We write the file with the formatted header template. File ( self . output ) . write ( formatted_template + \"\\n\" )", "nl": "Management and creation of templates of header . Please consider as header the title of each columns ."}}
{"translation": {"code": "def _header_constructor ( cls , data_to_print , header_separator = \"-\" , column_separator = \" \" ) : # We initiate a variable which will save the header data. header_data = [ ] # We initiate a variable which will save the header sizes. header_size = \"\" # We initiate the glue to set before the size. before_size = \"%-\" # We initiate the glue to set after the size. after_size = \"s\" if header_separator : # The header separator is not empty. # We initiate a variable which will save the list of # separator data. header_separator_data = [ ] # We get the length of the data to print. length_data_to_print = len ( data_to_print ) - 1 # We initiate an iterator. i = 0 for data in data_to_print : # We loop through the list of data. # We get the size of the currently read data. size = data_to_print [ data ] # We append the data to the header data list. header_data . append ( data ) # We construct the header size. # Note: our header size is formatted line %s-sizes # (the s at the end is part of the formatting.) header_size += before_size + str ( size ) + after_size if i < length_data_to_print : # The iterator is less than the length of data to print. # We append the the colomn separator to the header size. header_size += column_separator if header_separator : # The header separator is given. # We append the right size of separator to the list of # separator data. header_separator_data . append ( header_separator * size ) # We increase the iterator. i += 1 if header_separator : # The header separator is given. return [ # We return the formatted header (like we will do with print('%s' % 'hello')) header_size % tuple ( header_data ) , # We return the formatted header separator. header_size % tuple ( header_separator_data ) , ] # The header separator is not given. # We return the formetted header. return [ header_size % tuple ( header_data ) ]", "nl": "Construct header of the table according to template ."}}
{"translation": {"code": "def _before_header ( self ) : if ( not PyFunceble . CONFIGURATION [ \"no_files\" ] and self . output and not PyFunceble . path . isfile ( self . output ) ) : # * We are allowed to generate files. # and # * And output is given. # and # * The given output does not exist. # We initiate the information about what generated the file. link = \"# File generated by %s\\n\" % PyFunceble . LINKS [ \"repo\" ] # We initiate the information about the generation date of this file. date_of_generation = ( \"# Date of generation: %s \\n\\n\" % PyFunceble . CURRENT_TIME ) # We initiate a variable which will save the list of # templates which have to meet in order to write the before # header informations. authorized_templates = [ \"Generic_File\" , PyFunceble . STATUS [ \"official\" ] [ \"up\" ] , PyFunceble . STATUS [ \"official\" ] [ \"down\" ] , PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] , PyFunceble . STATUS [ \"official\" ] [ \"valid\" ] , \"Less\" , ] if self . template in authorized_templates : # The current header is in our list of authorized templated. # We get the header. header = ( self . _header_constructor ( self . currently_used_header , None ) [ 0 ] + \"\\n\" ) try : # We try to print the link, the date of generation and the header in the # given file. File ( self . output ) . write ( link + date_of_generation + header ) except UnboundLocalError : # We don't have any header. # We print the link and the date in the given file. File ( self . output ) . write ( link + date_of_generation )", "nl": "Print informations about PyFunceble and the date of generation of a file into a given path if doesn t exist ."}}
{"translation": {"code": "def update ( self ) : if not PyFunceble . CONFIGURATION [ \"quiet\" ] : # * The quiet mode is not activated. # We print on screen what we are doing. print ( \"Update of iana-domains-db\" , end = \" \" ) # We loop through the line of the iana website. for extension , referer in self . _extensions ( ) : if extension not in self . iana_db or self . iana_db [ extension ] != referer : # We add the extension to the databae. self . iana_db [ extension ] = referer # We save the content of the constructed database. Dict ( self . iana_db ) . to_json ( self . destination ) if not PyFunceble . CONFIGURATION [ \"quiet\" ] : # The quiet mode is not activated. # We indicate that the work is done without any issue. print ( PyFunceble . INTERN [ \"done\" ] )", "nl": "Update the content of the iana - domains - db file ."}}
{"translation": {"code": "def _extensions ( self ) : upstream_lines = ( Download ( self . iana_url , return_data = True ) . text ( ) . split ( '<span class=\"domain tld\">' ) ) # We extract the different extension from the currently readed line. regex_valid_extension = r\"(/domains/root/db/)(.*)(\\.html)\" for block in upstream_lines : if \"/domains/root/db/\" in block : # The link is in the line. # We try to extract the extension. matched = Regex ( block , regex_valid_extension , return_data = True , rematch = True ) . match ( ) [ 1 ] if matched : # The extraction is not empty or None. # We get the referer. referer = self . _referer ( matched ) # We yield the matched extension and its referer. yield ( matched , referer )", "nl": "Extract the extention from the given block . Plus get its referer ."}}
{"translation": {"code": "def _referer ( self , extension ) : # We get the a copy of the page. iana_record = self . lookup . whois ( PyFunceble . CONFIGURATION [ \"iana_whois_server\" ] , \"hello.%s\" % extension ) if iana_record and \"refer\" in iana_record : # The record is not empty. # We initiate a regex which will extract the referer. regex_referer = r\"(?s)refer\\:\\s+([a-zA-Z0-9._-]+)\\n\" # We try to extract the referer. matched = Regex ( iana_record , regex_referer , return_data = True , group = 1 ) . match ( ) if matched : # The referer was extracted successfully. # We return the matched referer. return matched # * The referer was not extracted successfully. # or # * The iana record is empty. if extension in self . manual_server : # The extension is in the list of manual entries. # We return the server which we set manually. return self . manual_server [ extension ] # We return None because we weren't able to get the server to call for # the given extension. return None", "nl": "Return the referer for the given extension ."}}
{"translation": {"code": "def unified_file ( self ) : if ( \"file_to_test\" in PyFunceble . INTERN and PyFunceble . INTERN [ \"file_to_test\" ] and PyFunceble . CONFIGURATION [ \"unified\" ] ) : # * We are not testing as an imported module. # and # * The unified file generation is activated. # We construct the path of the unified file. output = ( self . output_parent_dir + PyFunceble . OUTPUTS [ \"default_files\" ] [ \"results\" ] ) if PyFunceble . CONFIGURATION [ \"less\" ] : # We have to print less information. if PyFunceble . HTTP_CODE [ \"active\" ] : # The http status code request is activated. # We construct what we have to print. to_print = [ self . tested , self . domain_status , PyFunceble . INTERN [ \"http_code\" ] , ] else : # The http status code request is not activated. # We construct what we have to print. to_print = [ self . tested , self . domain_status , self . source ] # And we print the informations on file. Prints ( to_print , \"Less\" , output , True ) . data ( ) else : # The unified file generation is not activated. # We construct what we have to print. to_print = [ self . tested , self . domain_status , self . expiration_date , self . source , PyFunceble . INTERN [ \"http_code\" ] , PyFunceble . CURRENT_TIME , ] # And we print the information on file. Prints ( to_print , \"Generic_File\" , output , True ) . data ( )", "nl": "Generate unified file . Understand by that that we use an unified table instead of a separate table for each status which could result into a misunderstanding ."}}
{"translation": {"code": "def execute ( self ) : # We initiate a process and parse the command to it. process = Popen ( self . command , stdout = PIPE , stderr = PIPE , shell = True ) # We communicate the command and get the output and the error. ( output , error ) = process . communicate ( ) if process . returncode != 0 : # pragma: no cover # The return code is different to 0. # We return the decoded error. return self . _decode_output ( error ) # The return code (or exit code if you prefer) if equal to 0. # We return the decoded output of the executed command. return self . _decode_output ( output )", "nl": "Execute the given command ."}}
{"translation": {"code": "def remove_key ( self , key_to_remove ) : if isinstance ( self . main_dictionnary , dict ) : # The main dictionnary is a dictionnary if isinstance ( key_to_remove , list ) : # The parsed key to remove is a list. for key in key_to_remove : # We loop through the list of key to remove. # We delete the key from the dictionnary. del self . main_dictionnary [ key ] else : # The parsed key to remove is not a list. try : # We delete the given key from the dictionnary. del self . main_dictionnary [ key_to_remove ] except KeyError : pass # We return the final dictionnary. return self . main_dictionnary # The main dictionnary is not a dictionnary. # We return None. return None", "nl": "Remove a given key from a given dictionary ."}}
{"translation": {"code": "def rename_key ( self , key_to_rename , strict = True ) : if isinstance ( self . main_dictionnary , dict ) and isinstance ( key_to_rename , dict ) : # * The given main directory is a dictionnary. # and # * The given key to rename is a dictionnary. for old , new in key_to_rename . items ( ) : # We loop through the key to raname. if strict : # The strict method is activated. if old in self . main_dictionnary : # The old key is in the main dictionnary. # We initiate the new with the old and remove the old content. self . main_dictionnary [ new ] = self . main_dictionnary . pop ( old ) else : # The strict method is not activated. # We initiate the elements to rename. to_rename = { } for index in self . main_dictionnary : # We loop throught the indexes of the main dictionnary. if old in index : # The old key is into the index name. # We append the index name and the new index to our # local list to rename. to_rename . update ( { index : new [ : - 1 ] + index . split ( old ) [ - 1 ] } ) # We run this method against the local list to rename in order # to rename the element. self . main_dictionnary = Dict ( self . main_dictionnary ) . rename_key ( to_rename , True ) # We return the final list. return self . main_dictionnary # * The given main directory is not a dictionnary. # or # * The given key to rename is not a dictionnary. # We return None. return None", "nl": "Rename the given keys from the given dictionary ."}}
{"translation": {"code": "def to_json ( self , destination ) : try : with open ( destination , \"w\" ) as file : # We open the file we are going to write. # Note: We always overwrite the destination. # We save the current dictionnary into a json format. dump ( self . main_dictionnary , file , ensure_ascii = False , indent = 4 , sort_keys = True , ) except UnicodeEncodeError : # pragma: no cover with open ( destination , \"w\" , encoding = \"utf-8\" ) as file : # We open the file we are going to write. # Note: We always overwrite the destination. # We save the current dictionnary into a json format. dump ( self . main_dictionnary , file , ensure_ascii = False , indent = 4 , sort_keys = True , )", "nl": "Save a dictionnary into a JSON file ."}}
{"translation": {"code": "def whois ( cls , whois_server , domain = None , timeout = None ) : # pragma: no cover if domain is None : # The domain is not given (localy). # We consider the domain as the domain or IP we are currently testing. domain = PyFunceble . INTERN [ \"to_test\" ] if timeout is None : # The time is not given (localy). # We consider the timeout from the configuration as the timeout to use. timeout = PyFunceble . CONFIGURATION [ \"seconds_before_http_timeout\" ] if whois_server : # A whois server is given. # We initiate a PyFunceble.socket. req = PyFunceble . socket . socket ( PyFunceble . socket . AF_INET , PyFunceble . socket . SOCK_STREAM ) if timeout % 3 == 0 : # The timeout is modulo 3. # We report the timeout to our initiated PyFunceble.socket. req . settimeout ( timeout ) else : # The timeout is not modulo 3. # We report 3 seconds as the timeout to our initiated PyFunceble.socket. req . settimeout ( 3 ) try : # We try to connect to the whois server at the port 43. req . connect ( ( whois_server , 43 ) ) except PyFunceble . socket . error : # We got an error. # We return None. return None # We send end encode the domain we want the data from. req . send ( ( domain + \"\\r\\n\" ) . encode ( ) ) # We initiate a bytes variable which will save the response # from the server. response = b\"\" while True : # We loop infinitly. try : # We try to receive the data in a buffer of 4096 bytes. data = req . recv ( 4096 ) except ( PyFunceble . socket . timeout , ConnectionResetError ) : # We got an error. # We close the connection. req . close ( ) # And we return None. return None # Everything goes right. # We append data to the response we got. response += data if not data : # The data is empty. # We break the loop. break # We close the connection. req . close ( ) try : # We finally decode and return the response we got from the # server. return response . decode ( ) except UnicodeDecodeError : # We got an encoding error. # We decode the response. # Note: Because we don't want to deal with other issue, we # decided to use `replace` in order to automatically replace # all non utf-8 encoded characters. return response . decode ( \"utf-8\" , \"replace\" ) # The whois server is not given. # We return None. return None", "nl": "Implementation of UNIX whois ."}}
{"translation": {"code": "def nslookup ( cls ) : try : # We try to get the addresse information of the given domain or IP. if \"current_test_data\" in PyFunceble . INTERN : # pragma: no cover # The end-user want more information whith his test. if not Check ( ) . is_ip_valid ( ) : # The element we are testing is not an IP. # We request the address informations. request = PyFunceble . socket . getaddrinfo ( PyFunceble . INTERN [ \"to_test\" ] , 80 , 0 , 0 , PyFunceble . socket . IPPROTO_TCP , ) for sequence in request : # We loop through the sequence returned by the request. # We append the NS informations into the nslookup index. PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] . append ( sequence [ - 1 ] [ 0 ] ) else : # The element we are testing is an IP. request = PyFunceble . socket . gethostbyaddr ( PyFunceble . INTERN [ \"to_test\" ] ) # We append the NS informations into the nslookup index. PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"hostname\" ] = request [ 0 ] PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"aliases\" ] = request [ 1 ] PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"ips\" ] = request [ 2 ] else : if not Check ( ) . is_ip_valid ( ) : # The element we are testing is not an IP. PyFunceble . socket . getaddrinfo ( PyFunceble . INTERN [ \"to_test\" ] , 80 , 0 , 0 , PyFunceble . socket . IPPROTO_TCP , ) else : # The element we are testing is an IP. PyFunceble . socket . gethostbyaddr ( PyFunceble . INTERN [ \"to_test\" ] ) # It was done successfuly, we return True. # Note: we don't need to read the addresses so we consider as successful # as long as there is no error. return True except ( OSError , PyFunceble . socket . herror , PyFunceble . socket . gaierror ) : # One of the listed exception is matched. # It was done unsuccesfuly, we return False. return False", "nl": "Implementation of UNIX nslookup ."}}
{"translation": {"code": "def _travis ( self ) : if PyFunceble . CONFIGURATION [ \"travis\" ] : try : _ = PyFunceble . environ [ \"TRAVIS_BUILD_DIR\" ] time_autorisation = False try : time_autorisation = int ( PyFunceble . time ( ) ) >= int ( PyFunceble . INTERN [ \"start\" ] ) + ( int ( PyFunceble . CONFIGURATION [ \"travis_autosave_minutes\" ] ) * 60 ) except KeyError : if self . last and not self . bypass : raise Exception ( \"Please review the way `ExecutionTime()` is called.\" ) if self . last or time_autorisation or self . bypass : Percentage ( ) . log ( ) self . travis_permissions ( ) command = 'git add --all && git commit -a -m \"%s\"' if self . last or self . bypass : if PyFunceble . CONFIGURATION [ \"command_before_end\" ] : for line in Command ( PyFunceble . CONFIGURATION [ \"command_before_end\" ] ) . run ( ) : sys_stdout . write ( \"{}\\n\" . format ( line ) ) self . travis_permissions ( ) message = ( PyFunceble . CONFIGURATION [ \"travis_autosave_final_commit\" ] + \" [ci skip]\" ) Command ( command % message ) . execute ( ) else : if PyFunceble . CONFIGURATION [ \"command\" ] : for line in Command ( PyFunceble . CONFIGURATION [ \"command\" ] ) . run ( ) : sys_stdout . write ( \"{}\\n\" . format ( line ) ) self . travis_permissions ( ) Command ( command % PyFunceble . CONFIGURATION [ \"travis_autosave_commit\" ] ) . execute ( ) print ( Command ( \"git push origin %s\" % PyFunceble . CONFIGURATION [ \"travis_branch\" ] ) . execute ( ) ) exit ( 0 ) except KeyError : pass", "nl": "Logic behind autosave under Travis CI ."}}
{"translation": {"code": "def travis_permissions ( cls ) : if PyFunceble . CONFIGURATION [ \"travis\" ] : try : build_dir = PyFunceble . environ [ \"TRAVIS_BUILD_DIR\" ] commands = [ \"sudo chown -R travis:travis %s\" % ( build_dir ) , \"sudo chgrp -R travis %s\" % ( build_dir ) , \"sudo chmod -R g+rwX %s\" % ( build_dir ) , \"sudo chmod 777 -Rf %s.git\" % ( build_dir + PyFunceble . directory_separator ) , r\"sudo find %s -type d -exec chmod g+x '{}' \\;\" % ( build_dir ) , ] for command in commands : Command ( command ) . execute ( ) if Command ( \"git config core.sharedRepository\" ) . execute ( ) == \"\" : Command ( \"git config core.sharedRepository group\" ) . execute ( ) except KeyError : pass", "nl": "Set permissions in order to avoid issues before commiting ."}}
{"translation": {"code": "def content ( cls ) : # We initiate a variable which will save what we are going to return. result = [ ] if ( PyFunceble . CONFIGURATION [ \"inactive_database\" ] and PyFunceble . INTERN [ \"inactive_db\" ] ) : # * The database subsystem is activated. # and # * The database is not empty. for key in PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] : # We loop through the index of the current file database. if key == \"to_test\" : # The current key is `to_test`. # We continue to the next element. continue # We extend the result with the content of the currently read index. result . extend ( PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ key ] ) # We return the content of the database. return result", "nl": "Get the content of the database ."}}
{"translation": {"code": "def _timestamp ( self ) : if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : # The database subsystem is activated. if ( \"inactive_db\" in PyFunceble . INTERN and PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"inactive_db\" ] and PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] ) : # The file we are testing is into the database and its content # is not empty. # We get the indexes of the current file (in the dabase). database_keys = [ x for x in PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] . keys ( ) if x . isdigit ( ) ] if database_keys : # The list of keys is not empty. # We get the most recent date. recent_date = max ( database_keys ) else : # pragma: no cover # The list of keys is empty. # We return the current time. return int ( PyFunceble . time ( ) ) if int ( PyFunceble . time ( ) ) > int ( recent_date ) + self . one_day_in_seconds : # The most recent time was in more than one day. # We return the current time. return int ( PyFunceble . time ( ) ) # The most recent time was in less than one day. if int ( PyFunceble . time ( ) ) < int ( recent_date ) + self . days_in_seconds : # The most recent time was in less than the expected number of day for # retesting. # We return the most recent data. return int ( recent_date ) # The database subsystem is not activated. # We return the current time. return int ( PyFunceble . time ( ) )", "nl": "Get the timestamp where we are going to save our current list ."}}
{"translation": {"code": "def _backup ( self ) : if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : # The database subsystem is activated. # We save the current database state into the database file. Dict ( PyFunceble . INTERN [ \"inactive_db\" ] ) . to_json ( self . inactive_db_path )", "nl": "Save the current database into the inactive - db . json file ."}}
{"translation": {"code": "def _retrieve ( self ) : if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : # The database subsystem is activated. # We get, format and initiate the historical database file. self . _reformat_historical_formating_error ( ) if PyFunceble . path . isfile ( self . inactive_db_path ) : # The database file exist. # We merge our current database into already initiated one. self . _merge ( )", "nl": "Return the current content of the inactive - db . json file ."}}
{"translation": {"code": "def check_versions ( cls , local , upstream ) : # A version should be in format [1,2,3] which is actually the version `1.2.3` # So as we only have 3 elements in the versioning, # we initiate the following variable in order to get the status of each parts. status = [ None , None , None ] for index , version_number in enumerate ( local ) : # We loop through the local version. if int ( version_number ) < int ( upstream [ index ] ) : # The local version is less than the upstream version. # We initiate its status to True which means that we are in # an old version (for the current version part). status [ index ] = True elif int ( version_number ) > int ( upstream [ index ] ) : # The local version is greater then the upstream version. # We initiate its status to False which means that we are in # a more recent version (for the current version part). status [ index ] = False # Otherwise the status stay None which means that there is no change # between both local and upstream. if False in status : # There is a False in the status. # We return False which means that we are in a more recent version. return False if True in status : # There is a True in the status. # We return True which means that we are in a older version. return True # There is no True or False in the status. # We return None which means that we are in the same version as upstream. return None", "nl": "Compare the given versions ."}}
{"translation": {"code": "def log ( self ) : if ( PyFunceble . CONFIGURATION [ \"show_percentage\" ] and PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] > 0 ) : # * We are allowed to show the percentage on screen. # and # * The number of tested is greater than 0. # We initiate the output file. output = ( PyFunceble . OUTPUT_DIRECTORY + PyFunceble . OUTPUTS [ \"parent_directory\" ] + PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"parent\" ] + PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"percentage\" ] + PyFunceble . OUTPUTS [ \"logs\" ] [ \"filenames\" ] [ \"percentage\" ] ) # We delete the output file if it does exist. File ( output ) . delete ( ) # We calculate the percentage of each statuses. self . _calculate ( ) if not PyFunceble . CONFIGURATION [ \"quiet\" ] : # The quiet mode is activated. # We print a new line. print ( \"\\n\" ) # We print the percentage header on file and screen. Prints ( None , \"Percentage\" , output ) . header ( ) # We construct the different lines/data to print on screen and file. lines_to_print = [ [ PyFunceble . STATUS [ \"official\" ] [ \"up\" ] , str ( PyFunceble . INTERN [ \"counter\" ] [ \"percentage\" ] [ \"up\" ] ) + \"%\" , PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"up\" ] , ] , [ PyFunceble . STATUS [ \"official\" ] [ \"down\" ] , str ( PyFunceble . INTERN [ \"counter\" ] [ \"percentage\" ] [ \"down\" ] ) + \"%\" , PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"down\" ] , ] , [ PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] , str ( PyFunceble . INTERN [ \"counter\" ] [ \"percentage\" ] [ \"invalid\" ] ) + \"%\" , PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"invalid\" ] , ] , ] if PyFunceble . CONFIGURATION [ \"syntax\" ] : # We are checking for syntax. # We update the denomination of the UP. lines_to_print [ 0 ] [ 0 ] = PyFunceble . STATUS [ \"official\" ] [ \"valid\" ] # And we unset the INACTIVE line. del lines_to_print [ 1 ] for to_print in lines_to_print : # We loop throught the different line to print. # (one line for each status.) # And we print the current status line on file and screen. Prints ( to_print , \"Percentage\" , output ) . data ( ) elif PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] > 0 : # * We are not allowed to show the percentage on screen. # but # * The number of tested is greater than 0. # We run the calculation. # Note: The following is needed, because all counter calculation are # done by this class. self . _calculate ( )", "nl": "Print on screen and on file the percentages for each status ."}}
{"translation": {"code": "def count ( self ) : if self . status : # The status is parsed. # We increase the number of tested. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] += 1 if ( self . status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"up\" ] or self . status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"valid\" ] ) : # The status is in the list of up status. # We increase the number of up. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"up\" ] += 1 elif self . status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"down\" ] : # The status is in the list of down status. # We increase the number of down. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"down\" ] += 1 else : # The status is not in the list of up nor down status. # We increase the number of invalid. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"invalid\" ] += 1", "nl": "Count the number of domain for each status ."}}
{"translation": {"code": "def replace ( self ) : if self . replace_with : # pylint: disable=no-member return substrings ( self . regex , self . replace_with , # pylint: disable=no-member self . data , self . occurences , # pylint: disable=no-member ) return self . data", "nl": "Used to replace a matched string with another ."}}
{"translation": {"code": "def match ( self ) : # We initate this variable which gonna contain the returned data result = [ ] # We compile the regex string to_match = comp ( self . regex ) # In case we have to use the implementation of ${BASH_REMATCH} we use # re.findall otherwise, we use re.search if self . rematch : # pylint: disable=no-member pre_result = to_match . findall ( self . data ) else : pre_result = to_match . search ( self . data ) if self . return_data and pre_result : # pylint: disable=no-member if self . rematch : # pylint: disable=no-member for data in pre_result : if isinstance ( data , tuple ) : result . extend ( list ( data ) ) else : result . append ( data ) if self . group != 0 : # pylint: disable=no-member return result [ self . group ] # pylint: disable=no-member else : result = pre_result . group ( self . group # pylint: disable=no-member ) . strip ( ) return result if not self . return_data and pre_result : # pylint: disable=no-member return True return False", "nl": "Used to get exploitable result of re . search"}}
{"translation": {"code": "def not_matching_list ( self ) : pre_result = comp ( self . regex ) return [ x for x in self . data if not pre_result . search ( str ( x ) ) ]", "nl": "Return a list of string which don t match the given regex ."}}
{"translation": {"code": "def format ( self ) : try : return sorted ( list ( set ( self . main_list ) ) , key = str . lower ) except TypeError : # pragma: no cover return self . main_list", "nl": "Return a well formatted list . Basicaly it s sort a list and remove duplicate ."}}
{"translation": {"code": "def read ( self ) : try : with open ( self . file , \"r\" , encoding = \"utf-8\" ) as file : # We open and read a file. # We get the file content. funilrys = file . read ( ) except UnicodeDecodeError : # pragma: no cover with open ( self . file , \"r\" ) as file : # We open and read a file. # We get the file content. funilrys = file . read ( ) # We return the file content. return funilrys", "nl": "Read a given file path and return its content ."}}
{"translation": {"code": "def write ( self , data_to_write , overwrite = False ) : if overwrite or not path . isfile ( self . file ) : # * We have to overwrite the file data. # or # * The file path does not already exist. with open ( self . file , \"w\" , encoding = \"utf-8\" , newline = \"\\n\" ) as file : # We prepare the file for writting. if data_to_write and isinstance ( data_to_write , str ) : # * A data  to write is given. # and # * The data to write is a string # We write the string into the file. file . write ( data_to_write ) else : # * We do not have to overwrite the file data. # or # * The file path does already exist. with open ( self . file , \"a\" , encoding = \"utf-8\" , newline = \"\\n\" ) as file : # We prepare the file for append writting. if data_to_write and isinstance ( data_to_write , str ) : # * A data  to write is given. # and # * The data to write is a string # We append the string into the file. file . write ( data_to_write )", "nl": "Write or append data into the given file path ."}}
{"translation": {"code": "def fix_path ( self , splited_path = None ) : if not splited_path : # A splited path is parsed. # We initate a variable which will save the splited path. split_path = [ ] if self . directory : # The parsed directory is not empty or equal to None. if \"/\" in self . directory : # We split the separator. split_path = self . directory . split ( \"/\" ) elif \"\\\\\" in self . directory : # We split the separator. split_path = self . directory . split ( \"\\\\\" ) else : split_path = [ self . directory ] # We run the same function with the splited_path argument filled. return self . fix_path ( splited_path = [ x for x in split_path if x ] ) # We return the directory. return self . directory # We join the splited element with the directory separator as glue. return directory_separator . join ( splited_path ) + directory_separator", "nl": "Fix the path of the given path ."}}
{"translation": {"code": "def _calculate ( cls ) : # We map the current state/counters of the different status. percentages = { \"up\" : PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"up\" ] , \"down\" : PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"down\" ] , \"invalid\" : PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"invalid\" ] , } for percentage in percentages : # We loop through our map index. # We calculate the percentage. calculation = ( percentages [ percentage ] * 100 // PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] ) # And we update the percentage counter of the actual status. PyFunceble . INTERN [ \"counter\" ] [ \"percentage\" ] . update ( { percentage : calculation } )", "nl": "Calculate the percentage of each status ."}}
{"translation": {"code": "def split_versions ( cls , version , return_non_digits = False ) : # We split the version. splited_version = version . split ( \".\" ) # We split the parsed version and keep the digits. digits = [ x for x in splited_version if x . isdigit ( ) ] if not return_non_digits : # We do not have to return the non digits part of the version. # We return the digits part of the version. return digits # We have to return the non digit parts of the version. # We split the parsed version and keep the non digits. non_digits = [ x for x in splited_version if not x . isdigit ( ) ] # We return a tuple with first the digits part and finally the non digit parts. return ( digits , non_digits [ 0 ] )", "nl": "Convert the versions to a shorter one ."}}
{"translation": {"code": "def get ( self ) : if not PyFunceble . CONFIGURATION [ \"local\" ] : # We are not running a test in a local network. if self . domain_extension not in self . ignored_extension : # The extension of the domain we are testing is not into # the list of ignored extensions. # We set the referer to None as we do not have any. referer = None if self . domain_extension in PyFunceble . INTERN [ \"iana_db\" ] : # The domain extension is in the iana database. if not PyFunceble . CONFIGURATION [ \"no_whois\" ] : # We are authorized to use WHOIS for the test result. # We get the referer from the database. referer = PyFunceble . INTERN [ \"iana_db\" ] [ self . domain_extension ] if not referer : # The referer is not filled. # We log the case of the current extension. Logs ( ) . referer_not_found ( self . domain_extension ) # And we handle and return None status. return None # The referer is into the database. # We return the extracted referer. return referer # We are not authorized to use WHOIS for the test result. # We return None. return None # The domain extension is not in the iana database. # We return False, it is an invalid domain. return False # The extension of the domain we are testing is not into # the list of ignored extensions. # We return None, the domain does not have a whois server. return None # We are running a test in a local network. # We return None. return None", "nl": "Return the referer aka the WHOIS server of the current domain extension ."}}
{"translation": {"code": "def restore ( self ) : if PyFunceble . CONFIGURATION [ \"auto_continue\" ] and self . backup_content : # The auto_continue subsystem is activated and the backup_content # is not empty. # We get the file we have to restore. file_to_restore = PyFunceble . INTERN [ \"file_to_test\" ] if file_to_restore in self . backup_content : # The file we are working with is already into the backup content. # We initiate the different status to set. to_initiate = [ \"up\" , \"down\" , \"invalid\" , \"tested\" ] # Because at some time it was not the current status, we have to map # the new with the old. This way, if someone is running the latest # version but with old data, we still continue like nothing happend. alternatives = { \"up\" : \"number_of_up\" , \"down\" : \"number_of_down\" , \"invalid\" : \"number_of_invalid\" , \"tested\" : \"number_of_tested\" , } for string in to_initiate : # We loop over the status we have to initiate. try : # We try to update the counters by using the currently read status. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] . update ( { string : self . backup_content [ file_to_restore ] [ string ] } ) except KeyError : # But if the status is not present, we try with the older index # we mapped previously. PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] . update ( { string : self . backup_content [ file_to_restore ] [ alternatives [ string ] ] } )", "nl": "Restore data from the given path ."}}
{"translation": {"code": "def _extract_domain_from_file ( cls ) : # We initiate the variable which will save what we are going to return. result = [ ] if PyFunceble . path . isfile ( PyFunceble . INTERN [ \"file_to_test\" ] ) : # The give file to test exist. try : with open ( PyFunceble . INTERN [ \"file_to_test\" ] ) as file : # We open and read the file. for line in file : # We loop through each lines. if not line . startswith ( \"#\" ) : # The currently read line is not a commented line. # We append the current read line to the result. result . append ( line . rstrip ( \"\\n\" ) . strip ( ) ) except UnicodeDecodeError : with open ( PyFunceble . INTERN [ \"file_to_test\" ] , encoding = \"utf-8\" ) as file : # We open and read the file. for line in file : # We loop through each lines. if not line . startswith ( \"#\" ) : # The currently read line is not a commented line. # We append the current read line to the result. result . append ( line . rstrip ( \"\\n\" ) . strip ( ) ) else : # The given file to test does not exist. # We raise a FileNotFoundError exception. raise FileNotFoundError ( PyFunceble . INTERN [ \"file_to_test\" ] ) # We return the result. return result", "nl": "Extract all non commented lines from the file we are testing ."}}
{"translation": {"code": "def domain ( self , domain = None , last_domain = None ) : # We print the header. self . _print_header ( ) if domain : # A domain is given. # We format and set the domain we are testing and treating. PyFunceble . INTERN [ \"to_test\" ] = self . _format_domain ( domain ) else : # A domain is not given. # We set the domain we are testing and treating to None. PyFunceble . INTERN [ \"to_test\" ] = None if PyFunceble . INTERN [ \"to_test\" ] : # The domain is given (Not None). if PyFunceble . CONFIGURATION [ \"syntax\" ] : # The syntax mode is activated. # We get the status from Syntax. status = self . syntax_status . get ( ) else : # We test and get the status of the domain. status , _ = self . status . get ( ) # We run the file decision logic. self . _file_decision ( PyFunceble . INTERN [ \"to_test\" ] , last_domain , status ) if PyFunceble . CONFIGURATION [ \"simple\" ] : # The simple mode is activated. # We print the domain and the status. print ( PyFunceble . INTERN [ \"to_test\" ] , status ) # We return the tested domain and its status. return PyFunceble . INTERN [ \"to_test\" ] , status # We return None, there is nothing to test. return None", "nl": "Manage the case that we want to test only a domain ."}}
{"translation": {"code": "def switch ( cls , variable , custom = False ) : # pylint: disable=inconsistent-return-statements if not custom : # We are not working with custom variable which is not into # the configuration. # We get the current state. current_state = dict . get ( PyFunceble . CONFIGURATION , variable ) else : # We are working with a custom variable which is not into the # configuration current_state = variable if isinstance ( current_state , bool ) : # The current state is a boolean. if current_state : # The current state is equal to True. # We return False. return False # The current state is equal to False. # We return True. return True # The current state is not a boolean. # We set the message to raise. to_print = \"Impossible to switch %s. Please post an issue to %s\" # We raise an exception inviting the user to report an issue. raise Exception ( to_print % ( repr ( variable ) , PyFunceble . LINKS [ \"repo\" ] + \"/issues.\" ) )", "nl": "Switch PyFunceble . CONFIGURATION variables to their opposite ."}}
{"translation": {"code": "def get ( cls ) : if \"to_test\" in PyFunceble . INTERN and PyFunceble . INTERN [ \"to_test\" ] : expiration_date = ExpirationDate ( ) . get ( ) if expiration_date is False : return cls . handle ( status = \"invalid\" ) if expiration_date == PyFunceble . STATUS [ \"official\" ] [ \"up\" ] : return expiration_date , \"WHOIS\" return cls . handle ( status = \"inactive\" ) raise NotImplementedError ( \"We expect `INTERN['to_test']` to be set.\" )", "nl": "Get the status while testing for an IP or domain ."}}
{"translation": {"code": "def _get_structure ( self ) : # We initiate an empty variable which is going to save the location of # file we are going to download. structure_file = \"\" # We initiate the variable which will save the request instance. req = \"\" if PyFunceble . path . isfile ( self . structure ) : # The structure path file exist. # We set it as the destination file. structure_file = self . structure elif PyFunceble . path . isfile ( self . base + \"dir_structure_production.json\" ) : # * The structure path file does not exist. # but # * The production structure path file exist. # We set it as the destination file structure_file = self . base + \"dir_structure_production.json\" else : # * The structure path file does not exist. # and # * The production structure path file does not exist. if \"dev\" not in PyFunceble . VERSION : # `dev` is not into the local version name. # We get the production file from the master branch. req = PyFunceble . requests . get ( PyFunceble . LINKS [ \"dir_structure\" ] . replace ( \"dev\" , \"master\" ) ) else : # `dev` is into the local version name. # We get the production file from the dev branch. req = PyFunceble . requests . get ( PyFunceble . LINKS [ \"dir_structure\" ] . replace ( \"master\" , \"dev\" ) ) if structure_file . endswith ( \"_production.json\" ) : # The destination is the production file. # And we return the updated the structure from the last read file. # (with the names from the configuration file). return self . _update_structure_from_config ( Dict ( ) . from_json ( File ( structure_file ) . read ( ) ) ) # The destination is not the production file. if structure_file . endswith ( \".json\" ) : # The destination ends with `.json`. # And we return the updated the structure from the given file. # (with the names from the configuration file). return self . _update_structure_from_config ( Dict ( ) . from_json ( File ( structure_file ) . read ( ) ) ) # The destination does not ends with `.json`. # We return the updated the structure from the link we previously got. # (with the names from the configuration file). return self . _update_structure_from_config ( Dict ( ) . from_json ( req . text ) )", "nl": "Get the structure we are going to work with ."}}
{"translation": {"code": "def _file_decision ( self , current , last , status = None ) : if ( status and not PyFunceble . CONFIGURATION [ \"simple\" ] and PyFunceble . INTERN [ \"file_to_test\" ] ) : # * The status is given. # and # * The simple mode is deactivated. # and # * A file to test is set. # We run the mining logic. self . mining . process ( ) # We delete the currently tested element from the mining # database. # Indeed, as it is tested, it is already in our # testing process which means that we don't need it into # the mining database. self . mining . remove ( ) if ( status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"up\" ] or status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"valid\" ] ) : # The status is in the list of up status. if self . inactive_database . is_present ( ) : # The currently tested element is in the database. # We generate the suspicious file(s). Generate ( PyFunceble . STATUS [ \"official\" ] [ \"up\" ] ) . analytic_file ( \"suspicious\" ) # We remove the currently tested element from the # database. self . inactive_database . remove ( ) else : # The status is not in the list of up status. # We add the currently tested element to the # database. self . inactive_database . add ( ) # We backup the current state of the file reading # for the case that we need to continue later. self . auto_continue . backup ( ) if current != last : # The current element is not the last one. # We run the autosave logic. AutoSave ( ) else : # The current element is the last one. # We stop and log the execution time. ExecutionTime ( \"stop\" , last = True ) # We show/log the percentage. self . percentage . log ( ) # We reset the counters as we end the process. self . reset_counters ( ) # We backup the current state of the file reading # for the case that we need to continue later. self . auto_continue . backup ( ) # We show the colored logo. self . colorify_logo ( ) # We save and stop the script if we are under # Travis CI. AutoSave ( True ) for index in [ \"http_code\" , \"referer\" ] : # We loop through some configuration index we have to empty. if index in PyFunceble . INTERN : # The index is in the configuration. # We empty the configuration index. PyFunceble . INTERN [ index ] = \"\"", "nl": "Manage the database autosave and autocontinue systems for the case that we are reading a file ."}}
{"translation": {"code": "def _print_header ( cls ) : if ( not PyFunceble . CONFIGURATION [ \"quiet\" ] and not PyFunceble . CONFIGURATION [ \"header_printed\" ] ) : # * The quiet mode is not activated. # and # * The header has not been already printed. # We print a new line. print ( \"\\n\" ) if PyFunceble . CONFIGURATION [ \"less\" ] : # We have to show less informations on screen. # We print the `Less` header. Prints ( None , \"Less\" ) . header ( ) else : # We have to show every informations on screen. # We print the `Generic` header. Prints ( None , \"Generic\" ) . header ( ) # The header was printed. # We initiate the variable which say that the header has been printed to True. PyFunceble . CONFIGURATION [ \"header_printed\" ] = True", "nl": "Decide if we print or not the header ."}}
{"translation": {"code": "def load_config ( under_test = False , custom = None ) : # pragma: no cover if \"config_loaded\" not in INTERN : # The configuration was not already loaded. # We load and download the different configuration file if they are non # existant. Load ( CURRENT_DIRECTORY ) if not under_test : # If we are not under test which means that we want to save informations, # we initiate the directory structure. DirectoryStructure ( ) # We save that the configuration was loaded. INTERN . update ( { \"config_loaded\" : True } ) if custom and isinstance ( custom , dict ) : # The given configuration is not None or empty. # and # It is a dict. # We update the configuration index. CONFIGURATION . update ( custom )", "nl": "Load the configuration ."}}
{"translation": {"code": "def get ( self ) : if PyFunceble . HTTP_CODE [ \"active\" ] : # The http status code extraction is activated. # We get the http status code. http_code = self . _access ( ) # We initiate a variable which will save the list of allowed # http status code. list_of_valid_http_code = [ ] for codes in [ PyFunceble . HTTP_CODE [ \"list\" ] [ \"up\" ] , PyFunceble . HTTP_CODE [ \"list\" ] [ \"potentially_down\" ] , PyFunceble . HTTP_CODE [ \"list\" ] [ \"potentially_up\" ] , ] : # We loop throught the list of http status code. # We extend the list of valid with the currently read # codes. list_of_valid_http_code . extend ( codes ) if http_code not in list_of_valid_http_code or http_code is None : # * The extracted http code is not in the list of valid http code. # or # * The extracted http code is equal to `None`. # We return 3 star in order to mention that we were not eable to extract # the http status code. return \"*\" * 3 # * The extracted http code is in the list of valid http code. # or # * The extracted http code is not equal to `None`. # We return the extracted http status code. return http_code # The http status code extraction is activated. # We return None. return None", "nl": "Return the HTTP code status ."}}
{"translation": {"code": "def _access ( self ) : # pragma: no cover try : # We try to get the HTTP status code. if PyFunceble . INTERN [ \"to_test_type\" ] == \"url\" : # We are globally testing a URL. # We get the head of the URL. req = PyFunceble . requests . head ( self . to_get , timeout = PyFunceble . CONFIGURATION [ \"seconds_before_http_timeout\" ] , headers = self . headers , verify = PyFunceble . CONFIGURATION [ \"verify_ssl_certificate\" ] , ) else : # We are not globally testing a URL. # We get the head of the constructed URL. req = PyFunceble . requests . head ( self . to_get , timeout = PyFunceble . CONFIGURATION [ \"seconds_before_http_timeout\" ] , headers = self . headers , ) # And we try to get the status code. return req . status_code except ( PyFunceble . requests . exceptions . InvalidURL , PyFunceble . socket . timeout , PyFunceble . requests . exceptions . Timeout , PyFunceble . requests . ConnectionError , urllib3_exceptions . InvalidHeader , UnicodeDecodeError , # The probability that this happend in production is minimal. ) : # If one of the listed exception is matched, that means that something # went wrong and we were unable to extract the status code. # We return None. return None", "nl": "Get the HTTP code status ."}}
{"translation": {"code": "def _format_domain ( cls , extracted_domain ) : if not extracted_domain . startswith ( \"#\" ) : # The line is not a commented line. if \"#\" in extracted_domain : # There is a comment at the end of the line. # We delete the comment from the line. extracted_domain = extracted_domain [ : extracted_domain . find ( \"#\" ) ] . strip ( ) if \" \" in extracted_domain or \"\\t\" in extracted_domain : # A space or a tabs is in the line. # We remove all whitestring from the extracted line. splited_line = extracted_domain . split ( ) # As there was a space or a tab in the string, we consider # that we are working with the hosts file format which means # that the domain we have to test is after the first string. # So we set the index to 1. index = 1 while index < len ( splited_line ) : # We loop until the index is greater than the length of #  the splited line. if splited_line [ index ] : # The element at the current index is not an empty string. # We break the loop. break # The element at the current index is an empty string. # We increase the index number. index += 1 # We return the last read element. return splited_line [ index ] # We return the extracted line. return extracted_domain # The extracted line is a comment line. # We return an empty string as we do not want to work with commented line. return \"\"", "nl": "Format the extracted domain before passing it to the system ."}}
{"translation": {"code": "def backup ( self ) : if PyFunceble . CONFIGURATION [ \"auto_continue\" ] : # The auto_continue subsystem is activated. # We initiate the location where we are going to save the data to backup. data_to_backup = { } # We get the current counter states. configuration_counter = PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] # We initiate the data we have to backup. data_to_backup [ PyFunceble . INTERN [ \"file_to_test\" ] ] = { # We backup the number of tested. \"tested\" : configuration_counter [ \"tested\" ] , # We backup the number of up. \"up\" : configuration_counter [ \"up\" ] , # We backup the number of down. \"down\" : configuration_counter [ \"down\" ] , # We backup the number of invalid. \"invalid\" : configuration_counter [ \"invalid\" ] , } # We initiate the final data we have to save. # We initiate this variable instead of updating backup_content because # we do not want to touch the backup_content. to_save = { } # We add the backup_content into to_save. to_save . update ( self . backup_content ) # And we overwrite with the newly data to backup. to_save . update ( data_to_backup ) # Finaly, we save our informations into the log file. Dict ( to_save ) . to_json ( self . autocontinue_log_file )", "nl": "Backup the current execution state ."}}
{"translation": {"code": "def _create_directory ( cls , directory , loop = False ) : if not loop and PyFunceble . directory_separator in directory : # * We are not in the loop. # and # * The directory separator in the given directory. # We split the directories separator. splited_directory = directory . split ( PyFunceble . directory_separator ) # We initiate a variable which will save the full path to create. full_path_to_create = \"\" for single_directory in splited_directory : # We loop through each directory. # We append the currently read directory to the full path. full_path_to_create += single_directory + PyFunceble . directory_separator # And we create the directory if it does not exist. cls . _create_directory ( full_path_to_create , True ) if not PyFunceble . path . isdir ( directory ) : # The given directory does not exist. # We update the permission. # (Only if we are under Travis CI.) AutoSave . travis_permissions ( ) # We create the directory. PyFunceble . mkdir ( directory ) # We update the permission. # (Only if we are under Travis CI.) AutoSave . travis_permissions ( )", "nl": "Creates the given directory if it does not exists ."}}
{"translation": {"code": "def colorify_logo ( cls , home = False ) : if not PyFunceble . CONFIGURATION [ \"quiet\" ] : # The quiet mode is not activated. to_print = [ ] if home : # We have to print the initial logo. for line in PyFunceble . ASCII_PYFUNCEBLE . split ( \"\\n\" ) : # We loop through each lines of the ASCII representation # of PyFunceble. # And we append to the data to print the currently read # line with the right coloration. to_print . append ( PyFunceble . Fore . YELLOW + line + PyFunceble . Fore . RESET ) elif PyFunceble . INTERN [ \"counter\" ] [ \"percentage\" ] [ \"up\" ] >= 50 : # The percentage of up is greater or equal to 50%. for line in PyFunceble . ASCII_PYFUNCEBLE . split ( \"\\n\" ) : # We loop through each lines of the ASCII representation # of PyFunceble. # And we append to the data to print the currently read # line with the right coloration. to_print . append ( PyFunceble . Fore . GREEN + line + PyFunceble . Fore . RESET ) else : # The percentage of up is less than 50%. for line in PyFunceble . ASCII_PYFUNCEBLE . split ( \"\\n\" ) : # We loop through each lines of the ASCII representation # of PyFunceble. # And we append to the data to print the currently read # line with the right coloration. to_print . append ( PyFunceble . Fore . RED + line + PyFunceble . Fore . RESET ) print ( \"\\n\" . join ( to_print ) )", "nl": "Print the colored logo based on global results ."}}
{"translation": {"code": "def _convert_or_shorten_month ( cls , data ) : # We map the different month and their possible representation. short_month = { \"jan\" : [ str ( 1 ) , \"01\" , \"Jan\" , \"January\" ] , \"feb\" : [ str ( 2 ) , \"02\" , \"Feb\" , \"February\" ] , \"mar\" : [ str ( 3 ) , \"03\" , \"Mar\" , \"March\" ] , \"apr\" : [ str ( 4 ) , \"04\" , \"Apr\" , \"April\" ] , \"may\" : [ str ( 5 ) , \"05\" , \"May\" ] , \"jun\" : [ str ( 6 ) , \"06\" , \"Jun\" , \"June\" ] , \"jul\" : [ str ( 7 ) , \"07\" , \"Jul\" , \"July\" ] , \"aug\" : [ str ( 8 ) , \"08\" , \"Aug\" , \"August\" ] , \"sep\" : [ str ( 9 ) , \"09\" , \"Sep\" , \"September\" ] , \"oct\" : [ str ( 10 ) , \"Oct\" , \"October\" ] , \"nov\" : [ str ( 11 ) , \"Nov\" , \"November\" ] , \"dec\" : [ str ( 12 ) , \"Dec\" , \"December\" ] , } for month in short_month : # We loop through our map. if data in short_month [ month ] : # If the parsed data (or month if you prefer) is into our map. # We return the element (or key if you prefer) assigned to # the month. return month # The element is not into our map. # We return the parsed element (or month if you prefer). return data", "nl": "Convert a given month into our unified format ."}}
{"translation": {"code": "def _install_iana_config ( cls ) : # We initiate the link to the iana configuration. # It is not hard coded because this method is called only if we # are sure that the configuration file exist. iana_link = PyFunceble . CONFIGURATION [ \"links\" ] [ \"iana\" ] # We update the link according to our current version. iana_link = Version ( True ) . right_url_from_version ( iana_link ) # We set the destination of the downloaded file. destination = PyFunceble . CURRENT_DIRECTORY + \"iana-domains-db.json\" if not Version ( True ) . is_cloned ( ) or not PyFunceble . path . isfile ( destination ) : # The current version is not the cloned version. # We Download the link content and return the download status. return Download ( iana_link , destination ) . text ( ) # We are in the cloned version. # We do not need to download the file, so we are returning None. return None", "nl": "Download iana - domains - db . json if not present ."}}
{"translation": {"code": "def _install_production_config ( self ) : # We initiate the link to the production configuration. # It is not hard coded because this method is called only if we # are sure that the configuration file exist. production_config_link = \"https://raw.githubusercontent.com/funilrys/PyFunceble/master/.PyFunceble_production.yaml\" # pylint: disable=line-too-long # We update the link according to our current version. production_config_link = Version ( True ) . right_url_from_version ( production_config_link ) if not Version ( True ) . is_cloned ( ) : # The current version is not the cloned one. # We download the link content and save it inside the default location. # # Note: We add this one in order to allow the enduser to always have # a copy of our upstream configuration file. Download ( production_config_link , self . path_to_default_config ) . text ( ) # And we download the link content and return the download status. return Download ( production_config_link , self . path_to_config ) . text ( )", "nl": "Download the production configuration and install it in the current directory ."}}
{"translation": {"code": "def _load_config_file ( self ) : try : # We try to load the configuration file. PyFunceble . CONFIGURATION . update ( Dict . from_yaml ( File ( self . path_to_config ) . read ( ) ) ) # We install the latest iana configuration file. self . _install_iana_config ( ) # We install the latest public suffix configuration file. self . _install_psl_config ( ) # We install the latest directory structure file. self . _install_directory_structure_file ( ) except FileNotFoundError as exception : # But if the configuration file is not found. if PyFunceble . path . isfile ( self . path_to_default_config ) : # The `DEFAULT_CONFIGURATION_FILENAME` file exists. # We copy it as the configuration file. File ( self . path_to_default_config ) . copy ( self . path_to_config ) # And we load the configuration file as it does exist (yet). self . _load_config_file ( ) else : # The `DEFAULT_CONFIGURATION_FILENAME` file does not exists. # We raise the exception we were handling. raise exception", "nl": "Load . PyFunceble . yaml into the system ."}}
{"translation": {"code": "def _does_require_deprecation ( self ) : for index , version_number in enumerate ( self . current_version [ 0 ] [ : 2 ] ) : # We loop through the 2 last elements of the version. if version_number > self . version_yaml [ index ] : # The currently read version number is greater than the one we have in # the version.yaml. # We return True. return True # We return False, we do not need to deprecate anything. return False", "nl": "Check if we have to put the previous version into the deprecated list ."}}
{"translation": {"code": "def _is_version_greater ( self ) : # we compare the 2 versions. checked = Version ( True ) . check_versions ( self . current_version [ 0 ] , self . version_yaml ) if checked is not None and not checked : # The current version is greater as the older one. # We return True. return True # We return False return False", "nl": "Check if the current version is greater as the older older one ."}}
{"translation": {"code": "def to_yaml ( self , destination , flow_style = False ) : with open ( destination , \"w\" ) as file : # We open the file we are going to write. # Note: We always overwrite the destination. # We save the current dictionnary into a json format. dump_yaml ( self . main_dictionnary , file , encoding = \"utf-8\" , allow_unicode = True , indent = 4 , default_flow_style = flow_style , )", "nl": "Save a dictionnary into a YAML file ."}}
{"translation": {"code": "def get ( cls ) : # pragma: no cover if Check ( ) . is_url_valid ( ) or PyFunceble . CONFIGURATION [ \"local\" ] : # * The url is valid. # or # * We are testing in/for a local or private network. if \"current_test_data\" in PyFunceble . INTERN : PyFunceble . INTERN [ \"current_test_data\" ] [ \"url_syntax_validation\" ] = True # We initiate the HTTP status code. PyFunceble . INTERN . update ( { \"http_code\" : HTTPCode ( ) . get ( ) } ) # We initiate the list of active status code. active_list = [ ] active_list . extend ( PyFunceble . HTTP_CODE [ \"list\" ] [ \"potentially_up\" ] ) active_list . extend ( PyFunceble . HTTP_CODE [ \"list\" ] [ \"up\" ] ) # We initiate the list of inactive status code. inactive_list = [ ] inactive_list . extend ( PyFunceble . HTTP_CODE [ \"list\" ] [ \"potentially_down\" ] ) inactive_list . append ( \"*\" * 3 ) if PyFunceble . INTERN [ \"http_code\" ] in active_list : # The extracted HTTP status code is in the list of active list. # We handle and return the up status. return URLStatus ( PyFunceble . STATUS [ \"official\" ] [ \"up\" ] ) . handle ( ) if PyFunceble . INTERN [ \"http_code\" ] in inactive_list : # The extracted HTTP status code is in the list of inactive list. # We handle and return the down status. return URLStatus ( PyFunceble . STATUS [ \"official\" ] [ \"down\" ] ) . handle ( ) # The extracted HTTP status code is not in the list of active nor invalid list. if \"current_test_data\" in PyFunceble . INTERN : # The end-user want more information whith his test. # We update the url_syntax_validation index. PyFunceble . INTERN [ \"current_test_data\" ] [ \"url_syntax_validation\" ] = False # We handle and return the invalid down status. return URLStatus ( PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] ) . handle ( )", "nl": "Execute the logic behind the URL handling ."}}
{"translation": {"code": "def file_url ( self ) : # We get, format, clean the list of URL to test. list_to_test = self . _file_list_to_test_filtering ( ) # We initiate a local variable which will save the current state of the list. not_filtered = list_to_test try : # We remove the element which are in the database from the # current list to test. list_to_test = List ( list ( set ( list_to_test [ PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] : ] ) - set ( PyFunceble . INTERN [ \"flatten_inactive_db\" ] ) ) ) . format ( ) _ = list_to_test [ - 1 ] except IndexError : # Our list to test is the one with the element from the database. list_to_test = not_filtered [ PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] : ] # We delete the undesired variable. del not_filtered if PyFunceble . CONFIGURATION [ \"hierarchical_sorting\" ] : # The hierarchical sorting is desired by the user. # We format the list. list_to_test = List ( list ( list_to_test ) ) . custom_format ( Sort . hierarchical ) try : # We test each URL from the list to test. return [ self . url ( x , list_to_test [ - 1 ] ) for x in list_to_test if x ] except IndexError : # We print a message on screen. print ( PyFunceble . Fore . CYAN + PyFunceble . Style . BRIGHT + \"Nothing to test.\" )", "nl": "Manage the case that we have to test a file"}}
{"translation": {"code": "def handle ( self ) : # We initiate the source we are going to parse to the Generate class. source = \"URL\" if self . catched . lower ( ) not in PyFunceble . STATUS [ \"list\" ] [ \"invalid\" ] : # The parsed status is not in the list of invalid. # We generate the status file with the catched status. Generate ( self . catched , source ) . status_file ( ) else : # The parsed status is in the list of invalid. # We generate the status file with the parsed status. Generate ( self . catched , \"SYNTAX\" ) . status_file ( ) # We return the parsed status. return self . catched", "nl": "Handle the backend of the given status ."}}
{"translation": {"code": "def _entry_management_url ( self ) : if ( self . url_file # pylint: disable=no-member and not self . _entry_management_url_download ( self . url_file # pylint: disable=no-member ) ) : # pylint: disable=no-member # The current url_file is not a URL. # We initiate the filename as the file we have to test. PyFunceble . INTERN [ \"file_to_test\" ] = self . url_file", "nl": "Manage the loading of the url system ."}}
{"translation": {"code": "def _entry_management_url_download ( self , passed ) : if passed and self . checker . is_url_valid ( passed ) : # The passed string is an URL. # We get the file name based on the URL. # We actually just get the  string after the last `/` in the URL. file_to_test = passed . split ( \"/\" ) [ - 1 ] if ( not PyFunceble . path . isfile ( file_to_test ) or PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] == 0 ) : # The filename does not exist in the current directory # or the currently number of tested is equal to 0. # We download the content of the link. Download ( passed , file_to_test ) . text ( ) # The files does exist or the currently number of tested is greater than # 0. # We initiate the file we have to test. PyFunceble . INTERN [ \"file_to_test\" ] = file_to_test # We return true to say that everything goes right. return True # The passed string is not an URL. # We do not need to do anything else. return False", "nl": "Check if the given information is a URL . If it is the case it download and update the location of file to test ."}}
{"translation": {"code": "def is_dev_version ( cls ) : # We initiate the command we have to run in order to # get the branch we are currently working with. command = \"git branch\" # We execute and get the command output. command_result = Command ( command ) . execute ( ) for branch in command_result . split ( \"\\n\" ) : # We loop through each line of the command output. if branch . startswith ( \"*\" ) and \"dev\" in branch : # The current branch is `dev`. # We return True. return True # The current branch is not `dev`. # We return False. return False", "nl": "Check if the current branch is dev ."}}
{"translation": {"code": "def _extensions ( self , line ) : # We strip the parsed line. line = line . strip ( ) if not line . startswith ( \"//\" ) and \".\" in line : # * The parsed line is not a commented line. # and # * There is a point in the parsed line. line = line . encode ( \"idna\" ) . decode ( \"utf-8\" ) if line . startswith ( \"*.\" ) : # The parsed line start with `*.`. # We remove the first two characters. line = line [ 2 : ] # We we split the points and we get the last element. # Explanation: The idea behind this action is to # always get the extension. extension = line . split ( \".\" ) [ - 1 ] if extension in self . public_suffix_db : # The extension is alrady in our database. # We update the content of the 1st level TDL with # the content of the suffix. # In between, we format so that we ensure that there is no # duplicate in the database index content. self . public_suffix_db [ extension ] = List ( self . public_suffix_db [ extension ] + [ line ] ) . format ( ) else : # The extension is not already in our database. # We append the currently formatted extension and the line content. self . public_suffix_db . update ( { extension : [ line ] } )", "nl": "Extract the extension from the given line ."}}
{"translation": {"code": "def _install_psl_config ( cls ) : # We initiate the link to the public suffix configuration. # It is not hard coded because this method is called only if we # are sure that the configuration file exist. psl_link = PyFunceble . CONFIGURATION [ \"links\" ] [ \"psl\" ] # We update the link according to our current version. psl_link = Version ( True ) . right_url_from_version ( psl_link ) # We set the destination of the downloaded file. destination = ( PyFunceble . CURRENT_DIRECTORY + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"public_suffix\" ] ) if not Version ( True ) . is_cloned ( ) or not PyFunceble . path . isfile ( destination ) : # The current version is not the cloned version. # We Download the link content and return the download status. return Download ( psl_link , destination ) . text ( ) # We are in the cloned version. # We do not need to download the file, so we are returning None. return None", "nl": "Download public - suffix . json if not present ."}}
{"translation": {"code": "def _update_code_urls ( self ) : to_ignore = [ \".gitignore\" , \".keep\" ] for root , _ , files in PyFunceble . walk ( PyFunceble . CURRENT_DIRECTORY + PyFunceble . directory_separator + \"PyFunceble\" + PyFunceble . directory_separator ) : # We loop through every directories and files in the `PyFunceble` directory. for file in files : # We loop through the list of files of the currently read directory. if file not in to_ignore and \"__pycache__\" not in root : # * The filename is not into the list of file to ignore. # and # * The directory we are reading is not `__pycache__`. if root . endswith ( PyFunceble . directory_separator ) : # The root directory ends with the directory separator. # We fix the path in the currently read file. self . _update_docs ( root + file ) else : # The root directory does not ends with the directory separator. # We fix the path in the currently read file. # (after appending the directory separator between the root and file) self . _update_docs ( root + PyFunceble . directory_separator + file ) for root , _ , files in PyFunceble . walk ( PyFunceble . CURRENT_DIRECTORY + PyFunceble . directory_separator + \"tests\" + PyFunceble . directory_separator ) : # We loop through every directories and files in the `tests` directory. for file in files : # We loop through the list of files of the currently read directory. if file not in to_ignore and \"__pycache__\" not in root : # * The filename is not into the list of file to ignore. # and # * The directory we are reading is not `__pycache__`. if root . endswith ( PyFunceble . directory_separator ) : # The root directory ends with the directory separator. # We fix the path in the currently read file. self . _update_docs ( root + file ) else : # The root directory does not ends with the directory separator. # We fix the path in the currently read file. # (after appending the directory separator between the root and file) self . _update_docs ( root + PyFunceble . directory_separator + file )", "nl": "Read the code and update all links ."}}
{"translation": {"code": "def _set_path_to_configs ( cls , path_to_config ) : if not path_to_config . endswith ( PyFunceble . directory_separator ) : # The path to the config does not ends with the directory separator. # We initiate the default and the parsed variable with the directory separator. default = parsed = path_to_config + PyFunceble . directory_separator else : # The path to the config does ends with the directory separator. # We initiate the default and the parsed variable. default = parsed = path_to_config # We append the `CONFIGURATION_FILENAME` to the parsed variable. parsed += PyFunceble . CONFIGURATION_FILENAME # And we append the `DEFAULT_CONFIGURATION_FILENAME` to the default variable. default += PyFunceble . DEFAULT_CONFIGURATION_FILENAME # We finaly return a tuple which contain both informations. return ( parsed , default )", "nl": "Set the paths to the configuration files ."}}
{"translation": {"code": "def file ( self ) : # We get, format, filter, clean the list to test. list_to_test = self . _file_list_to_test_filtering ( ) if PyFunceble . CONFIGURATION [ \"idna_conversion\" ] : # We have to convert domains to idna. # We convert if we need to convert. list_to_test = domain2idna ( list_to_test ) if PyFunceble . CONFIGURATION [ \"hierarchical_sorting\" ] : # The hierarchical sorting is desired by the user. # We format the list. list_to_test = List ( list_to_test ) . custom_format ( Sort . hierarchical ) else : # The hierarchical sorting is not desired by the user. # We format the list. list_to_test = List ( list_to_test ) . custom_format ( Sort . standard ) # We initiate a local variable which will save the current state of the list. not_filtered = list_to_test try : # We remove the element which are in the database from the # current list to test. list_to_test = List ( list ( set ( list_to_test [ PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] : ] ) - set ( PyFunceble . INTERN [ \"flatten_inactive_db\" ] ) ) ) . format ( ) _ = list_to_test [ - 1 ] except IndexError : # Our list to test is the one with the element from the database. list_to_test = not_filtered [ PyFunceble . INTERN [ \"counter\" ] [ \"number\" ] [ \"tested\" ] : ] # We delete the undesired variable. del not_filtered if PyFunceble . CONFIGURATION [ \"hierarchical_sorting\" ] : # The hierarchical sorting is desired by the user. # We format the list. list_to_test = List ( list ( list_to_test ) ) . custom_format ( Sort . hierarchical ) try : # We test each element of the list to test. return [ self . domain ( x , list_to_test [ - 1 ] ) for x in list_to_test if x ] except IndexError : # We print a message on screen. print ( PyFunceble . Fore . CYAN + PyFunceble . Style . BRIGHT + \"Nothing to test.\" )", "nl": "Manage the case that need to test each domain of a given file path ."}}
{"translation": {"code": "def is_cloned ( cls ) : if not PyFunceble . path . isdir ( \".git\" ) : # The git directory does not exist. # We return False, the current version is not the cloned version. return False # We list the list of file which can be found only in a cloned version. list_of_file = [ \".coveragerc\" , \".coveralls.yml\" , \".gitignore\" , \".PyFunceble_production.yaml\" , \".travis.yml\" , \"CODE_OF_CONDUCT.md\" , \"CONTRIBUTING.md\" , \"dir_structure_production.json\" , \"MANIFEST.in\" , \"README.rst\" , \"requirements.txt\" , \"setup.py\" , \"version.yaml\" , ] # We list the list of directory which can be found only in a cloned # version. list_of_dir = [ \"docs\" , \"PyFunceble\" , \"tests\" ] for file in list_of_file : # We loop through the list of file. if not PyFunceble . path . isfile ( file ) : # The file does not exist in the current directory. # We return False, the current version is not the cloned version. return False # All required files exist in the current directory. for directory in list_of_dir : # We loop through the list of directory. if not PyFunceble . path . isdir ( directory ) : # The directory does not exist in the current directory. # We return False, the current version is not the cloned version. return False # All required directories exist in the current directory. # We return True, the current version is a cloned version. return True", "nl": "Let us know if we are currently in the cloned version of PyFunceble which implicitly mean that we are in developement mode ."}}
{"translation": {"code": "def _reformat_historical_formating_error ( self ) : # pragma: no cover if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : # The database subsystem is activated. # We construct the possible path to an older version of the database. historical_formating_error = ( PyFunceble . CURRENT_DIRECTORY + \"inactive-db.json\" ) if PyFunceble . path . isfile ( historical_formating_error ) : # The histortical file already exists. # We get its content. data = Dict ( ) . from_json ( File ( historical_formating_error ) . read ( ) ) # We initiate a variable which will save the data that is going # to be merged. data_to_parse = { } # We get the database keybase. top_keys = data . keys ( ) for top_key in top_keys : # We loop through the list of upper keys. # We get the lowest keys. low_keys = data [ top_key ] . keys ( ) # We initiate the data to parse. data_to_parse [ top_key ] = { } for low_key in low_keys : # We loop through the list of lower keys. if low_key . isdigit ( ) : # The current low key is a digit. # We parse its content (from the old) into the new format. # In between, we remove 30 days from the low_key so that # it become in the past. This way they will be retested # automatically. data_to_parse [ top_key ] [ int ( low_key ) - ( self . one_day_in_seconds * 30 ) ] = data [ top_key ] [ low_key ] else : # The current low key is not a digit. # We parse its content (from the old) into the new format. # In between, we remove 30 days from the current time so that # it become in the past. This way they will be retested # automatically. data_to_parse [ top_key ] [ int ( PyFunceble . time ( ) ) - ( self . one_day_in_seconds * 30 ) ] = data [ top_key ] [ low_key ] if \"inactive_db\" in PyFunceble . INTERN : # The current (new) database is not empty. # We update add the content of the old into the current database. PyFunceble . INTERN [ \"inactive_db\" ] . update ( data_to_parse ) else : # The current (new) database is empty. # We replace the content with the data_to_parse as it is complient # with the new format. PyFunceble . INTERN [ \"inactive_db\" ] = data_to_parse # We delete the old database file. File ( historical_formating_error ) . delete ( )", "nl": "Format the old format so it can be merged into the newer format ."}}
{"translation": {"code": "def status_file ( self ) : # pylint: disable=inconsistent-return-statements if \"file_to_test\" in PyFunceble . INTERN : # We are not testing as an imported module. # We generate the hosts file. Generate ( self . domain_status , self . source , self . expiration_date ) . info_files ( ) # We are testing a file content. # We increase the percentage count. Percentage ( self . domain_status ) . count ( ) # We print on screen if needed. self . _prints_status_screen ( ) if self . _do_not_produce_file ( ) : return None if ( not PyFunceble . CONFIGURATION [ \"no_files\" ] and PyFunceble . CONFIGURATION [ \"split\" ] ) : # * The file non-generation of file is globaly deactivated. # and # * We have to split the outputs. # We print or generate the files. self . _prints_status_file ( ) else : # * The file non-generation of file is globaly activated. # or # * We do not have to split the outputs. # We print or generate the unified files. self . unified_file ( )", "nl": "Generate a file according to the domain status ."}}
{"translation": {"code": "def hierarchical ( cls , element ) : # We initiate a variable which will save the element to sort without # the extension. to_sort = \"\" # We initiate a variable which will save the full extension. full_extension = \"\" # We convert the parsed element to lower case. element = element . lower ( ) # We try to get the url base. url_base = Check ( ) . is_url_valid ( element , return_base = True ) if not isinstance ( url_base , str ) : # The url base is not found. if \".\" in element : # There is point in the parsed element. # We get the position of the first letter of the extension. extension_index = element . rindex ( \".\" ) + 1 # We get the extension from the position of the first letter # of the extension. extension = element [ extension_index : ] if extension in PyFunceble . INTERN [ \"psl_db\" ] : # The extension is in the public suffix database. for suffix in PyFunceble . INTERN [ \"psl_db\" ] [ extension ] : # We loop through the list of suffix of the extracted extension. # We suffix the sufix with a point. formatted_suffix = \".\" + suffix if element . endswith ( formatted_suffix ) : # The elements ends with the suffix. # We get the position of the first character of the suffix in # the parsed element. suffix_index = element . rindex ( formatted_suffix ) # We update the to_sort variable with the element without the suffix. to_sort = element [ : suffix_index ] # We replace the full extension with the currently read suffix. full_extension = suffix # We break the loop, we got what we wanted. break if not full_extension : # The full extension is empty. # We initiate it with the extension. full_extension = element [ extension_index : ] # We update the to_sort variable with the element without the extension. to_sort = element [ : extension_index - 1 ] # We append a point to the full extension because the point has to be # at the end and not at the begining of the extension. # To understand: Imagine a miror. full_extension += \".\" # We reverse the to_sort string. tros_ot = to_sort [ : : - 1 ] if \".\" in tros_ot : # There is a point in the reversed string. # We prefix the full extension with the top level # domain name. full_extension = ( tros_ot [ : tros_ot . index ( \".\" ) ] [ : : - 1 ] + \".\" + full_extension ) # We remove the tor level domain from the rest of # the reversed string. tros_ot = tros_ot [ tros_ot . index ( \".\" ) + 1 : ] # * We reverse each level of the parsed element. # and # * We glue each level of the parsed element with each other. # # Note: after this, there is no point anymore. reversion = full_extension + \".\" . join ( [ x [ : : - 1 ] for x in tros_ot . split ( \".\" ) ] ) # We remove all special characters and return the formatted string. return ( Regex ( reversion , cls . regex_replace , replace_with = \"@funilrys\" ) . replace ( ) . replace ( \"@funilrys\" , \"\" ) ) # We remove all special characters and return the formatted string. return ( Regex ( to_sort + full_extension , cls . regex_replace , replace_with = \"@funilrys\" , ) . replace ( ) . replace ( \"@funilrys\" , \"\" ) ) # There is no point in the parsed element. # We return the parsed element. return element # The url base is found. # We get the position of the element. protocol_position = element . rindex ( url_base ) # We extract the protocol from the element position. protocol = element [ : protocol_position ] # We return the output of this method but with the url base instead of the full url. return protocol + cls . hierarchical ( url_base )", "nl": "The idea behind this method is to sort a list of domain hierarchicaly ."}}
{"translation": {"code": "def standard ( cls , element ) : # We remove all special characters and return the formatted string. return ( Regex ( element , cls . regex_replace , replace_with = \"@funilrys\" ) . replace ( ) . replace ( \"@funilrys\" , \"\" ) )", "nl": "Implement the standard and alphabetical sorting ."}}
{"translation": {"code": "def _analytic_host_file_directory ( self ) : # We construct the path to the analytic directory. output_dir = ( self . output_parent_dir + PyFunceble . OUTPUTS [ \"analytic\" ] [ \"directories\" ] [ \"parent\" ] ) if self . domain_status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"potentially_up\" ] : # The status is in the list of analytic up status. # We complete the output directory. output_dir += PyFunceble . OUTPUTS [ \"analytic\" ] [ \"directories\" ] [ \"potentially_up\" ] elif ( self . domain_status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"potentially_down\" ] ) : # The status is in the list of analytic down status. # We complete the output directory. output_dir += PyFunceble . OUTPUTS [ \"analytic\" ] [ \"directories\" ] [ \"potentially_down\" ] elif self . domain_status . lower ( ) in PyFunceble . STATUS [ \"list\" ] [ \"suspicious\" ] : # The status is in the list of analytic suspicious status. # We complete the output directory. output_dir += PyFunceble . OUTPUTS [ \"analytic\" ] [ \"directories\" ] [ \"suspicious\" ] else : # The status is not in the list of analytic down or up status. # We complete the output directory. output_dir += PyFunceble . OUTPUTS [ \"analytic\" ] [ \"directories\" ] [ \"up\" ] return output_dir", "nl": "Return the analytic directory to write depending of the matched status ."}}
{"translation": {"code": "def _handle_non_existant_index ( cls ) : try : # We try to call the http code. PyFunceble . INTERN [ \"http_code\" ] except KeyError : # If it is not found. # We initiate an empty http code. PyFunceble . INTERN [ \"http_code\" ] = \"*\" * 3 try : # We try to call the referer. PyFunceble . INTERN [ \"referer\" ] except KeyError : # If it is not found. # We initate an `Unknown` referer. PyFunceble . INTERN [ \"referer\" ] = \"Unknown\"", "nl": "Handle and check that some configuration index exists ."}}
{"translation": {"code": "def _install_directory_structure_file ( cls ) : # We initiate the link to the public suffix configuration. # It is not hard coded because this method is called only if we # are sure that the configuration file exist. dir_structure_link = PyFunceble . CONFIGURATION [ \"links\" ] [ \"dir_structure\" ] # We update the link according to our current version. dir_structure_link = Version ( True ) . right_url_from_version ( dir_structure_link ) # We set the destination of the downloaded file. destination = ( PyFunceble . CURRENT_DIRECTORY + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"dir_structure\" ] ) if not Version ( True ) . is_cloned ( ) or not PyFunceble . path . isfile ( destination ) : # The current version is not the cloned version. # We Download the link content and return the download status. data = Download ( dir_structure_link , destination , return_data = True ) . text ( ) File ( destination ) . write ( data , overwrite = True ) return True # We are in the cloned version. # We do not need to download the file, so we are returning None. return None", "nl": "Download the latest version of dir_structure_production . json ."}}
{"translation": {"code": "def load ( self ) : if not PyFunceble . INTERN [ \"psl_db\" ] : # The public database was not already loaded. # * We read, convert to dict and return the file content. # and # * We fill/create the database. PyFunceble . INTERN [ \"psl_db\" ] = Dict ( ) . from_json ( File ( self . destination ) . read ( ) )", "nl": "Load the public suffix database into the system ."}}
{"translation": {"code": "def _backup ( self ) : if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. # We backup our mined informations. Dict ( PyFunceble . INTERN [ \"mined\" ] ) . to_json ( self . file )", "nl": "Backup the mined informations ."}}
{"translation": {"code": "def list_of_mined ( cls ) : # We initiate a variable which will return the result. result = [ ] if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. if PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"mined\" ] : # The file we are testing is into our mining database. for element in PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] : # We loop through the list of index of the file we are testing. # We append the element of the currently read index to our result. result . extend ( PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] ) # We format our result. result = List ( result ) . format ( ) # We return the result. return result", "nl": "Provide the list of mined so they can be added to the list queue ."}}
{"translation": {"code": "def _add ( self , to_add ) : if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. if PyFunceble . INTERN [ \"file_to_test\" ] not in PyFunceble . INTERN [ \"mined\" ] : # Our tested file path is not into our mined database. # We initiate it. PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] = { } for element in to_add : # We loop through the element to add. if ( element in PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] ) : # The element is already into the tested file path database. # We extent it with our element to add. PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] . extend ( to_add [ element ] ) else : # The element is already into the tested file path database. # We initiate it. PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] = to_add [ element ] # We format the added information in order to avoid duplicate. PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] = List ( PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] ) . format ( ) # We backup everything. self . _backup ( )", "nl": "Add the currently mined information to the mined database ."}}
{"translation": {"code": "def _retrieve ( self ) : if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. if \"mined\" not in PyFunceble . INTERN : PyFunceble . INTERN [ \"mined\" ] = { } if PyFunceble . path . isfile ( self . file ) : # Our backup file exist. # We return the information from our backup. data = Dict ( ) . from_json ( File ( self . file ) . read ( ) ) # We clean the empty elements. for file_path in data : PyFunceble . INTERN [ \"mined\" ] [ file_path ] = { } for element in data [ file_path ] : if data [ file_path ] [ element ] : PyFunceble . INTERN [ \"mined\" ] [ file_path ] [ element ] = data [ file_path ] [ element ] return # * The mining is not activated. # or # * Our backup file does not exist. # We return nothing. PyFunceble . INTERN [ \"mined\" ] = { } return", "nl": "Retrieve the mining informations ."}}
{"translation": {"code": "def process ( self ) : # pragma: no cover if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. # We load the mining logic. mined = self . mine ( ) if mined : # The mined data is not empty or None. # We add the mined data to the global database. self . _add ( mined ) # And we finally backup everything. self . _backup ( )", "nl": "Process the logic and structuration of the mining database ."}}
{"translation": {"code": "def remove ( self ) : if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. if PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"mined\" ] : # The currently tested file is in our mined database. for element in PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] : # We loop through the mined index. if ( self . to_get_bare in PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] ) : # The currently read element content. # We remove the globally tested element from the currently # read element content. PyFunceble . INTERN [ \"mined\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ element ] . remove ( self . to_get_bare ) # We backup everything. self . _backup ( )", "nl": "Remove the currently tested element from the mining data ."}}
{"translation": {"code": "def mine ( self ) : # pragma: no cover if PyFunceble . CONFIGURATION [ \"mining\" ] : # The mining is activated. try : # We get the history. history = PyFunceble . requests . get ( self . to_get , timeout = PyFunceble . CONFIGURATION [ \"seconds_before_http_timeout\" ] , headers = self . headers , ) . history # We initiate a dictionnary which will save the # list of mined links. mined = { self . to_get_bare : [ ] } for element in history : # We loop through the history. # We update the element. element = element . url if PyFunceble . INTERN [ \"to_test_type\" ] == \"url\" : # We are testing a full url. # We get the element to append. to_append = Check ( ) . is_url_valid ( element , return_base = False ) elif PyFunceble . INTERN [ \"to_test_type\" ] == \"domain\" : # We are testing a domain. # We get the element to append. to_append = Check ( ) . is_url_valid ( element , return_base = True ) else : raise Exception ( \"Unknown tested.\" ) if to_append : # There is something to append. if to_append . endswith ( \":80\" ) : # The port is present. # We get rid of it. to_append = to_append [ : - 3 ] if to_append != self . to_get_bare : # The element to append is different as # the element we are globally testing. # We append the element to append to the # list of mined links. mined [ self . to_get_bare ] . append ( to_append ) if mined [ self . to_get_bare ] : # There is something in the list of mined links. # We return the whole element. return mined # There is nothing in the list of mined links. # We return None. return None except ( PyFunceble . requests . ConnectionError , PyFunceble . requests . exceptions . Timeout , PyFunceble . requests . exceptions . InvalidURL , PyFunceble . socket . timeout , urllib3_exceptions . InvalidHeader , UnicodeDecodeError , # The probability that this happend in production is minimal. ) : # Something went wrong. # We return None. return None return None", "nl": "Search for domain or URL related to the original URL or domain ."}}
{"translation": {"code": "def _json_print ( self ) : # pragma: no cover if self . output : # The given output is not empty. if PyFunceble . path . isfile ( self . output ) : # The given output already exist. # We get the content of the output. content = Dict ( ) . from_json ( File ( self . output ) . read ( ) ) if isinstance ( content , list ) : # The content is a list. # We extend the content with our data to print. content . extend ( self . data_to_print ) # We format our list. content = List ( content ) . custom_format ( Sort . standard ) if PyFunceble . CONFIGURATION [ \"hierarchical_sorting\" ] : # The hierarchical sorting is activated. # We format our content hierarchicaly content = List ( content ) . custom_format ( Sort . hierarchical ) # We finally save our content into the file. Dict ( content ) . to_json ( self . output ) else : # The content is not a list. # We raise an exception. raise Exception ( \"Output not correctly formatted.\" ) else : # The given output does not already exist. # We save our data to print into the output. # # Note: We do not have to take care if self.data_to_print is a list # formatted or not because this method should not be called if it is # not the case. Dict ( self . data_to_print ) . to_json ( self . output ) else : # The given output is empty. # We raise an exception. raise Exception ( \"Empty output given.\" )", "nl": "Management of the json template ."}}
{"translation": {"code": "def is_url_valid ( self , url = None , return_base = False , return_formatted = False ) : # We initiate a variable which will save the initial base in case # we have to convert the base to IDNA. initial_base = None if url : # The given url is not empty. # We initiate the element to test. to_test = url elif self . element : # The globaly given url is not empty. # We initiate the element to test. to_test = self . element else : # The given url is empty. # We initiate the element to test from the globaly URl to test. to_test = PyFunceble . INTERN [ \"to_test\" ] if to_test . startswith ( \"http\" ) : # The element to test starts with http. try : # We initiate a regex which will match the domain or the url base. regex = r\"(^(http:\\/\\/|https:\\/\\/)(.+?(?=\\/)|.+?$))\" # We extract the url base with the help of the initiated regex. initial_base = base = Regex ( to_test , regex , return_data = True , rematch = True ) . match ( ) [ 2 ] if PyFunceble . CONFIGURATION [ \"idna_conversion\" ] : # We have to convert the domain to IDNA. # We convert the initial base to IDNA. base = domain2idna ( base ) # We check if the url base is a valid domain. domain_status = self . is_domain_valid ( base ) # We check if the url base is a valid IP. ip_status = self . is_ip_valid ( base ) if domain_status or ip_status : # * The url base is a valid domain. # and # * The url base is a valid IP. if PyFunceble . CONFIGURATION [ \"idna_conversion\" ] and return_formatted : # * We have to convert to IDNA. # and # * We have to return the converted full URL. # We return the converted full URL. return Regex ( to_test , initial_base , escape = True , return_data = True , replace_with = base , occurences = 1 , ) . replace ( ) if return_formatted : # * We do not have to convert to IDNA. # but # * We have to return the full URL. # We return the initially given URL. return to_test if return_base : # We have to return the base of the URL. # We return the base of the URL. return base # We return True. return True except TypeError : pass if return_formatted : # We have to return an URL. # We return the initily given URL. return to_test # We return False. return False", "nl": "Check if the given URL is valid ."}}
{"translation": {"code": "def is_domain_valid ( self , domain = None , subdomain_check = False ) : # pylint:disable=too-many-return-statements, too-many-branches # We initate our regex which will match for valid domains. regex_valid_domains = r\"^(?=.{0,253}$)(([a-z0-9][a-z0-9-]{0,61}[a-z0-9]|[a-z0-9])\\.)+((?=.*[^0-9])([a-z0-9][a-z0-9-]{0,61}[a-z0-9](?:\\.)?|[a-z0-9](?:\\.)?))$\" # pylint: disable=line-too-long # We initiate our regex which will match for valid subdomains. regex_valid_subdomains = r\"^(?=.{0,253}$)(([a-z0-9_][a-z0-9-_]{0,61}[a-z0-9_-]|[a-z0-9])\\.)+((?=.*[^0-9])([a-z0-9][a-z0-9-]{0,61}[a-z0-9]|[a-z0-9]))$\" # pylint: disable=line-too-long if domain : # A domain is given. # We set the element to test as the parsed domain. to_test = domain elif self . element : # A domain is globally given. # We set the globally parsed domain. to_test = self . element else : # A domain is not given. # We set the element to test as the currently tested element. to_test = PyFunceble . INTERN [ \"to_test\" ] try : # We get the position of the last point. last_point_index = to_test . rindex ( \".\" ) # And with the help of the position of the last point, we get the domain extension. extension = to_test [ last_point_index + 1 : ] if not extension and to_test . endswith ( \".\" ) : try : extension = [ x for x in to_test . split ( \".\" ) if x ] [ - 1 ] except IndexError : pass if not extension or extension not in PyFunceble . INTERN [ \"iana_db\" ] : # * The extension is not found. # or # * The extension is not into the IANA database. # We return false. return False if ( Regex ( to_test , regex_valid_domains , return_data = False ) . match ( ) and not subdomain_check ) : # * The element pass the domain validation. # and # * We are not checking if it is a subdomain. # We return True. The domain is valid. return True # The element did not pass the domain validation. That means that # it has invalid character or the position of - or _ are not right. if extension in PyFunceble . INTERN [ \"psl_db\" ] : # The extension is into the psl database. for suffix in PyFunceble . INTERN [ \"psl_db\" ] [ extension ] : # We loop through the element of the extension into the psl database. try : # We try to get the position of the currently read suffix # in the element ot test. suffix_index = to_test . rindex ( \".\" + suffix ) # We get the element to check. # The idea here is to delete the suffix, then retest with our # subdomains regex. to_check = to_test [ : suffix_index ] if \".\" not in to_check and subdomain_check : # * There is no point into the new element to check. # and # * We are checking if it is a subdomain. # We return False, it is not a subdomain. return False if \".\" in to_check and subdomain_check : # * There is a point into the new element to check. # and # * We are checking if it is a subdomain. # We return True, it is a subdomain. return True # We are not checking if it is a subdomain. if \".\" in to_check : # There is a point into the new element to check. # We check if it passes our subdomain regex. # * True: It's a valid domain. # * False: It's an invalid domain. return Regex ( to_check , regex_valid_subdomains , return_data = False ) . match ( ) except ValueError : # In case of a value error because the position is not found, # we continue to the next element. pass # * The extension is not into the psl database. # or # * there was no point into the suffix checking. # We get the element before the last point. to_check = to_test [ : last_point_index ] if \".\" in to_check and subdomain_check : # * There is a point in to_check. # and # * We are checking if it is a subdomain. # We return True, it is a subdomain. return True # We are not checking if it is a subdomain. if \".\" in to_check : # There is a point in to_check. # We check if it passes our subdomain regex. # * True: It's a valid domain. # * False: It's an invalid domain. return Regex ( to_check , regex_valid_subdomains , return_data = False ) . match ( ) except ( ValueError , AttributeError ) : # In case of a value or attribute error we ignore them. pass # And we return False, the domain is not valid. return False", "nl": "Check if the given domain is a valid ."}}
{"translation": {"code": "def is_subdomain ( self , domain = None ) : if domain : # A domain is given. # We set the element to test as the parsed domain. to_test = domain elif self . element : # A domain is globally given. # We set the globally parsed domain. to_test = self . element else : # A domain is not given. # We set the element to test as the currently tested element. to_test = PyFunceble . INTERN [ \"to_test\" ] # We return the status of the check. return self . is_domain_valid ( to_test , subdomain_check = True )", "nl": "Check if the given subdomain is a subdomain ."}}
{"translation": {"code": "def _retrieve ( self ) : if self . _authorization ( ) and \"whois_db\" not in PyFunceble . INTERN : # The usage of the whois database is activated. if PyFunceble . path . isfile ( self . whois_db_path ) : # The database file exist. # We merge our current database into already initiated one. PyFunceble . INTERN [ \"whois_db\" ] = Dict ( ) . from_json ( File ( self . whois_db_path ) . read ( ) ) else : # The database file does not exist. # We initiate an empty database. PyFunceble . INTERN [ \"whois_db\" ] = { }", "nl": "Retrieve the data from the database ."}}
{"translation": {"code": "def is_in_database ( self ) : if ( self . _authorization ( ) and PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"whois_db\" ] and PyFunceble . INTERN [ \"to_test\" ] in PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] ) : # * We are authorized to work. # and # * The given file path exist in the database. # and # * The element we are testing is in the database related to the # given file path. # We return True, the element we are testing is into the database. return True # * We are not authorized to work. # or # * The given file path does not exist in the database. # or # * The element we are testing is not in the database related to the # given file path. # We return False,the element we are testing is not into the database. return False", "nl": "Check if the element is into the database ."}}
{"translation": {"code": "def is_time_older ( self ) : if ( self . _authorization ( ) and self . is_in_database ( ) and int ( PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] [ \"epoch\" ] ) < int ( PyFunceble . time ( ) ) ) : # * We are authorized to work. # and # * The element we are testing is in the database. # and # * The epoch of the expiration date is less than our current epoch. # The expiration date is in the past, we return True. return True # The expiration date is in the future, we return False. return False", "nl": "Check if the current time is older than the one in the database ."}}
{"translation": {"code": "def get_expiration_date ( self ) : if self . _authorization ( ) and self . is_in_database ( ) and not self . is_time_older ( ) : # * We are authorized to work. # and # * The element we are testing is in the database. # and # * The expiration date is in the future. # We get the expiration date from the database. result = PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] [ \"expiration_date\" ] if result : # The expiration date from the database is not empty nor # equal to None. # We return it. return result # We return None, there is no data to work with. return None", "nl": "Get the expiration date from the database ."}}
{"translation": {"code": "def _hash_data ( self , algo ) : # We het the algorithm function. hash_data = getattr ( hashlib , algo ) ( ) # We set the data into our hashlib. hash_data . update ( self . data ) # And we extract and return the hash. return hash_data . hexdigest ( )", "nl": "Get hash of the given data ."}}
{"translation": {"code": "def add ( self ) : if self . _authorization ( ) : # We are authorized to work. if self . epoch < int ( PyFunceble . time ( ) ) : state = \"past\" else : state = \"future\" if self . is_in_database ( ) : # The element we are working with is in the database. if ( str ( self . epoch ) != PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] [ \"epoch\" ] ) : # The given epoch is diffent from the one saved. # We update it. PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] . update ( { \"epoch\" : str ( self . epoch ) , \"state\" : state , \"expiration_date\" : self . expiration_date , } ) elif self . is_time_older ( ) : # The expiration date from the database is in the past. if ( PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] [ \"state\" ] != \"past\" ) : # pragma: no cover # The state of the element in the datbase is not # equal to `past`. # We update it to `past`. PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] . update ( { \"state\" : \"past\" } ) elif ( PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] [ \"state\" ] != \"future\" ) : # * The expiration date from the database is in the future. # and # * The state of the element in the database is not # equal to `future`. # We update it to `future`. PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ PyFunceble . INTERN [ \"to_test\" ] ] . update ( { \"state\" : \"future\" } ) else : # The element we are working with is not in the database. if ( not PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"whois_db\" ] ) : # The file path is not in the database. # We initiate it. PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] = { } # We create the first dataset. PyFunceble . INTERN [ \"whois_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] . update ( { PyFunceble . INTERN [ \"to_test\" ] : { \"epoch\" : str ( self . epoch ) , \"state\" : state , \"expiration_date\" : self . expiration_date , } } ) # We do a safety backup of our database. self . _backup ( )", "nl": "Add the currently tested element into the database ."}}
{"translation": {"code": "def _backup ( self ) : if self . _authorization ( ) : # We are authorized to work. # We backup the current state of the datbase. Dict ( PyFunceble . INTERN [ \"whois_db\" ] ) . to_json ( self . whois_db_path )", "nl": "Backup the database into its file ."}}
{"translation": {"code": "def _save ( self , last = False ) : # pragma: no cover if ( self . _authorization ( ) and PyFunceble . CONFIGURATION [ \"logs\" ] and \"file_to_test\" in PyFunceble . INTERN and PyFunceble . INTERN [ \"file_to_test\" ] ) : # * We are authorized to work. # and # * The generation of logs is activated. # and # * We are not testing as an imported module. # We set the location of the file we are working with. self . file = ( PyFunceble . OUTPUT_DIRECTORY + PyFunceble . OUTPUTS [ \"parent_directory\" ] + PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"parent\" ] + PyFunceble . OUTPUTS [ \"logs\" ] [ \"filenames\" ] [ \"execution_time\" ] ) if PyFunceble . path . isfile ( self . file ) : # The file we are working with exist. # We get its content so we can directly work with it. content = Dict ( ) . from_json ( File ( self . file ) . read ( ) ) else : # The file we are working with does not exist. # We generate a dummy content. content = { } if self . action == \"start\" : # The action is equal to `start`. if \"final_total\" in content and content [ \"final_total\" ] : # The final total index exist. # We delete it. del content [ \"final_total\" ] if \"data\" in content : # The data index exist. # We append the current start time inside it at # a new sublist. content [ \"data\" ] . append ( [ PyFunceble . INTERN [ \"start\" ] ] ) else : # The data index does not exist. # We create the index along with the current start time. content [ \"data\" ] = [ [ PyFunceble . INTERN [ \"start\" ] ] ] elif self . action == \"stop\" : # The action is equal to `stop`. try : # We try to work with the data index. # We append the end time at the end of the last element # of data. # # Note: It is at the end because we should have as first # the star time. content [ \"data\" ] [ - 1 ] . append ( PyFunceble . INTERN [ \"end\" ] ) # We get the start time. start = content [ \"data\" ] [ 0 ] [ 0 ] # We get the end time. end = content [ \"data\" ] [ - 1 ] [ - 1 ] # We calculate the execution time of the test. content [ \"current_total\" ] = self . format_execution_time ( start , end ) if last : # We are at the very end of the file testing. # We initiate the global execution time. content [ \"final_total\" ] = content [ \"current_total\" ] # We inform the user about the global execution time. print ( PyFunceble . Fore . MAGENTA + PyFunceble . Style . BRIGHT + \"Global execution time: \" + content [ \"final_total\" ] ) except KeyError : # It is not possible to work with the data index because # it does not exist. # We ignore the problem. pass try : # We try to save the whole data at its final location. Dict ( content ) . to_json ( self . file ) except FileNotFoundError : # The directory was not found. # We construct the output directory DirectoryStructure ( ) # And we retry to save the whole data at its final location. Dict ( content ) . to_json ( self . file )", "nl": "Save the current time to the file ."}}