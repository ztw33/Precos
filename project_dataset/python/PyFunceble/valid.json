{"translation": {"code": "def databases_to_delete ( cls ) : # pragma: no cover # We initiate the directory we have to look for. directory = PyFunceble . CURRENT_DIRECTORY # We initate the result variable. result = [ ] # We append the dir_structure file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"dir_structure\" ] ) # We append the iana file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"iana\" ] ) # We append the public suffix file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"public_suffix\" ] ) # We append the inactive database file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"inactive_db\" ] ) # We append the mining database file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"mining\" ] ) # We append the whois database file. result . append ( directory + PyFunceble . CONFIGURATION [ \"outputs\" ] [ \"default_files\" ] [ \"whois_db\" ] ) return result", "nl": "Set the databases files to delete ."}}
{"translation": {"code": "def referer_not_found ( self , extension ) : if PyFunceble . CONFIGURATION [ \"logs\" ] : # The logs subsystem is activated. to_write = { self . current_time : { \"domain\" : PyFunceble . INTERN [ \"to_test\" ] , \"extension\" : extension , } } if self . output : output = self . output else : output = PyFunceble . OUTPUT_DIRECTORY output += PyFunceble . OUTPUTS [ \"parent_directory\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"parent\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"filenames\" ] [ \"no_referer\" ] current_content = self . _get_content ( output ) current_content . update ( to_write ) self . _write_content ( current_content , output ) if PyFunceble . CONFIGURATION [ \"share_logs\" ] : # The logs sharing is activated. # And we share the logs with the api. PyFunceble . requests . post ( PyFunceble . LINKS [ \"api_no_referer\" ] , data = to_write [ self . current_time ] )", "nl": "Logs the case that the referer was not found ."}}
{"translation": {"code": "def _write_content ( cls , content , file ) : if not PyFunceble . CONFIGURATION [ \"no_files\" ] : if not isinstance ( content , dict ) : content = { } Dict ( content ) . to_json ( file )", "nl": "Write the content into the given file ."}}
{"translation": {"code": "def whois ( self , record ) : if PyFunceble . CONFIGURATION [ \"debug\" ] and PyFunceble . CONFIGURATION [ \"logs\" ] : # The debug and the logs subsystem are activated. if PyFunceble . INTERN [ \"referer\" ] : referer = PyFunceble . INTERN [ \"referer\" ] else : referer = None to_write = { self . current_time : { \"domain\" : PyFunceble . INTERN [ \"to_test\" ] , \"record\" : record , \"referer\" : referer , } } if self . output : output = self . output else : output = PyFunceble . OUTPUT_DIRECTORY output += PyFunceble . OUTPUTS [ \"parent_directory\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"parent\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"filenames\" ] [ \"whois\" ] current_content = self . _get_content ( output ) current_content . update ( to_write ) self . _write_content ( current_content , output )", "nl": "Logs the WHOIS record if needed ."}}
{"translation": {"code": "def expiration_date ( self , extracted ) : if PyFunceble . CONFIGURATION [ \"logs\" ] : # The logs subsystem is activated. if PyFunceble . INTERN [ \"referer\" ] : referer = PyFunceble . INTERN [ \"referer\" ] else : referer = None to_write = { self . current_time : { \"domain\" : PyFunceble . INTERN [ \"to_test\" ] , \"expiration_date\" : extracted , \"whois_server\" : referer , } } if self . output : output = self . output else : output = PyFunceble . OUTPUT_DIRECTORY output += PyFunceble . OUTPUTS [ \"parent_directory\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"directories\" ] [ \"parent\" ] output += PyFunceble . OUTPUTS [ \"logs\" ] [ \"filenames\" ] [ \"date_format\" ] current_content = self . _get_content ( output ) current_content . update ( to_write ) self . _write_content ( current_content , output ) if PyFunceble . CONFIGURATION [ \"share_logs\" ] : # The logs sharing is activated. # And we share the logs with the api. PyFunceble . requests . post ( PyFunceble . LINKS [ \"api_date_format\" ] , data = to_write [ self . current_time ] , )", "nl": "Logs the extracted expiration date ."}}
{"translation": {"code": "def ipv4_syntax_check ( ip ) : # pragma: no cover if ip and isinstance ( ip , str ) : # The given IP is not empty nor None. # and # * The given IP is a string. # We silently load the configuration. load_config ( True ) return Check ( ip ) . is_ip_valid ( ) # We return None, there is nothing to check. return None", "nl": "Check the syntax of the given IPv4 ."}}
{"translation": {"code": "def is_ipv4_range ( ip ) : # pragma: no cover if ip and isinstance ( ip , str ) : # The given IP is not empty nor None. # and # * The given IP is a string. # We silently load the configuration. load_config ( True ) return Check ( ip ) . is_ip_range ( ) # We return None, there is nothing to check. return None", "nl": "Check if the given IP is an IP range ."}}
{"translation": {"code": "def _format_decoded ( self , to_format , result = None ) : # pragma: no cover if not result : # The result is not given. # We set the result as an empty list. result = [ ] for data in List ( to_format ) . format ( ) : # We loop through the different lines to format. if data : # The currently read line is not empty. if \"^\" in data : # There is an accent in the currently read line. # We recall this method but with the current result state # and splited data. return self . _format_decoded ( data . split ( \"^\" ) , result ) if \"#\" in data : # There is a dash in the currently read line. # We recall this method but with the current result state # and splited data. return self . _format_decoded ( data . split ( \"#\" ) , result ) if \",\" in data : # There is a comma in the currently read line. # We recall this method but with the current result state # and splited data. return self . _format_decoded ( data . split ( \",\" ) , result ) if \"!\" in data : # There is an exclamation mark in the currently read line. # We recall this method but with the current result state # and splited data. return self . _format_decoded ( data . split ( \"!\" ) , result ) if \"|\" in data : # There is a vertival bar in the currently read line. # We recall this method but with the current result state # and splited data. return self . _format_decoded ( data . split ( \"|\" ) , result ) if data : # The currently read line is not empty. data = self . _extract_base ( data ) if data and ( self . checker . is_domain_valid ( data ) or self . checker . is_ip_valid ( data ) ) : # The extraced base is not empty. # and # * The currently read line is a valid domain. # or # * The currently read line is a valid IP. # We append the currently read line to the result. result . append ( data ) elif data : # * The currently read line is not a valid domain. # or # * The currently read line is not a valid IP. # We try to get the url base. url_base = self . checker . is_url_valid ( data , return_base = True ) if url_base : # The url_base is not empty or equal to False or None. # We append the url base to the result. result . append ( url_base ) # We return the result element. return result", "nl": "Format the exctracted adblock line before passing it to the system ."}}
{"translation": {"code": "def _is_to_ignore ( cls , line ) : # We set the list of regex to match to be # considered as ignored. to_ignore = [ r\"(^!|^@@|^\\/|^\\[|^\\.|^-|^_|^\\?|^&)\" ] # , r\"(\\$|,)(image)\"] for element in to_ignore : # We loop through the list of regex. if Regex ( line , element , return_data = False ) . match ( ) : # The currently read line match the currently read # regex. # We return true, it has to be ignored. return True # Wer return False, it does not has to be ignored. return False", "nl": "Check if we have to ignore the given line ."}}
{"translation": {"code": "def load ( self ) : if \"iana_db\" not in PyFunceble . INTERN or not PyFunceble . INTERN [ \"iana_db\" ] : # The global database is empty, None or does not exist. # We update it with the database content. PyFunceble . INTERN [ \"iana_db\" ] = self . iana_db", "nl": "Initiate the IANA database if it is not the case ."}}
{"translation": {"code": "def is_present ( cls ) : if PyFunceble . CONFIGURATION [ \"inactive_database\" ] : # The database subsystem is activated. if PyFunceble . INTERN [ \"to_test\" ] in PyFunceble . INTERN [ \"flatten_inactive_db\" ] or ( PyFunceble . INTERN [ \"file_to_test\" ] in PyFunceble . INTERN [ \"inactive_db\" ] and PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] and \"to_test\" in PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] and PyFunceble . INTERN [ \"to_test\" ] in PyFunceble . INTERN [ \"inactive_db\" ] [ PyFunceble . INTERN [ \"file_to_test\" ] ] [ \"to_test\" ] ) : return True return False", "nl": "Check if the currently tested element is into the database ."}}
{"translation": {"code": "def _do_not_produce_file ( self ) : if ( Inactive ( ) . is_present ( ) and self . domain_status in [ PyFunceble . STATUS [ \"official\" ] [ \"down\" ] , PyFunceble . STATUS [ \"official\" ] [ \"invalid\" ] , ] and PyFunceble . INTERN [ \"to_test\" ] not in PyFunceble . INTERN [ \"extracted_list_to_test\" ] ) : return True return False", "nl": "Check if we are allowed to produce a file based from the given information ."}}
{"translation": {"code": "def is_subdomain ( domain ) : # pragma: no cover if domain and isinstance ( domain , str ) : # * The given domain is not empty nor None. # and # * The given domain is a string. # We silently load the configuration. load_config ( True ) return Check ( domain ) . is_subdomain ( ) # We return None, there is nothing to check. return None", "nl": "Check if the given domain is a subdomain ."}}