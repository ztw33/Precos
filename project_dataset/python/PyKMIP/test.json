{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _nonce_id : self . _nonce_id . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Nonce struct is missing the nonce ID.\" ) if self . _nonce_value : self . _nonce_value . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Nonce struct is missing the nonce value.\" ) self . length = local_stream . length ( ) super ( Nonce , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Nonce struct to a stream ."}}
{"translation": {"code": "def get_client_identity_from_certificate ( certificate ) : client_ids = get_common_names_from_certificate ( certificate ) if len ( client_ids ) > 0 : if len ( client_ids ) > 1 : raise exceptions . PermissionDenied ( \"Multiple client identities found.\" ) return client_ids [ 0 ] else : raise exceptions . PermissionDenied ( \"The certificate does not define any subject common names. \" \"Client identity unavailable.\" )", "nl": "Given an X . 509 certificate extract and return the client identity ."}}
{"translation": {"code": "def authenticate ( self , connection_certificate = None , connection_info = None , request_credentials = None ) : if ( self . users_url is None ) or ( self . groups_url is None ) : raise exceptions . ConfigurationError ( \"The SLUGS URL must be specified.\" ) user_id = utils . get_client_identity_from_certificate ( connection_certificate ) try : response = requests . get ( self . users_url . format ( user_id ) ) except Exception : raise exceptions . ConfigurationError ( \"A connection could not be established using the SLUGS URL.\" ) if response . status_code == 404 : raise exceptions . PermissionDenied ( \"Unrecognized user ID: {}\" . format ( user_id ) ) response = requests . get ( self . groups_url . format ( user_id ) ) if response . status_code == 404 : raise exceptions . PermissionDenied ( \"Group information could not be retrieved for user ID: \" \"{}\" . format ( user_id ) ) return user_id , response . json ( ) . get ( 'groups' )", "nl": "Query the configured SLUGS service with the provided credentials ."}}
{"translation": {"code": "def get_json_files ( p ) : f = [ os . path . join ( p , x ) for x in os . listdir ( p ) if x . endswith ( \".json\" ) ] return sorted ( f )", "nl": "Scan the provided policy directory for all JSON policy files ."}}
{"translation": {"code": "def run ( self ) : self . initialize_tracking_structures ( ) if self . live_monitoring : self . logger . info ( \"Starting up the operation policy file monitor.\" ) while not self . halt_trigger . is_set ( ) : time . sleep ( 1 ) self . scan_policies ( ) self . logger . info ( \"Stopping the operation policy file monitor.\" ) else : self . scan_policies ( )", "nl": "Start monitoring operation policy files ."}}
{"translation": {"code": "def scan_policies ( self ) : policy_files = get_json_files ( self . policy_directory ) for f in set ( policy_files ) - set ( self . policy_files ) : self . file_timestamps [ f ] = 0 for f in set ( self . policy_files ) - set ( policy_files ) : self . logger . info ( \"Removing policies for file: {}\" . format ( f ) ) self . file_timestamps . pop ( f , None ) for p in self . policy_cache . keys ( ) : self . disassociate_policy_and_file ( p , f ) for p in [ k for k , v in self . policy_map . items ( ) if v == f ] : self . restore_or_delete_policy ( p ) self . policy_files = policy_files for f in sorted ( self . file_timestamps . keys ( ) ) : t = os . path . getmtime ( f ) if t > self . file_timestamps [ f ] : self . logger . info ( \"Loading policies for file: {}\" . format ( f ) ) self . file_timestamps [ f ] = t old_p = [ k for k , v in self . policy_map . items ( ) if v == f ] try : new_p = operation_policy . read_policy_from_file ( f ) except ValueError : self . logger . error ( \"Failure loading file: {}\" . format ( f ) ) self . logger . debug ( \"\" , exc_info = True ) continue for p in new_p . keys ( ) : self . logger . info ( \"Loading policy: {}\" . format ( p ) ) if p in self . reserved_policies : self . logger . warning ( \"Policy '{}' overwrites a reserved policy and \" \"will be thrown out.\" . format ( p ) ) continue if p in sorted ( self . policy_store . keys ( ) ) : self . logger . debug ( \"Policy '{}' overwrites an existing \" \"policy.\" . format ( p ) ) if f != self . policy_map . get ( p ) : self . policy_cache . get ( p ) . append ( ( time . time ( ) , self . policy_map . get ( p ) , self . policy_store . get ( p ) ) ) else : self . policy_cache [ p ] = [ ] self . policy_store [ p ] = new_p . get ( p ) self . policy_map [ p ] = f for p in set ( old_p ) - set ( new_p . keys ( ) ) : self . disassociate_policy_and_file ( p , f ) self . restore_or_delete_policy ( p )", "nl": "Scan the policy directory for policy data ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( RekeyResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"The Rekey response payload encoding is missing the unique \" \"identifier.\" ) if self . is_tag_next ( enums . Tags . TEMPLATE_ATTRIBUTE , local_stream ) : self . _template_attribute = objects . TemplateAttribute ( ) self . _template_attribute . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Rekey response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def rekey ( self , uid = None , offset = None , * * kwargs ) : if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"The unique identifier must be a string.\" ) if offset is not None : if not isinstance ( offset , six . integer_types ) : raise TypeError ( \"The offset must be an integer.\" ) # TODO (peter-hamilton) Unify attribute handling across operations attributes = [ ] if kwargs . get ( 'activation_date' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . ACTIVATION_DATE , kwargs . get ( 'activation_date' ) ) ) if kwargs . get ( 'process_start_date' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . PROCESS_START_DATE , kwargs . get ( 'process_start_date' ) ) ) if kwargs . get ( 'protect_stop_date' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . PROTECT_STOP_DATE , kwargs . get ( 'protect_stop_date' ) ) ) if kwargs . get ( 'deactivation_date' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . DEACTIVATION_DATE , kwargs . get ( 'deactivation_date' ) ) ) template_attribute = cobjects . TemplateAttribute ( attributes = attributes ) # Derive the new key/data and handle the results result = self . proxy . rekey ( uuid = uid , offset = offset , template_attribute = template_attribute ) status = result . get ( 'result_status' ) if status == enums . ResultStatus . SUCCESS : return result . get ( 'unique_identifier' ) else : raise exceptions . KmipOperationFailure ( status , result . get ( 'result_reason' ) , result . get ( 'result_message' ) )", "nl": "Rekey an existing key ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( LocateRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . MAXIMUM_ITEMS , local_buffer ) : self . _maximum_items = primitives . Integer ( tag = enums . Tags . MAXIMUM_ITEMS ) self . _maximum_items . read ( local_buffer , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . OFFSET_ITEMS , local_buffer ) : self . _offset_items = primitives . Integer ( tag = enums . Tags . OFFSET_ITEMS ) self . _offset_items . read ( local_buffer , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . STORAGE_STATUS_MASK , local_buffer ) : self . _storage_status_mask = primitives . Integer ( tag = enums . Tags . STORAGE_STATUS_MASK ) self . _storage_status_mask . read ( local_buffer , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . OBJECT_GROUP_MEMBER , local_buffer ) : self . _object_group_member = primitives . Enumeration ( enums . ObjectGroupMember , tag = enums . Tags . OBJECT_GROUP_MEMBER ) self . _object_group_member . read ( local_buffer , kmip_version = kmip_version ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : while self . is_tag_next ( enums . Tags . ATTRIBUTE , local_buffer ) : attribute = objects . Attribute ( ) attribute . read ( local_buffer , kmip_version = kmip_version ) self . _attributes . append ( attribute ) else : if self . is_tag_next ( enums . Tags . ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( ) attributes . read ( local_buffer , kmip_version = kmip_version ) # TODO (ph) Add a new utility to avoid using TemplateAttributes temp_attr = objects . convert_attributes_to_template_attribute ( attributes ) self . _attributes = temp_attr . attributes else : raise exceptions . InvalidKmipEncoding ( \"The Locate request payload encoding is missing the \" \"attributes structure.\" )", "nl": "Read the data encoding the Locate request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the Attributes object.\" . format ( kmip_version . value ) ) local_stream = BytearrayStream ( ) for attribute in self . _attributes : tag = attribute . tag if not enums . is_attribute ( tag , kmip_version = kmip_version ) : raise exceptions . AttributeNotSupported ( \"Attribute {} is not supported by KMIP {}.\" . format ( tag . name , kmip_version . value ) ) attribute . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( Attributes , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the Attributes structure encoding to the data stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the Attributes object.\" . format ( kmip_version . value ) ) super ( Attributes , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) while True : if len ( local_stream ) < 3 : break tag = struct . unpack ( '!I' , b'\\x00' + local_stream . peek ( 3 ) ) [ 0 ] if enums . is_enum_value ( enums . Tags , tag ) : tag = enums . Tags ( tag ) if not enums . is_attribute ( tag , kmip_version = kmip_version ) : raise exceptions . AttributeNotSupported ( \"Attribute {} is not supported by KMIP {}.\" . format ( tag . name , kmip_version . value ) ) value = self . _factory . create_attribute_value_by_enum ( tag , None ) value . read ( local_stream , kmip_version = kmip_version ) self . _attributes . append ( value ) else : break self . is_oversized ( local_stream )", "nl": "Read the data stream and decode the Attributes structure into its parts ."}}
{"translation": {"code": "def get_bit_mask_from_enumerations ( enumerations ) : return functools . reduce ( lambda x , y : x | y , [ z . value for z in enumerations ] )", "nl": "A utility function that computes a bit mask from a collection of enumeration values ."}}
{"translation": {"code": "def is_bit_mask ( enumeration , potential_mask ) : if not isinstance ( potential_mask , six . integer_types ) : return False mask_enumerations = ( CryptographicUsageMask , ProtectionStorageMask , StorageStatusMask ) if enumeration not in mask_enumerations : return False mask = 0 for value in [ e . value for e in enumeration ] : if ( value & potential_mask ) == value : mask |= value if mask != potential_mask : return False return True", "nl": "A utility function that checks if the provided value is a composite bit mask of enumeration values in the specified enumeration class ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the AttributeReference \" \"object.\" . format ( kmip_version . value ) ) super ( AttributeReference , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . VENDOR_IDENTIFICATION , local_buffer ) : self . _vendor_identification = primitives . TextString ( tag = enums . Tags . VENDOR_IDENTIFICATION ) self . _vendor_identification . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The AttributeReference encoding is missing the vendor \" \"identification string.\" ) if self . is_tag_next ( enums . Tags . ATTRIBUTE_NAME , local_buffer ) : self . _attribute_name = primitives . TextString ( tag = enums . Tags . ATTRIBUTE_NAME ) self . _attribute_name . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The AttributeReference encoding is missing the attribute \" \"name string.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data stream and decode the AttributeReference structure into its parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the ObjectDefaults object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _object_type : self . _object_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ObjectDefaults structure is missing the object type \" \"field.\" ) if self . _attributes : self . _attributes . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ObjectDefaults structure is missing the attributes field.\" ) self . length = local_buffer . length ( ) super ( ObjectDefaults , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the ObjectDefaults structure encoding to the data stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the RNGParameters object.\" . format ( kmip_version . value ) ) super ( RNGParameters , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . RNG_ALGORITHM , local_buffer ) : rng_algorithm = primitives . Enumeration ( enums . RNGAlgorithm , tag = enums . Tags . RNG_ALGORITHM ) rng_algorithm . read ( local_buffer , kmip_version = kmip_version ) self . _rng_algorithm = rng_algorithm else : raise exceptions . InvalidKmipEncoding ( \"The RNGParameters encoding is missing the RNG algorithm.\" ) if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_ALGORITHM , local_buffer ) : cryptographic_algorithm = primitives . Enumeration ( enums . CryptographicAlgorithm , tag = enums . Tags . CRYPTOGRAPHIC_ALGORITHM ) cryptographic_algorithm . read ( local_buffer , kmip_version = kmip_version ) self . _cryptographic_algorithm = cryptographic_algorithm if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_LENGTH , local_buffer ) : cryptographic_length = primitives . Integer ( tag = enums . Tags . CRYPTOGRAPHIC_LENGTH ) cryptographic_length . read ( local_buffer , kmip_version = kmip_version ) self . _cryptographic_length = cryptographic_length if self . is_tag_next ( enums . Tags . HASHING_ALGORITHM , local_buffer ) : hashing_algorithm = primitives . Enumeration ( enums . HashingAlgorithm , tag = enums . Tags . HASHING_ALGORITHM ) hashing_algorithm . read ( local_buffer , kmip_version = kmip_version ) self . _hashing_algorithm = hashing_algorithm if self . is_tag_next ( enums . Tags . DRBG_ALGORITHM , local_buffer ) : drbg_algorithm = primitives . Enumeration ( enums . DRBGAlgorithm , tag = enums . Tags . DRBG_ALGORITHM ) drbg_algorithm . read ( local_buffer , kmip_version = kmip_version ) self . _drbg_algorithm = drbg_algorithm if self . is_tag_next ( enums . Tags . RECOMMENDED_CURVE , local_buffer ) : recommended_curve = primitives . Enumeration ( enums . RecommendedCurve , tag = enums . Tags . RECOMMENDED_CURVE ) recommended_curve . read ( local_buffer , kmip_version = kmip_version ) self . _recommended_curve = recommended_curve if self . is_tag_next ( enums . Tags . FIPS186_VARIATION , local_buffer ) : fips186_variation = primitives . Enumeration ( enums . FIPS186Variation , tag = enums . Tags . FIPS186_VARIATION ) fips186_variation . read ( local_buffer , kmip_version = kmip_version ) self . _fips186_variation = fips186_variation if self . is_tag_next ( enums . Tags . PREDICTION_RESISTANCE , local_buffer ) : prediction_resistance = primitives . Boolean ( tag = enums . Tags . PREDICTION_RESISTANCE ) prediction_resistance . read ( local_buffer , kmip_version = kmip_version ) self . _prediction_resistance = prediction_resistance self . is_oversized ( local_buffer )", "nl": "Read the data encoding the RNGParameters structure and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the ProfileInformation \" \"object.\" . format ( kmip_version . value ) ) super ( ProfileInformation , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . PROFILE_NAME , local_buffer ) : profile_name = primitives . Enumeration ( enums . ProfileName , tag = enums . Tags . PROFILE_NAME ) profile_name . read ( local_buffer , kmip_version = kmip_version ) self . _profile_name = profile_name else : raise exceptions . InvalidKmipEncoding ( \"The ProfileInformation encoding is missing the profile name.\" ) if self . is_tag_next ( enums . Tags . SERVER_URI , local_buffer ) : server_uri = primitives . TextString ( tag = enums . Tags . SERVER_URI ) server_uri . read ( local_buffer , kmip_version = kmip_version ) self . _server_uri = server_uri if self . is_tag_next ( enums . Tags . SERVER_PORT , local_buffer ) : server_port = primitives . Integer ( tag = enums . Tags . SERVER_PORT ) server_port . read ( local_buffer , kmip_version = kmip_version ) self . _server_port = server_port self . is_oversized ( local_buffer )", "nl": "Read the data encoding the ProfileInformation structure and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the ProfileInformation \" \"object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _profile_name : self . _profile_name . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ProfileInformation structure is missing the profile \" \"name field.\" ) if self . _server_uri : self . _server_uri . write ( local_buffer , kmip_version = kmip_version ) if self . _server_port : self . _server_port . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( ProfileInformation , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the ProfileInformation structure encoding to the data stream ."}}