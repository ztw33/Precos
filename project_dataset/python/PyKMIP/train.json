{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Certificate , self ) . read ( istream , kmip_version = kmip_version ) tstream = BytearrayStream ( istream . read ( self . length ) ) self . certificate_type = CertificateType ( ) self . certificate_value = CertificateValue ( ) self . certificate_type . read ( tstream , kmip_version = kmip_version ) self . certificate_value . read ( tstream , kmip_version = kmip_version ) self . is_oversized ( tstream )", "nl": "Read the data encoding the Certificate object and decode it into its constituent parts ."}}
{"translation": {"code": "def create ( self , secret_type , value = None ) : if secret_type is ObjectType . CERTIFICATE : return self . _create_certificate ( value ) elif secret_type is ObjectType . SYMMETRIC_KEY : return self . _create_symmetric_key ( value ) elif secret_type is ObjectType . PUBLIC_KEY : return self . _create_public_key ( value ) elif secret_type is ObjectType . PRIVATE_KEY : return self . _create_private_key ( value ) elif secret_type is ObjectType . SPLIT_KEY : return self . _create_split_key ( value ) elif secret_type is ObjectType . TEMPLATE : return self . _create_template ( value ) elif secret_type is ObjectType . SECRET_DATA : return self . _create_secret_data ( value ) elif secret_type is ObjectType . OPAQUE_DATA : return self . _create_opaque_data ( value ) else : raise TypeError ( \"Unrecognized secret type: {0}\" . format ( secret_type ) )", "nl": "Create a secret object of the specified type with the given value ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( KeyWrappingSpecification , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . WRAPPING_METHOD , local_stream ) : self . _wrapping_method = primitives . Enumeration ( enum = enums . WrappingMethod , tag = enums . Tags . WRAPPING_METHOD ) self . _wrapping_method . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the wrapping method attribute.\" ) if self . is_tag_next ( enums . Tags . ENCRYPTION_KEY_INFORMATION , local_stream ) : self . _encryption_key_information = EncryptionKeyInformation ( ) self . _encryption_key_information . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . MAC_SIGNATURE_KEY_INFORMATION , local_stream ) : self . _mac_signature_key_information = MACSignatureKeyInformation ( ) self . _mac_signature_key_information . read ( local_stream , kmip_version = kmip_version ) attribute_names = [ ] while self . is_tag_next ( enums . Tags . ATTRIBUTE_NAME , local_stream ) : attribute_name = primitives . TextString ( tag = enums . Tags . ATTRIBUTE_NAME ) attribute_name . read ( local_stream , kmip_version = kmip_version ) attribute_names . append ( attribute_name ) self . _attribute_names = attribute_names if self . is_tag_next ( enums . Tags . ENCODING_OPTION , local_stream ) : self . _encoding_option = primitives . Enumeration ( enum = enums . EncodingOption , tag = enums . Tags . ENCODING_OPTION ) self . _encoding_option . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the KeyWrappingSpecification struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _credential_type : self . _credential_type . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Credential struct missing the credential type.\" ) if self . _credential_value : self . _credential_value . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Credential struct missing the credential value.\" ) self . length = local_stream . length ( ) super ( Credential , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Credential struct to a stream ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _major : self . _major . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the major protocol version number.\" ) if self . _minor : self . _minor . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the minor protocol version number.\" ) self . length = local_stream . length ( ) super ( ProtocolVersion , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the ProtocolVersion struct to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( ProtocolVersion , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . PROTOCOL_VERSION_MAJOR , local_stream ) : self . _major = primitives . Integer ( tag = enums . Tags . PROTOCOL_VERSION_MAJOR ) self . _major . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid encoding missing the major protocol version number.\" ) if self . is_tag_next ( enums . Tags . PROTOCOL_VERSION_MINOR , local_stream ) : self . _minor = primitives . Integer ( tag = enums . Tags . PROTOCOL_VERSION_MINOR ) self . _minor . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid encoding missing the minor protocol version number.\" ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the ProtocolVersion struct and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( LongInteger , self ) . read ( istream , kmip_version = kmip_version ) if self . length is not LongInteger . LENGTH : raise exceptions . InvalidPrimitiveLength ( \"invalid long integer length read; \" \"expected: {0}, observed: {1}\" . format ( LongInteger . LENGTH , self . length ) ) self . value = unpack ( '!q' , istream . read ( self . length ) ) [ 0 ] self . validate ( )", "nl": "Read the encoding of the LongInteger from the input stream ."}}
{"translation": {"code": "def validate ( self ) : if self . value is not None : if not isinstance ( self . value , six . integer_types ) : raise TypeError ( 'expected (one of): {0}, observed: {1}' . format ( six . integer_types , type ( self . value ) ) ) else : if self . value > LongInteger . MAX : raise ValueError ( 'long integer value greater than accepted max' ) elif self . value < LongInteger . MIN : raise ValueError ( 'long integer value less than accepted min' )", "nl": "Verify that the value of the LongInteger is valid ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : # Convert the value to binary and pad it as needed. binary = \"{0:b}\" . format ( abs ( self . value ) ) binary = ( \"0\" * ( 64 - ( len ( binary ) % 64 ) ) ) + binary # If the value is negative, convert via two's complement. if self . value < 0 : binary = binary . replace ( '1' , 'i' ) binary = binary . replace ( '0' , '1' ) binary = binary . replace ( 'i' , '0' ) pivot = binary . rfind ( '0' ) binary = binary [ 0 : pivot ] + '1' + ( '0' * len ( binary [ pivot + 1 : ] ) ) # Convert each byte to hex and build the hex string for the value. hexadecimal = b'' for i in range ( 0 , len ( binary ) , 8 ) : byte = binary [ i : i + 8 ] byte = int ( byte , 2 ) hexadecimal += struct . pack ( '!B' , byte ) self . length = len ( hexadecimal ) super ( BigInteger , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( hexadecimal )", "nl": "Write the encoding of the BigInteger to the output stream ."}}
{"translation": {"code": "def create ( cls , application_namespace , application_data ) : namespace = ApplicationNamespace ( application_namespace ) data = ApplicationData ( application_data ) return ApplicationSpecificInformation ( application_namespace = namespace , application_data = data )", "nl": "Construct an ApplicationSpecificInformation object from provided data and namespace values ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( BigInteger , self ) . read ( istream , kmip_version = kmip_version ) # Check for a valid length before even trying to parse the value. if self . length % 8 : raise exceptions . InvalidPrimitiveLength ( \"invalid big integer length read; \" \"expected: multiple of 8, observed: {0}\" . format ( self . length ) ) sign = 1 binary = '' # Read the value byte by byte and convert it into binary, padding each # byte as needed. for _ in range ( self . length ) : byte = struct . unpack ( '!B' , istream . read ( 1 ) ) [ 0 ] bits = \"{0:b}\" . format ( byte ) pad = len ( bits ) % 8 if pad : bits = ( '0' * ( 8 - pad ) ) + bits binary += bits # If the value is negative, convert via two's complement. if binary [ 0 ] == '1' : sign = - 1 binary = binary . replace ( '1' , 'i' ) binary = binary . replace ( '0' , '1' ) binary = binary . replace ( 'i' , '0' ) pivot = binary . rfind ( '0' ) binary = binary [ 0 : pivot ] + '1' + ( '0' * len ( binary [ pivot + 1 : ] ) ) # Convert the value back to an integer and reapply the sign. self . value = int ( binary , 2 ) * sign", "nl": "Read the encoding of the BigInteger from the input stream ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( ApplicationSpecificInformation , self ) . read ( istream , kmip_version = kmip_version ) tstream = BytearrayStream ( istream . read ( self . length ) ) self . application_namespace . read ( tstream , kmip_version = kmip_version ) self . application_data . read ( tstream , kmip_version = kmip_version ) self . is_oversized ( tstream ) self . validate ( )", "nl": "Read the data encoding the ApplicationSpecificInformation object and decode it into its constituent parts ."}}
{"translation": {"code": "def validate ( self ) : if self . value is not None : if not isinstance ( self . value , six . integer_types ) : raise TypeError ( 'expected (one of): {0}, observed: {1}' . format ( six . integer_types , type ( self . value ) ) )", "nl": "Verify that the value of the BigInteger is valid ."}}
{"translation": {"code": "def validate ( self ) : if not isinstance ( self . enum , enumeration . EnumMeta ) : raise TypeError ( 'enumeration type {0} must be of type EnumMeta' . format ( self . enum ) ) if self . value is not None : if not isinstance ( self . value , self . enum ) : raise TypeError ( 'enumeration {0} must be of type {1}' . format ( self . value , self . enum ) ) if type ( self . value . value ) not in six . integer_types : raise TypeError ( 'enumeration value must be an int' ) else : if self . value . value > Enumeration . MAX : raise ValueError ( 'enumeration value greater than accepted max' ) elif self . value . value < Enumeration . MIN : raise ValueError ( 'enumeration value less than accepted min' )", "nl": "Verify that the value of the Enumeration is valid ."}}
{"translation": {"code": "def read_value ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : try : value = unpack ( '!Q' , istream . read ( self . LENGTH ) ) [ 0 ] except Exception : self . logger . error ( \"Error reading boolean value from buffer\" ) raise if value == 1 : self . value = True elif value == 0 : self . value = False else : raise ValueError ( \"expected: 0 or 1, observed: {0}\" . format ( value ) ) self . validate ( )", "nl": "Read the value of the Boolean object from the input stream ."}}
{"translation": {"code": "def create ( cls , name_value , name_type ) : if isinstance ( name_value , Name . NameValue ) : value = name_value elif isinstance ( name_value , str ) : value = cls . NameValue ( name_value ) else : name = 'Name' msg = exceptions . ErrorStrings . BAD_EXP_RECV member = 'name_value' raise TypeError ( msg . format ( '{0}.{1}' . format ( name , member ) , 'name_value' , type ( Name . NameValue ) , type ( name_value ) ) ) if isinstance ( name_type , Name . NameType ) : n_type = name_type elif isinstance ( name_type , Enum ) : n_type = cls . NameType ( name_type ) else : name = 'Name' msg = exceptions . ErrorStrings . BAD_EXP_RECV member = 'name_type' raise TypeError ( msg . format ( '{0}.{1}' . format ( name , member ) , 'name_type' , type ( Name . NameType ) , type ( name_type ) ) ) return Name ( name_value = value , name_type = n_type )", "nl": "Returns a Name object populated with the given value and type"}}
{"translation": {"code": "def validate ( self ) : if self . value : if not isinstance ( self . value , bool ) : raise TypeError ( \"expected: {0}, observed: {1}\" . format ( bool , type ( self . value ) ) )", "nl": "Verify that the value of the Boolean object is valid ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if len ( self . _credentials ) == 0 : raise ValueError ( \"Authentication struct missing credentials.\" ) for credential in self . _credentials : credential . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( Authentication , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Authentication struct to a stream ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : tstream = BytearrayStream ( ) self . certificate_type . write ( tstream , kmip_version = kmip_version ) self . certificate_value . write ( tstream , kmip_version = kmip_version ) self . length = tstream . length ( ) super ( Certificate , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( tstream . buffer )", "nl": "Write the data encoding the Certificate object to a stream ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : tstream = BytearrayStream ( ) self . application_namespace . write ( tstream , kmip_version = kmip_version ) self . application_data . write ( tstream , kmip_version = kmip_version ) self . length = tstream . length ( ) super ( ApplicationSpecificInformation , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( tstream . buffer )", "nl": "Write the data encoding the ApplicationSpecificInformation object to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Authentication , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) credentials = [ ] while self . is_tag_next ( enums . Tags . CREDENTIAL , local_stream ) : credential = objects . Credential ( ) credential . read ( local_stream , kmip_version = kmip_version ) credentials . append ( credential ) if len ( credentials ) == 0 : raise ValueError ( \"Authentication encoding missing credentials.\" ) self . _credentials = credentials self . is_oversized ( local_stream )", "nl": "Read the data encoding the Authentication struct and decode it into its constituent parts ."}}
{"translation": {"code": "def get_valid_value ( self , direct_value , config_section , config_option_name , default_value ) : ARG_MSG = \"Using given value '{0}' for {1}\" CONF_MSG = \"Using value '{0}' from configuration file {1} for {2}\" DEFAULT_MSG = \"Using default value '{0}' for {1}\" if direct_value : return_value = direct_value self . logger . debug ( ARG_MSG . format ( direct_value , config_option_name ) ) else : try : return_value = self . conf . get ( config_section , config_option_name ) self . logger . debug ( CONF_MSG . format ( return_value , CONFIG_FILE , config_option_name ) ) except Exception : return_value = default_value self . logger . debug ( DEFAULT_MSG . format ( default_value , config_option_name ) ) # TODO (peter-hamilton): Think about adding better value validation if return_value == self . NONE_VALUE : return None else : return return_value", "nl": "Returns a value that can be used as a parameter in client or server . If a direct_value is given that value will be returned instead of the value from the config file . If the appropriate config file option is not found the default_value is returned ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CreateRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . OBJECT_TYPE , local_buffer ) : self . _object_type = primitives . Enumeration ( enums . ObjectType , tag = enums . Tags . OBJECT_TYPE ) self . _object_type . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The Create request payload encoding is missing the object \" \"type.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . TEMPLATE_ATTRIBUTE , local_buffer ) : self . _template_attribute = objects . TemplateAttribute ( ) self . _template_attribute . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The Create request payload encoding is missing the \" \"template attribute.\" ) else : # NOTE (ph) For now, leave attributes natively in TemplateAttribute # form and just convert to the KMIP 2.0 Attributes form as needed # for encoding/decoding purposes. Changing the payload to require # the new Attributes structure will trigger a bunch of second-order # effects across the client and server codebases that is beyond # the scope of updating the Create payloads to support KMIP 2.0. if self . is_tag_next ( enums . Tags . ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( ) attributes . read ( local_buffer , kmip_version = kmip_version ) value = objects . convert_attributes_to_template_attribute ( attributes ) self . _template_attribute = value else : raise exceptions . InvalidKmipEncoding ( \"The Create request payload encoding is missing the \" \"attributes structure.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the Create request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _object_type : self . _object_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Create request payload is missing the object type field.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _template_attribute : self . _template_attribute . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Create request payload is missing the template \" \"attribute field.\" ) else : # NOTE (ph) For now, leave attributes natively in TemplateAttribute # form and just convert to the KMIP 2.0 Attributes form as needed # for encoding/decoding purposes. Changing the payload to require # the new Attributes structure will trigger a bunch of second-order # effects across the client and server codebases that is beyond # the scope of updating the Create payloads to support KMIP 2.0. if self . _template_attribute : attributes = objects . convert_template_attribute_to_attributes ( self . _template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Create request payload is missing the template \" \"attribute field.\" ) self . length = local_buffer . length ( ) super ( CreateRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the Create request payload to a buffer ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CreateResponsePayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . OBJECT_TYPE , local_buffer ) : self . _object_type = primitives . Enumeration ( enums . ObjectType , tag = enums . Tags . OBJECT_TYPE ) self . _object_type . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The Create response payload encoding is missing the object \" \"type.\" ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The Create response payload encoding is missing the unique \" \"identifier.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . TEMPLATE_ATTRIBUTE , local_buffer ) : self . _template_attribute = objects . TemplateAttribute ( ) self . _template_attribute . read ( local_buffer , kmip_version = kmip_version ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the Create response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _object_type : self . _object_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Create response payload is missing the object type field.\" ) if self . _unique_identifier : self . _unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Create response payload is missing the unique identifier \" \"field.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _template_attribute : self . _template_attribute . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( CreateResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the Create response payload to a buffer ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _located_items : self . _located_items . write ( local_buffer , kmip_version = kmip_version ) if self . _unique_identifiers : for unique_identifier in self . _unique_identifiers : unique_identifier . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( LocateResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the Locate response payload to a buffer ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( LocateResponsePayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . LOCATED_ITEMS , local_buffer ) : self . _located_items = primitives . Integer ( tag = enums . Tags . LOCATED_ITEMS ) self . _located_items . read ( local_buffer , kmip_version = kmip_version ) self . _unique_identifiers = [ ] while self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) unique_identifier . read ( local_buffer , kmip_version = kmip_version ) self . _unique_identifiers . append ( unique_identifier ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the Locate response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CreateKeyPairResponsePayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . PRIVATE_KEY_UNIQUE_IDENTIFIER , local_buffer ) : self . _private_key_unique_identifier = primitives . TextString ( tag = enums . Tags . PRIVATE_KEY_UNIQUE_IDENTIFIER ) self . _private_key_unique_identifier . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The CreateKeyPair response payload encoding is missing the \" \"private key unique identifier.\" ) if self . is_tag_next ( enums . Tags . PUBLIC_KEY_UNIQUE_IDENTIFIER , local_buffer ) : self . _public_key_unique_identifier = primitives . TextString ( tag = enums . Tags . PUBLIC_KEY_UNIQUE_IDENTIFIER ) self . _public_key_unique_identifier . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The CreateKeyPair response payload encoding is missing the \" \"public key unique identifier.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . PRIVATE_KEY_TEMPLATE_ATTRIBUTE , local_buffer ) : self . _private_key_template_attribute = objects . TemplateAttribute ( tag = enums . Tags . PRIVATE_KEY_TEMPLATE_ATTRIBUTE ) self . _private_key_template_attribute . read ( local_buffer , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . PUBLIC_KEY_TEMPLATE_ATTRIBUTE , local_buffer ) : self . _public_key_template_attribute = objects . TemplateAttribute ( tag = enums . Tags . PUBLIC_KEY_TEMPLATE_ATTRIBUTE ) self . _public_key_template_attribute . read ( local_buffer , kmip_version = kmip_version ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the CreateKeyPair response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _private_key_unique_identifier : self . _private_key_unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The CreateKeyPair response payload is missing the private \" \"key unique identifier field.\" ) if self . _public_key_unique_identifier : self . _public_key_unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The CreateKeyPair response payload is missing the public \" \"key unique identifier field.\" ) if self . _private_key_template_attribute : self . _private_key_template_attribute . write ( local_buffer , kmip_version = kmip_version ) if self . _public_key_template_attribute : self . _public_key_template_attribute . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( CreateKeyPairResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the CreateKeyPair response payload to a buffer ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _common_template_attribute is not None : self . _common_template_attribute . write ( local_buffer , kmip_version = kmip_version ) else : if self . _common_template_attribute is not None : attributes = objects . convert_template_attribute_to_attributes ( self . _common_template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _private_key_template_attribute is not None : self . _private_key_template_attribute . write ( local_buffer , kmip_version = kmip_version ) else : if self . _private_key_template_attribute is not None : attributes = objects . convert_template_attribute_to_attributes ( self . _private_key_template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _public_key_template_attribute is not None : self . _public_key_template_attribute . write ( local_buffer , kmip_version = kmip_version ) else : if self . _public_key_template_attribute is not None : attributes = objects . convert_template_attribute_to_attributes ( self . _public_key_template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( CreateKeyPairRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the CreateKeyPair request payload to a buffer ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CreateKeyPairRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . COMMON_TEMPLATE_ATTRIBUTE , local_buffer ) : self . _common_template_attribute = objects . TemplateAttribute ( tag = enums . Tags . COMMON_TEMPLATE_ATTRIBUTE ) self . _common_template_attribute . read ( local_buffer , kmip_version = kmip_version ) else : if self . is_tag_next ( enums . Tags . COMMON_ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( tag = enums . Tags . COMMON_ATTRIBUTES ) attributes . read ( local_buffer , kmip_version = kmip_version ) self . _common_template_attribute = objects . convert_attributes_to_template_attribute ( attributes ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . PRIVATE_KEY_TEMPLATE_ATTRIBUTE , local_buffer ) : self . _private_key_template_attribute = objects . TemplateAttribute ( tag = enums . Tags . PRIVATE_KEY_TEMPLATE_ATTRIBUTE ) self . _private_key_template_attribute . read ( local_buffer , kmip_version = kmip_version ) else : if self . is_tag_next ( enums . Tags . PRIVATE_KEY_ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( tag = enums . Tags . PRIVATE_KEY_ATTRIBUTES ) attributes . read ( local_buffer , kmip_version = kmip_version ) self . _private_key_template_attribute = objects . convert_attributes_to_template_attribute ( attributes ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . PUBLIC_KEY_TEMPLATE_ATTRIBUTE , local_buffer ) : self . _public_key_template_attribute = objects . TemplateAttribute ( tag = enums . Tags . PUBLIC_KEY_TEMPLATE_ATTRIBUTE ) self . _public_key_template_attribute . read ( local_buffer , kmip_version = kmip_version ) else : if self . is_tag_next ( enums . Tags . PUBLIC_KEY_ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( tag = enums . Tags . PUBLIC_KEY_ATTRIBUTES ) attributes . read ( local_buffer , kmip_version = kmip_version ) self . _public_key_template_attribute = objects . convert_attributes_to_template_attribute ( attributes ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the CreateKeyPair request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _query_functions : for query_function in self . _query_functions : query_function . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Query request payload is missing the query functions \" \"field.\" ) self . length = local_buffer . length ( ) super ( QueryRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the QueryRequestPayload object to a stream ."}}
{"translation": {"code": "def query ( self , batch = False , query_functions = None , credential = None ) : batch_item = self . _build_query_batch_item ( query_functions ) # TODO (peter-hamilton): Replace this with official client batch mode. if batch : self . batch_items . append ( batch_item ) else : request = self . _build_request_message ( credential , [ batch_item ] ) response = self . _send_and_receive_message ( request ) results = self . _process_batch_items ( response ) return results [ 0 ]", "nl": "Send a Query request to the server ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _operations : for operation in self . _operations : operation . write ( local_buffer , kmip_version = kmip_version ) if self . _object_types : for object_type in self . _object_types : object_type . write ( local_buffer , kmip_version = kmip_version ) if self . _vendor_identification : self . _vendor_identification . write ( local_buffer , kmip_version = kmip_version ) if self . _server_information : self . _server_information . write ( local_buffer , kmip_version = kmip_version ) if self . _application_namespaces : for application_namespace in self . _application_namespaces : application_namespace . write ( local_buffer , kmip_version = kmip_version ) if kmip_version >= enums . KMIPVersion . KMIP_1_1 : if self . _extension_information : for extension_information in self . _extension_information : extension_information . write ( local_buffer , kmip_version = kmip_version ) if kmip_version >= enums . KMIPVersion . KMIP_1_2 : if self . _attestation_types : for attestation_type in self . _attestation_types : attestation_type . write ( local_buffer , kmip_version = kmip_version ) if kmip_version >= enums . KMIPVersion . KMIP_1_3 : if self . _rng_parameters : for rng_parameters in self . _rng_parameters : rng_parameters . write ( local_buffer , kmip_version = kmip_version ) if self . _profile_information : for profile_information in self . _profile_information : profile_information . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_information : for validation_information in self . _validation_information : validation_information . write ( local_buffer , kmip_version = kmip_version ) if self . _capability_information : for capability_information in self . _capability_information : capability_information . write ( local_buffer , kmip_version = kmip_version ) if self . _client_registration_methods : for client_reg_method in self . _client_registration_methods : client_reg_method . write ( local_buffer , kmip_version = kmip_version ) if kmip_version >= enums . KMIPVersion . KMIP_2_0 : if self . _defaults_information : self . _defaults_information . write ( local_buffer , kmip_version = kmip_version ) if self . _storage_protection_masks : for storage_protection_mask in self . _storage_protection_masks : storage_protection_mask . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( QueryResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the QueryResponsePayload object to a stream ."}}
{"translation": {"code": "def create ( cls , extension_name = None , extension_tag = None , extension_type = None ) : extension_name = ExtensionName ( extension_name ) extension_tag = ExtensionTag ( extension_tag ) extension_type = ExtensionType ( extension_type ) return ExtensionInformation ( extension_name = extension_name , extension_tag = extension_tag , extension_type = extension_type )", "nl": "Construct an ExtensionInformation object from provided extension values ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( ExtensionInformation , self ) . read ( istream , kmip_version = kmip_version ) tstream = BytearrayStream ( istream . read ( self . length ) ) self . extension_name . read ( tstream , kmip_version = kmip_version ) if self . is_tag_next ( Tags . EXTENSION_TAG , tstream ) : self . extension_tag = ExtensionTag ( ) self . extension_tag . read ( tstream , kmip_version = kmip_version ) if self . is_tag_next ( Tags . EXTENSION_TYPE , tstream ) : self . extension_type = ExtensionType ( ) self . extension_type . read ( tstream , kmip_version = kmip_version ) self . is_oversized ( tstream ) self . validate ( )", "nl": "Read the data encoding the ExtensionInformation object and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : tstream = BytearrayStream ( ) self . extension_name . write ( tstream , kmip_version = kmip_version ) if self . extension_tag is not None : self . extension_tag . write ( tstream , kmip_version = kmip_version ) if self . extension_type is not None : self . extension_type . write ( tstream , kmip_version = kmip_version ) self . length = tstream . length ( ) super ( ExtensionInformation , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( tstream . buffer )", "nl": "Write the data encoding the ExtensionInformation object to a stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( QueryRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) query_functions = [ ] while ( self . is_tag_next ( enums . Tags . QUERY_FUNCTION , local_buffer ) ) : query_function = primitives . Enumeration ( enums . QueryFunction , tag = enums . Tags . QUERY_FUNCTION ) query_function . read ( local_buffer , kmip_version = kmip_version ) query_functions . append ( query_function ) if query_functions : self . _query_functions = query_functions else : raise exceptions . InvalidKmipEncoding ( \"The Query request payload encoding is missing the query \" \"functions.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the QueryRequestPayload object and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Digest , self ) . read ( istream , kmip_version = kmip_version ) tstream = BytearrayStream ( istream . read ( self . length ) ) self . hashing_algorithm . read ( tstream , kmip_version = kmip_version ) self . digest_value . read ( tstream , kmip_version = kmip_version ) self . key_format_type . read ( tstream , kmip_version = kmip_version ) self . is_oversized ( tstream ) self . validate ( )", "nl": "Read the data encoding the Digest object and decode it into its constituent parts ."}}
{"translation": {"code": "def create ( cls , hashing_algorithm = HashingAlgorithmEnum . SHA_256 , digest_value = b'' , key_format_type = KeyFormatTypeEnum . RAW ) : algorithm = HashingAlgorithm ( hashing_algorithm ) value = DigestValue ( bytearray ( digest_value ) ) format_type = KeyFormatType ( key_format_type ) return Digest ( hashing_algorithm = algorithm , digest_value = value , key_format_type = format_type )", "nl": "Construct a Digest object from provided digest values ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : tstream = BytearrayStream ( ) self . hashing_algorithm . write ( tstream , kmip_version = kmip_version ) self . digest_value . write ( tstream , kmip_version = kmip_version ) self . key_format_type . write ( tstream , kmip_version = kmip_version ) self . length = tstream . length ( ) super ( Digest , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( tstream . buffer )", "nl": "Write the data encoding the Digest object to a stream ."}}
{"translation": {"code": "def is_profile_supported ( self , conformance_clause , authentication_suite ) : return ( self . is_conformance_clause_supported ( conformance_clause ) and self . is_authentication_suite_supported ( authentication_suite ) )", "nl": "Check if a profile is supported by the client ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Boolean , self ) . write ( ostream , kmip_version = kmip_version ) self . write_value ( ostream , kmip_version = kmip_version )", "nl": "Write the encoding of the Boolean object to the output stream ."}}
{"translation": {"code": "def write_value ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : try : ostream . write ( pack ( '!Q' , self . value ) ) except Exception : self . logger . error ( \"Error writing boolean value to buffer\" ) raise", "nl": "Write the value of the Boolean object to the output stream ."}}
{"translation": {"code": "def validate ( self ) : if not isinstance ( self . revocation_code , RevocationReasonCode ) : msg = \"RevocationReaonCode expected\" raise TypeError ( msg ) if self . revocation_message is not None : if not isinstance ( self . revocation_message , TextString ) : msg = \"TextString expect\" raise TypeError ( msg )", "nl": "validate the RevocationReason object"}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( RevocationReason , self ) . read ( istream , kmip_version = kmip_version ) tstream = BytearrayStream ( istream . read ( self . length ) ) self . revocation_code = RevocationReasonCode ( ) self . revocation_code . read ( tstream , kmip_version = kmip_version ) if self . is_tag_next ( Tags . REVOCATION_MESSAGE , tstream ) : self . revocation_message = TextString ( ) self . revocation_message . read ( tstream , kmip_version = kmip_version ) self . is_oversized ( tstream ) self . validate ( )", "nl": "Read the data encoding the RevocationReason object and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : tstream = BytearrayStream ( ) self . revocation_code . write ( tstream , kmip_version = kmip_version ) if self . revocation_message is not None : self . revocation_message . write ( tstream , kmip_version = kmip_version ) # Write the length and value self . length = tstream . length ( ) super ( RevocationReason , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( tstream . buffer )", "nl": "Write the data encoding the RevocationReason object to a stream ."}}
{"translation": {"code": "def validate ( self ) : if not isinstance ( self . value , bytes ) : raise TypeError ( \"key value must be bytes\" ) elif not isinstance ( self . cryptographic_algorithm , enums . CryptographicAlgorithm ) : raise TypeError ( \"key algorithm must be a CryptographicAlgorithm \" \"enumeration\" ) elif not isinstance ( self . cryptographic_length , six . integer_types ) : raise TypeError ( \"key length must be an integer\" ) elif not isinstance ( self . key_format_type , enums . KeyFormatType ) : raise TypeError ( \"key format type must be a KeyFormatType \" \"enumeration\" ) elif self . key_format_type not in self . _valid_formats : raise ValueError ( \"key format type must be one of {0}\" . format ( self . _valid_formats ) ) # TODO (peter-hamilton) Verify that the key bytes match the key format mask_count = len ( self . cryptographic_usage_masks ) for i in range ( mask_count ) : mask = self . cryptographic_usage_masks [ i ] if not isinstance ( mask , enums . CryptographicUsageMask ) : position = \"({0} in list)\" . format ( i ) raise TypeError ( \"key mask {0} must be a CryptographicUsageMask \" \"enumeration\" . format ( position ) ) name_count = len ( self . names ) for i in range ( name_count ) : name = self . names [ i ] if not isinstance ( name , six . string_types ) : position = \"({0} in list)\" . format ( i ) raise TypeError ( \"key name {0} must be a string\" . format ( position ) )", "nl": "Verify that the contents of the PublicKey object are valid ."}}
{"translation": {"code": "def convert ( self , obj ) : if isinstance ( obj , pobjects . SymmetricKey ) : return self . _build_core_key ( obj , secrets . SymmetricKey ) elif isinstance ( obj , secrets . SymmetricKey ) : return self . _build_pie_key ( obj , pobjects . SymmetricKey ) elif isinstance ( obj , pobjects . PublicKey ) : return self . _build_core_key ( obj , secrets . PublicKey ) elif isinstance ( obj , secrets . PublicKey ) : return self . _build_pie_key ( obj , pobjects . PublicKey ) elif isinstance ( obj , pobjects . PrivateKey ) : return self . _build_core_key ( obj , secrets . PrivateKey ) elif isinstance ( obj , secrets . PrivateKey ) : return self . _build_pie_key ( obj , pobjects . PrivateKey ) elif isinstance ( obj , pobjects . Certificate ) : return self . _build_core_certificate ( obj ) elif isinstance ( obj , secrets . Certificate ) : return self . _build_pie_certificate ( obj ) elif isinstance ( obj , pobjects . SecretData ) : return self . _build_core_secret_data ( obj ) elif isinstance ( obj , secrets . SecretData ) : return self . _build_pie_secret_data ( obj ) elif isinstance ( obj , pobjects . OpaqueObject ) : return self . _build_core_opaque_object ( obj ) elif isinstance ( obj , secrets . OpaqueObject ) : return self . _build_pie_opaque_object ( obj ) else : raise TypeError ( \"object type unsupported and cannot be converted\" )", "nl": "Convert a Pie object into a core secret object and vice versa ."}}
{"translation": {"code": "def open ( self ) : if self . _is_open : raise exceptions . ClientConnectionFailure ( \"client connection already open\" ) else : try : self . proxy . open ( ) self . _is_open = True except Exception as e : self . logger . error ( \"could not open client connection: %s\" , e ) raise", "nl": "Open the client connection ."}}
{"translation": {"code": "def close ( self ) : if not self . _is_open : return else : try : self . proxy . close ( ) self . _is_open = False except Exception as e : self . logger . error ( \"could not close client connection: %s\" , e ) raise", "nl": "Close the client connection ."}}
{"translation": {"code": "def create ( self , algorithm , length , operation_policy_name = None , name = None , cryptographic_usage_mask = None ) : # Check inputs if not isinstance ( algorithm , enums . CryptographicAlgorithm ) : raise TypeError ( \"algorithm must be a CryptographicAlgorithm enumeration\" ) elif not isinstance ( length , six . integer_types ) or length <= 0 : raise TypeError ( \"length must be a positive integer\" ) if cryptographic_usage_mask is not None : if not isinstance ( cryptographic_usage_mask , list ) or all ( isinstance ( item , enums . CryptographicUsageMask ) for item in cryptographic_usage_mask ) is False : raise TypeError ( \"cryptographic_usage_mask must be a list of \" \"CryptographicUsageMask enumerations\" ) # Create the template containing the attributes common_attributes = self . _build_common_attributes ( operation_policy_name ) key_attributes = self . _build_key_attributes ( algorithm , length , cryptographic_usage_mask ) key_attributes . extend ( common_attributes ) if name : key_attributes . extend ( self . _build_name_attribute ( name ) ) template = cobjects . TemplateAttribute ( attributes = key_attributes ) # Create the symmetric key and handle the results result = self . proxy . create ( enums . ObjectType . SYMMETRIC_KEY , template ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return result . uuid else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Create a symmetric key on a KMIP appliance ."}}
{"translation": {"code": "def get ( self , uid = None , key_wrapping_specification = None ) : # Check input if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"uid must be a string\" ) if key_wrapping_specification is not None : if not isinstance ( key_wrapping_specification , dict ) : raise TypeError ( \"Key wrapping specification must be a dictionary.\" ) spec = self . _build_key_wrapping_specification ( key_wrapping_specification ) # Get the managed object and handle the results result = self . proxy . get ( uid , key_wrapping_specification = spec ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : managed_object = self . object_factory . convert ( result . secret ) return managed_object else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Get a managed object from a KMIP appliance ."}}
{"translation": {"code": "def create_key_pair ( self , algorithm , length , operation_policy_name = None , public_name = None , public_usage_mask = None , private_name = None , private_usage_mask = None ) : # Check inputs if not isinstance ( algorithm , enums . CryptographicAlgorithm ) : raise TypeError ( \"algorithm must be a CryptographicAlgorithm enumeration\" ) elif not isinstance ( length , six . integer_types ) or length <= 0 : raise TypeError ( \"length must be a positive integer\" ) # Create the common attributes that are shared common_attributes = self . _build_common_attributes ( operation_policy_name ) algorithm_attribute = self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_ALGORITHM , algorithm ) length_attribute = self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_LENGTH , length ) common_attributes . extend ( [ algorithm_attribute , length_attribute ] ) template = cobjects . TemplateAttribute ( attributes = common_attributes , tag = enums . Tags . COMMON_TEMPLATE_ATTRIBUTE ) # Create public / private specific attributes public_template = None names = None if public_name : names = self . _build_name_attribute ( name = public_name ) attrs = [ ] if public_usage_mask : attrs = [ self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_USAGE_MASK , public_usage_mask ) ] if names or attrs : public_template = cobjects . TemplateAttribute ( names = names , attributes = attrs , tag = enums . Tags . PUBLIC_KEY_TEMPLATE_ATTRIBUTE ) private_template = None names = None if private_name : names = self . _build_name_attribute ( name = private_name ) attrs = [ ] if private_usage_mask : attrs = [ self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_USAGE_MASK , private_usage_mask ) ] if names or attrs : private_template = cobjects . TemplateAttribute ( names = names , attributes = attrs , tag = enums . Tags . PRIVATE_KEY_TEMPLATE_ATTRIBUTE ) # Create the asymmetric key pair and handle the results result = self . proxy . create_key_pair ( common_template_attribute = template , private_key_template_attribute = private_template , public_key_template_attribute = public_template ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : public_uid = result . public_key_uuid private_uid = result . private_key_uuid return public_uid , private_uid else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Create an asymmetric key pair on a KMIP appliance ."}}
{"translation": {"code": "def register ( self , managed_object ) : # Check input if not isinstance ( managed_object , pobjects . ManagedObject ) : raise TypeError ( \"managed object must be a Pie ManagedObject\" ) # Extract and create attributes object_attributes = list ( ) if hasattr ( managed_object , 'cryptographic_usage_masks' ) : if managed_object . cryptographic_usage_masks is not None : mask_attribute = self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_USAGE_MASK , managed_object . cryptographic_usage_masks ) object_attributes . append ( mask_attribute ) if hasattr ( managed_object , 'operation_policy_name' ) : if managed_object . operation_policy_name is not None : opn_attribute = self . attribute_factory . create_attribute ( enums . AttributeType . OPERATION_POLICY_NAME , managed_object . operation_policy_name ) object_attributes . append ( opn_attribute ) if hasattr ( managed_object , 'names' ) : if managed_object . names : for name in managed_object . names : name_attribute = self . attribute_factory . create_attribute ( enums . AttributeType . NAME , name ) object_attributes . append ( name_attribute ) template = cobjects . TemplateAttribute ( attributes = object_attributes ) object_type = managed_object . object_type # Register the managed object and handle the results secret = self . object_factory . convert ( managed_object ) result = self . proxy . register ( object_type , template , secret ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return result . uuid else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Register a managed object with a KMIP appliance ."}}
{"translation": {"code": "def validate ( self ) : if not isinstance ( self . value , bytes ) : raise TypeError ( \"secret value must be bytes\" ) elif not isinstance ( self . data_type , enums . SecretDataType ) : raise TypeError ( \"secret data type must be a SecretDataType \" \"enumeration\" ) mask_count = len ( self . cryptographic_usage_masks ) for i in range ( mask_count ) : mask = self . cryptographic_usage_masks [ i ] if not isinstance ( mask , enums . CryptographicUsageMask ) : position = \"({0} in list)\" . format ( i ) raise TypeError ( \"secret data mask {0} must be a CryptographicUsageMask \" \"enumeration\" . format ( position ) ) name_count = len ( self . names ) for i in range ( name_count ) : name = self . names [ i ] if not isinstance ( name , six . string_types ) : position = \"({0} in list)\" . format ( i ) raise TypeError ( \"secret data name {0} must be a string\" . format ( position ) )", "nl": "Verify that the contents of the SecretData object are valid ."}}
{"translation": {"code": "def validate ( self ) : if not isinstance ( self . value , bytes ) : raise TypeError ( \"opaque value must be bytes\" ) elif not isinstance ( self . opaque_type , enums . OpaqueDataType ) : raise TypeError ( \"opaque data type must be an OpaqueDataType \" \"enumeration\" ) name_count = len ( self . names ) for i in range ( name_count ) : name = self . names [ i ] if not isinstance ( name , six . string_types ) : position = \"({0} in list)\" . format ( i ) raise TypeError ( \"opaque data name {0} must be a string\" . format ( position ) )", "nl": "Verify that the contents of the OpaqueObject are valid ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The GetAttributeList response payload is missing the unique \" \"identifier field.\" ) if self . _attribute_names : if kmip_version < enums . KMIPVersion . KMIP_2_0 : for attribute_name in self . _attribute_names : attribute_name . write ( local_buffer , kmip_version = kmip_version ) else : # NOTE (ph) This approach simplifies backwards compatible #           issues but limits easy support for Attribute #           Reference structures going forward, specifically #           limiting the use of VendorIdentification for #           custom attributes. If custom attributes need to #           be retrieved using the GetAttributeList operation #           for KMIP 2.0 applications this code will need to #           change. for attribute_name in self . _attribute_names : t = enums . convert_attribute_name_to_tag ( attribute_name . value ) e = primitives . Enumeration ( enums . Tags , value = t , tag = enums . Tags . ATTRIBUTE_REFERENCE ) e . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The GetAttributeList response payload is missing the \" \"attribute names field.\" ) self . length = local_buffer . length ( ) super ( GetAttributeListResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the GetAttributeList response payload to a stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetAttributeListResponsePayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The GetAttributeList response payload encoding is missing \" \"the unique identifier.\" ) names = list ( ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : while self . is_tag_next ( enums . Tags . ATTRIBUTE_NAME , local_buffer ) : name = primitives . TextString ( tag = enums . Tags . ATTRIBUTE_NAME ) name . read ( local_buffer , kmip_version = kmip_version ) names . append ( name ) if len ( names ) == 0 : raise exceptions . InvalidKmipEncoding ( \"The GetAttributeList response payload encoding is \" \"missing the attribute names.\" ) self . _attribute_names = names else : while self . is_tag_next ( enums . Tags . ATTRIBUTE_REFERENCE , local_buffer ) : if self . is_type_next ( enums . Types . STRUCTURE , local_buffer ) : reference = objects . AttributeReference ( ) reference . read ( local_buffer , kmip_version = kmip_version ) names . append ( primitives . TextString ( value = reference . attribute_name , tag = enums . Tags . ATTRIBUTE_NAME ) ) elif self . is_type_next ( enums . Types . ENUMERATION , local_buffer ) : reference = primitives . Enumeration ( enums . Tags , tag = enums . Tags . ATTRIBUTE_REFERENCE ) reference . read ( local_buffer , kmip_version = kmip_version ) name = enums . convert_attribute_tag_to_name ( reference . value ) names . append ( primitives . TextString ( value = name , tag = enums . Tags . ATTRIBUTE_NAME ) ) else : raise exceptions . InvalidKmipEncoding ( \"The GetAttributeList response payload encoding \" \"contains an invalid AttributeReference type.\" ) self . _attribute_names = names self . is_oversized ( local_buffer )", "nl": "Read the data encoding the GetAttributeList response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( GetAttributeListRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the GetAttributeList request payload to a stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetAttributeListRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_buffer , kmip_version = kmip_version ) else : self . _unique_identifier = None self . is_oversized ( local_buffer )", "nl": "Read the data encoding the GetAttributeList request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def get_attribute_list ( self , uid = None ) : batch_item = self . _build_get_attribute_list_batch_item ( uid ) request = self . _build_request_message ( None , [ batch_item ] ) response = self . _send_and_receive_message ( request ) results = self . _process_batch_items ( response ) return results [ 0 ]", "nl": "Send a GetAttributeList request to the server ."}}
{"translation": {"code": "def write ( self , ostream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( LongInteger , self ) . write ( ostream , kmip_version = kmip_version ) ostream . write ( pack ( '!q' , self . value ) )", "nl": "Write the encoding of the LongInteger to the output stream ."}}
{"translation": {"code": "def validate ( self ) : if self . value is not None : if type ( self . value ) not in six . integer_types : raise TypeError ( 'expected (one of): {0}, observed: {1}' . format ( six . integer_types , type ( self . value ) ) ) else : if self . value > Interval . MAX : raise ValueError ( 'interval value greater than accepted max' ) elif self . value < Interval . MIN : raise ValueError ( 'interval value less than accepted min' )", "nl": "Verify that the value of the Interval is valid ."}}
{"translation": {"code": "def read ( self , istream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Interval , self ) . read ( istream , kmip_version = kmip_version ) # Check for a valid length before even trying to parse the value. if self . length != Interval . LENGTH : raise exceptions . InvalidPrimitiveLength ( \"interval length must be {0}\" . format ( Interval . LENGTH ) ) # Decode the Interval value and the padding bytes. self . value = unpack ( '!I' , istream . read ( Interval . LENGTH ) ) [ 0 ] pad = unpack ( '!I' , istream . read ( Interval . LENGTH ) ) [ 0 ] # Verify that the padding bytes are zero bytes. if pad != 0 : raise exceptions . InvalidPaddingBytes ( \"padding bytes must be zero\" ) self . validate ( )", "nl": "Read the encoding of the Interval from the input stream ."}}
{"translation": {"code": "def create_asymmetric_key_pair ( self , algorithm , length ) : if algorithm not in self . _asymmetric_key_algorithms . keys ( ) : raise exceptions . InvalidField ( \"The cryptographic algorithm ({0}) is not a supported \" \"asymmetric key algorithm.\" . format ( algorithm ) ) engine_method = self . _asymmetric_key_algorithms . get ( algorithm ) return engine_method ( length )", "nl": "Create an asymmetric key pair ."}}
{"translation": {"code": "def _create_rsa_key_pair ( self , length , public_exponent = 65537 ) : self . logger . info ( \"Generating an RSA key pair with length: {0}, and \" \"public_exponent: {1}\" . format ( length , public_exponent ) ) try : private_key = rsa . generate_private_key ( public_exponent = public_exponent , key_size = length , backend = default_backend ( ) ) public_key = private_key . public_key ( ) private_bytes = private_key . private_bytes ( serialization . Encoding . DER , serialization . PrivateFormat . PKCS8 , serialization . NoEncryption ( ) ) public_bytes = public_key . public_bytes ( serialization . Encoding . DER , serialization . PublicFormat . PKCS1 ) except Exception as e : self . logger . exception ( e ) raise exceptions . CryptographicFailure ( \"An error occurred while generating the RSA key pair. \" \"See the server log for more information.\" ) public_key = { 'value' : public_bytes , 'format' : enums . KeyFormatType . PKCS_1 , 'public_exponent' : public_exponent } private_key = { 'value' : private_bytes , 'format' : enums . KeyFormatType . PKCS_8 , 'public_exponent' : public_exponent } return public_key , private_key", "nl": "Create an RSA key pair ."}}
{"translation": {"code": "def create_symmetric_key ( self , algorithm , length ) : if algorithm not in self . _symmetric_key_algorithms . keys ( ) : raise exceptions . InvalidField ( \"The cryptographic algorithm {0} is not a supported symmetric \" \"key algorithm.\" . format ( algorithm ) ) cryptography_algorithm = self . _symmetric_key_algorithms . get ( algorithm ) if length not in cryptography_algorithm . key_sizes : raise exceptions . InvalidField ( \"The cryptographic length ({0}) is not valid for \" \"the cryptographic algorithm ({1}).\" . format ( length , algorithm . name ) ) self . logger . info ( \"Generating a {0} symmetric key with length: {1}\" . format ( algorithm . name , length ) ) key_bytes = os . urandom ( length // 8 ) try : cryptography_algorithm ( key_bytes ) except Exception as e : self . logger . exception ( e ) raise exceptions . CryptographicFailure ( \"Invalid bytes for the provided cryptographic algorithm.\" ) return { 'value' : key_bytes , 'format' : enums . KeyFormatType . RAW }", "nl": "Create a symmetric key ."}}
{"translation": {"code": "def run ( self ) : self . _logger . info ( \"Starting session: {0}\" . format ( self . name ) ) try : self . _connection . do_handshake ( ) except Exception as e : self . _logger . info ( \"Failure running TLS handshake\" ) self . _logger . exception ( e ) else : while True : try : self . _handle_message_loop ( ) except exceptions . ConnectionClosed as e : break except Exception as e : self . _logger . info ( \"Failure handling message loop\" ) self . _logger . exception ( e ) self . _connection . shutdown ( socket . SHUT_RDWR ) self . _connection . close ( ) self . _logger . info ( \"Stopping session: {0}\" . format ( self . name ) )", "nl": "The main thread routine executed by invoking thread . start ."}}
{"translation": {"code": "def process_result_value ( self , value , dialect ) : masks = list ( ) if value : for e in enums . CryptographicUsageMask : if e . value & value : masks . append ( e ) return masks", "nl": "Returns a new list of enums . CryptographicUsageMask Enums . This converts the integer value into the list of enums ."}}
{"translation": {"code": "def process_bind_param ( self , value , dialect ) : bitmask = 0x00 for e in value : bitmask = bitmask | e . value return bitmask", "nl": "Returns the integer value of the usage mask bitmask . This value is stored in the database ."}}
{"translation": {"code": "def build_error_response ( self , version , reason , message ) : batch_item = messages . ResponseBatchItem ( result_status = contents . ResultStatus ( enums . ResultStatus . OPERATION_FAILED ) , result_reason = contents . ResultReason ( reason ) , result_message = contents . ResultMessage ( message ) ) return self . _build_response ( version , [ batch_item ] )", "nl": "Build a simple ResponseMessage with a single error result ."}}
{"translation": {"code": "def process_request ( self , request , credential = None ) : self . _client_identity = [ None , None ] header = request . request_header # Process the protocol version self . _set_protocol_version ( header . protocol_version ) # Process the maximum response size max_response_size = None if header . maximum_response_size : max_response_size = header . maximum_response_size . value # Process the time stamp now = int ( time . time ( ) ) if header . time_stamp : then = header . time_stamp . value if ( now >= then ) and ( ( now - then ) < 60 ) : self . _logger . info ( \"Received request at time: {0}\" . format ( time . strftime ( \"%Y-%m-%d %H:%M:%S\" , time . gmtime ( then ) ) ) ) else : if now < then : self . _logger . warning ( \"Received request with future timestamp. Received \" \"timestamp: {0}, Current timestamp: {1}\" . format ( then , now ) ) raise exceptions . InvalidMessage ( \"Future request rejected by server.\" ) else : self . _logger . warning ( \"Received request with old timestamp. Possible \" \"replay attack. Received timestamp: {0}, Current \" \"timestamp: {1}\" . format ( then , now ) ) raise exceptions . InvalidMessage ( \"Stale request rejected by server.\" ) else : self . _logger . info ( \"Received request at time: {0}\" . format ( time . strftime ( \"%Y-%m-%d %H:%M:%S\" , time . gmtime ( now ) ) ) ) # Process the asynchronous indicator self . is_asynchronous = False if header . asynchronous_indicator is not None : self . is_asynchronous = header . asynchronous_indicator . value if self . is_asynchronous : raise exceptions . InvalidMessage ( \"Asynchronous operations are not supported.\" ) # Process the authentication credentials if header . authentication : if header . authentication . credentials : auth_credentials = header . authentication . credentials [ 0 ] else : auth_credentials = None else : auth_credentials = None self . _verify_credential ( auth_credentials , credential ) # Process the batch error continuation option batch_error_option = enums . BatchErrorContinuationOption . STOP if header . batch_error_cont_option is not None : batch_error_option = header . batch_error_cont_option . value if batch_error_option == enums . BatchErrorContinuationOption . UNDO : raise exceptions . InvalidMessage ( \"Undo option for batch handling is not supported.\" ) # Process the batch order option batch_order_option = False if header . batch_order_option : batch_order_option = header . batch_order_option . value response_batch = self . _process_batch ( request . batch_items , batch_error_option , batch_order_option ) response = self . _build_response ( header . protocol_version , response_batch ) return response , max_response_size , header . protocol_version", "nl": "Process a KMIP request message ."}}
{"translation": {"code": "def is_attribute_multivalued ( self , attribute ) : # TODO (peterhamilton) Handle multivalue swap between certificate types rule_set = self . _attribute_rule_sets . get ( attribute ) return rule_set . multiple_instances_permitted", "nl": "Check if the attribute is allowed to have multiple instances ."}}
{"translation": {"code": "def is_attribute_applicable_to_object_type ( self , attribute , object_type ) : # TODO (peterhamilton) Handle applicability between certificate types rule_set = self . _attribute_rule_sets . get ( attribute ) if object_type in rule_set . applies_to_object_types : return True else : return False", "nl": "Check if the attribute is supported by the given object type ."}}
{"translation": {"code": "def is_attribute_supported ( self , attribute ) : if attribute not in self . _attribute_rule_sets . keys ( ) : return False rule_set = self . _attribute_rule_sets . get ( attribute ) if self . _version >= rule_set . version_added : return True else : return False", "nl": "Check if the attribute is supported by the current KMIP version ."}}
{"translation": {"code": "def is_attribute_deprecated ( self , attribute ) : rule_set = self . _attribute_rule_sets . get ( attribute ) if rule_set . version_deprecated : if self . _version >= rule_set . version_deprecated : return True else : return False else : return False", "nl": "Check if the attribute is deprecated by the current KMIP version ."}}
{"translation": {"code": "def _set_attribute_on_managed_object ( self , managed_object , attribute ) : attribute_name = attribute [ 0 ] attribute_value = attribute [ 1 ] if self . _attribute_policy . is_attribute_multivalued ( attribute_name ) : if attribute_name == 'Name' : managed_object . names . extend ( [ x . name_value . value for x in attribute_value ] ) for name in managed_object . names : if managed_object . names . count ( name ) > 1 : raise exceptions . InvalidField ( \"Cannot set duplicate name values.\" ) else : # TODO (peterhamilton) Remove when all attributes are supported raise exceptions . InvalidField ( \"The {0} attribute is unsupported.\" . format ( attribute_name ) ) else : field = None value = attribute_value . value if attribute_name == 'Cryptographic Algorithm' : field = 'cryptographic_algorithm' elif attribute_name == 'Cryptographic Length' : field = 'cryptographic_length' elif attribute_name == 'Cryptographic Usage Mask' : field = 'cryptographic_usage_masks' value = list ( ) for e in enums . CryptographicUsageMask : if e . value & attribute_value . value : value . append ( e ) elif attribute_name == 'Operation Policy Name' : field = 'operation_policy_name' if field : existing_value = getattr ( managed_object , field ) if existing_value : if existing_value != value : raise exceptions . InvalidField ( \"Cannot overwrite the {0} attribute.\" . format ( attribute_name ) ) else : setattr ( managed_object , field , value ) else : # TODO (peterhamilton) Remove when all attributes are supported raise exceptions . InvalidField ( \"The {0} attribute is unsupported.\" . format ( attribute_name ) )", "nl": "Set the attribute value on the kmip . pie managed object ."}}
{"translation": {"code": "def _set_attributes_on_managed_object ( self , managed_object , attributes ) : for attribute_name , attribute_value in six . iteritems ( attributes ) : object_type = managed_object . _object_type if self . _attribute_policy . is_attribute_applicable_to_object_type ( attribute_name , object_type ) : self . _set_attribute_on_managed_object ( managed_object , ( attribute_name , attribute_value ) ) else : name = object_type . name raise exceptions . InvalidField ( \"Cannot set {0} attribute on {1} object.\" . format ( attribute_name , '' . join ( [ x . capitalize ( ) for x in name . split ( '_' ) ] ) ) )", "nl": "Given a kmip . pie object and a dictionary of attributes attempt to set the attribute values on the object ."}}
{"translation": {"code": "def _process_template_attribute ( self , template_attribute ) : attributes = { } if len ( template_attribute . names ) > 0 : raise exceptions . ItemNotFound ( \"Attribute templates are not supported.\" ) for attribute in template_attribute . attributes : name = attribute . attribute_name . value if not self . _attribute_policy . is_attribute_supported ( name ) : raise exceptions . InvalidField ( \"The {0} attribute is unsupported.\" . format ( name ) ) if self . _attribute_policy . is_attribute_multivalued ( name ) : values = attributes . get ( name , list ( ) ) if ( not attribute . attribute_index ) and len ( values ) > 0 : raise exceptions . InvalidField ( \"Attribute index missing from multivalued attribute.\" ) values . append ( attribute . attribute_value ) attributes . update ( [ ( name , values ) ] ) else : if attribute . attribute_index : if attribute . attribute_index . value != 0 : raise exceptions . InvalidField ( \"Non-zero attribute index found for \" \"single-valued attribute.\" ) value = attributes . get ( name , None ) if value : raise exceptions . IndexOutOfBounds ( \"Cannot set multiple instances of the \" \"{0} attribute.\" . format ( name ) ) else : attributes . update ( [ ( name , attribute . attribute_value ) ] ) return attributes", "nl": "Given a kmip . core TemplateAttribute object extract the attribute value data into a usable dictionary format ."}}
{"translation": {"code": "def stop ( self ) : self . _logger . info ( \"Cleaning up remaining connection threads.\" ) for thread in threading . enumerate ( ) : if thread is not threading . current_thread ( ) : try : thread . join ( 10.0 ) except Exception as e : self . _logger . info ( \"Error occurred while attempting to cleanup thread: \" \"{0}\" . format ( thread . name ) ) self . _logger . exception ( e ) else : if thread . is_alive ( ) : self . _logger . warning ( \"Cleanup failed for thread: {0}. Thread is \" \"still alive\" . format ( thread . name ) ) else : self . _logger . info ( \"Cleanup succeeded for thread: {0}\" . format ( thread . name ) ) self . _logger . info ( \"Shutting down server socket handler.\" ) try : self . _socket . shutdown ( socket . SHUT_RDWR ) self . _socket . close ( ) except Exception as e : self . _logger . exception ( e ) raise exceptions . NetworkingError ( \"Server failed to shutdown socket handler.\" ) if hasattr ( self , \"policy_monitor\" ) : try : self . policy_monitor . stop ( ) self . policy_monitor . join ( ) except Exception as e : self . _logger . exception ( e ) raise exceptions . ShutdownError ( \"Server failed to clean up the policy monitor.\" )", "nl": "Stop the server ."}}
{"translation": {"code": "def set_setting ( self , setting , value ) : if setting not in self . _expected_settings + self . _optional_settings : raise exceptions . ConfigurationError ( \"Setting '{0}' is not supported.\" . format ( setting ) ) if setting == 'hostname' : self . _set_hostname ( value ) elif setting == 'port' : self . _set_port ( value ) elif setting == 'certificate_path' : self . _set_certificate_path ( value ) elif setting == 'key_path' : self . _set_key_path ( value ) elif setting == 'ca_path' : self . _set_ca_path ( value ) elif setting == 'auth_suite' : self . _set_auth_suite ( value ) elif setting == 'policy_path' : self . _set_policy_path ( value ) elif setting == 'enable_tls_client_auth' : self . _set_enable_tls_client_auth ( value ) elif setting == 'tls_cipher_suites' : self . _set_tls_cipher_suites ( value ) elif setting == 'logging_level' : self . _set_logging_level ( value ) else : self . _set_database_path ( value )", "nl": "Set a specific setting value ."}}
{"translation": {"code": "def load_settings ( self , path ) : if not os . path . exists ( path ) : raise exceptions . ConfigurationError ( \"The server configuration file ('{0}') could not be \" \"located.\" . format ( path ) ) self . _logger . info ( \"Loading server configuration settings from: {0}\" . format ( path ) ) parser = configparser . ConfigParser ( ) parser . read ( path ) self . _parse_settings ( parser ) self . parse_auth_settings ( parser )", "nl": "Load configuration settings from the file pointed to by path ."}}
{"translation": {"code": "def serve ( self ) : self . _socket . listen ( 5 ) def _signal_handler ( signal_number , stack_frame ) : self . _is_serving = False # Python3.5+ silently ignores SIGINT and retries system calls if # the signal handler does not raise an exception. Explicitly # detect SIGINT and raise a KeyboardInterrupt exception to regain # old functionality. if signal_number == signal . SIGINT : raise KeyboardInterrupt ( \"SIGINT received\" ) signal . signal ( signal . SIGINT , _signal_handler ) signal . signal ( signal . SIGTERM , _signal_handler ) self . _logger . info ( \"Starting connection service...\" ) while self . _is_serving : try : connection , address = self . _socket . accept ( ) except socket . timeout : # Setting the default socket timeout to break hung connections # will cause accept to periodically raise socket.timeout. This # is expected behavior, so ignore it and retry accept. pass except socket . error as e : self . _logger . warning ( \"Error detected while establishing new connection.\" ) self . _logger . exception ( e ) except KeyboardInterrupt : self . _logger . warning ( \"Interrupting connection service.\" ) self . _is_serving = False break except Exception as e : self . _logger . warning ( \"Error detected while establishing new connection.\" ) self . _logger . exception ( e ) else : self . _setup_connection_handler ( connection , address ) self . _logger . info ( \"Stopping connection service.\" )", "nl": "Serve client connections ."}}
{"translation": {"code": "def _build_common_attributes ( self , operation_policy_name = None ) : common_attributes = [ ] if operation_policy_name : common_attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . OPERATION_POLICY_NAME , operation_policy_name ) ) return common_attributes", "nl": "Build a list of common attributes that are shared across symmetric as well as asymmetric objects"}}
{"translation": {"code": "def is_allowed ( self , policy_name , session_user , session_group , object_owner , object_type , operation ) : policy_section = self . get_relevant_policy_section ( policy_name , session_group ) if policy_section is None : return False object_policy = policy_section . get ( object_type ) if not object_policy : self . _logger . warning ( \"The '{0}' policy does not apply to {1} objects.\" . format ( policy_name , self . _get_enum_string ( object_type ) ) ) return False operation_object_policy = object_policy . get ( operation ) if not operation_object_policy : self . _logger . warning ( \"The '{0}' policy does not apply to {1} operations on {2} \" \"objects.\" . format ( policy_name , self . _get_enum_string ( operation ) , self . _get_enum_string ( object_type ) ) ) return False if operation_object_policy == enums . Policy . ALLOW_ALL : return True elif operation_object_policy == enums . Policy . ALLOW_OWNER : if session_user == object_owner : return True else : return False elif operation_object_policy == enums . Policy . DISALLOW_ALL : return False else : return False", "nl": "Determine if object access is allowed for the provided policy and session settings ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetAttributesResponsePayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) unique_identifier . read ( local_buffer , kmip_version = kmip_version ) self . unique_identifier = unique_identifier . value else : raise exceptions . InvalidKmipEncoding ( \"The GetAttributes response payload encoding is missing the \" \"unique identifier.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : self . _attributes = list ( ) while self . is_tag_next ( enums . Tags . ATTRIBUTE , local_buffer ) : attribute = objects . Attribute ( ) attribute . read ( local_buffer , kmip_version = kmip_version ) self . _attributes . append ( attribute ) else : if self . is_tag_next ( enums . Tags . ATTRIBUTES , local_buffer ) : attributes = objects . Attributes ( ) attributes . read ( local_buffer , kmip_version = kmip_version ) # TODO (ph) Add a new utility to avoid using TemplateAttributes temp_attr = objects . convert_attributes_to_template_attribute ( attributes ) self . _attributes = temp_attr . attributes else : raise exceptions . InvalidKmipEncoding ( \"The GetAttributes response payload encoding is missing \" \"the attributes structure.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the GetAttributes response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The GetAttributes response payload is missing the unique \" \"identifier field.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : for attribute in self . _attributes : attribute . write ( local_buffer , kmip_version = kmip_version ) else : if self . _attributes : # TODO (ph) Add a new utility to avoid using TemplateAttributes template_attribute = objects . TemplateAttribute ( attributes = self . attributes ) attributes = objects . convert_template_attribute_to_attributes ( template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The GetAttributes response payload is missing the \" \"attributes list.\" ) self . length = local_buffer . length ( ) super ( GetAttributesResponsePayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the GetAttributes response payload to a stream ."}}
{"translation": {"code": "def _build_name_attribute ( self , name = None ) : name_list = [ ] if name : name_list . append ( self . attribute_factory . create_attribute ( enums . AttributeType . NAME , name ) ) return name_list", "nl": "Build a name attribute returned in a list for ease of use in the caller"}}
{"translation": {"code": "def _get_attributes_from_managed_object ( self , managed_object , attr_names ) : attr_factory = attribute_factory . AttributeFactory ( ) retrieved_attributes = list ( ) if not attr_names : attr_names = self . _attribute_policy . get_all_attribute_names ( ) for attribute_name in attr_names : object_type = managed_object . _object_type if not self . _attribute_policy . is_attribute_supported ( attribute_name ) : continue if self . _attribute_policy . is_attribute_applicable_to_object_type ( attribute_name , object_type ) : try : attribute_value = self . _get_attribute_from_managed_object ( managed_object , attribute_name ) except Exception : attribute_value = None if attribute_value is not None : if self . _attribute_policy . is_attribute_multivalued ( attribute_name ) : for count , value in enumerate ( attribute_value ) : attribute = attr_factory . create_attribute ( enums . AttributeType ( attribute_name ) , value , count ) retrieved_attributes . append ( attribute ) else : attribute = attr_factory . create_attribute ( enums . AttributeType ( attribute_name ) , attribute_value ) retrieved_attributes . append ( attribute ) return retrieved_attributes", "nl": "Given a kmip . pie object and a list of attribute names attempt to get all of the existing attribute values from the object ."}}
{"translation": {"code": "def _get_attribute_from_managed_object ( self , managed_object , attr_name ) : if attr_name == 'Unique Identifier' : return str ( managed_object . unique_identifier ) elif attr_name == 'Name' : names = list ( ) for name in managed_object . names : name = attributes . Name ( attributes . Name . NameValue ( name ) , attributes . Name . NameType ( enums . NameType . UNINTERPRETED_TEXT_STRING ) ) names . append ( name ) return names elif attr_name == 'Object Type' : return managed_object . _object_type elif attr_name == 'Cryptographic Algorithm' : return managed_object . cryptographic_algorithm elif attr_name == 'Cryptographic Length' : return managed_object . cryptographic_length elif attr_name == 'Cryptographic Parameters' : return None elif attr_name == 'Cryptographic Domain Parameters' : return None elif attr_name == 'Certificate Type' : return managed_object . certificate_type elif attr_name == 'Certificate Length' : return None elif attr_name == 'X.509 Certificate Identifier' : return None elif attr_name == 'X.509 Certificate Subject' : return None elif attr_name == 'X.509 Certificate Issuer' : return None elif attr_name == 'Certificate Identifier' : return None elif attr_name == 'Certificate Subject' : return None elif attr_name == 'Certificate Issuer' : return None elif attr_name == 'Digital Signature Algorithm' : return None elif attr_name == 'Digest' : return None elif attr_name == 'Operation Policy Name' : return managed_object . operation_policy_name elif attr_name == 'Cryptographic Usage Mask' : return managed_object . cryptographic_usage_masks elif attr_name == 'Lease Time' : return None elif attr_name == 'Usage Limits' : return None elif attr_name == 'State' : return managed_object . state elif attr_name == 'Initial Date' : return managed_object . initial_date elif attr_name == 'Activation Date' : return None elif attr_name == 'Process Start Date' : return None elif attr_name == 'Protect Stop Date' : return None elif attr_name == 'Deactivation Date' : return None elif attr_name == 'Destroy Date' : return None elif attr_name == 'Compromise Occurrence Date' : return None elif attr_name == 'Compromise Date' : return None elif attr_name == 'Revocation Reason' : return None elif attr_name == 'Archive Date' : return None elif attr_name == 'Object Group' : return None elif attr_name == 'Fresh' : return None elif attr_name == 'Link' : return None elif attr_name == 'Application Specific Information' : return None elif attr_name == 'Contact Information' : return None elif attr_name == 'Last Change Date' : return None else : # Since custom attribute names are possible, just return None # for unrecognized attributes. This satisfies the spec. return None", "nl": "Get the attribute value from the kmip . pie managed object ."}}
{"translation": {"code": "def get_attributes ( self , uid = None , attribute_names = None ) : # Check input if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"uid must be a string\" ) if attribute_names is not None : if not isinstance ( attribute_names , list ) : raise TypeError ( \"attribute_names must be a list of strings\" ) else : for attribute_name in attribute_names : if not isinstance ( attribute_name , six . string_types ) : raise TypeError ( \"attribute_names must be a list of strings\" ) # Get the list of attributes for a managed object result = self . proxy . get_attributes ( uid , attribute_names ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return result . uuid , result . attributes else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Get the attributes associated with a managed object ."}}
{"translation": {"code": "def get_attributes ( self , uuid = None , attribute_names = None ) : batch_item = self . _build_get_attributes_batch_item ( uuid , attribute_names ) request = self . _build_request_message ( None , [ batch_item ] ) response = self . _send_and_receive_message ( request ) results = self . _process_batch_items ( response ) return results [ 0 ]", "nl": "Send a GetAttributes request to the server ."}}
{"translation": {"code": "def mac ( self , algorithm , key , data ) : mac_data = None if algorithm in self . _hash_algorithms . keys ( ) : self . logger . info ( \"Generating a hash-based message authentication code using \" \"{0}\" . format ( algorithm . name ) ) hash_algorithm = self . _hash_algorithms . get ( algorithm ) try : h = hmac . HMAC ( key , hash_algorithm ( ) , backend = default_backend ( ) ) h . update ( data ) mac_data = h . finalize ( ) except Exception as e : self . logger . exception ( e ) raise exceptions . CryptographicFailure ( \"An error occurred while computing an HMAC. \" \"See the server log for more information.\" ) elif algorithm in self . _symmetric_key_algorithms . keys ( ) : self . logger . info ( \"Generating a cipher-based message authentication code using \" \"{0}\" . format ( algorithm . name ) ) cipher_algorithm = self . _symmetric_key_algorithms . get ( algorithm ) try : # ARC4 and IDEA algorithms will raise exception as CMAC # requires block ciphers c = cmac . CMAC ( cipher_algorithm ( key ) , backend = default_backend ( ) ) c . update ( data ) mac_data = c . finalize ( ) except Exception as e : raise exceptions . CryptographicFailure ( \"An error occurred while computing a CMAC. \" \"See the server log for more information.\" ) else : raise exceptions . InvalidField ( \"The cryptographic algorithm ({0}) is not a supported \" \"for a MAC operation.\" . format ( algorithm ) ) return mac_data", "nl": "Generate message authentication code ."}}
{"translation": {"code": "def mac ( self , data , uid = None , algorithm = None ) : # Check inputs if not isinstance ( data , six . binary_type ) : raise TypeError ( \"data must be bytes\" ) if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"uid must be a string\" ) if algorithm is not None : if not isinstance ( algorithm , enums . CryptographicAlgorithm ) : raise TypeError ( \"algorithm must be a CryptographicAlgorithm enumeration\" ) parameters_attribute = self . _build_cryptographic_parameters ( { 'cryptographic_algorithm' : algorithm } ) # Get the message authentication code and handle the results result = self . proxy . mac ( data , uid , parameters_attribute ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : uid = result . uuid . value mac_data = result . mac_data . value return uid , mac_data else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Get the message authentication code for data ."}}
{"translation": {"code": "def locate ( self , maximum_items = None , storage_status_mask = None , object_group_member = None , attributes = None ) : # Check inputs if maximum_items is not None : if not isinstance ( maximum_items , six . integer_types ) : raise TypeError ( \"maximum_items must be an integer\" ) if storage_status_mask is not None : if not isinstance ( storage_status_mask , six . integer_types ) : raise TypeError ( \"storage_status_mask must be an integer\" ) if object_group_member is not None : if not isinstance ( object_group_member , enums . ObjectGroupMember ) : raise TypeError ( \"object_group_member must be a ObjectGroupMember\" \"enumeration\" ) if attributes is not None : if not isinstance ( attributes , list ) or all ( isinstance ( item , cobjects . Attribute ) for item in attributes ) is False : raise TypeError ( \"attributes must be a list of attributes\" ) # Search for managed objects and handle the results result = self . proxy . locate ( maximum_items , storage_status_mask , object_group_member , attributes ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return result . uuids else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Search for managed objects depending on the attributes specified in the request ."}}
{"translation": {"code": "def activate ( self , uid = None ) : # Check input if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"uid must be a string\" ) # Activate the managed object and handle the results result = self . proxy . activate ( uid ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Activate a managed object stored by a KMIP appliance ."}}
{"translation": {"code": "def revoke ( self , revocation_reason , uid = None , revocation_message = None , compromise_occurrence_date = None ) : # Check input if not isinstance ( revocation_reason , enums . RevocationReasonCode ) : raise TypeError ( \"revocation_reason must be a RevocationReasonCode enumeration\" ) if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"uid must be a string\" ) if revocation_message is not None : if not isinstance ( revocation_message , six . string_types ) : raise TypeError ( \"revocation_message must be a string\" ) if compromise_occurrence_date is not None : if not isinstance ( compromise_occurrence_date , six . integer_types ) : raise TypeError ( \"compromise_occurrence_date must be an integer\" ) compromise_occurrence_date = primitives . DateTime ( compromise_occurrence_date , enums . Tags . COMPROMISE_OCCURRENCE_DATE ) # revoke the managed object and handle the results result = self . proxy . revoke ( revocation_reason , uid , revocation_message , compromise_occurrence_date ) status = result . result_status . value if status == enums . ResultStatus . SUCCESS : return else : reason = result . result_reason . value message = result . result_message . value raise exceptions . KmipOperationFailure ( status , reason , message )", "nl": "Revoke a managed object stored by a KMIP appliance ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( EncryptResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the unique identifier attribute\" ) if self . is_tag_next ( enums . Tags . DATA , local_stream ) : self . _data = primitives . ByteString ( tag = enums . Tags . DATA ) self . _data . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the data attribute\" ) if self . is_tag_next ( enums . Tags . IV_COUNTER_NONCE , local_stream ) : self . _iv_counter_nonce = primitives . ByteString ( tag = enums . Tags . IV_COUNTER_NONCE ) self . _iv_counter_nonce . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Encrypt response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( SignResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the unique identifier attribute\" ) if self . is_tag_next ( enums . Tags . SIGNATURE_DATA , local_stream ) : self . _signature_data = primitives . ByteString ( tag = enums . Tags . SIGNATURE_DATA ) self . _signature_data . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the signature data attribute\" )", "nl": "Read the data encoding the Sign response payload and decode it ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the unique identifier attribute\" ) if self . _signature_data : self . _signature_data . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the signature attribute\" ) self . length = local_stream . length ( ) super ( SignResponsePayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Sign response to a stream ."}}
{"translation": {"code": "def _encrypt_symmetric ( self , encryption_algorithm , encryption_key , plain_text , cipher_mode = None , padding_method = None , iv_nonce = None ) : # Set up the algorithm algorithm = self . _symmetric_key_algorithms . get ( encryption_algorithm , None ) if algorithm is None : raise exceptions . InvalidField ( \"Encryption algorithm '{0}' is not a supported symmetric \" \"encryption algorithm.\" . format ( encryption_algorithm ) ) try : algorithm = algorithm ( encryption_key ) except Exception as e : self . logger . exception ( e ) raise exceptions . CryptographicFailure ( \"Invalid key bytes for the specified encryption algorithm.\" ) # Set up the cipher mode if needed return_iv_nonce = False if encryption_algorithm == enums . CryptographicAlgorithm . RC4 : mode = None else : if cipher_mode is None : raise exceptions . InvalidField ( \"Cipher mode is required.\" ) mode = self . _modes . get ( cipher_mode , None ) if mode is None : raise exceptions . InvalidField ( \"Cipher mode '{0}' is not a supported mode.\" . format ( cipher_mode ) ) if hasattr ( mode , 'initialization_vector' ) or hasattr ( mode , 'nonce' ) : if iv_nonce is None : iv_nonce = os . urandom ( algorithm . block_size // 8 ) return_iv_nonce = True mode = mode ( iv_nonce ) else : mode = mode ( ) # Pad the plain text if needed (separate methods for testing purposes) if cipher_mode in [ enums . BlockCipherMode . CBC , enums . BlockCipherMode . ECB ] : plain_text = self . _handle_symmetric_padding ( self . _symmetric_key_algorithms . get ( encryption_algorithm ) , plain_text , padding_method ) # Encrypt the plain text cipher = ciphers . Cipher ( algorithm , mode , backend = default_backend ( ) ) encryptor = cipher . encryptor ( ) cipher_text = encryptor . update ( plain_text ) + encryptor . finalize ( ) if return_iv_nonce : return { 'cipher_text' : cipher_text , 'iv_nonce' : iv_nonce } else : return { 'cipher_text' : cipher_text }", "nl": "Encrypt data using symmetric encryption ."}}
{"translation": {"code": "def encrypt ( self , encryption_algorithm , encryption_key , plain_text , cipher_mode = None , padding_method = None , iv_nonce = None , hashing_algorithm = None ) : if encryption_algorithm is None : raise exceptions . InvalidField ( \"Encryption algorithm is required.\" ) if encryption_algorithm == enums . CryptographicAlgorithm . RSA : return self . _encrypt_asymmetric ( encryption_algorithm , encryption_key , plain_text , padding_method , hashing_algorithm = hashing_algorithm ) else : return self . _encrypt_symmetric ( encryption_algorithm , encryption_key , plain_text , cipher_mode = cipher_mode , padding_method = padding_method , iv_nonce = iv_nonce )", "nl": "Encrypt data using symmetric or asymmetric encryption ."}}
{"translation": {"code": "def sign ( self , data , unique_identifier = None , cryptographic_parameters = None , credential = None ) : operation = Operation ( OperationEnum . SIGN ) request_payload = payloads . SignRequestPayload ( unique_identifier = unique_identifier , cryptographic_parameters = cryptographic_parameters , data = data ) batch_item = messages . RequestBatchItem ( operation = operation , request_payload = request_payload ) request = self . _build_request_message ( credential , [ batch_item ] ) response = self . _send_and_receive_message ( request ) batch_item = response . batch_items [ 0 ] payload = batch_item . response_payload result = { } if payload : result [ 'unique_identifier' ] = payload . unique_identifier result [ 'signature' ] = payload . signature_data result [ 'result_status' ] = batch_item . result_status . value try : result [ 'result_reason' ] = batch_item . result_reason . value except Exception : result [ 'result_reason' ] = batch_item . result_reason try : result [ 'result_message' ] = batch_item . result_message . value except Exception : result [ 'result_message' ] = batch_item . result_message return result", "nl": "Sign specified data using a specified signing key ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _cryptographic_parameters : self . _cryptographic_parameters . write ( local_stream , kmip_version = kmip_version ) if self . _data : self . _data . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"invalid payload missing the data attribute\" ) if self . _iv_counter_nonce : self . _iv_counter_nonce . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( DecryptRequestPayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Decrypt request payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( DerivationParameters , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_PARAMETERS , local_stream ) : self . _cryptographic_parameters = CryptographicParameters ( ) self . _cryptographic_parameters . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . INITIALIZATION_VECTOR , local_stream ) : self . _initialization_vector = ByteString ( tag = enums . Tags . INITIALIZATION_VECTOR ) self . _initialization_vector . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . DERIVATION_DATA , local_stream ) : self . _derivation_data = ByteString ( tag = enums . Tags . DERIVATION_DATA ) self . _derivation_data . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . SALT , local_stream ) : self . _salt = ByteString ( tag = enums . Tags . SALT ) self . _salt . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( Tags . ITERATION_COUNT , local_stream ) : self . _iteration_count = Integer ( tag = Tags . ITERATION_COUNT ) self . _iteration_count . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the DerivationParameters struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _cryptographic_parameters : self . _cryptographic_parameters . write ( local_stream , kmip_version = kmip_version ) if self . _initialization_vector : self . _initialization_vector . write ( local_stream , kmip_version = kmip_version ) if self . _derivation_data : self . _derivation_data . write ( local_stream , kmip_version = kmip_version ) if self . _salt : self . _salt . write ( local_stream , kmip_version = kmip_version ) if self . _iteration_count : self . _iteration_count . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( DerivationParameters , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the DerivationParameters struct to a stream ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _object_type : self . _object_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the object type \" \"field.\" ) if self . _unique_identifiers : for unique_identifier in self . _unique_identifiers : unique_identifier . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the unique \" \"identifiers field.\" ) if self . _derivation_method : self . _derivation_method . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the derivation \" \"method field.\" ) if self . _derivation_parameters : self . _derivation_parameters . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the derivation \" \"parameters field.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _template_attribute : self . _template_attribute . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the template \" \"attribute field.\" ) else : if self . _template_attribute : attrs = objects . convert_template_attribute_to_attributes ( self . _template_attribute ) attrs . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DeriveKey request payload is missing the template \" \"attribute field.\" ) self . length = local_buffer . length ( ) super ( DeriveKeyRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the DeriveKey request payload to a stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( DeriveKeyRequestPayload , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . OBJECT_TYPE , local_buffer ) : self . _object_type = primitives . Enumeration ( enums . ObjectType , tag = enums . Tags . OBJECT_TYPE ) self . _object_type . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the object \" \"type.\" ) unique_identifiers = [ ] while self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_buffer ) : unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) unique_identifier . read ( local_buffer , kmip_version = kmip_version ) unique_identifiers . append ( unique_identifier ) if not unique_identifiers : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the unique \" \"identifiers.\" ) else : self . _unique_identifiers = unique_identifiers if self . is_tag_next ( enums . Tags . DERIVATION_METHOD , local_buffer ) : self . _derivation_method = primitives . Enumeration ( enums . DerivationMethod , tag = enums . Tags . DERIVATION_METHOD ) self . _derivation_method . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the \" \"derivation method.\" ) if self . is_tag_next ( enums . Tags . DERIVATION_PARAMETERS , local_buffer ) : self . _derivation_parameters = attributes . DerivationParameters ( ) self . _derivation_parameters . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the \" \"derivation parameters.\" ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . is_tag_next ( enums . Tags . TEMPLATE_ATTRIBUTE , local_buffer ) : self . _template_attribute = objects . TemplateAttribute ( ) self . _template_attribute . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the \" \"template attribute.\" ) else : if self . is_tag_next ( enums . Tags . ATTRIBUTES , local_buffer ) : attrs = objects . Attributes ( ) attrs . read ( local_buffer , kmip_version = kmip_version ) value = objects . convert_attributes_to_template_attribute ( attrs ) self . _template_attribute = value else : raise exceptions . InvalidKmipEncoding ( \"The DeriveKey request payload encoding is missing the \" \"attributes structure.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the DeriveKey request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def derive_key ( self , derivation_method , derivation_length , derivation_data = None , key_material = None , hash_algorithm = None , salt = None , iteration_count = None , encryption_algorithm = None , cipher_mode = None , padding_method = None , iv_nonce = None ) : if derivation_method == enums . DerivationMethod . ENCRYPT : result = self . encrypt ( encryption_algorithm = encryption_algorithm , encryption_key = key_material , plain_text = derivation_data , cipher_mode = cipher_mode , padding_method = padding_method , iv_nonce = iv_nonce ) return result . get ( 'cipher_text' ) else : # Handle key derivation functions that use hash algorithms # Set up the hashing algorithm if hash_algorithm is None : raise exceptions . InvalidField ( \"Hash algorithm is required.\" ) hashing_algorithm = self . _encryption_hash_algorithms . get ( hash_algorithm , None ) if hashing_algorithm is None : raise exceptions . InvalidField ( \"Hash algorithm '{0}' is not a supported hashing \" \"algorithm.\" . format ( hash_algorithm ) ) if derivation_method == enums . DerivationMethod . HMAC : df = hkdf . HKDF ( algorithm = hashing_algorithm ( ) , length = derivation_length , salt = salt , info = derivation_data , backend = default_backend ( ) ) derived_data = df . derive ( key_material ) return derived_data elif derivation_method == enums . DerivationMethod . HASH : if None not in [ derivation_data , key_material ] : raise exceptions . InvalidField ( \"For hash-based key derivation, specify only \" \"derivation data or key material, not both.\" ) elif derivation_data is not None : hashing_data = derivation_data elif key_material is not None : hashing_data = key_material else : raise exceptions . InvalidField ( \"For hash-based key derivation, derivation data or \" \"key material must be specified.\" ) df = hashes . Hash ( algorithm = hashing_algorithm ( ) , backend = default_backend ( ) ) df . update ( hashing_data ) derived_data = df . finalize ( ) return derived_data elif derivation_method == enums . DerivationMethod . PBKDF2 : if salt is None : raise exceptions . InvalidField ( \"For PBKDF2 key derivation, salt must be specified.\" ) if iteration_count is None : raise exceptions . InvalidField ( \"For PBKDF2 key derivation, iteration count must be \" \"specified.\" ) df = pbkdf2 . PBKDF2HMAC ( algorithm = hashing_algorithm ( ) , length = derivation_length , salt = salt , iterations = iteration_count , backend = default_backend ( ) ) derived_data = df . derive ( key_material ) return derived_data elif derivation_method == enums . DerivationMethod . NIST800_108_C : df = kbkdf . KBKDFHMAC ( algorithm = hashing_algorithm ( ) , mode = kbkdf . Mode . CounterMode , length = derivation_length , rlen = 4 , llen = None , location = kbkdf . CounterLocation . BeforeFixed , label = None , context = None , fixed = derivation_data , backend = default_backend ( ) ) derived_data = df . derive ( key_material ) return derived_data else : raise exceptions . InvalidField ( \"Derivation method '{0}' is not a supported key \" \"derivation method.\" . format ( derivation_method ) )", "nl": "Derive key data using a variety of key derivation functions ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( MACSignatureKeyInformation , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the unique identifier attribute.\" ) if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_PARAMETERS , local_stream ) : self . _cryptographic_parameters = CryptographicParameters ( ) self . _cryptographic_parameters . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the MACSignatureKeyInformation struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the unique identifier attribute.\" ) if self . _cryptographic_parameters : self . _cryptographic_parameters . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( MACSignatureKeyInformation , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the MACSignatureKeyInformation struct to a stream ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _wrapping_method : self . _wrapping_method . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the wrapping method attribute.\" ) if self . _encryption_key_information : self . _encryption_key_information . write ( local_stream , kmip_version = kmip_version ) if self . _mac_signature_key_information : self . _mac_signature_key_information . write ( local_stream , kmip_version = kmip_version ) if self . _attribute_names : for unique_identifier in self . _attribute_names : unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _encoding_option : self . _encoding_option . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( KeyWrappingSpecification , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the KeyWrappingSpecification struct to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( KeyWrappingData , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . WRAPPING_METHOD , local_stream ) : self . _wrapping_method = primitives . Enumeration ( enum = enums . WrappingMethod , tag = enums . Tags . WRAPPING_METHOD ) self . _wrapping_method . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the wrapping method attribute.\" ) if self . is_tag_next ( enums . Tags . ENCRYPTION_KEY_INFORMATION , local_stream ) : self . _encryption_key_information = EncryptionKeyInformation ( ) self . _encryption_key_information . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . MAC_SIGNATURE_KEY_INFORMATION , local_stream ) : self . _mac_signature_key_information = MACSignatureKeyInformation ( ) self . _mac_signature_key_information . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . MAC_SIGNATURE , local_stream ) : self . _mac_signature = primitives . ByteString ( tag = enums . Tags . MAC_SIGNATURE ) self . _mac_signature . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . IV_COUNTER_NONCE , local_stream ) : self . _iv_counter_nonce = primitives . ByteString ( tag = enums . Tags . IV_COUNTER_NONCE ) self . _iv_counter_nonce . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . ENCODING_OPTION , local_stream ) : self . _encoding_option = primitives . Enumeration ( enum = enums . EncodingOption , tag = enums . Tags . ENCODING_OPTION ) self . _encoding_option . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the KeyWrappingData struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _wrapping_method : self . _wrapping_method . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Invalid struct missing the wrapping method attribute.\" ) if self . _encryption_key_information : self . _encryption_key_information . write ( local_stream , kmip_version = kmip_version ) if self . _mac_signature_key_information : self . _mac_signature_key_information . write ( local_stream , kmip_version = kmip_version ) if self . _mac_signature : self . _mac_signature . write ( local_stream , kmip_version = kmip_version ) if self . _iv_counter_nonce : self . _iv_counter_nonce . write ( local_stream , kmip_version = kmip_version ) if self . _encoding_option : self . _encoding_option . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( KeyWrappingData , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the KeyWrappingData struct to a stream ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . object_type : self . _object_type . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Payload is missing the object type field.\" ) if self . unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Payload is missing the unique identifier field.\" ) if self . secret : self . _secret . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Payload is missing the secret field.\" ) self . length = local_stream . length ( ) super ( GetResponsePayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Get response payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetRequestPayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . KEY_FORMAT_TYPE , local_stream ) : self . _key_format_type = primitives . Enumeration ( enum = enums . KeyFormatType , tag = enums . Tags . KEY_FORMAT_TYPE ) self . _key_format_type . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . KEY_COMPRESSION_TYPE , local_stream ) : self . _key_compression_type = primitives . Enumeration ( enum = enums . KeyCompressionType , tag = enums . Tags . KEY_COMPRESSION_TYPE ) self . _key_compression_type . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . KEY_WRAPPING_SPECIFICATION , local_stream ) : self . _key_wrapping_specification = objects . KeyWrappingSpecification ( ) self . _key_wrapping_specification . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Get request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier is not None : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _key_format_type is not None : self . _key_format_type . write ( local_stream , kmip_version = kmip_version ) if self . _key_compression_type is not None : self . _key_compression_type . write ( local_stream , kmip_version = kmip_version ) if self . _key_wrapping_specification is not None : self . _key_wrapping_specification . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( GetRequestPayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Get request payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . OBJECT_TYPE , local_stream ) : self . _object_type = primitives . Enumeration ( enum = enums . ObjectType , tag = enums . Tags . OBJECT_TYPE ) self . _object_type . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Parsed payload encoding is missing the object type field.\" ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Parsed payload encoding is missing the unique identifier \" \"field.\" ) self . secret = self . secret_factory . create ( self . object_type ) if self . is_tag_next ( self . _secret . tag , local_stream ) : self . _secret . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Parsed payload encoding is missing the secret field.\" ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Get response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def derive_key ( self , object_type , unique_identifiers , derivation_method , derivation_parameters , template_attribute , credential = None ) : operation = Operation ( OperationEnum . DERIVE_KEY ) request_payload = payloads . DeriveKeyRequestPayload ( object_type = object_type , unique_identifiers = unique_identifiers , derivation_method = derivation_method , derivation_parameters = derivation_parameters , template_attribute = template_attribute ) batch_item = messages . RequestBatchItem ( operation = operation , request_payload = request_payload ) request = self . _build_request_message ( credential , [ batch_item ] ) response = self . _send_and_receive_message ( request ) batch_item = response . batch_items [ 0 ] payload = batch_item . response_payload result = { } if payload : result [ 'unique_identifier' ] = payload . unique_identifier result [ 'template_attribute' ] = payload . template_attribute result [ 'result_status' ] = batch_item . result_status . value try : result [ 'result_reason' ] = batch_item . result_reason . value except Exception : result [ 'result_reason' ] = batch_item . result_reason try : result [ 'result_message' ] = batch_item . result_message . value except Exception : result [ 'result_message' ] = batch_item . result_message return result", "nl": "Derive a new key or secret data from an existing managed object ."}}
{"translation": {"code": "def _create_RSA_private_key ( self , bytes ) : try : private_key = serialization . load_pem_private_key ( bytes , password = None , backend = default_backend ( ) ) return private_key except Exception : private_key = serialization . load_der_private_key ( bytes , password = None , backend = default_backend ( ) ) return private_key", "nl": "Instantiates an RSA key from bytes ."}}
{"translation": {"code": "def _build_cryptographic_parameters ( self , value ) : if value is None : return None elif not isinstance ( value , dict ) : raise TypeError ( \"Cryptographic parameters must be a dictionary.\" ) cryptographic_parameters = CryptographicParameters ( block_cipher_mode = value . get ( 'block_cipher_mode' ) , padding_method = value . get ( 'padding_method' ) , hashing_algorithm = value . get ( 'hashing_algorithm' ) , key_role_type = value . get ( 'key_role_type' ) , digital_signature_algorithm = value . get ( 'digital_signature_algorithm' ) , cryptographic_algorithm = value . get ( 'cryptographic_algorithm' ) , random_iv = value . get ( 'random_iv' ) , iv_length = value . get ( 'iv_length' ) , tag_length = value . get ( 'tag_length' ) , fixed_field_length = value . get ( 'fixed_field_length' ) , invocation_field_length = value . get ( 'invocation_field_length' ) , counter_length = value . get ( 'counter_length' ) , initial_counter_value = value . get ( 'initial_counter_value' ) ) return cryptographic_parameters", "nl": "Build a CryptographicParameters struct from a dictionary ."}}
{"translation": {"code": "def derive_key ( self , object_type , unique_identifiers , derivation_method , derivation_parameters , * * kwargs ) : # Check input if not isinstance ( object_type , enums . ObjectType ) : raise TypeError ( \"Object type must be an ObjectType enumeration.\" ) if not isinstance ( unique_identifiers , list ) : raise TypeError ( \"Unique identifiers must be a list of strings.\" ) else : for unique_identifier in unique_identifiers : if not isinstance ( unique_identifier , six . string_types ) : raise TypeError ( \"Unique identifiers must be a list of strings.\" ) if not isinstance ( derivation_method , enums . DerivationMethod ) : raise TypeError ( \"Derivation method must be a DerivationMethod enumeration.\" ) if not isinstance ( derivation_parameters , dict ) : raise TypeError ( \"Derivation parameters must be a dictionary.\" ) derivation_parameters = DerivationParameters ( cryptographic_parameters = self . _build_cryptographic_parameters ( derivation_parameters . get ( 'cryptographic_parameters' ) ) , initialization_vector = derivation_parameters . get ( 'initialization_vector' ) , derivation_data = derivation_parameters . get ( 'derivation_data' ) , salt = derivation_parameters . get ( 'salt' ) , iteration_count = derivation_parameters . get ( 'iteration_count' ) ) # Handle object attributes attributes = [ ] if kwargs . get ( 'cryptographic_length' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_LENGTH , kwargs . get ( 'cryptographic_length' ) ) ) if kwargs . get ( 'cryptographic_algorithm' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_ALGORITHM , kwargs . get ( 'cryptographic_algorithm' ) ) ) if kwargs . get ( 'cryptographic_usage_mask' ) : attributes . append ( self . attribute_factory . create_attribute ( enums . AttributeType . CRYPTOGRAPHIC_USAGE_MASK , kwargs . get ( 'cryptographic_usage_mask' ) ) ) template_attribute = cobjects . TemplateAttribute ( attributes = attributes ) # Derive the new key/data and handle the results result = self . proxy . derive_key ( object_type , unique_identifiers , derivation_method , derivation_parameters , template_attribute ) status = result . get ( 'result_status' ) if status == enums . ResultStatus . SUCCESS : return result . get ( 'unique_identifier' ) else : raise exceptions . KmipOperationFailure ( status , result . get ( 'result_reason' ) , result . get ( 'result_message' ) )", "nl": "Derive a new key or secret data from existing managed objects ."}}
{"translation": {"code": "def _encrypt_asymmetric ( self , encryption_algorithm , encryption_key , plain_text , padding_method , hashing_algorithm = None ) : if encryption_algorithm == enums . CryptographicAlgorithm . RSA : if padding_method == enums . PaddingMethod . OAEP : hash_algorithm = self . _encryption_hash_algorithms . get ( hashing_algorithm ) if hash_algorithm is None : raise exceptions . InvalidField ( \"The hashing algorithm '{0}' is not supported for \" \"asymmetric encryption.\" . format ( hashing_algorithm ) ) padding_method = asymmetric_padding . OAEP ( mgf = asymmetric_padding . MGF1 ( algorithm = hash_algorithm ( ) ) , algorithm = hash_algorithm ( ) , label = None ) elif padding_method == enums . PaddingMethod . PKCS1v15 : padding_method = asymmetric_padding . PKCS1v15 ( ) else : raise exceptions . InvalidField ( \"The padding method '{0}' is not supported for asymmetric \" \"encryption.\" . format ( padding_method ) ) backend = default_backend ( ) try : public_key = backend . load_der_public_key ( encryption_key ) except Exception : try : public_key = backend . load_pem_public_key ( encryption_key ) except Exception : raise exceptions . CryptographicFailure ( \"The public key bytes could not be loaded.\" ) cipher_text = public_key . encrypt ( plain_text , padding_method ) return { 'cipher_text' : cipher_text } else : raise exceptions . InvalidField ( \"The cryptographic algorithm '{0}' is not supported for \" \"asymmetric encryption.\" . format ( encryption_algorithm ) )", "nl": "Encrypt data using asymmetric encryption ."}}
{"translation": {"code": "def _decrypt_asymmetric ( self , decryption_algorithm , decryption_key , cipher_text , padding_method , hashing_algorithm = None ) : if decryption_algorithm == enums . CryptographicAlgorithm . RSA : if padding_method == enums . PaddingMethod . OAEP : hash_algorithm = self . _encryption_hash_algorithms . get ( hashing_algorithm ) if hash_algorithm is None : raise exceptions . InvalidField ( \"The hashing algorithm '{0}' is not supported for \" \"asymmetric decryption.\" . format ( hashing_algorithm ) ) padding_method = asymmetric_padding . OAEP ( mgf = asymmetric_padding . MGF1 ( algorithm = hash_algorithm ( ) ) , algorithm = hash_algorithm ( ) , label = None ) elif padding_method == enums . PaddingMethod . PKCS1v15 : padding_method = asymmetric_padding . PKCS1v15 ( ) else : raise exceptions . InvalidField ( \"The padding method '{0}' is not supported for asymmetric \" \"decryption.\" . format ( padding_method ) ) backend = default_backend ( ) try : private_key = backend . load_der_private_key ( decryption_key , None ) except Exception : try : private_key = backend . load_pem_private_key ( decryption_key , None ) except Exception : raise exceptions . CryptographicFailure ( \"The private key bytes could not be loaded.\" ) plain_text = private_key . decrypt ( cipher_text , padding_method ) return plain_text else : raise exceptions . InvalidField ( \"The cryptographic algorithm '{0}' is not supported for \" \"asymmetric decryption.\" . format ( decryption_algorithm ) )", "nl": "Encrypt data using asymmetric decryption ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( SignatureVerifyRequestPayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_PARAMETERS , local_stream ) : self . _cryptographic_parameters = attributes . CryptographicParameters ( ) self . _cryptographic_parameters . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . DATA , local_stream ) : self . _data = primitives . ByteString ( tag = enums . Tags . DATA ) self . _data . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . DIGESTED_DATA , local_stream ) : self . _digested_data = primitives . ByteString ( tag = enums . Tags . DIGESTED_DATA ) self . _digested_data . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . SIGNATURE_DATA , local_stream ) : self . _signature_data = primitives . ByteString ( tag = enums . Tags . SIGNATURE_DATA ) self . _signature_data . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . CORRELATION_VALUE , local_stream ) : self . _correlation_value = primitives . ByteString ( tag = enums . Tags . CORRELATION_VALUE ) self . _correlation_value . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . INIT_INDICATOR , local_stream ) : self . _init_indicator = primitives . Boolean ( tag = enums . Tags . INIT_INDICATOR ) self . _init_indicator . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . FINAL_INDICATOR , local_stream ) : self . _final_indicator = primitives . Boolean ( tag = enums . Tags . FINAL_INDICATOR ) self . _final_indicator . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the SignatureVerify request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( SignatureVerifyResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Parsed payload encoding is missing the unique identifier \" \"field.\" ) if self . is_tag_next ( enums . Tags . VALIDITY_INDICATOR , local_stream ) : self . _validity_indicator = primitives . Enumeration ( enums . ValidityIndicator , tag = enums . Tags . VALIDITY_INDICATOR ) self . _validity_indicator . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Parsed payload encoding is missing the validity indicator \" \"field.\" ) if self . is_tag_next ( enums . Tags . DATA , local_stream ) : self . _data = primitives . ByteString ( tag = enums . Tags . DATA ) self . _data . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . CORRELATION_VALUE , local_stream ) : self . _correlation_value = primitives . ByteString ( tag = enums . Tags . CORRELATION_VALUE ) self . _correlation_value . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the SignatureVerify response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _cryptographic_parameters : self . _cryptographic_parameters . write ( local_stream , kmip_version = kmip_version ) if self . _data : self . _data . write ( local_stream , kmip_version = kmip_version ) if self . _digested_data : self . _digested_data . write ( local_stream , kmip_version = kmip_version ) if self . _signature_data : self . _signature_data . write ( local_stream , kmip_version = kmip_version ) if self . _correlation_value : self . _correlation_value . write ( local_stream , kmip_version = kmip_version ) if self . _init_indicator : self . _init_indicator . write ( local_stream , kmip_version = kmip_version ) if self . _final_indicator : self . _final_indicator . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( SignatureVerifyRequestPayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the SignatureVerify request payload to a stream ."}}
{"translation": {"code": "def verify_signature ( self , signing_key , message , signature , padding_method , signing_algorithm = None , hashing_algorithm = None , digital_signature_algorithm = None ) : backend = default_backend ( ) hash_algorithm = None dsa_hash_algorithm = None dsa_signing_algorithm = None if hashing_algorithm : hash_algorithm = self . _encryption_hash_algorithms . get ( hashing_algorithm ) if digital_signature_algorithm : algorithm_pair = self . _digital_signature_algorithms . get ( digital_signature_algorithm ) if algorithm_pair : dsa_hash_algorithm = algorithm_pair [ 0 ] dsa_signing_algorithm = algorithm_pair [ 1 ] if dsa_hash_algorithm and dsa_signing_algorithm : if hash_algorithm and ( hash_algorithm != dsa_hash_algorithm ) : raise exceptions . InvalidField ( \"The hashing algorithm does not match the digital \" \"signature algorithm.\" ) if ( signing_algorithm and ( signing_algorithm != dsa_signing_algorithm ) ) : raise exceptions . InvalidField ( \"The signing algorithm does not match the digital \" \"signature algorithm.\" ) signing_algorithm = dsa_signing_algorithm hash_algorithm = dsa_hash_algorithm if signing_algorithm == enums . CryptographicAlgorithm . RSA : if padding_method == enums . PaddingMethod . PSS : if hash_algorithm : padding = asymmetric_padding . PSS ( mgf = asymmetric_padding . MGF1 ( hash_algorithm ( ) ) , salt_length = asymmetric_padding . PSS . MAX_LENGTH ) else : raise exceptions . InvalidField ( \"A hashing algorithm must be specified for PSS \" \"padding.\" ) elif padding_method == enums . PaddingMethod . PKCS1v15 : padding = asymmetric_padding . PKCS1v15 ( ) else : raise exceptions . InvalidField ( \"The padding method '{0}' is not supported for signature \" \"verification.\" . format ( padding_method ) ) try : public_key = backend . load_der_public_key ( signing_key ) except Exception : try : public_key = backend . load_pem_public_key ( signing_key ) except Exception : raise exceptions . CryptographicFailure ( \"The signing key bytes could not be loaded.\" ) try : public_key . verify ( signature , message , padding , hash_algorithm ( ) ) return True except errors . InvalidSignature : return False except Exception : raise exceptions . CryptographicFailure ( \"The signature verification process failed.\" ) else : raise exceptions . InvalidField ( \"The signing algorithm '{0}' is not supported for \" \"signature verification.\" . format ( signing_algorithm ) )", "nl": "Verify a message signature ."}}
{"translation": {"code": "def _build_key_wrapping_specification ( self , value ) : if value is None : return None if not isinstance ( value , dict ) : raise TypeError ( \"Key wrapping specification must be a dictionary.\" ) encryption_key_info = self . _build_encryption_key_information ( value . get ( 'encryption_key_information' ) ) mac_signature_key_info = self . _build_mac_signature_key_information ( value . get ( 'mac_signature_key_information' ) ) key_wrapping_specification = cobjects . KeyWrappingSpecification ( wrapping_method = value . get ( 'wrapping_method' ) , encryption_key_information = encryption_key_info , mac_signature_key_information = mac_signature_key_info , attribute_names = value . get ( 'attribute_names' ) , encoding_option = value . get ( 'encoding_option' ) ) return key_wrapping_specification", "nl": "Build a KeyWrappingSpecification struct from a dictionary ."}}
{"translation": {"code": "def _build_mac_signature_key_information ( self , value ) : if value is None : return None if not isinstance ( value , dict ) : raise TypeError ( \"MAC/signature key information must be a dictionary.\" ) cryptographic_parameters = value . get ( 'cryptographic_parameters' ) if cryptographic_parameters : cryptographic_parameters = self . _build_cryptographic_parameters ( cryptographic_parameters ) mac_signature_key_information = cobjects . MACSignatureKeyInformation ( unique_identifier = value . get ( 'unique_identifier' ) , cryptographic_parameters = cryptographic_parameters ) return mac_signature_key_information", "nl": "Build an MACSignatureKeyInformation struct from a dictionary ."}}
{"translation": {"code": "def _build_encryption_key_information ( self , value ) : if value is None : return None if not isinstance ( value , dict ) : raise TypeError ( \"Encryption key information must be a dictionary.\" ) cryptographic_parameters = value . get ( 'cryptographic_parameters' ) if cryptographic_parameters : cryptographic_parameters = self . _build_cryptographic_parameters ( cryptographic_parameters ) encryption_key_information = cobjects . EncryptionKeyInformation ( unique_identifier = value . get ( 'unique_identifier' ) , cryptographic_parameters = cryptographic_parameters ) return encryption_key_information", "nl": "Build an EncryptionKeyInformation struct from a dictionary ."}}
{"translation": {"code": "def key_wrapping_data ( self ) : key_wrapping_data = { } encryption_key_info = { 'unique_identifier' : self . _kdw_eki_unique_identifier , 'cryptographic_parameters' : { 'block_cipher_mode' : self . _kdw_eki_cp_block_cipher_mode , 'padding_method' : self . _kdw_eki_cp_padding_method , 'hashing_algorithm' : self . _kdw_eki_cp_hashing_algorithm , 'key_role_type' : self . _kdw_eki_cp_key_role_type , 'digital_signature_algorithm' : self . _kdw_eki_cp_digital_signature_algorithm , 'cryptographic_algorithm' : self . _kdw_eki_cp_cryptographic_algorithm , 'random_iv' : self . _kdw_eki_cp_random_iv , 'iv_length' : self . _kdw_eki_cp_iv_length , 'tag_length' : self . _kdw_eki_cp_tag_length , 'fixed_field_length' : self . _kdw_eki_cp_fixed_field_length , 'invocation_field_length' : self . _kdw_eki_cp_invocation_field_length , 'counter_length' : self . _kdw_eki_cp_counter_length , 'initial_counter_value' : self . _kdw_eki_cp_initial_counter_value } } if not any ( encryption_key_info [ 'cryptographic_parameters' ] . values ( ) ) : encryption_key_info [ 'cryptographic_parameters' ] = { } if not any ( encryption_key_info . values ( ) ) : encryption_key_info = { } mac_sign_key_info = { 'unique_identifier' : self . _kdw_mski_unique_identifier , 'cryptographic_parameters' : { 'block_cipher_mode' : self . _kdw_mski_cp_block_cipher_mode , 'padding_method' : self . _kdw_mski_cp_padding_method , 'hashing_algorithm' : self . _kdw_mski_cp_hashing_algorithm , 'key_role_type' : self . _kdw_mski_cp_key_role_type , 'digital_signature_algorithm' : self . _kdw_mski_cp_digital_signature_algorithm , 'cryptographic_algorithm' : self . _kdw_mski_cp_cryptographic_algorithm , 'random_iv' : self . _kdw_mski_cp_random_iv , 'iv_length' : self . _kdw_mski_cp_iv_length , 'tag_length' : self . _kdw_mski_cp_tag_length , 'fixed_field_length' : self . _kdw_mski_cp_fixed_field_length , 'invocation_field_length' : self . _kdw_mski_cp_invocation_field_length , 'counter_length' : self . _kdw_mski_cp_counter_length , 'initial_counter_value' : self . _kdw_mski_cp_initial_counter_value } } if not any ( mac_sign_key_info [ 'cryptographic_parameters' ] . values ( ) ) : mac_sign_key_info [ 'cryptographic_parameters' ] = { } if not any ( mac_sign_key_info . values ( ) ) : mac_sign_key_info = { } key_wrapping_data [ 'wrapping_method' ] = self . _kdw_wrapping_method key_wrapping_data [ 'encryption_key_information' ] = encryption_key_info key_wrapping_data [ 'mac_signature_key_information' ] = mac_sign_key_info key_wrapping_data [ 'mac_signature' ] = self . _kdw_mac_signature key_wrapping_data [ 'iv_counter_nonce' ] = self . _kdw_iv_counter_nonce key_wrapping_data [ 'encoding_option' ] = self . _kdw_encoding_option if not any ( key_wrapping_data . values ( ) ) : key_wrapping_data = { } return key_wrapping_data", "nl": "Retrieve all of the relevant key wrapping data fields and return them as a dictionary ."}}
{"translation": {"code": "def key_wrapping_data ( self , value ) : if value is None : value = { } elif not isinstance ( value , dict ) : raise TypeError ( \"Key wrapping data must be a dictionary.\" ) self . _kdw_wrapping_method = value . get ( 'wrapping_method' ) eki = value . get ( 'encryption_key_information' ) if eki is None : eki = { } self . _kdw_eki_unique_identifier = eki . get ( 'unique_identifier' ) eki_cp = eki . get ( 'cryptographic_parameters' ) if eki_cp is None : eki_cp = { } self . _kdw_eki_cp_block_cipher_mode = eki_cp . get ( 'block_cipher_mode' ) self . _kdw_eki_cp_padding_method = eki_cp . get ( 'padding_method' ) self . _kdw_eki_cp_hashing_algorithm = eki_cp . get ( 'hashing_algorithm' ) self . _kdw_eki_cp_key_role_type = eki_cp . get ( 'key_role_type' ) self . _kdw_eki_cp_digital_signature_algorithm = eki_cp . get ( 'digital_signature_algorithm' ) self . _kdw_eki_cp_cryptographic_algorithm = eki_cp . get ( 'cryptographic_algorithm' ) self . _kdw_eki_cp_random_iv = eki_cp . get ( 'random_iv' ) self . _kdw_eki_cp_iv_length = eki_cp . get ( 'iv_length' ) self . _kdw_eki_cp_tag_length = eki_cp . get ( 'tag_length' ) self . _kdw_eki_cp_fixed_field_length = eki_cp . get ( 'fixed_field_length' ) self . _kdw_eki_cp_invocation_field_length = eki_cp . get ( 'invocation_field_length' ) self . _kdw_eki_cp_counter_length = eki_cp . get ( 'counter_length' ) self . _kdw_eki_cp_initial_counter_value = eki_cp . get ( 'initial_counter_value' ) mski = value . get ( 'mac_signature_key_information' ) if mski is None : mski = { } self . _kdw_mski_unique_identifier = mski . get ( 'unique_identifier' ) mski_cp = mski . get ( 'cryptographic_parameters' ) if mski_cp is None : mski_cp = { } self . _kdw_mski_cp_block_cipher_mode = mski_cp . get ( 'block_cipher_mode' ) self . _kdw_mski_cp_padding_method = mski_cp . get ( 'padding_method' ) self . _kdw_mski_cp_hashing_algorithm = mski_cp . get ( 'hashing_algorithm' ) self . _kdw_mski_cp_key_role_type = mski_cp . get ( 'key_role_type' ) self . _kdw_mski_cp_digital_signature_algorithm = mski_cp . get ( 'digital_signature_algorithm' ) self . _kdw_mski_cp_cryptographic_algorithm = mski_cp . get ( 'cryptographic_algorithm' ) self . _kdw_mski_cp_random_iv = mski_cp . get ( 'random_iv' ) self . _kdw_mski_cp_iv_length = mski_cp . get ( 'iv_length' ) self . _kdw_mski_cp_tag_length = mski_cp . get ( 'tag_length' ) self . _kdw_mski_cp_fixed_field_length = mski_cp . get ( 'fixed_field_length' ) self . _kdw_mski_cp_invocation_field_length = mski_cp . get ( 'invocation_field_length' ) self . _kdw_mski_cp_counter_length = mski_cp . get ( 'counter_length' ) self . _kdw_mski_cp_initial_counter_value = mski_cp . get ( 'initial_counter_value' ) self . _kdw_mac_signature = value . get ( 'mac_signature' ) self . _kdw_iv_counter_nonce = value . get ( 'iv_counter_nonce' ) self . _kdw_encoding_option = value . get ( 'encoding_option' )", "nl": "Set the key wrapping data attributes using a dictionary ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _usage_limits_count : self . _usage_limits_count . write ( local_stream , kmip_version = kmip_version ) if self . _cryptographic_usage_mask : self . _cryptographic_usage_mask . write ( local_stream , kmip_version = kmip_version ) if self . _lease_time : self . _lease_time . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( CheckResponsePayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Check response payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CheckResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . USAGE_LIMITS_COUNT , local_stream ) : self . _usage_limits_count = primitives . LongInteger ( tag = enums . Tags . USAGE_LIMITS_COUNT ) self . _usage_limits_count . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . CRYPTOGRAPHIC_USAGE_MASK , local_stream ) : self . _cryptographic_usage_mask = primitives . Integer ( tag = enums . Tags . CRYPTOGRAPHIC_USAGE_MASK ) self . _cryptographic_usage_mask . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . LEASE_TIME , local_stream ) : self . _lease_time = primitives . Interval ( tag = enums . Tags . LEASE_TIME ) self . _lease_time . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Check response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( ObtainLeaseResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . LEASE_TIME , local_stream ) : self . _lease_time = primitives . Interval ( tag = enums . Tags . LEASE_TIME ) self . _lease_time . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . LAST_CHANGE_DATE , local_stream ) : self . _last_change_date = primitives . DateTime ( tag = enums . Tags . LAST_CHANGE_DATE ) self . _last_change_date . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the ObtainLease response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _lease_time : self . _lease_time . write ( local_stream , kmip_version = kmip_version ) if self . _last_change_date : self . _last_change_date . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( ObtainLeaseResponsePayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the ObtainLease response payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( GetUsageAllocationRequestPayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . USAGE_LIMITS_COUNT , local_stream ) : self . _usage_limits_count = primitives . LongInteger ( tag = enums . Tags . USAGE_LIMITS_COUNT ) self . _usage_limits_count . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the GetUsageAllocation request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _unique_identifier : self . _unique_identifier . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( ArchiveResponsePayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Archive response payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( ArchiveResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . UNIQUE_IDENTIFIER , local_stream ) : self . _unique_identifier = primitives . TextString ( tag = enums . Tags . UNIQUE_IDENTIFIER ) self . _unique_identifier . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Archive response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( PollRequestPayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . ASYNCHRONOUS_CORRELATION_VALUE , local_stream ) : self . _asynchronous_correlation_value = primitives . ByteString ( tag = enums . Tags . ASYNCHRONOUS_CORRELATION_VALUE ) self . _asynchronous_correlation_value . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Poll request payload and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = utils . BytearrayStream ( ) if self . _asynchronous_correlation_value : self . _asynchronous_correlation_value . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( CancelRequestPayload , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the Cancel request payload to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( CancelResponsePayload , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = utils . BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . ASYNCHRONOUS_CORRELATION_VALUE , local_stream ) : self . _asynchronous_correlation_value = primitives . ByteString ( tag = enums . Tags . ASYNCHRONOUS_CORRELATION_VALUE ) self . _asynchronous_correlation_value . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . CANCELLATION_RESULT , local_stream ) : self . _cancellation_result = primitives . Enumeration ( enums . CancellationResult , tag = enums . Tags . CANCELLATION_RESULT ) self . _cancellation_result . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Cancel response payload and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( UsernamePasswordCredential , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . USERNAME , local_stream ) : self . _username = primitives . TextString ( tag = enums . Tags . USERNAME ) self . _username . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Username/password credential encoding missing the username.\" ) if self . is_tag_next ( enums . Tags . PASSWORD , local_stream ) : self . _password = primitives . TextString ( tag = enums . Tags . PASSWORD ) self . _password . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the UsernamePasswordCredential struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _username : self . _username . write ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Username/password credential struct missing the username.\" ) if self . _password : self . _password . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( UsernamePasswordCredential , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the UsernamePasswordCredential struct to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( DeviceCredential , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . DEVICE_SERIAL_NUMBER , local_stream ) : self . _device_serial_number = primitives . TextString ( tag = enums . Tags . DEVICE_SERIAL_NUMBER ) self . _device_serial_number . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . PASSWORD , local_stream ) : self . _password = primitives . TextString ( tag = enums . Tags . PASSWORD ) self . _password . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . DEVICE_IDENTIFIER , local_stream ) : self . _device_identifier = primitives . TextString ( tag = enums . Tags . DEVICE_IDENTIFIER ) self . _device_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . NETWORK_IDENTIFIER , local_stream ) : self . _network_identifier = primitives . TextString ( tag = enums . Tags . NETWORK_IDENTIFIER ) self . _network_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . MACHINE_IDENTIFIER , local_stream ) : self . _machine_identifier = primitives . TextString ( tag = enums . Tags . MACHINE_IDENTIFIER ) self . _machine_identifier . read ( local_stream , kmip_version = kmip_version ) if self . is_tag_next ( enums . Tags . MEDIA_IDENTIFIER , local_stream ) : self . _media_identifier = primitives . TextString ( tag = enums . Tags . MEDIA_IDENTIFIER ) self . _media_identifier . read ( local_stream , kmip_version = kmip_version ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the DeviceCredential struct and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_stream = BytearrayStream ( ) if self . _device_serial_number is not None : self . _device_serial_number . write ( local_stream , kmip_version = kmip_version ) if self . _password is not None : self . _password . write ( local_stream , kmip_version = kmip_version ) if self . _device_identifier is not None : self . _device_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _network_identifier is not None : self . _network_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _machine_identifier is not None : self . _machine_identifier . write ( local_stream , kmip_version = kmip_version ) if self . _media_identifier is not None : self . _media_identifier . write ( local_stream , kmip_version = kmip_version ) self . length = local_stream . length ( ) super ( DeviceCredential , self ) . write ( output_stream , kmip_version = kmip_version ) output_stream . write ( local_stream . buffer )", "nl": "Write the data encoding the DeviceCredential struct to a stream ."}}
{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Credential , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . CREDENTIAL_TYPE , local_stream ) : self . _credential_type = primitives . Enumeration ( enum = enums . CredentialType , tag = enums . Tags . CREDENTIAL_TYPE ) self . _credential_type . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Credential encoding missing the credential type.\" ) if self . is_tag_next ( enums . Tags . CREDENTIAL_VALUE , local_stream ) : if self . credential_type == enums . CredentialType . USERNAME_AND_PASSWORD : self . _credential_value = UsernamePasswordCredential ( ) elif self . credential_type == enums . CredentialType . DEVICE : self . _credential_value = DeviceCredential ( ) elif self . credential_type == enums . CredentialType . ATTESTATION : self . _credential_value = AttestationCredential ( ) else : raise ValueError ( \"Credential encoding includes unrecognized credential \" \"type.\" ) self . _credential_value . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Credential encoding missing the credential value.\" ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Credential struct and decode it into its constituent parts ."}}