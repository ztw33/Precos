{"translation": {"code": "def read ( self , input_stream , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : super ( Nonce , self ) . read ( input_stream , kmip_version = kmip_version ) local_stream = BytearrayStream ( input_stream . read ( self . length ) ) if self . is_tag_next ( enums . Tags . NONCE_ID , local_stream ) : self . _nonce_id = primitives . ByteString ( tag = enums . Tags . NONCE_ID ) self . _nonce_id . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Nonce encoding missing the nonce ID.\" ) if self . is_tag_next ( enums . Tags . NONCE_VALUE , local_stream ) : self . _nonce_value = primitives . ByteString ( tag = enums . Tags . NONCE_VALUE ) self . _nonce_value . read ( local_stream , kmip_version = kmip_version ) else : raise ValueError ( \"Nonce encoding missing the nonce value.\" ) self . is_oversized ( local_stream )", "nl": "Read the data encoding the Nonce struct and decode it into its constituent parts ."}}
{"translation": {"code": "def get_certificate_from_connection ( connection ) : certificate = connection . getpeercert ( binary_form = True ) if certificate : return x509 . load_der_x509_certificate ( certificate , backends . default_backend ( ) ) return None", "nl": "Extract an X . 509 certificate from a socket connection ."}}
{"translation": {"code": "def get_extended_key_usage_from_certificate ( certificate ) : try : return certificate . extensions . get_extension_for_oid ( x509 . oid . ExtensionOID . EXTENDED_KEY_USAGE ) . value except x509 . ExtensionNotFound : return None", "nl": "Given an X . 509 certificate extract and return the extendedKeyUsage extension ."}}
{"translation": {"code": "def get_common_names_from_certificate ( certificate ) : common_names = certificate . subject . get_attributes_for_oid ( x509 . oid . NameOID . COMMON_NAME ) return [ common_name . value for common_name in common_names ]", "nl": "Given an X . 509 certificate extract and return all common names ."}}
{"translation": {"code": "def check ( self , uid = None , usage_limits_count = None , cryptographic_usage_mask = None , lease_time = None ) : if uid is not None : if not isinstance ( uid , six . string_types ) : raise TypeError ( \"The unique identifier must be a string.\" ) if usage_limits_count is not None : if not isinstance ( usage_limits_count , six . integer_types ) : raise TypeError ( \"The usage limits count must be an integer.\" ) if cryptographic_usage_mask is not None : if not isinstance ( cryptographic_usage_mask , list ) or not all ( isinstance ( x , enums . CryptographicUsageMask ) for x in cryptographic_usage_mask ) : raise TypeError ( \"The cryptographic usage mask must be a list of \" \"CryptographicUsageMask enumerations.\" ) if lease_time is not None : if not isinstance ( lease_time , six . integer_types ) : raise TypeError ( \"The lease time must be an integer.\" ) result = self . proxy . check ( uid , usage_limits_count , cryptographic_usage_mask , lease_time ) status = result . get ( 'result_status' ) if status == enums . ResultStatus . SUCCESS : return result . get ( 'unique_identifier' ) else : raise exceptions . KmipOperationFailure ( status , result . get ( 'result_reason' ) , result . get ( 'result_message' ) )", "nl": "Check the constraints for a managed object ."}}
{"translation": {"code": "def protocol_version_to_kmip_version ( value ) : if not isinstance ( value , ProtocolVersion ) : return None if value . major == 1 : if value . minor == 0 : return enums . KMIPVersion . KMIP_1_0 elif value . minor == 1 : return enums . KMIPVersion . KMIP_1_1 elif value . minor == 2 : return enums . KMIPVersion . KMIP_1_2 elif value . minor == 3 : return enums . KMIPVersion . KMIP_1_3 elif value . minor == 4 : return enums . KMIPVersion . KMIP_1_4 else : return None else : return None", "nl": "Convert a ProtocolVersion struct to its KMIPVersion enumeration equivalent ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_0 ) : local_buffer = utils . BytearrayStream ( ) if self . _maximum_items : self . _maximum_items . write ( local_buffer , kmip_version = kmip_version ) if self . _offset_items : self . _offset_items . write ( local_buffer , kmip_version = kmip_version ) if self . _storage_status_mask : self . _storage_status_mask . write ( local_buffer , kmip_version = kmip_version ) if self . _object_group_member : self . _object_group_member . write ( local_buffer , kmip_version = kmip_version ) if kmip_version < enums . KMIPVersion . KMIP_2_0 : if self . _attributes : for attribute in self . attributes : attribute . write ( local_buffer , kmip_version = kmip_version ) else : if self . _attributes : # TODO (ph) Add a new utility to avoid using TemplateAttributes template_attribute = objects . TemplateAttribute ( attributes = self . attributes ) attributes = objects . convert_template_attribute_to_attributes ( template_attribute ) attributes . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The Locate request payload is missing the attributes \" \"list.\" ) self . length = local_buffer . length ( ) super ( LocateRequestPayload , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the data encoding the Locate request payload to a buffer ."}}
{"translation": {"code": "def convert_attribute_name_to_tag ( value ) : if not isinstance ( value , six . string_types ) : raise ValueError ( \"The attribute name must be a string.\" ) for entry in attribute_name_tag_table : if value == entry [ 0 ] : return entry [ 1 ] raise ValueError ( \"Unrecognized attribute name: '{}'\" . format ( value ) )", "nl": "A utility function that converts an attribute name string into the corresponding attribute tag ."}}
{"translation": {"code": "def convert_attribute_tag_to_name ( value ) : if not isinstance ( value , Tags ) : raise ValueError ( \"The attribute tag must be a Tags enumeration.\" ) for entry in attribute_name_tag_table : if value == entry [ 1 ] : return entry [ 0 ] raise ValueError ( \"Unrecognized attribute tag: {}\" . format ( value ) )", "nl": "A utility function that converts an attribute tag into the corresponding attribute name string ."}}
{"translation": {"code": "def get_enumerations_from_bit_mask ( enumeration , mask ) : return [ x for x in enumeration if ( x . value & mask ) == x . value ]", "nl": "A utility function that creates a list of enumeration values from a bit mask for a specific mask enumeration class ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the AttributeReference \" \"object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _vendor_identification : self . _vendor_identification . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The AttributeReference is missing the vendor identification \" \"field.\" ) if self . _attribute_name : self . _attribute_name . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The AttributeReference is missing the attribute name field.\" ) self . length = local_buffer . length ( ) super ( AttributeReference , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the AttributeReference structure encoding to the data stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the ObjectDefaults object.\" . format ( kmip_version . value ) ) super ( ObjectDefaults , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . OBJECT_TYPE , local_buffer ) : self . _object_type = primitives . Enumeration ( enums . ObjectType , tag = enums . Tags . OBJECT_TYPE ) self . _object_type . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The ObjectDefaults encoding is missing the object type \" \"enumeration.\" ) if self . is_tag_next ( enums . Tags . ATTRIBUTES , local_buffer ) : self . _attributes = Attributes ( ) self . _attributes . read ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidKmipEncoding ( \"The ObjectDefaults encoding is missing the attributes \" \"structure.\" ) self . is_oversized ( local_buffer )", "nl": "Read the data encoding the ObjectDefaults structure and decode it into its constituent parts ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the DefaultsInformation \" \"object.\" . format ( kmip_version . value ) ) super ( DefaultsInformation , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) object_defaults = [ ] while self . is_tag_next ( enums . Tags . OBJECT_DEFAULTS , local_buffer ) : object_default = ObjectDefaults ( ) object_default . read ( local_buffer , kmip_version = kmip_version ) object_defaults . append ( object_default ) if len ( object_defaults ) == 0 : raise exceptions . InvalidKmipEncoding ( \"The DefaultsInformation encoding is missing the object \" \"defaults structure.\" ) else : self . _object_defaults = object_defaults self . is_oversized ( local_buffer )", "nl": "Read the data encoding the DefaultsInformation structure and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_2_0 ) : if kmip_version < enums . KMIPVersion . KMIP_2_0 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the DefaultsInformation \" \"object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _object_defaults : for object_default in self . _object_defaults : object_default . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The DefaultsInformation structure is missing the object \" \"defaults field.\" ) self . length = local_buffer . length ( ) super ( DefaultsInformation , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the DefaultsInformation structure encoding to the data stream ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the RNGParameters object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _rng_algorithm : self . _rng_algorithm . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The RNGParameters structure is missing the RNG algorithm \" \"field.\" ) if self . _cryptographic_algorithm : self . _cryptographic_algorithm . write ( local_buffer , kmip_version = kmip_version ) if self . _cryptographic_length : self . _cryptographic_length . write ( local_buffer , kmip_version = kmip_version ) if self . _hashing_algorithm : self . _hashing_algorithm . write ( local_buffer , kmip_version = kmip_version ) if self . _drbg_algorithm : self . _drbg_algorithm . write ( local_buffer , kmip_version = kmip_version ) if self . _recommended_curve : self . _recommended_curve . write ( local_buffer , kmip_version = kmip_version ) if self . _fips186_variation : self . _fips186_variation . write ( local_buffer , kmip_version = kmip_version ) if self . _prediction_resistance : self . _prediction_resistance . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( RNGParameters , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the RNGParameters structure encoding to the data stream ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the ValidationInformation \" \"object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _validation_authority_type : self . _validation_authority_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ValidationInformation structure is missing the \" \"validation authority type field.\" ) if self . _validation_authority_country : self . _validation_authority_country . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_authority_uri : self . _validation_authority_uri . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_version_major : self . _validation_version_major . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ValidationInformation structure is missing the \" \"validation version major field.\" ) if self . _validation_version_minor : self . _validation_version_minor . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_type : self . _validation_type . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ValidationInformation structure is missing the \" \"validation type field.\" ) if self . _validation_level : self . _validation_level . write ( local_buffer , kmip_version = kmip_version ) else : raise exceptions . InvalidField ( \"The ValidationInformation structure is missing the \" \"validation level field.\" ) if self . _validation_certificate_identifier : self . _validation_certificate_identifier . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_certificate_uri : self . _validation_certificate_uri . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_vendor_uri : self . _validation_vendor_uri . write ( local_buffer , kmip_version = kmip_version ) if self . _validation_profiles : for validation_profile in self . _validation_profiles : validation_profile . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( ValidationInformation , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the ValidationInformation structure encoding to the data stream ."}}
{"translation": {"code": "def read ( self , input_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the CapabilityInformation \" \"object.\" . format ( kmip_version . value ) ) super ( CapabilityInformation , self ) . read ( input_buffer , kmip_version = kmip_version ) local_buffer = utils . BytearrayStream ( input_buffer . read ( self . length ) ) if self . is_tag_next ( enums . Tags . STREAMING_CAPABILITY , local_buffer ) : streaming_capability = primitives . Boolean ( tag = enums . Tags . STREAMING_CAPABILITY ) streaming_capability . read ( local_buffer , kmip_version = kmip_version ) self . _streaming_capability = streaming_capability if self . is_tag_next ( enums . Tags . ASYNCHRONOUS_CAPABILITY , local_buffer ) : asynchronous_capability = primitives . Boolean ( tag = enums . Tags . ASYNCHRONOUS_CAPABILITY ) asynchronous_capability . read ( local_buffer , kmip_version = kmip_version ) self . _asynchronous_capability = asynchronous_capability if self . is_tag_next ( enums . Tags . ATTESTATION_CAPABILITY , local_buffer ) : attestation_capability = primitives . Boolean ( tag = enums . Tags . ATTESTATION_CAPABILITY ) attestation_capability . read ( local_buffer , kmip_version = kmip_version ) self . _attestation_capability = attestation_capability if kmip_version >= enums . KMIPVersion . KMIP_1_4 : if self . is_tag_next ( enums . Tags . BATCH_UNDO_CAPABILITY , local_buffer ) : batch_undo_capability = primitives . Boolean ( tag = enums . Tags . BATCH_UNDO_CAPABILITY ) batch_undo_capability . read ( local_buffer , kmip_version = kmip_version ) self . _batch_continue_capability = batch_undo_capability if self . is_tag_next ( enums . Tags . BATCH_CONTINUE_CAPABILITY , local_buffer ) : batch_continue_capability = primitives . Boolean ( tag = enums . Tags . BATCH_CONTINUE_CAPABILITY ) batch_continue_capability . read ( local_buffer , kmip_version = kmip_version ) self . _batch_continue_capability = batch_continue_capability if self . is_tag_next ( enums . Tags . UNWRAP_MODE , local_buffer ) : unwrap_mode = primitives . Enumeration ( enums . UnwrapMode , tag = enums . Tags . UNWRAP_MODE ) unwrap_mode . read ( local_buffer , kmip_version = kmip_version ) self . _unwrap_mode = unwrap_mode if self . is_tag_next ( enums . Tags . DESTROY_ACTION , local_buffer ) : destroy_action = primitives . Enumeration ( enums . DestroyAction , tag = enums . Tags . DESTROY_ACTION ) destroy_action . read ( local_buffer , kmip_version = kmip_version ) self . _destroy_action = destroy_action if self . is_tag_next ( enums . Tags . SHREDDING_ALGORITHM , local_buffer ) : shredding_algorithm = primitives . Enumeration ( enums . ShreddingAlgorithm , tag = enums . Tags . SHREDDING_ALGORITHM ) shredding_algorithm . read ( local_buffer , kmip_version = kmip_version ) self . _shredding_algorithm = shredding_algorithm if self . is_tag_next ( enums . Tags . RNG_MODE , local_buffer ) : rng_mode = primitives . Enumeration ( enums . RNGMode , tag = enums . Tags . RNG_MODE ) rng_mode . read ( local_buffer , kmip_version = kmip_version ) self . _rng_mode = rng_mode self . is_oversized ( local_buffer )", "nl": "Read the data encoding the CapabilityInformation structure and decode it into its constituent parts ."}}
{"translation": {"code": "def write ( self , output_buffer , kmip_version = enums . KMIPVersion . KMIP_1_3 ) : if kmip_version < enums . KMIPVersion . KMIP_1_3 : raise exceptions . VersionNotSupported ( \"KMIP {} does not support the CapabilityInformation \" \"object.\" . format ( kmip_version . value ) ) local_buffer = BytearrayStream ( ) if self . _streaming_capability : self . _streaming_capability . write ( local_buffer , kmip_version = kmip_version ) if self . _asynchronous_capability : self . _asynchronous_capability . write ( local_buffer , kmip_version = kmip_version ) if self . _attestation_capability : self . _attestation_capability . write ( local_buffer , kmip_version = kmip_version ) if kmip_version >= enums . KMIPVersion . KMIP_1_4 : if self . _batch_undo_capability : self . _batch_undo_capability . write ( local_buffer , kmip_version = kmip_version ) if self . _batch_continue_capability : self . _batch_continue_capability . write ( local_buffer , kmip_version = kmip_version ) if self . _unwrap_mode : self . _unwrap_mode . write ( local_buffer , kmip_version = kmip_version ) if self . _destroy_action : self . _destroy_action . write ( local_buffer , kmip_version = kmip_version ) if self . _shredding_algorithm : self . _shredding_algorithm . write ( local_buffer , kmip_version = kmip_version ) if self . _rng_mode : self . _rng_mode . write ( local_buffer , kmip_version = kmip_version ) self . length = local_buffer . length ( ) super ( CapabilityInformation , self ) . write ( output_buffer , kmip_version = kmip_version ) output_buffer . write ( local_buffer . buffer )", "nl": "Write the CapabilityInformation structure encoding to the data stream ."}}