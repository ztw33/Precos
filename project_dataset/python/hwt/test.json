{"translation": {"code": "def HWProcess ( cls , proc : HWProcess , ctx : ResourceContext ) -> None : seen = ctx . seen for stm in proc . statements : encl = stm . _enclosed_for full_ev_dep = stm . _is_completly_event_dependent now_ev_dep = stm . _now_is_event_dependent ev_dep = full_ev_dep or now_ev_dep out_mux_dim = count_mux_inputs_for_outputs ( stm ) for o in stm . _outputs : if o in seen : continue i = out_mux_dim [ o ] if isinstance ( o . _dtype , HArray ) : assert i == 1 , ( o , i , \" only one ram port per HWProcess\" ) for a in walk_assignments ( stm , o ) : assert len ( a . indexes ) == 1 , \"one address per RAM port\" addr = a . indexes [ 0 ] ctx . registerRAM_write_port ( o , addr , ev_dep ) elif ev_dep : ctx . registerFF ( o ) if i > 1 : ctx . registerMUX ( stm , o , i ) elif o not in encl : ctx . registerLatch ( o ) if i > 1 : ctx . registerMUX ( stm , o , i ) elif i > 1 : ctx . registerMUX ( stm , o , i ) else : # just a connection continue if isinstance ( stm , SwitchContainer ) : caseEqs = set ( [ stm . switchOn . _eq ( c [ 0 ] ) for c in stm . cases ] ) inputs = chain ( [ sig for sig in stm . _inputs if sig not in caseEqs ] , [ stm . switchOn ] ) else : inputs = stm . _inputs for i in inputs : # discover only internal signals in this statements for # operators if not i . hidden or i in seen : continue cls . HWProcess_operators ( i , ctx , ev_dep )", "nl": "Gues resource usage by HWProcess"}}
{"translation": {"code": "def onTWriteCallback__init ( self , sim ) : yield from self . onTWriteCallback ( sim ) self . intf . t . _sigInside . registerWriteCallback ( self . onTWriteCallback , self . getEnable ) self . intf . o . _sigInside . registerWriteCallback ( self . onTWriteCallback , self . getEnable )", "nl": "Process for injecting of this callback loop into simulator"}}
{"translation": {"code": "def _on_parent_event_dependent ( self ) : if not self . _is_completly_event_dependent : self . _is_completly_event_dependent = True for stm in self . _iter_stms ( ) : stm . _on_parent_event_dependent ( )", "nl": "After parrent statement become event dependent propagate event dependency flag to child statements"}}
{"translation": {"code": "def _register_stements ( self , statements : List [ \"HdlStatement\" ] , target : List [ \"HdlStatement\" ] ) : for stm in flatten ( statements ) : assert stm . parentStm is None , stm stm . _set_parent_stm ( self ) target . append ( stm )", "nl": "Append statements to this container under conditions specified by condSet"}}
{"translation": {"code": "def _on_reduce ( self , self_reduced : bool , io_changed : bool , result_statements : List [ \"HdlStatement\" ] ) -> None : parentStm = self . parentStm if self_reduced : was_top = parentStm is None # update signal drivers/endpoints if was_top : # disconnect self from signals ctx = self . _get_rtl_context ( ) ctx . statements . remove ( self ) ctx . statements . update ( result_statements ) for i in self . _inputs : i . endpoints . discard ( self ) for o in self . _outputs : o . drivers . remove ( self ) for stm in result_statements : stm . parentStm = parentStm if parentStm is None : # conect signals to child statements for inp in stm . _inputs : inp . endpoints . append ( stm ) for outp in stm . _outputs : outp . drivers . append ( stm ) else : # parent has to update it's inputs/outputs if io_changed : self . _inputs = UniqList ( ) self . _outputs = UniqList ( ) self . _collect_io ( )", "nl": "Update signal IO after reuce atempt"}}
{"translation": {"code": "def _merge_nested_if_from_else ( self , ifStm : \"IfContainer\" ) : self . elIfs . append ( ( ifStm . cond , ifStm . ifTrue ) ) self . elIfs . extend ( ifStm . elIfs ) self . ifFalse = ifStm . ifFalse", "nl": "Merge nested IfContarner form else branch to this IfContainer as elif and else branches"}}
{"translation": {"code": "def _mkOp ( fn ) : def op ( * operands , key = None ) -> RtlSignalBase : \"\"\"\n        :param operands: variadic parameter of input uperands\n        :param key: optional function applied on every operand\n            before processing\n        \"\"\" assert operands , operands top = None if key is not None : operands = map ( key , operands ) for s in operands : if top is None : top = s else : top = fn ( top , s ) return top return op", "nl": "Function to create variadic operator function"}}
{"translation": {"code": "def _merge_statement_lists ( stmsA : List [ \"HdlStatement\" ] , stmsB : List [ \"HdlStatement\" ] ) -> List [ \"HdlStatement\" ] : if stmsA is None and stmsB is None : return None tmp = [ ] a_it = iter ( stmsA ) b_it = iter ( stmsB ) a = None b = None a_empty = False b_empty = False while not a_empty and not b_empty : while not a_empty : a = next ( a_it , None ) if a is None : a_empty = True break elif a . rank == 0 : # simple statement does not require merging tmp . append ( a ) a = None else : break while not b_empty : b = next ( b_it , None ) if b is None : b_empty = True break elif b . rank == 0 : # simple statement does not require merging tmp . append ( b ) b = None else : break if a is not None or b is not None : a . _merge_with_other_stm ( b ) tmp . append ( a ) a = None b = None return tmp", "nl": "Merge two lists of statements into one"}}
{"translation": {"code": "def _merge_statements ( statements : List [ \"HdlStatement\" ] ) -> Tuple [ List [ \"HdlStatement\" ] , int ] : order = { } for i , stm in enumerate ( statements ) : order [ stm ] = i new_statements = [ ] rank_decrease = 0 for rank , stms in groupedby ( statements , lambda s : s . rank ) : if rank == 0 : new_statements . extend ( stms ) else : if len ( stms ) == 1 : new_statements . extend ( stms ) continue # try to merge statements if they are same condition tree for iA , stmA in enumerate ( stms ) : if stmA is None : continue for iB , stmB in enumerate ( islice ( stms , iA + 1 , None ) ) : if stmB is None : continue if stmA . _is_mergable ( stmB ) : rank_decrease += stmB . rank stmA . _merge_with_other_stm ( stmB ) stms [ iA + 1 + iB ] = None new_statements . append ( stmA ) else : new_statements . append ( stmA ) new_statements . append ( stmB ) new_statements . sort ( key = lambda stm : order [ stm ] ) return new_statements , rank_decrease", "nl": "Merge statements in list to remove duplicated if - then - else trees"}}
{"translation": {"code": "def _clean_signal_meta ( self ) : self . _enclosed_for = None self . _sensitivity = None for stm in self . _iter_stms ( ) : stm . _clean_signal_meta ( )", "nl": "Clean informations about enclosure for outputs and sensitivity of this statement"}}
{"translation": {"code": "def _add_process ( self , proc , priority ) -> None : self . _events . push ( self . now , priority , proc )", "nl": "Schedule process on actual time with specified priority"}}
{"translation": {"code": "def _destroy ( self ) : ctx = self . _get_rtl_context ( ) for i in self . _inputs : i . endpoints . discard ( self ) for o in self . _outputs : o . drivers . remove ( self ) ctx . statements . remove ( self )", "nl": "Disconnect this statement from signals and delete it from RtlNetlist context"}}
{"translation": {"code": "def propagateRstn ( obj ) : rst_n = obj . rst_n for u in obj . _units : _tryConnect ( rst_n , u , 'rst_n' ) _tryConnect ( ~ rst_n , u , 'rst' )", "nl": "Propagate negative reset rst_n signal to all subcomponents"}}
{"translation": {"code": "def propagateRst ( obj ) : rst = obj . rst for u in obj . _units : _tryConnect ( ~ rst , u , 'rst_n' ) _tryConnect ( rst , u , 'rst' )", "nl": "Propagate reset rst signal to all subcomponents"}}
{"translation": {"code": "def _updateParamsFrom ( self , otherObj : \"PropDeclrCollector\" , updater , exclude : set , prefix : str ) -> None : excluded = set ( ) if exclude is not None : exclude = set ( exclude ) for myP in self . _params : pPName = prefix + myP . _scopes [ self ] [ 1 ] try : otherP = getattr ( otherObj , pPName ) if not isinstance ( otherP , Param ) : continue except AttributeError : continue if exclude and otherP in exclude : excluded . add ( otherP ) continue updater ( self , myP , otherP ) if exclude is not None : # assert that what should be excluded really exists assert excluded == exclude", "nl": "Update all parameters which are defined on self from otherObj"}}
{"translation": {"code": "def _make_association ( self , * args , * * kwargs ) : for o in self : o . _make_association ( * args , * * kwargs )", "nl": "Delegate _make_association on items"}}