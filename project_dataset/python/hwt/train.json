{"translation": {"code": "def find_files ( directory , pattern , recursive = True ) : if not os . path . isdir ( directory ) : if os . path . exists ( directory ) : raise IOError ( directory + ' is not directory' ) else : raise IOError ( directory + \" does not exists\" ) if recursive : for root , _ , files in os . walk ( directory ) : for basename in files : if fnmatch . fnmatch ( basename , pattern ) : filename = os . path . join ( root , basename ) yield filename else : root = directory for basename in os . listdir ( root ) : if fnmatch . fnmatch ( basename , pattern ) : filename = os . path . join ( root , basename ) if os . path . isfile ( filename ) : yield filename", "nl": "Find files by pattern in directory"}}
{"translation": {"code": "def synthesize ( self , name , interfaces , targetPlatform ) : ent = Entity ( name ) ent . _name = name + \"_inst\" # instance name # create generics for _ , v in self . params . items ( ) : ent . generics . append ( v ) # interface set for faster lookup if isinstance ( interfaces , set ) : intfSet = interfaces else : intfSet = set ( interfaces ) # create ports for s in interfaces : pi = portItemfromSignal ( s , ent ) pi . registerInternSig ( s ) ent . ports . append ( pi ) s . hidden = False removeUnconnectedSignals ( self ) markVisibilityOfSignals ( self , name , self . signals , intfSet ) for proc in targetPlatform . beforeHdlArchGeneration : proc ( self ) arch = Architecture ( ent ) for p in statements_to_HWProcesses ( self . statements ) : arch . processes . append ( p ) # add signals, variables etc. in architecture for s in self . signals : if s not in intfSet and not s . hidden : arch . variables . append ( s ) # instantiate subUnits in architecture for u in self . subUnits : arch . componentInstances . append ( u ) # add components in architecture for su in distinctBy ( self . subUnits , lambda x : x . name ) : arch . components . append ( su ) self . synthesised = True return [ ent , arch ]", "nl": "Build Entity and Architecture instance out of netlist representation"}}
{"translation": {"code": "def sig ( self , name , dtype = BIT , clk = None , syncRst = None , defVal = None ) : if isinstance ( defVal , RtlSignal ) : assert defVal . _const , \"Initial value of register has to be constant\" _defVal = defVal . _auto_cast ( dtype ) elif isinstance ( defVal , Value ) : _defVal = defVal . _auto_cast ( dtype ) elif isinstance ( defVal , InterfaceBase ) : _defVal = defVal . _sig else : _defVal = dtype . fromPy ( defVal ) if clk is not None : s = RtlSyncSignal ( self , name , dtype , _defVal ) if syncRst is not None and defVal is None : raise SigLvlConfErr ( \"Probably forgotten default value on sync signal %s\" , name ) if syncRst is not None : r = If ( syncRst . _isOn ( ) , RtlSignal . __call__ ( s , _defVal ) ) . Else ( RtlSignal . __call__ ( s , s . next ) ) else : r = [ RtlSignal . __call__ ( s , s . next ) ] If ( clk . _onRisingEdge ( ) , r ) else : if syncRst : raise SigLvlConfErr ( \"Signal %s has reset but has no clk\" % name ) s = RtlSignal ( self , name , dtype , defVal = _defVal ) self . signals . add ( s ) return s", "nl": "Create new signal in this context"}}
{"translation": {"code": "def distinctBy ( iterable , fn ) : s = set ( ) for i in iterable : r = fn ( i ) if r not in s : s . add ( r ) yield i", "nl": "uniq operation with key selector"}}
{"translation": {"code": "def _signalsForInterface ( self , context , prefix = '' , typeTransform = None ) : sigs = [ ] if self . _interfaces : for intf in self . _interfaces : sigs . extend ( intf . _signalsForInterface ( context , prefix , typeTransform = typeTransform ) ) else : if hasattr ( self , '_sig' ) : sigs = [ self . _sig ] else : t = self . _dtype if typeTransform is not None : t = typeTransform ( t ) s = context . sig ( prefix + self . _getPhysicalName ( ) , t ) s . _interface = self self . _sig = s if hasattr ( self , '_boundedEntityPort' ) : self . _boundedEntityPort . connectSig ( self . _sig ) sigs = [ s ] return sigs", "nl": "generate _sig for each interface which has no subinterface if already has _sig return it instead"}}
{"translation": {"code": "def set ( self , val ) : assert not self . __isReadOnly , ( \"This parameter(%s) was locked\" \" and now it can not be changed\" % self . name ) assert self . replacedWith is None , ( \"This param was replaced with new one and this \" \"should not exists\" ) val = toHVal ( val ) self . defVal = val self . _val = val . staticEval ( ) self . _dtype = self . _val . _dtype", "nl": "set value of this param"}}
{"translation": {"code": "def _getPhysicalName ( self ) : if hasattr ( self , \"_boundedEntityPort\" ) : return self . _boundedEntityPort . name else : return self . _getFullName ( ) . replace ( '.' , self . _NAME_SEPARATOR )", "nl": "Get name in HDL"}}
{"translation": {"code": "def eval ( self , operator , simulator = None ) : def getVal ( v ) : while not isinstance ( v , Value ) : v = v . _val return v operands = list ( map ( getVal , operator . operands ) ) if isEventDependentOp ( operator . operator ) : operands . append ( simulator . now ) elif operator . operator == AllOps . IntToBits : operands . append ( operator . result . _dtype ) return self . _evalFn ( * operands )", "nl": "Load all operands and process them by self . _evalFn"}}
{"translation": {"code": "def vec ( val , width , signed = None ) : return Bits ( width , signed , forceVector = True ) . fromPy ( val )", "nl": "create hdl vector value"}}
{"translation": {"code": "def auto_cast ( self , sigOrVal , toType ) : if sigOrVal . _dtype == toType : return sigOrVal try : c = self . _auto_cast_fn except AttributeError : c = self . get_auto_cast_fn ( ) self . _auto_cast_fn = c return c ( self , sigOrVal , toType )", "nl": "Cast value or signal of this type to another compatible type ."}}
{"translation": {"code": "def staticEval ( self ) : for o in self . operands : o . staticEval ( ) self . result . _val = self . evalFn ( )", "nl": "Recursively statistically evaluate result of this operator"}}
{"translation": {"code": "def _registerParameter ( self , pName , parameter ) -> None : nameAvailabilityCheck ( self , pName , parameter ) # resolve name in this scope try : hasName = parameter . _name is not None except AttributeError : hasName = False if not hasName : parameter . _name = pName # add name in this scope parameter . _registerScope ( pName , self ) if parameter . hasGenericName : parameter . name = pName if parameter . _parent is None : parameter . _parent = self self . _params . append ( parameter )", "nl": "Register Param object on interface level object"}}
{"translation": {"code": "def walkParams ( intf , discovered ) : for si in intf . _interfaces : yield from walkParams ( si , discovered ) for p in intf . _params : if p not in discovered : discovered . add ( p ) yield p", "nl": "walk parameter instances on this interface"}}
{"translation": {"code": "def _toRtl ( self , targetPlatform : DummyPlatform ) : assert not self . _wasSynthetised ( ) self . _targetPlatform = targetPlatform if not hasattr ( self , \"_name\" ) : self . _name = self . _getDefaultName ( ) for proc in targetPlatform . beforeToRtl : proc ( self ) self . _ctx . params = self . _buildParams ( ) self . _externInterf = [ ] # prepare subunits for u in self . _units : yield from u . _toRtl ( targetPlatform ) for u in self . _units : subUnitName = u . _name u . _signalsForMyEntity ( self . _ctx , \"sig_\" + subUnitName ) # prepare signals for interfaces for i in self . _interfaces : signals = i . _signalsForInterface ( self . _ctx ) if i . _isExtern : self . _externInterf . extend ( signals ) for proc in targetPlatform . beforeToRtlImpl : proc ( self ) self . _loadMyImplementations ( ) yield from self . _lazyLoaded if not self . _externInterf : raise IntfLvlConfErr ( \"Can not find any external interface for unit %s\" \"- unit without interfaces are not allowed\" % self . _name ) for proc in targetPlatform . afterToRtlImpl : proc ( self ) yield from self . _synthetiseContext ( self . _externInterf ) self . _checkArchCompInstances ( ) for proc in targetPlatform . afterToRtl : proc ( self )", "nl": "synthesize all subunits make connections between them build entity and component for this unit"}}
{"translation": {"code": "def _loadDeclarations ( self ) : if not hasattr ( self , \"_interfaces\" ) : self . _interfaces = [ ] self . _setAttrListener = self . _declrCollector self . _declr ( ) self . _setAttrListener = None for i in self . _interfaces : i . _isExtern = self . _isExtern i . _loadDeclarations ( ) for p in self . _params : p . setReadOnly ( ) if self . _isExtern : # direction from inside of unit (reverset compared to outside direction) if self . _direction == INTF_DIRECTION . UNKNOWN : self . _direction = INTF_DIRECTION . MASTER self . _setDirectionsLikeIn ( self . _direction )", "nl": "load declaratoins from _declr method This function is called first for parent and then for children"}}
{"translation": {"code": "def evalParam ( p ) : while isinstance ( p , Param ) : p = p . get ( ) if isinstance ( p , RtlSignalBase ) : return p . staticEval ( ) # use rather param inheritance instead of param as param value return toHVal ( p )", "nl": "Get value of parameter"}}
{"translation": {"code": "def _sig ( self , name , dtype = BIT , defVal = None ) : if isinstance ( dtype , HStruct ) : if defVal is not None : raise NotImplementedError ( ) container = dtype . fromPy ( None ) for f in dtype . fields : if f . name is not None : r = self . _sig ( \"%s_%s\" % ( name , f . name ) , f . dtype ) setattr ( container , f . name , r ) return container return self . _ctx . sig ( name , dtype = dtype , defVal = defVal )", "nl": "Create signal in this unit"}}
{"translation": {"code": "def _cleanAsSubunit ( self ) : for pi in self . _entity . ports : pi . connectInternSig ( ) for i in chain ( self . _interfaces , self . _private_interfaces ) : i . _clean ( )", "nl": "Disconnect internal signals so unit can be reused by parent unit"}}
{"translation": {"code": "def toRtl ( unitOrCls : Unit , name : str = None , serializer : GenericSerializer = VhdlSerializer , targetPlatform = DummyPlatform ( ) , saveTo : str = None ) : if not isinstance ( unitOrCls , Unit ) : u = unitOrCls ( ) else : u = unitOrCls u . _loadDeclarations ( ) if name is not None : assert isinstance ( name , str ) u . _name = name globScope = serializer . getBaseNameScope ( ) mouduleScopes = { } # unitCls : unitobj serializedClasses = { } # (unitCls, paramsValues) : unitObj # where paramsValues are dict name:value serializedConfiguredUnits = { } doSerialize = True createFiles = saveTo is not None if createFiles : os . makedirs ( saveTo , exist_ok = True ) files = UniqList ( ) else : codeBuff = [ ] for obj in u . _toRtl ( targetPlatform ) : doSerialize = serializer . serializationDecision ( obj , serializedClasses , serializedConfiguredUnits ) if doSerialize : if isinstance ( obj , Entity ) : s = globScope . fork ( 1 ) s . setLevel ( 2 ) ctx = serializer . getBaseContext ( ) ctx . scope = s mouduleScopes [ obj ] = ctx ctx . currentUnit = obj . origin sc = serializer . Entity ( obj , ctx ) if createFiles : fName = obj . name + serializer . fileExtension fileMode = 'w' elif isinstance ( obj , Architecture ) : try : ctx = mouduleScopes [ obj . entity ] except KeyError : raise SerializerException ( \"Entity should be serialized\" \" before architecture of %s\" % ( obj . getEntityName ( ) ) ) sc = serializer . Architecture ( obj , ctx ) if createFiles : fName = obj . getEntityName ( ) + serializer . fileExtension fileMode = 'a' else : if hasattr ( obj , \"_hdlSources\" ) : for fn in obj . _hdlSources : if isinstance ( fn , str ) : shutil . copy2 ( fn , saveTo ) files . append ( fn ) continue else : sc = serializer . asHdl ( obj ) if sc : if createFiles : fp = os . path . join ( saveTo , fName ) files . append ( fp ) with open ( fp , fileMode ) as f : if fileMode == 'a' : f . write ( \"\\n\" ) f . write ( serializer . formatter ( sc ) ) else : codeBuff . append ( sc ) elif not createFiles : try : name = '\"%s\"' % obj . name except AttributeError : name = \"\" codeBuff . append ( serializer . comment ( \"Object of class %s, %s was not serialized as specified\" % ( obj . __class__ . __name__ , name ) ) ) if createFiles : return files else : return serializer . formatter ( \"\\n\" . join ( codeBuff ) )", "nl": "Convert unit to RTL using specified serializer"}}
{"translation": {"code": "def singleDriver ( self ) : # [TODO] no driver exception drv_cnt = len ( self . drivers ) if not drv_cnt : raise NoDriverErr ( self ) elif drv_cnt != 1 : raise MultipleDriversErr ( self ) return self . drivers [ 0 ]", "nl": "Returns a first driver if signal has only one driver ."}}
{"translation": {"code": "def _tryConnect ( src , unit , intfName ) : try : dst = getattr ( unit , intfName ) except AttributeError : return if not dst . _sig . drivers : connect ( src , dst )", "nl": "Try connect src to interface of specified name on unit . Ignore if interface is not present or if it already has driver ."}}
{"translation": {"code": "def propagateClkRst ( obj ) : clk = obj . clk rst = obj . rst for u in obj . _units : _tryConnect ( clk , u , 'clk' ) _tryConnect ( ~ rst , u , 'rst_n' ) _tryConnect ( rst , u , 'rst' )", "nl": "Propagate clk clock and reset rst signal to all subcomponents"}}
{"translation": {"code": "def convertBits ( self , sigOrVal , toType ) : if isinstance ( sigOrVal , Value ) : return convertBits__val ( self , sigOrVal , toType ) elif isinstance ( toType , HBool ) : if self . bit_length ( ) == 1 : v = 0 if sigOrVal . _dtype . negated else 1 return sigOrVal . _eq ( self . getValueCls ( ) . fromPy ( v , self ) ) elif isinstance ( toType , Bits ) : if self . bit_length ( ) == toType . bit_length ( ) : return sigOrVal . _convSign ( toType . signed ) elif toType == INT : return Operator . withRes ( AllOps . BitsToInt , [ sigOrVal ] , toType ) return default_auto_cast_fn ( self , sigOrVal , toType )", "nl": "Cast signed - unsigned to int or bool"}}
{"translation": {"code": "def _getIndexCascade ( self ) : try : # now I am result of the index  xxx[xx] <= source # get index op d = self . singleDriver ( ) try : op = d . operator except AttributeError : return if op == AllOps . INDEX : # get signal on which is index applied indexedOn = d . operands [ 0 ] if isinstance ( indexedOn , RtlSignalBase ) : # [TODO] multidimensional indexing return indexedOn , [ d . operands [ 1 ] ] else : raise Exception ( \"can not drive static value %r\" % indexedOn ) except ( MultipleDriversErr , NoDriverErr ) : pass", "nl": "Find out if this signal is something indexed"}}
{"translation": {"code": "def withRes ( opDef , operands , resT , outputs = [ ] ) : op = Operator ( opDef , operands ) out = RtlSignal ( getCtxFromOps ( operands ) , None , resT ) out . _const = arr_all ( op . operands , isConst ) out . drivers . append ( op ) out . origin = op op . result = out op . registerSignals ( outputs ) if out . _const : out . staticEval ( ) return out", "nl": "Create operator with result signal"}}
{"translation": {"code": "def _convSign ( self , signed ) : if isinstance ( self , Value ) : return self . _convSign__val ( signed ) else : if self . _dtype . signed == signed : return self t = copy ( self . _dtype ) t . signed = signed if signed is None : cnv = AllOps . BitsAsVec elif signed : cnv = AllOps . BitsAsSigned else : cnv = AllOps . BitsAsUnsigned return Operator . withRes ( cnv , [ self ] , t )", "nl": "Convert signum no bit manipulation just data are represented differently"}}
{"translation": {"code": "def simUnit ( self , synthesisedUnit : Unit , until : float , extraProcesses = [ ] ) : beforeSim = self . config . beforeSim if beforeSim is not None : beforeSim ( self , synthesisedUnit ) add_proc = self . add_process for p in extraProcesses : add_proc ( p ( self ) ) self . _initUnitSignals ( synthesisedUnit ) self . run ( until )", "nl": "Run simulation for Unit instance"}}
{"translation": {"code": "def simUnitVcd ( simModel , stimulFunctions , outputFile = sys . stdout , until = 100 * Time . ns ) : assert isinstance ( simModel , SimModel ) , \"Class of SimModel is required (got %r)\" % ( simModel ) if isinstance ( outputFile , str ) : d = os . path . dirname ( outputFile ) if d : os . makedirs ( d , exist_ok = True ) with open ( outputFile , 'w' ) as f : return _simUnitVcd ( simModel , stimulFunctions , f , until ) else : return _simUnitVcd ( simModel , stimulFunctions , outputFile , until )", "nl": "Syntax sugar If outputFile is string try to open it as file"}}
{"translation": {"code": "def beforeSim ( self , simulator , synthesisedUnit ) : vcd = self . vcdWriter vcd . date ( datetime . now ( ) ) vcd . timescale ( 1 ) self . vcdRegisterInterfaces ( synthesisedUnit , None ) self . vcdRegisterRemainingSignals ( synthesisedUnit ) vcd . enddefinitions ( )", "nl": "This method is called before first step of simulation ."}}
{"translation": {"code": "def logChange ( self , nowTime , sig , nextVal ) : try : self . vcdWriter . logChange ( nowTime , sig , nextVal ) except KeyError : # not every signal has to be registered pass", "nl": "This method is called for every value change of any signal ."}}
{"translation": {"code": "def read ( self , sig ) -> Value : try : v = sig . _val except AttributeError : v = sig . _sigInside . _val return v . clone ( )", "nl": "Read value from signal or interface"}}
{"translation": {"code": "def write ( self , val , sig : SimSignal ) -> None : # get target RtlSignal try : simSensProcs = sig . simSensProcs except AttributeError : sig = sig . _sigInside simSensProcs = sig . simSensProcs # type cast of input value t = sig . _dtype if isinstance ( val , Value ) : v = val . clone ( ) v = v . _auto_cast ( t ) else : v = t . fromPy ( val ) # can not update value in signal directly due singnal proxies sig . simUpdateVal ( self , lambda curentV : ( valueHasChanged ( curentV , v ) , v ) ) if not self . _applyValPlaned : if not ( simSensProcs or sig . simRisingSensProcs or sig . simFallingSensProcs ) : # signal value was changed but there are no sensitive processes # to it because of this _applyValues is never planed # and should be self . _scheduleApplyValues ( ) elif ( sig . _writeCallbacks or sig . _writeCallbacksToEn ) : # signal write did not caused any change on any other signal # but there are still simulation agets waiting on # updateComplete event self . _scheduleApplyValues ( )", "nl": "Write value to signal or interface ."}}
{"translation": {"code": "def _applyValues ( self ) -> Generator [ None , None , None ] : va = self . _valuesToApply self . _applyValPlaned = False # log if there are items to log lav = self . config . logApplyingValues if va and lav : lav ( self , va ) self . _valuesToApply = [ ] # apply values to signals, values can overwrite each other # but each signal should be driven by only one process and # it should resolve value collision addSp = self . _seqProcsToRun . append for s , vUpdater , isEventDependent , comesFrom in va : if isEventDependent : # now=0 and this was process initialization or async reg addSp ( comesFrom ) else : # regular combinational process s . simUpdateVal ( self , vUpdater ) self . _runCombProcesses ( ) # processes triggered from simUpdateVal can add new values if self . _valuesToApply and not self . _applyValPlaned : self . _scheduleApplyValues ( ) return yield", "nl": "Perform delta step by writing stacked values to signals"}}
{"translation": {"code": "def connectSig ( self , signal ) : if self . direction == DIRECTION . IN : if self . src is not None : raise HwtSyntaxError ( \"Port %s is already associated with %r\" % ( self . name , self . src ) ) self . src = signal signal . endpoints . append ( self ) elif self . direction == DIRECTION . OUT : if self . dst is not None : raise HwtSyntaxError ( \"Port %s is already associated with %r\" % ( self . name , self . dst ) ) self . dst = signal signal . drivers . append ( self ) else : raise NotImplementedError ( self ) signal . hidden = False signal . ctx . subUnits . add ( self . unit )", "nl": "Connect to port item on subunit"}}
{"translation": {"code": "def registerInternSig ( self , signal ) : if self . direction == DIRECTION . OUT : if self . src is not None : raise HwtSyntaxError ( \"Port %s is already associated with %s\" % ( self . name , str ( self . src ) ) ) self . src = signal elif self . direction == DIRECTION . IN : if self . dst is not None : raise HwtSyntaxError ( \"Port %s is already associated with %s\" % ( self . name , str ( self . dst ) ) ) self . dst = signal else : raise NotImplementedError ( self . direction )", "nl": "Connect internal signal to port item this connection is used by simulator and only output port items will be connected"}}
{"translation": {"code": "def vcdRegisterInterfaces ( self , obj : Union [ Interface , Unit ] , parent : Optional [ VcdVarWritingScope ] ) : if hasattr ( obj , \"_interfaces\" ) and obj . _interfaces : name = obj . _name parent_ = self . vcdWriter if parent is None else parent subScope = parent_ . varScope ( name ) self . _obj2scope [ obj ] = subScope with subScope : # register all subinterfaces for chIntf in obj . _interfaces : self . vcdRegisterInterfaces ( chIntf , subScope ) if isinstance ( obj , ( Unit , SimModel ) ) : # register interfaces from all subunits for u in obj . _units : self . vcdRegisterInterfaces ( u , subScope ) return subScope else : t = obj . _dtype if isinstance ( t , self . supported_type_classes ) : tName , width , formatter = vcdTypeInfoForHType ( t ) try : parent . addVar ( obj , getSignalName ( obj ) , tName , width , formatter ) except VarAlreadyRegistered : pass", "nl": "Register signals from interfaces for Interface or Unit instances"}}
{"translation": {"code": "def connectInternSig ( self ) : d = self . direction if d == DIRECTION . OUT : self . src . endpoints . append ( self ) elif d == DIRECTION . IN or d == DIRECTION . INOUT : self . dst . drivers . append ( self ) else : raise NotImplementedError ( d )", "nl": "connet signal from internal side of of this component to this port"}}
{"translation": {"code": "def autoAddAgents ( unit ) : proc = [ ] for intf in unit . _interfaces : if not intf . _isExtern : continue intf . _initSimAgent ( ) assert intf . _ag is not None , intf agents = [ intf . _ag , ] if intf . _direction == INTF_DIRECTION . MASTER : agProcs = list ( map ( lambda a : a . getMonitors ( ) , agents ) ) elif intf . _direction == INTF_DIRECTION . SLAVE : agProcs = list ( map ( lambda a : a . getDrivers ( ) , agents ) ) else : raise NotImplementedError ( \"intf._direction %r for %r\" % ( intf . _direction , intf ) ) for p in agProcs : proc . extend ( p ) return proc", "nl": "Walk all interfaces on unit and instantiate agent for every interface ."}}
{"translation": {"code": "def _reg ( self , name , dtype = BIT , defVal = None , clk = None , rst = None ) : if clk is None : clk = getClk ( self ) if defVal is None : # if no value is specified reset is not required rst = None else : rst = getRst ( self ) . _sig if isinstance ( dtype , HStruct ) : if defVal is not None : raise NotImplementedError ( ) container = dtype . fromPy ( None ) for f in dtype . fields : if f . name is not None : r = self . _reg ( \"%s_%s\" % ( name , f . name ) , f . dtype ) setattr ( container , f . name , r ) return container return self . _ctx . sig ( name , dtype = dtype , clk = clk . _sig , syncRst = rst , defVal = defVal )", "nl": "Create register in this unit"}}
{"translation": {"code": "def nameAvailabilityCheck ( obj , propName , prop ) : if getattr ( obj , propName , None ) is not None : raise IntfLvlConfErr ( \"%r already has property %s old:%s new:%s\" % ( obj , propName , repr ( getattr ( obj , propName ) ) , prop ) )", "nl": "Check if not redefining property on obj"}}
{"translation": {"code": "def _registerInterface ( self , iName , intf , isPrivate = False ) : nameAvailabilityCheck ( self , iName , intf ) assert intf . _parent is None intf . _parent = self intf . _name = iName intf . _ctx = self . _ctx if isPrivate : self . _private_interfaces . append ( intf ) intf . _isExtern = False else : self . _interfaces . append ( intf ) intf . _isExtern = True", "nl": "Register interface object on interface level object"}}
{"translation": {"code": "def _registerUnit ( self , uName , unit ) : nameAvailabilityCheck ( self , uName , unit ) assert unit . _parent is None unit . _parent = self unit . _name = uName self . _units . append ( unit )", "nl": "Register unit object on interface level object"}}
{"translation": {"code": "def _registerArray ( self , name , items ) : items . _parent = self items . _name = name for i , item in enumerate ( items ) : setattr ( self , \"%s_%d\" % ( name , i ) , item )", "nl": "Register array of items on interface level object"}}
{"translation": {"code": "def propagateClkRstn ( obj ) : clk = obj . clk rst_n = obj . rst_n for u in obj . _units : _tryConnect ( clk , u , 'clk' ) _tryConnect ( rst_n , u , 'rst_n' ) _tryConnect ( ~ rst_n , u , 'rst' )", "nl": "Propagate clk clock and negative reset rst_n signal to all subcomponents"}}
{"translation": {"code": "def Default ( self , * statements ) : assert self . parentStm is None self . rank += 1 self . default = [ ] self . _register_stements ( statements , self . default ) return self", "nl": "c - like default of switch statement"}}
{"translation": {"code": "def Case ( self , caseVal , * statements ) : assert self . parentStm is None caseVal = toHVal ( caseVal , self . switchOn . _dtype ) assert isinstance ( caseVal , Value ) , caseVal assert caseVal . _isFullVld ( ) , \"Cmp with invalid value\" assert caseVal not in self . _case_value_index , ( \"Switch statement already has case for value \" , caseVal ) self . rank += 1 case = [ ] self . _case_value_index [ caseVal ] = len ( self . cases ) self . cases . append ( ( caseVal , case ) ) cond = self . switchOn . _eq ( caseVal ) self . _inputs . append ( cond ) cond . endpoints . append ( self ) self . _register_stements ( statements , case ) return self", "nl": "c - like case of switch statement"}}
{"translation": {"code": "def In ( sigOrVal , iterable ) : res = None for i in iterable : i = toHVal ( i ) if res is None : res = sigOrVal . _eq ( i ) else : res = res | sigOrVal . _eq ( i ) assert res is not None , \"Parameter iterable is empty\" return res", "nl": "Hdl convertible in operator check if any of items in iterable equals sigOrVal"}}
{"translation": {"code": "def propagateClk ( obj ) : clk = obj . clk for u in obj . _units : _tryConnect ( clk , u , 'clk' )", "nl": "Propagate clk clock signal to all subcomponents"}}
{"translation": {"code": "def getBaseCond ( c ) : isNegated = False try : drivers = c . drivers except AttributeError : return ( c , isNegated ) if len ( drivers ) == 1 : d = list ( c . drivers ) [ 0 ] if isinstance ( d , Operator ) and d . operator == AllOps . NOT : c = d . operands [ 0 ] isNegated = True return ( c , isNegated )", "nl": "if is negated return original cond and negated flag"}}
{"translation": {"code": "def _addHdlProcToRun ( self , trigger : SimSignal , proc ) -> None : # first process in time has to plan executing of apply values on the # end of this time if not self . _applyValPlaned : # (apply on end of this time to minimalize process reevaluation) self . _scheduleApplyValues ( ) if isEvDependentOn ( trigger , proc ) : if self . now == 0 : return # pass event dependent on startup self . _seqProcsToRun . append ( proc ) else : self . _combProcsToRun . append ( proc )", "nl": "Add hdl process to execution queue"}}
{"translation": {"code": "def _conflictResolveStrategy ( self , newValue : set ) -> Tuple [ Callable [ [ Value ] , bool ] , bool ] : invalidate = False resLen = len ( newValue ) if resLen == 3 : # update for item in array val , indexes , isEvDependent = newValue return ( mkArrayUpdater ( val , indexes , invalidate ) , isEvDependent ) else : # update for simple signal val , isEvDependent = newValue return ( mkUpdater ( val , invalidate ) , isEvDependent )", "nl": "This functions resolves write conflicts for signal"}}
{"translation": {"code": "def removeUnconnectedSignals ( netlist ) : toDelete = set ( ) toSearch = netlist . signals while toSearch : _toSearch = set ( ) for sig in toSearch : if not sig . endpoints : try : if sig . _interface is not None : # skip interfaces before we want to check them, # they should not be optimized out from design continue except AttributeError : pass for e in sig . drivers : # drivers of this signal are useless rm them if isinstance ( e , Operator ) : inputs = e . operands if e . result is sig : e . result = None else : inputs = e . _inputs netlist . statements . discard ( e ) for op in inputs : if not isinstance ( op , Value ) : try : op . endpoints . remove ( e ) except KeyError : # this operator has 2x+ same operand continue _toSearch . add ( op ) toDelete . add ( sig ) if toDelete : for sig in toDelete : if sig . ctx == netlist : netlist . signals . remove ( sig ) _toSearch . discard ( sig ) toDelete = set ( ) toSearch = _toSearch", "nl": "If signal is not driving anything remove it"}}
{"translation": {"code": "def maxStmId ( proc ) : maxId = 0 for stm in proc . statements : maxId = max ( maxId , getMaxStmIdForStm ( stm ) ) return maxId", "nl": "get max statement id used for sorting of processes in architecture"}}
{"translation": {"code": "def getMaxStmIdForStm ( stm ) : maxId = 0 if isinstance ( stm , Assignment ) : return stm . _instId elif isinstance ( stm , WaitStm ) : return maxId else : for _stm in stm . _iter_stms ( ) : maxId = max ( maxId , getMaxStmIdForStm ( _stm ) ) return maxId", "nl": "Get maximum _instId from all assigments in statement"}}
{"translation": {"code": "def sensitivity ( proc : HWProcess , * sensitiveTo ) : for s in sensitiveTo : if isinstance ( s , tuple ) : sen , s = s if sen == SENSITIVITY . ANY : s . simSensProcs . add ( proc ) elif sen == SENSITIVITY . RISING : s . simRisingSensProcs . add ( proc ) elif sen == SENSITIVITY . FALLING : s . simFallingSensProcs . add ( proc ) else : raise AssertionError ( sen ) else : s . simSensProcs . add ( proc )", "nl": "register sensitivity for process"}}
{"translation": {"code": "def toSimModel ( unit , targetPlatform = DummyPlatform ( ) , dumpModelIn = None ) : sim_code = toRtl ( unit , targetPlatform = targetPlatform , saveTo = dumpModelIn , serializer = SimModelSerializer ) if dumpModelIn is not None : d = os . path . join ( os . getcwd ( ) , dumpModelIn ) dInPath = d in sys . path if not dInPath : sys . path . insert ( 0 , d ) if unit . _name in sys . modules : del sys . modules [ unit . _name ] simModule = importlib . import_module ( unit . _name ) if not dInPath : sys . path . remove ( d ) else : simModule = ModuleType ( 'simModule' ) # python supports only ~100 opened brackets # it exceded it throws MemoryError: s_push: parser stack overflow exec ( sim_code , simModule . __dict__ ) return simModule . __dict__ [ unit . _name ]", "nl": "Create a simulation model for unit"}}
{"translation": {"code": "def simPrepare ( unit : Unit , modelCls : Optional [ SimModel ] = None , targetPlatform = DummyPlatform ( ) , dumpModelIn : str = None , onAfterToRtl = None ) : if modelCls is None : modelCls = toSimModel ( unit , targetPlatform = targetPlatform , dumpModelIn = dumpModelIn ) else : # to instantiate hierarchy of unit toSimModel ( unit ) if onAfterToRtl : onAfterToRtl ( unit , modelCls ) reconnectUnitSignalsToModel ( unit , modelCls ) model = modelCls ( ) procs = autoAddAgents ( unit ) return unit , model , procs", "nl": "Create simulation model and connect it with interfaces of original unit and decorate it with agents"}}
{"translation": {"code": "def simEvalCond ( simulator , * conds ) : _cond = True _vld = True for v in conds : val = bool ( v . val ) fullVld = v . vldMask == 1 if fullVld : if not val : return False , True else : return False , False _cond = _cond and val _vld = _vld and fullVld return _cond , _vld", "nl": "Evaluate list of values as condition"}}
{"translation": {"code": "def reconnectUnitSignalsToModel ( synthesisedUnitOrIntf , modelCls ) : obj = synthesisedUnitOrIntf subInterfaces = obj . _interfaces if subInterfaces : for intf in subInterfaces : # proxies are destroyed on original interfaces and only proxies on # array items will remain reconnectUnitSignalsToModel ( intf , modelCls ) else : # reconnect signal from model s = synthesisedUnitOrIntf s . _sigInside = getattr ( modelCls , s . _sigInside . name )", "nl": "Reconnect model signals to unit to run simulation with simulation model but use original unit interfaces for communication"}}
{"translation": {"code": "def mkUpdater ( nextVal : Value , invalidate : bool ) : def updater ( currentVal ) : _nextVal = nextVal . clone ( ) if invalidate : _nextVal . vldMask = 0 return ( valueHasChanged ( currentVal , _nextVal ) , _nextVal ) return updater", "nl": "Create value updater for simulation"}}
{"translation": {"code": "def mkArrayUpdater ( nextItemVal : Value , indexes : Tuple [ Value ] , invalidate : bool ) : def updater ( currentVal ) : if len ( indexes ) > 1 : raise NotImplementedError ( \"[TODO] implement for more indexes\" ) _nextItemVal = nextItemVal . clone ( ) if invalidate : _nextItemVal . vldMask = 0 index = indexes [ 0 ] change = valueHasChanged ( currentVal . _getitem__val ( index ) , _nextItemVal ) currentVal . _setitem__val ( index , _nextItemVal ) return ( change , currentVal ) return updater", "nl": "Create value updater for simulation for value of array type"}}
{"translation": {"code": "def connectSimPort ( simUnit , subSimUnit , srcName , dstName , direction ) : if direction == DIRECTION . OUT : origPort = getattr ( subSimUnit , srcName ) newPort = getattr ( simUnit , dstName ) setattr ( subSimUnit , srcName , newPort ) else : origPort = getattr ( subSimUnit , dstName ) newPort = getattr ( simUnit , srcName ) setattr ( subSimUnit , dstName , newPort ) subSimUnit . _ctx . signals . remove ( origPort )", "nl": "Connect ports of simulation models by name"}}
{"translation": {"code": "def sensitivityByOp ( op ) : if op == AllOps . RISING_EDGE : return SENSITIVITY . RISING elif op == AllOps . FALLING_EDGE : return SENSITIVITY . FALLING else : raise TypeError ( )", "nl": "get sensitivity type for operator"}}
{"translation": {"code": "def groupedby ( collection , fn ) : d = { } for item in collection : k = fn ( item ) try : arr = d [ k ] except KeyError : arr = [ ] d [ k ] = arr arr . append ( item ) yield from d . items ( )", "nl": "same like itertools . groupby"}}
{"translation": {"code": "def isEvDependentOn ( sig , process ) -> bool : if sig is None : return False return process in sig . simFallingSensProcs or process in sig . simRisingSensProcs", "nl": "Check if hdl process has event depenency on signal"}}
{"translation": {"code": "def _runSeqProcesses ( self ) -> Generator [ None , None , None ] : updates = [ ] for proc in self . _seqProcsToRun : try : outContainer = self . _outputContainers [ proc ] except KeyError : # processes does not have to have outputs outContainer = None proc ( self , outContainer ) if outContainer is not None : updates . append ( outContainer ) self . _seqProcsToRun = UniqList ( ) self . _runSeqProcessesPlaned = False for cont in updates : for sigName , sig in cont . _all_signals : newVal = getattr ( cont , sigName ) if newVal is not None : v = self . _conflictResolveStrategy ( newVal ) updater , _ = v sig . simUpdateVal ( self , updater ) setattr ( cont , sigName , None ) return yield", "nl": "Delta step for event dependent processes"}}
{"translation": {"code": "def _scheduleApplyValues ( self ) -> None : assert not self . _applyValPlaned , self . now self . _add_process ( self . _applyValues ( ) , PRIORITY_APPLY_COMB ) self . _applyValPlaned = True if self . _runSeqProcessesPlaned : # if runSeqProcesses is already scheduled return assert not self . _seqProcsToRun and not self . _runSeqProcessesPlaned , self . now self . _add_process ( self . _runSeqProcesses ( ) , PRIORITY_APPLY_SEQ ) self . _runSeqProcessesPlaned = True", "nl": "Apply stashed values to signals"}}
{"translation": {"code": "def simBitsT ( width : int , signed : Union [ bool , None ] ) : k = ( width , signed ) try : return __simBitsTCache [ k ] except KeyError : t = SimBitsT ( width , signed ) __simBitsTCache [ k ] = t return t", "nl": "Construct SimBitsT with cache"}}
{"translation": {"code": "def _registerIntfInImpl ( self , iName , intf ) : self . _registerInterface ( iName , intf , isPrivate = True ) self . _loadInterface ( intf , False ) intf . _signalsForInterface ( self . _ctx )", "nl": "Register interface in implementation phase"}}
{"translation": {"code": "def ternaryOpsToIf ( statements ) : stms = [ ] for st in statements : if isinstance ( st , Assignment ) : try : if not isinstance ( st . src , RtlSignalBase ) : raise DoesNotContainsTernary ( ) d = st . src . singleDriver ( ) if not isinstance ( d , Operator ) or d . operator != AllOps . TERNARY : raise DoesNotContainsTernary ( ) else : ops = d . operands ifc = IfContainer ( ops [ 0 ] , [ Assignment ( ops [ 1 ] , st . dst ) ] , [ Assignment ( ops [ 2 ] , st . dst ) ] ) stms . append ( ifc ) continue except ( MultipleDriversErr , DoesNotContainsTernary ) : pass except NoDriverErr : assert ( hasattr ( st . src , \"_interface\" ) and st . src . _interface is not None ) or st . src . defVal . vldMask , st . src stms . append ( st ) return stms", "nl": "Convert all ternary operators to IfContainers"}}
{"translation": {"code": "def log2ceil ( x ) : if not isinstance ( x , ( int , float ) ) : x = int ( x ) if x == 0 or x == 1 : res = 1 else : res = math . ceil ( math . log2 ( x ) ) return hInt ( res )", "nl": "Returns no of bits required to store x - 1 for example x = 8 returns 3"}}
{"translation": {"code": "def isPow2 ( num ) -> bool : if not isinstance ( num , int ) : num = int ( num ) return num != 0 and ( ( num & ( num - 1 ) ) == 0 )", "nl": "Check if number or constant is power of two"}}
{"translation": {"code": "def StaticForEach ( parentUnit , items , bodyFn , name = \"\" ) : items = list ( items ) itemsCnt = len ( items ) if itemsCnt == 0 : # if there are no items there is nothing to generate return [ ] elif itemsCnt == 1 : # if there is only one item do not generate counter logic generate return bodyFn ( items [ 0 ] , 0 ) else : # if there is multiple items we have to generate counter logic index = parentUnit . _reg ( name + \"for_index\" , Bits ( log2ceil ( itemsCnt + 1 ) , signed = False ) , defVal = 0 ) ackSig = parentUnit . _sig ( name + \"for_ack\" ) statementLists = [ ] for i , ( statementList , ack ) in [ ( i , bodyFn ( item , i ) ) for i , item in enumerate ( items ) ] : statementLists . append ( statementList + [ ( ackSig ( ack ) ) , ] ) If ( ackSig , If ( index . _eq ( itemsCnt - 1 ) , index ( 0 ) ) . Else ( index ( index + 1 ) ) ) return Switch ( index ) . addCases ( enumerate ( statementLists ) ) . Default ( bodyFn ( items [ 0 ] , 0 ) [ 0 ] , ackSig ( True ) )", "nl": "Generate for loop for static items"}}
{"translation": {"code": "def doWrite ( self , sim , data ) : sim . write ( data , self . intf . data )", "nl": "write data to interface"}}
{"translation": {"code": "def flatten ( iterables , level = inf ) : if level >= 0 and isinstance ( iterables , ( list , tuple , GeneratorType , map , zip ) ) : level -= 1 for i in iterables : yield from flatten ( i , level = level ) else : yield iterables", "nl": "Flatten nested lists tuples generators and maps"}}
{"translation": {"code": "def _set_parent_stm ( self , parentStm : \"HdlStatement\" ) : was_top = self . parentStm is None self . parentStm = parentStm if not self . _now_is_event_dependent and parentStm . _now_is_event_dependent : self . _on_parent_event_dependent ( ) topStatement = parentStm while topStatement . parentStm is not None : topStatement = topStatement . parentStm parent_out_add = topStatement . _outputs . append parent_in_add = topStatement . _inputs . append if was_top : for inp in self . _inputs : inp . endpoints . discard ( self ) inp . endpoints . append ( topStatement ) parent_in_add ( inp ) for outp in self . _outputs : outp . drivers . discard ( self ) outp . drivers . append ( topStatement ) parent_out_add ( outp ) ctx = self . _get_rtl_context ( ) ctx . statements . discard ( self ) parentStm . rank += self . rank", "nl": "Assign parent statement and propagate dependency flags if necessary"}}
{"translation": {"code": "def onWriteReq ( self , sim , addr , data ) : self . requests . append ( ( WRITE , addr , data ) )", "nl": "on writeReqRecieved in monitor mode"}}
{"translation": {"code": "def _bit_length ( self ) : try : interfaces = self . _interfaces except AttributeError : interfaces = None if interfaces is None : # not loaded interface _intf = self . _clone ( ) _intf . _loadDeclarations ( ) interfaces = _intf . _interfaces if interfaces : w = 0 for i in interfaces : w += i . _bit_length ( ) return w else : return self . _dtype . bit_length ( )", "nl": "Sum of all width of interfaces in this interface"}}
{"translation": {"code": "def _loadFromHStruct ( self , dtype : HdlType , bitAddr : int ) : for f in dtype . fields : t = f . dtype origin = f isPadding = f . name is None if isPadding : width = t . bit_length ( ) bitAddr += width else : fi = TransTmpl ( t , bitAddr , parent = self , origin = origin ) self . children . append ( fi ) bitAddr = fi . bitAddrEnd return bitAddr", "nl": "Parse HStruct type to this transaction template instance"}}
{"translation": {"code": "def _loadFromArray ( self , dtype : HdlType , bitAddr : int ) -> int : self . itemCnt = evalParam ( dtype . size ) . val self . children = TransTmpl ( dtype . elmType , 0 , parent = self , origin = self . origin ) return bitAddr + self . itemCnt * self . children . bitAddrEnd", "nl": "Parse HArray type to this transaction template instance"}}
{"translation": {"code": "def getItemWidth ( self ) -> int : if not isinstance ( self . dtype , HArray ) : raise TypeError ( ) return ( self . bitAddrEnd - self . bitAddr ) // self . itemCnt", "nl": "Only for transactions derived from HArray"}}
{"translation": {"code": "def walkWords ( self , showPadding : bool = False ) : wIndex = 0 lastEnd = self . startBitAddr parts = [ ] for p in self . parts : end = p . startOfPart if showPadding and end != lastEnd : # insert padding while end != lastEnd : assert end >= lastEnd , ( end , lastEnd ) endOfWord = ceil ( ( lastEnd + 1 ) / self . wordWidth ) * self . wordWidth endOfPadding = min ( endOfWord , end ) _p = TransPart ( self , None , lastEnd , endOfPadding , 0 ) parts . append ( _p ) if endOfPadding >= endOfWord : yield ( wIndex , parts ) wIndex += 1 parts = [ ] lastEnd = endOfPadding if self . _wordIndx ( lastEnd ) != self . _wordIndx ( p . startOfPart ) : yield ( wIndex , parts ) wIndex += 1 parts = [ ] lastEnd = p . endOfPart parts . append ( p ) lastEnd = p . endOfPart if lastEnd % self . wordWidth == 0 : yield ( wIndex , parts ) wIndex += 1 parts = [ ] if showPadding and ( parts or lastEnd != self . endBitAddr or lastEnd % self . wordWidth != 0 ) : # align end to end of last word end = ceil ( self . endBitAddr / self . wordWidth ) * self . wordWidth while end != lastEnd : assert end >= lastEnd , ( end , lastEnd ) endOfWord = ( ( lastEnd // self . wordWidth ) + 1 ) * self . wordWidth endOfPadding = min ( endOfWord , end ) _p = TransPart ( self , None , lastEnd , endOfPadding , 0 ) _p . parent = self parts . append ( _p ) if endOfPadding >= endOfWord : yield ( wIndex , parts ) wIndex += 1 parts = [ ] lastEnd = endOfPadding if parts : # in the case end of frame is not aligned to end of word yield ( wIndex , parts )", "nl": "Walk enumerated words in this frame"}}
{"translation": {"code": "def framesFromTransTmpl ( transaction : 'TransTmpl' , wordWidth : int , maxFrameLen : Union [ int , float ] = inf , maxPaddingWords : Union [ int , float ] = inf , trimPaddingWordsOnStart : bool = False , trimPaddingWordsOnEnd : bool = False ) -> Generator [ 'FrameTmpl' , None , None ] : isFirstInFrame = True partsPending = False startOfThisFrame = 0 assert maxFrameLen > 0 assert maxPaddingWords >= 0 if maxPaddingWords < inf : assert trimPaddingWordsOnStart or trimPaddingWordsOnEnd , \"Padding has to be cut off somewhere\" it = TransTmplWordIterator ( wordWidth ) lastWordI = 0 endOfThisFrame = maxFrameLen parts = [ ] for wordI , word in it . groupByWordIndex ( transaction , 0 ) : if wordI * wordWidth >= endOfThisFrame : # now in first+ word behind the frame # cut off padding at end of frame paddingWords = wordI - lastWordI if trimPaddingWordsOnEnd and paddingWords > maxPaddingWords : # cut off padding and align end of frame to word _endOfThisFrame = ( lastWordI + 1 ) * wordWidth else : _endOfThisFrame = wordI * wordWidth yield FrameTmpl ( transaction , wordWidth , startOfThisFrame , _endOfThisFrame , parts ) # prepare for start of new frame parts = [ ] isFirstInFrame = True partsPending = False # start on new word startOfThisFrame = _endOfThisFrame endOfThisFrame = startOfThisFrame + maxFrameLen lastWordI = wordI # check if padding at potential end of frame can be cut off if ( not isFirstInFrame and trimPaddingWordsOnEnd and wordI - lastWordI > 1 ) : # there is too much continual padding, # cut it out and start new frame _endOfThisFrame = ( lastWordI + 1 ) * wordWidth yield FrameTmpl ( transaction , wordWidth , startOfThisFrame , _endOfThisFrame , parts ) # prepare for start of new frame parts = [ ] isFirstInFrame = True partsPending = False # start on new word startOfThisFrame = _endOfThisFrame endOfThisFrame = startOfThisFrame + maxFrameLen lastWordI = wordI - 1 if isFirstInFrame : partsPending = True isFirstInFrame = False # cut off padding at start of frame paddingWords = wordI - lastWordI if trimPaddingWordsOnStart and paddingWords > maxPaddingWords : startOfThisFrame += paddingWords * wordWidth endOfThisFrame = startOfThisFrame + maxFrameLen # resolve end of this part parts . extend ( word ) lastWordI = wordI # reminder in \"parts\" after last iteration endOfThisFrame = transaction . bitAddrEnd withPadding = not ( trimPaddingWordsOnEnd or trimPaddingWordsOnStart ) if partsPending or ( withPadding and endOfThisFrame != startOfThisFrame ) : # cut off padding at end of frame endOfLastWord = ( lastWordI + 1 ) * wordWidth if endOfThisFrame < endOfLastWord : endOfThisFrame = endOfLastWord else : paddingWords = it . fullWordCnt ( endOfLastWord , endOfThisFrame ) if trimPaddingWordsOnEnd and paddingWords > maxPaddingWords : endOfThisFrame -= paddingWords * wordWidth # align end of frame to word endOfThisFrame = min ( startOfThisFrame + maxFrameLen , endOfThisFrame ) yield FrameTmpl ( transaction , wordWidth , startOfThisFrame , endOfThisFrame , parts ) parts = [ ] startOfThisFrame = endOfThisFrame # final padding on the end while withPadding and startOfThisFrame < transaction . bitAddrEnd : endOfThisFrame = min ( startOfThisFrame + maxFrameLen , transaction . bitAddrEnd ) yield FrameTmpl ( transaction , wordWidth , startOfThisFrame , endOfThisFrame , [ ] ) startOfThisFrame = endOfThisFrame", "nl": "Convert transaction template into FrameTmpls"}}
{"translation": {"code": "def packData ( self , data ) : typeOfWord = simBitsT ( self . wordWidth , None ) fieldToVal = self . _fieldToTPart if fieldToVal is None : fieldToVal = self . _fieldToTPart = self . fieldToDataDict ( self . origin . dtype , data , { } ) for _ , transParts in self . walkWords ( showPadding = True ) : actualVldMask = 0 actualVal = 0 for tPart in transParts : high , low = tPart . getBusWordBitRange ( ) fhigh , flow = tPart . getFieldBitRange ( ) if not tPart . isPadding : val = fieldToVal . get ( tPart . tmpl . origin , None ) else : val = None if val is None : newBits = 0 vld = 0 else : newBits = selectBitRange ( val , flow , fhigh - flow ) vld = mask ( high - low ) << low actualVal = setBitRange ( actualVal , low , high - low , newBits ) actualVldMask = setBitRange ( actualVal , low , high - low , vld ) yield typeOfWord . getValueCls ( ) ( actualVal , typeOfWord , actualVldMask , - 1 )", "nl": "Pack data into list of BitsVal of specified dataWidth"}}
{"translation": {"code": "def walkFlatten ( self , offset : int = 0 , shouldEnterFn = _default_shouldEnterFn , otherObjItCtx : ObjIteratorCtx = _DummyIteratorCtx ( ) ) -> Generator [ Union [ Tuple [ Tuple [ int , int ] , 'TransTmpl' ] , 'OneOfTransaction' ] , None , None ] : t = self . dtype base = self . bitAddr + offset end = self . bitAddrEnd + offset shouldEnter , shouldYield = shouldEnterFn ( self ) if shouldYield : yield ( ( base , end ) , self ) if shouldEnter : if isinstance ( t , Bits ) : pass elif isinstance ( t , HStruct ) : for ch in self . children : with otherObjItCtx ( ch . origin . name ) : yield from ch . walkFlatten ( offset , shouldEnterFn , otherObjItCtx ) elif isinstance ( t , HArray ) : itemSize = ( self . bitAddrEnd - self . bitAddr ) // self . itemCnt for i in range ( self . itemCnt ) : with otherObjItCtx ( i ) : yield from self . children . walkFlatten ( base + i * itemSize , shouldEnterFn , otherObjItCtx ) elif isinstance ( t , HUnion ) : yield OneOfTransaction ( self , offset , shouldEnterFn , self . children ) elif isinstance ( t , HStream ) : assert len ( self . children ) == 1 yield StreamTransaction ( self , offset , shouldEnterFn , self . children [ 0 ] ) else : raise TypeError ( t )", "nl": "Walk fields in instance of TransTmpl"}}
{"translation": {"code": "def getIndent ( indentNum ) : try : return _indentCache [ indentNum ] except KeyError : i = \"\" . join ( [ _indent for _ in range ( indentNum ) ] ) _indentCache [ indentNum ] = i return i", "nl": "Cached indent getter function"}}
{"translation": {"code": "def pprintInterface ( intf , prefix = \"\" , indent = 0 , file = sys . stdout ) : try : s = intf . _sig except AttributeError : s = \"\" if s is not \"\" : s = \" \" + repr ( s ) file . write ( \"\" . join ( [ getIndent ( indent ) , prefix , repr ( intf . _getFullName ( ) ) , s ] ) ) file . write ( \"\\n\" ) if isinstance ( intf , HObjList ) : for i , p in enumerate ( intf ) : # interfaces have already name of this array and index in it's name pprintInterface ( p , prefix = prefix , indent = indent + 1 , file = file ) else : for i in intf . _interfaces : pprintInterface ( i , indent = indent + 1 , file = file )", "nl": "Pretty print interface"}}
{"translation": {"code": "def signFix ( val , width ) : if val > 0 : msb = 1 << ( width - 1 ) if val & msb : val -= mask ( width ) + 1 return val", "nl": "Convert negative int to positive int which has same bits set"}}
{"translation": {"code": "def getConstName ( self , val ) : try : return self . _cache [ val ] except KeyError : if isinstance ( val . val , int ) : name = \"const_%d_\" % val . val else : name = \"const_\" c = self . nameCheckFn ( name , val ) self . _cache [ val ] = c return c", "nl": "Get constant name for value name of constant is reused if same value was used before"}}
{"translation": {"code": "def walkFlattenFields ( sigOrVal , skipPadding = True ) : t = sigOrVal . _dtype if isinstance ( t , Bits ) : yield sigOrVal elif isinstance ( t , HUnion ) : yield from walkFlattenFields ( sigOrVal . _val , skipPadding = skipPadding ) elif isinstance ( t , HStruct ) : for f in t . fields : isPadding = f . name is None if not isPadding or not skipPadding : if isPadding : v = f . dtype . fromPy ( None ) else : v = getattr ( sigOrVal , f . name ) yield from walkFlattenFields ( v ) elif isinstance ( t , HArray ) : for item in sigOrVal : yield from walkFlattenFields ( item ) else : raise NotImplementedError ( t )", "nl": "Walk all simple values in HStruct or HArray"}}
{"translation": {"code": "def HStruct_unpack ( structT , data , getDataFn = None , dataWidth = None ) : if getDataFn is None : assert dataWidth is not None def _getDataFn ( x ) : return toHVal ( x ) . _auto_cast ( Bits ( dataWidth ) ) getDataFn = _getDataFn val = structT . fromPy ( None ) fData = iter ( data ) # actual is storage variable for items from frameData actualOffset = 0 actual = None for v in walkFlattenFields ( val , skipPadding = False ) : # walk flatten fields and take values from fData and parse them to # field required = v . _dtype . bit_length ( ) if actual is None : actualOffset = 0 try : actual = getDataFn ( next ( fData ) ) except StopIteration : raise Exception ( \"Input data too short\" ) if dataWidth is None : dataWidth = actual . _dtype . bit_length ( ) actuallyHave = dataWidth else : actuallyHave = actual . _dtype . bit_length ( ) - actualOffset while actuallyHave < required : # collect data for this field try : d = getDataFn ( next ( fData ) ) except StopIteration : raise Exception ( \"Input data too short\" ) actual = d . _concat ( actual ) actuallyHave += dataWidth if actuallyHave >= required : # parse value of actual to field # skip padding _v = actual [ ( required + actualOffset ) : actualOffset ] _v = _v . _auto_cast ( v . _dtype ) v . val = _v . val v . vldMask = _v . vldMask v . updateTime = _v . updateTime # update slice out what was taken actuallyHave -= required actualOffset += required if actuallyHave == 0 : actual = None if actual is not None : assert actual . _dtype . bit_length ( ) - actualOffset < dataWidth , \"It should be just a padding at the end of frame\" return val", "nl": "opposite of packAxiSFrame"}}
{"translation": {"code": "def slice_to_SLICE ( sliceVals , width ) : if sliceVals . step is not None : raise NotImplementedError ( ) start = sliceVals . start stop = sliceVals . stop if sliceVals . start is None : start = INT . fromPy ( width ) else : start = toHVal ( sliceVals . start ) if sliceVals . stop is None : stop = INT . fromPy ( 0 ) else : stop = toHVal ( sliceVals . stop ) startIsVal = isinstance ( start , Value ) stopIsVal = isinstance ( stop , Value ) indexesAreValues = startIsVal and stopIsVal if indexesAreValues : updateTime = max ( start . updateTime , stop . updateTime ) else : updateTime = - 1 return Slice . getValueCls ( ) ( ( start , stop ) , SLICE , 1 , updateTime )", "nl": "convert python slice to value of SLICE hdl type"}}
{"translation": {"code": "def withIndent ( self , indent = 1 ) : ctx = copy ( self ) ctx . indent += indent return ctx", "nl": "Create copy of this context with increased indent"}}
{"translation": {"code": "def getBaseNameScope ( cls ) : s = NameScope ( False ) s . setLevel ( 1 ) s [ 0 ] . update ( cls . _keywords_dict ) return s", "nl": "Get root of name space"}}
{"translation": {"code": "def serializationDecision ( cls , obj , serializedClasses , serializedConfiguredUnits ) : isDeclaration = isinstance ( obj , Entity ) isDefinition = isinstance ( obj , Architecture ) if isDeclaration : unit = obj . origin elif isDefinition : unit = obj . entity . origin else : return True assert isinstance ( unit , Unit ) sd = unit . _serializeDecision if sd is None : return True else : prevPriv = serializedClasses . get ( unit . __class__ , None ) seriazlize , nextPriv = sd ( unit , obj , isDeclaration , prevPriv ) serializedClasses [ unit . __class__ ] = nextPriv return seriazlize", "nl": "Decide if this unit should be serialized or not eventually fix name to fit same already serialized unit"}}
{"translation": {"code": "def HdlType ( cls , typ : HdlType , ctx : SerializerCtx , declaration = False ) : if isinstance ( typ , Bits ) : sFn = cls . HdlType_bits elif isinstance ( typ , HEnum ) : sFn = cls . HdlType_enum elif isinstance ( typ , HArray ) : sFn = cls . HdlType_array elif isinstance ( typ , Integer ) : sFn = cls . HdlType_int elif isinstance ( typ , HBool ) : sFn = cls . HdlType_bool else : raise NotImplementedError ( \"type declaration is not implemented\" \" for type %s\" % ( typ . name ) ) return sFn ( typ , ctx , declaration = declaration )", "nl": "Serialize HdlType instance"}}
{"translation": {"code": "def HWProcess ( cls , proc , ctx ) : body = proc . statements childCtx = ctx . withIndent ( ) statemets = [ cls . asHdl ( s , childCtx ) for s in body ] proc . name = ctx . scope . checkedName ( proc . name , proc ) return cls . methodTmpl . render ( indent = getIndent ( ctx . indent ) , name = proc . name , statements = statemets )", "nl": "Serialize HWProcess instance"}}
{"translation": {"code": "def getInternSig ( self ) : d = self . direction if d == DIRECTION . IN : return self . dst elif d == DIRECTION . OUT : return self . src else : raise NotImplementedError ( d )", "nl": "return signal inside unit which has this port"}}
{"translation": {"code": "def HWProcess ( cls , proc , ctx ) : body = proc . statements extraVars = [ ] extraVarsSerialized = [ ] hasToBeVhdlProcess = arr_any ( body , lambda x : isinstance ( x , ( IfContainer , SwitchContainer , WhileContainer , WaitStm ) ) ) sensitivityList = sorted ( map ( lambda s : cls . sensitivityListItem ( s , ctx ) , proc . sensitivityList ) ) if hasToBeVhdlProcess : childCtx = ctx . withIndent ( ) else : childCtx = copy ( ctx ) def createTmpVarFn ( suggestedName , dtype ) : s = RtlSignal ( None , None , dtype , virtualOnly = True ) s . name = ctx . scope . checkedName ( suggestedName , s ) s . hidden = False serializedS = cls . SignalItem ( s , childCtx , declaration = True ) extraVars . append ( s ) extraVarsSerialized . append ( serializedS ) return s childCtx . createTmpVarFn = createTmpVarFn statemets = [ cls . asHdl ( s , childCtx ) for s in body ] proc . name = ctx . scope . checkedName ( proc . name , proc ) extraVarsInit = [ ] for s in extraVars : if isinstance ( s . defVal , RtlSignalBase ) or s . defVal . vldMask : a = Assignment ( s . defVal , s , virtualOnly = True ) extraVarsInit . append ( cls . Assignment ( a , childCtx ) ) else : assert s . drivers , s for d in s . drivers : extraVarsInit . append ( cls . asHdl ( d , childCtx ) ) _hasToBeVhdlProcess = hasToBeVhdlProcess hasToBeVhdlProcess = extraVars or hasToBeVhdlProcess if hasToBeVhdlProcess and not _hasToBeVhdlProcess : # add indent because we did not added it before because we did not # know t oneIndent = getIndent ( 1 ) statemets = list ( map ( lambda x : oneIndent + x , statemets ) ) return cls . processTmpl . render ( indent = getIndent ( ctx . indent ) , name = proc . name , hasToBeVhdlProcess = hasToBeVhdlProcess , extraVars = extraVarsSerialized , sensitivityList = \", \" . join ( sensitivityList ) , statements = extraVarsInit + statemets )", "nl": "Serialize HWProcess objects as VHDL"}}
{"translation": {"code": "def fromPy ( self , v , vldMask = None ) : return self . getValueCls ( ) . fromPy ( v , self , vldMask = vldMask )", "nl": "Construct value of this type . Delegated on value class for this type"}}
{"translation": {"code": "def IfContainer ( cls , ifc : IfContainer , ctx : SerializerCtx ) : childCtx = ctx . withIndent ( ) def asHdl ( statements ) : return [ cls . asHdl ( s , childCtx ) for s in statements ] try : cond = cls . condAsHdl ( ifc . cond , True , ctx ) except UnsupportedEventOpErr as e : cond = None if cond is None : assert not ifc . elIfs assert not ifc . ifFalse stmBuff = [ cls . asHdl ( s , ctx ) for s in ifc . ifTrue ] return \"\\n\" . join ( stmBuff ) elIfs = [ ] ifTrue = ifc . ifTrue ifFalse = ifc . ifFalse if ifFalse is None : ifFalse = [ ] for c , statements in ifc . elIfs : try : elIfs . append ( ( cls . condAsHdl ( c , True , ctx ) , asHdl ( statements ) ) ) except UnsupportedEventOpErr as e : if len ( ifc . elIfs ) == 1 and not ifFalse : # register expression is in valid format and this # is just register with asynchronous reset or etc... ifFalse = statements else : raise e return cls . ifTmpl . render ( indent = getIndent ( ctx . indent ) , cond = cond , ifTrue = asHdl ( ifTrue ) , elIfs = elIfs , ifFalse = asHdl ( ifFalse ) )", "nl": "Srialize IfContainer instance"}}
{"translation": {"code": "def hardcodeRomIntoProcess ( cls , rom ) : processes = [ ] signals = [ ] for e in rom . endpoints : assert isinstance ( e , Operator ) and e . operator == AllOps . INDEX , e me , index = e . operands assert me is rom # construct output of the rom romValSig = rom . ctx . sig ( rom . name , dtype = e . result . _dtype ) signals . append ( romValSig ) romValSig . hidden = False # construct process which will represent content of the rom cases = [ ( toHVal ( i ) , [ romValSig ( v ) , ] ) for i , v in enumerate ( rom . defVal . val ) ] statements = [ SwitchContainer ( index , cases ) , ] for ( _ , ( stm , ) ) in cases : stm . parentStm = statements [ 0 ] p = HWProcess ( rom . name , statements , { index , } , { index , } , { romValSig , } ) processes . append ( p ) # override usage of original index operator on rom # to use signal generated from this process def replaceOrigRomIndexExpr ( x ) : if x is e . result : return romValSig else : return x for _e in e . result . endpoints : _e . operands = tuple ( map ( replaceOrigRomIndexExpr , _e . operands ) ) e . result = romValSig return processes , signals", "nl": "Due to verilog restrictions it is not posible to use array constants and rom memories has to be hardcoded as process"}}
{"translation": {"code": "def packIntf ( intf , masterDirEqTo = DIRECTION . OUT , exclude = None ) : if not intf . _interfaces : if intf . _masterDir == masterDirEqTo : return intf . _sig return None res = None for i in intf . _interfaces : if exclude is not None and i in exclude : continue if i . _interfaces : if i . _masterDir == DIRECTION . IN : d = DIRECTION . opposite ( masterDirEqTo ) else : d = masterDirEqTo s = i . _pack ( d , exclude = exclude ) else : if i . _masterDir == masterDirEqTo : s = i . _sig else : s = None if s is not None : if res is None : res = s else : res = res . _concat ( s ) return res", "nl": "Concatenate all signals to one big signal recursively"}}
{"translation": {"code": "def connectPacked ( srcPacked , dstInterface , exclude = None ) : offset = 0 connections = [ ] for i in reversed ( list ( walkPhysInterfaces ( dstInterface ) ) ) : if exclude is not None and i in exclude : continue sig = i . _sig t = sig . _dtype if t == BIT : s = srcPacked [ offset ] offset += 1 else : w = t . bit_length ( ) s = srcPacked [ ( w + offset ) : offset ] offset += w connections . append ( sig ( s ) ) return connections", "nl": "Connect 1D vector signal to this structuralized interface"}}
{"translation": {"code": "def _getAssociatedClk ( self ) : a = self . _associatedClk if a is not None : return a p = self . _parent assert p is not None if isinstance ( p , UnitBase ) : return getClk ( p ) else : return p . _getAssociatedClk ( )", "nl": "If interface has associated clk return it otherwise try to find clk on parent recursively"}}
{"translation": {"code": "def _runCombProcesses ( self ) -> None : for proc in self . _combProcsToRun : cont = self . _outputContainers [ proc ] proc ( self , cont ) for sigName , sig in cont . _all_signals : newVal = getattr ( cont , sigName ) if newVal is not None : res = self . _conflictResolveStrategy ( newVal ) # prepare update updater , isEvDependent = res self . _valuesToApply . append ( ( sig , updater , isEvDependent , proc ) ) setattr ( cont , sigName , None ) # else value is latched self . _combProcsToRun = UniqList ( )", "nl": "Delta step for combinational processes"}}
{"translation": {"code": "def HTypeFromIntfMap ( interfaceMap ) : structFields = [ ] for m in interfaceMap : f = HTypeFromIntfMapItem ( m ) structFields . append ( f ) return HStruct ( * structFields )", "nl": "Generate flattened register map for HStruct"}}
{"translation": {"code": "def reduceProcesses ( processes ) : # sort to make order of merging same deterministic processes . sort ( key = lambda x : ( x . name , maxStmId ( x ) ) , reverse = True ) # now try to reduce processes with nearly same structure of statements into one # to minimize number of processes for _ , procs in groupedby ( processes , lambda p : p . rank ) : for iA , pA in enumerate ( procs ) : if pA is None : continue for iB , pB in enumerate ( islice ( procs , iA + 1 , None ) ) : if pB is None : continue try : pA = tryToMerge ( pA , pB ) except IncompatibleStructure : continue procs [ iA + 1 + iB ] = None # procs[iA] = pA for p in procs : if p is not None : yield p", "nl": "Try to merge processes as much is possible"}}
{"translation": {"code": "def tryToMerge ( procA : HWProcess , procB : HWProcess ) : if ( checkIfIsTooSimple ( procA ) or checkIfIsTooSimple ( procB ) or areSetsIntersets ( procA . outputs , procB . sensitivityList ) or areSetsIntersets ( procB . outputs , procA . sensitivityList ) or not HdlStatement . _is_mergable_statement_list ( procA . statements , procB . statements ) ) : raise IncompatibleStructure ( ) procA . statements = HdlStatement . _merge_statement_lists ( procA . statements , procB . statements ) procA . outputs . extend ( procB . outputs ) procA . inputs . extend ( procB . inputs ) procA . sensitivityList . extend ( procB . sensitivityList ) return procA", "nl": "Try merge procB into procA"}}
{"translation": {"code": "def checkIfIsTooSimple ( proc ) : try : a , = proc . statements if isinstance ( a , Assignment ) : return True except ValueError : pass return False", "nl": "check if process is just unconditional assignments and it is useless to merge them"}}
{"translation": {"code": "def tryReduceXor ( sig , val ) : m = sig . _dtype . all_mask ( ) if not val . vldMask : return val if val . _isFullVld ( ) : v = val . val if v == m : return ~ sig elif v == 0 : return sig", "nl": "Return sig and val reduced by ^ operator or None if it is not possible to statically reduce expression"}}
{"translation": {"code": "def tryReduceAnd ( sig , val ) : m = sig . _dtype . all_mask ( ) if val . _isFullVld ( ) : v = val . val if v == m : return sig elif v == 0 : return val", "nl": "Return sig and val reduced by & operator or None if it is not possible to statically reduce expression"}}
{"translation": {"code": "def _serializeParamsUniq_eval ( parentUnit , obj , isDeclaration , priv ) : params = paramsToValTuple ( parentUnit ) if priv is None : priv = { } if isDeclaration : try : prevUnit = priv [ params ] except KeyError : priv [ params ] = parentUnit return True , priv prepareEntity ( obj , prevUnit . _entity . name , prevUnit ) return False , priv return priv [ params ] is parentUnit , priv", "nl": "Decide to serialize only objs with uniq parameters and class"}}
{"translation": {"code": "def _serializeOnce_eval ( parentUnit , obj , isDeclaration , priv ) : clsName = parentUnit . __class__ . __name__ if isDeclaration : obj . name = clsName if priv is None : priv = parentUnit elif isDeclaration : # prepare entity which will not be serialized prepareEntity ( obj , clsName , parentUnit ) serialize = priv is parentUnit return serialize , priv", "nl": "Decide to serialize only first obj of it s class"}}
{"translation": {"code": "def _serializeExclude_eval ( parentUnit , obj , isDeclaration , priv ) : if isDeclaration : # prepare entity which will not be serialized prepareEntity ( obj , parentUnit . __class__ . __name__ , priv ) if priv is None : priv = parentUnit return False , priv", "nl": "Always decide not to serialize obj"}}
{"translation": {"code": "def sll ( sig , howMany ) -> RtlSignalBase : width = sig . _dtype . bit_length ( ) return sig [ ( width - howMany ) : ] . _concat ( vec ( 0 , howMany ) )", "nl": "Logical shift left"}}
{"translation": {"code": "def reinterpret_cast ( self , sigOrVal , toType ) : try : return self . auto_cast ( sigOrVal , toType ) except TypeConversionErr : pass try : r = self . _reinterpret_cast_fn except AttributeError : r = self . get_reinterpret_cast_fn ( ) self . _reinterpret_cast_fn = r return r ( self , sigOrVal , toType )", "nl": "Cast value or signal of this type to another type of same size ."}}
{"translation": {"code": "def reinterpret_bits_to_hstruct ( sigOrVal , hStructT ) : container = hStructT . fromPy ( None ) offset = 0 for f in hStructT . fields : t = f . dtype width = t . bit_length ( ) if f . name is not None : s = sigOrVal [ ( width + offset ) : offset ] s = s . _reinterpret_cast ( t ) setattr ( container , f . name , s ) offset += width return container", "nl": "Reinterpret signal of type Bits to signal of type HStruct"}}
{"translation": {"code": "def reinterptet_harray_to_bits ( typeFrom , sigOrVal , bitsT ) : size = int ( typeFrom . size ) widthOfElm = typeFrom . elmType . bit_length ( ) w = bitsT . bit_length ( ) if size * widthOfElm != w : raise TypeConversionErr ( \"Size of types is different\" , size * widthOfElm , w ) partT = Bits ( widthOfElm ) parts = [ p . _reinterpret_cast ( partT ) for p in sigOrVal ] return Concat ( * reversed ( parts ) ) . _reinterpret_cast ( bitsT )", "nl": "Cast HArray signal or value to signal or value of type Bits"}}
{"translation": {"code": "def getBits_from_array ( array , wordWidth , start , end , reinterpretElmToType = None ) : inPartOffset = 0 value = Bits ( end - start , None ) . fromPy ( None ) while start != end : assert start < end , ( start , end ) dataWordIndex = start // wordWidth v = array [ dataWordIndex ] if reinterpretElmToType is not None : v = v . _reinterpret_cast ( reinterpretElmToType ) endOfWord = ( dataWordIndex + 1 ) * wordWidth width = min ( end , endOfWord ) - start offset = start % wordWidth val = selectBitRange ( v . val , offset , width ) vldMask = selectBitRange ( v . vldMask , offset , width ) updateTime = v . updateTime m = mask ( width ) value . val |= ( val & m ) << inPartOffset value . vldMask |= ( vldMask & m ) << inPartOffset value . updateMask = max ( value . updateTime , updateTime ) inPartOffset += width start += width return value", "nl": "Gets value of bits between selected range from memory"}}
{"translation": {"code": "def fullWordCnt ( self , start : int , end : int ) : assert end >= start , ( start , end ) gap = max ( 0 , ( end - start ) - ( start % self . wordWidth ) ) return gap // self . wordWidth", "nl": "Count of complete words between two addresses"}}
{"translation": {"code": "def groupByWordIndex ( self , transaction : 'TransTmpl' , offset : int ) : actualW = None partsInWord = [ ] wordWidth = self . wordWidth for item in self . splitOnWords ( transaction , offset ) : _actualW = item . startOfPart // wordWidth if actualW is None : actualW = _actualW partsInWord . append ( item ) elif _actualW > actualW : yield ( actualW , partsInWord ) actualW = _actualW partsInWord = [ item , ] else : partsInWord . append ( item ) if partsInWord : yield ( actualW , partsInWord )", "nl": "Group transaction parts splited on words to words"}}
{"translation": {"code": "def _loadFromHType ( self , dtype : HdlType , bitAddr : int ) -> None : self . bitAddr = bitAddr childrenAreChoice = False if isinstance ( dtype , Bits ) : ld = self . _loadFromBits elif isinstance ( dtype , HStruct ) : ld = self . _loadFromHStruct elif isinstance ( dtype , HArray ) : ld = self . _loadFromArray elif isinstance ( dtype , HStream ) : ld = self . _loadFromHStream elif isinstance ( dtype , HUnion ) : ld = self . _loadFromUnion childrenAreChoice = True else : raise TypeError ( \"expected instance of HdlType\" , dtype ) self . bitAddrEnd = ld ( dtype , bitAddr ) self . childrenAreChoice = childrenAreChoice", "nl": "Parse any HDL type to this transaction template instance"}}
{"translation": {"code": "def iterBits ( sigOrVal : Union [ RtlSignal , Value ] , bitsInOne : int = 1 , skipPadding : bool = True , fillup : bool = False ) : bw = BitWalker ( sigOrVal , skipPadding , fillup ) for _ in range ( ceil ( sigOrVal . _dtype . bit_length ( ) / bitsInOne ) ) : yield bw . get ( bitsInOne ) bw . assertIsOnEnd ( )", "nl": "Iterate over bits in vector"}}