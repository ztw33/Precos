{"translation": {"code": "def finalize ( self ) : ff_to_remove = 0 res = self . resources for m , addrDict in self . memories . items ( ) : rwSyncPorts , rSyncPorts , wSyncPorts = 0 , 0 , 0 rwAsyncPorts , rAsyncPorts , wAsyncPorts = 0 , 0 , 0 rSync_wAsyncPorts , rAsync_wSyncPorts = 0 , 0 for _ , ( rSync , wSync , rAsync , wAsync ) in addrDict . items ( ) : if rSync : ff_to_remove += rSync * m . _dtype . elmType . bit_length ( ) # resolve port count for this addr signal rwSync = min ( rSync , wSync ) rSync -= rwSync wSync -= rwSync rwAsync = min ( rAsync , wAsync ) rAsync -= rwAsync wAsync -= rwAsync rSync_wAsync = min ( rSync , wAsync ) rSync -= rSync_wAsync wAsync -= rSync_wAsync rAsync_wSync = min ( rAsync , wSync ) rAsync -= rAsync_wSync wSync -= rAsync_wSync # update port counts for mem rwSyncPorts += rwSync rSyncPorts += rSync wSyncPorts += wSync rwAsyncPorts += rwAsync rAsyncPorts += rAsync wAsyncPorts += wAsync rSync_wAsyncPorts += rSync_wAsync rAsync_wSyncPorts += rAsync_wSync k = ResourceRAM ( m . _dtype . elmType . bit_length ( ) , int ( m . _dtype . size ) , rwSyncPorts , rSyncPorts , wSyncPorts , rSync_wAsyncPorts , rwAsyncPorts , rAsyncPorts , wAsyncPorts , rAsync_wSyncPorts ) res [ k ] = res . get ( k , 0 ) + 1 self . memories . clear ( ) # remove register on read ports which will be merged into ram if ff_to_remove : ff_cnt = res [ ResourceFF ] ff_cnt -= ff_to_remove if ff_cnt : res [ ResourceFF ] = ff_cnt else : del res [ ResourceFF ]", "nl": "Resolve ports of discovered memories"}}
{"translation": {"code": "def _scheduleCombUpdateDoneEv ( self ) -> Event : assert not self . _combUpdateDonePlaned , self . now cud = Event ( self ) cud . process_to_wake . append ( self . __deleteCombUpdateDoneEv ( ) ) self . _add_process ( cud , PRIORITY_AGENTS_UPDATE_DONE ) self . _combUpdateDonePlaned = True self . combUpdateDoneEv = cud return cud", "nl": "Schedule combUpdateDoneEv event to let agents know that current delta step is ending and values from combinational logic are stable"}}
{"translation": {"code": "def _get_rtl_context ( self ) : for sig in chain ( self . _inputs , self . _outputs ) : if sig . ctx : return sig . ctx else : # Param instances does not have context continue raise HwtSyntaxError ( \"Statement does not have any signal in any context\" , self )", "nl": "get RtlNetlist context from signals"}}
{"translation": {"code": "def _try_reduce_list ( statements : List [ \"HdlStatement\" ] ) : io_change = False new_statements = [ ] for stm in statements : reduced , _io_change = stm . _try_reduce ( ) new_statements . extend ( reduced ) io_change |= _io_change new_statements , rank_decrease = HdlStatement . _merge_statements ( new_statements ) return new_statements , rank_decrease , io_change", "nl": "Simplify statements in the list"}}
{"translation": {"code": "def name_for_process_and_mark_outputs ( statements : List [ HdlStatement ] ) -> str : out_names = [ ] for stm in statements : for sig in stm . _outputs : if not sig . hasGenericName : out_names . append ( sig . name ) if out_names : return min ( out_names ) else : return \"\"", "nl": "Resolve name for process and mark outputs of statemens as not hidden"}}
{"translation": {"code": "def cut_off_drivers_of ( dstSignal , statements ) : separated = [ ] stm_filter = [ ] for stm in statements : stm . _clean_signal_meta ( ) d = stm . _cut_off_drivers_of ( dstSignal ) if d is not None : separated . append ( d ) f = d is not stm stm_filter . append ( f ) return list ( compress ( statements , stm_filter ) ) , separated", "nl": "Cut off drivers from statements"}}
{"translation": {"code": "def _cut_off_drivers_of ( self , sig : RtlSignalBase ) : if self . dst is sig : self . parentStm = None return self else : return None", "nl": "Cut off statements which are driver of specified signal"}}
{"translation": {"code": "def _discover_sensitivity_seq ( self , signals : List [ RtlSignalBase ] , seen : set , ctx : SensitivityCtx ) -> None : casualSensitivity = set ( ) for s in signals : s . _walk_sensitivity ( casualSensitivity , seen , ctx ) if ctx . contains_ev_dependency : break # if event dependent sensitivity found do not add other sensitivity if not ctx . contains_ev_dependency : ctx . extend ( casualSensitivity )", "nl": "Discover sensitivity for list of signals"}}
{"translation": {"code": "def _on_merge ( self , other ) : self . _inputs . extend ( other . _inputs ) self . _outputs . extend ( other . _outputs ) if self . _sensitivity is not None : self . _sensitivity . extend ( other . _sensitivity ) else : assert other . _sensitivity is None if self . _enclosed_for is not None : self . _enclosed_for . update ( other . _enclosed_for ) else : assert other . _enclosed_for is None other_was_top = other . parentStm is None if other_was_top : other . _get_rtl_context ( ) . statements . remove ( other ) for s in other . _inputs : s . endpoints . discard ( other ) s . endpoints . append ( self ) for s in other . _outputs : s . drivers . discard ( other ) s . drivers . append ( self )", "nl": "After merging statements update IO sensitivity and context"}}
{"translation": {"code": "def _is_mergable_statement_list ( cls , stmsA , stmsB ) : if stmsA is None and stmsB is None : return True elif stmsA is None or stmsB is None : return False a_it = iter ( stmsA ) b_it = iter ( stmsB ) a = _get_stm_with_branches ( a_it ) b = _get_stm_with_branches ( b_it ) while a is not None or b is not None : if a is None or b is None or not a . _is_mergable ( b ) : return False a = _get_stm_with_branches ( a_it ) b = _get_stm_with_branches ( b_it ) # lists are empty return True", "nl": "Walk statements and compare if they can be merged into one statement list"}}
{"translation": {"code": "def _merge_with_other_stm ( self , other : \"IfContainer\" ) -> None : merge = self . _merge_statement_lists newCases = [ ] for ( c , caseA ) , ( _ , caseB ) in zip ( self . cases , other . cases ) : newCases . append ( ( c , merge ( caseA , caseB ) ) ) self . cases = newCases if self . default is not None : self . default = merge ( self . default , other . default ) self . _on_merge ( other )", "nl": "Merge other statement to this statement"}}
{"translation": {"code": "def _discover_enclosure_for_statements ( statements : List [ 'HdlStatement' ] , outputs : List [ 'HdlStatement' ] ) : result = set ( ) if not statements : return result for stm in statements : stm . _discover_enclosure ( ) for o in outputs : has_driver = False for stm in statements : if o in stm . _outputs : assert not has_driver has_driver = False if o in stm . _enclosed_for : result . add ( o ) else : pass return result", "nl": "Discover enclosure for list of statements"}}
{"translation": {"code": "def add_process ( self , proc ) -> None : self . _events . push ( self . now , PRIORITY_NORMAL , proc )", "nl": "Add process to events with default priority on current time"}}
{"translation": {"code": "def _getFullName ( self ) : name = \"\" tmp = self while isinstance ( tmp , ( InterfaceBase , HObjList ) ) : if hasattr ( tmp , \"_name\" ) : n = tmp . _name else : n = '' if name == '' : name = n else : name = n + '.' + name if hasattr ( tmp , \"_parent\" ) : tmp = tmp . _parent else : tmp = None return name", "nl": "get all name hierarchy separated by ."}}
{"translation": {"code": "def _m ( self ) : assert not hasattr ( self , \"_interfaces\" ) or not self . _interfaces , \"Too late to change direction of interface\" self . _direction = DIRECTION . asIntfDirection ( DIRECTION . opposite ( self . _masterDir ) ) return self", "nl": "Note that this interface will be master"}}