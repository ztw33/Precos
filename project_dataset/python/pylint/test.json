{"translation": {"code": "def _check_consistent_returns ( self , node ) : # explicit return statements are those with a not None value explicit_returns = [ _node for _node in self . _return_nodes [ node . name ] if _node . value is not None ] if not explicit_returns : return if len ( explicit_returns ) == len ( self . _return_nodes [ node . name ] ) and self . _is_node_return_ended ( node ) : return self . add_message ( \"inconsistent-return-statements\" , node = node )", "nl": "Check that all return statements inside a function are consistent ."}}
{"translation": {"code": "def node_ignores_exception ( node : astroid . node_classes . NodeNG , exception = Exception ) -> bool : managing_handlers = get_exception_handlers ( node , exception ) if not managing_handlers : return False return any ( managing_handlers )", "nl": "Check if the node is in a TryExcept which handles the given exception ."}}
{"translation": {"code": "def _has_different_parameters_default_value ( original , overridden ) : if original . args is None or overridden . args is None : return False all_args = chain ( original . args , original . kwonlyargs ) original_param_names = [ param . name for param in all_args ] default_missing = object ( ) for param_name in original_param_names : try : original_default = original . default_value ( param_name ) except astroid . exceptions . NoDefault : original_default = default_missing try : overridden_default = overridden . default_value ( param_name ) except astroid . exceptions . NoDefault : overridden_default = default_missing default_list = [ arg == default_missing for arg in ( original_default , overridden_default ) ] if any ( default_list ) and not all ( default_list ) : # Only one arg has no default value return True astroid_type_compared_attr = { astroid . Const : \"value\" , astroid . ClassDef : \"name\" , astroid . Tuple : \"elts\" , astroid . List : \"elts\" , } handled_types = tuple ( astroid_type for astroid_type in astroid_type_compared_attr ) original_type = _get_node_type ( original_default , handled_types ) if original_type : # \u00a0We handle only astroid types that are inside the dict astroid_type_compared_attr if not isinstance ( overridden_default , original_type ) : # \u00a0Two args with same name but different types return True if not _check_arg_equality ( original_default , overridden_default , astroid_type_compared_attr [ original_type ] , ) : # Two args with same type but different values return True return False", "nl": "Check if original and overridden methods arguments have different default values"}}
{"translation": {"code": "def _get_break_loop_node ( break_node ) : loop_nodes = ( astroid . For , astroid . While ) parent = break_node . parent while not isinstance ( parent , loop_nodes ) or break_node in getattr ( parent , \"orelse\" , [ ] ) : break_node = parent parent = parent . parent if parent is None : break return parent", "nl": "Returns the loop node that holds the break node in arguments ."}}
{"translation": {"code": "def _has_homonym_in_upper_function_scope ( self , node , index ) : for _consumer in self . _to_consume [ index - 1 : : - 1 ] : if _consumer . scope_type == \"function\" and node . name in _consumer . to_consume : return True return False", "nl": "Return True if there is a node with the same name in the to_consume dict of an upper scope and if that scope is a function"}}
{"translation": {"code": "def _check_chained_comparison ( self , node ) : if node . op != \"and\" or len ( node . values ) < 2 : return def _find_lower_upper_bounds ( comparison_node , uses ) : left_operand = comparison_node . left for operator , right_operand in comparison_node . ops : for operand in ( left_operand , right_operand ) : value = None if isinstance ( operand , astroid . Name ) : value = operand . name elif isinstance ( operand , astroid . Const ) : value = operand . value if value is None : continue if operator in ( \"<\" , \"<=\" ) : if operand is left_operand : uses [ value ] [ \"lower_bound\" ] . add ( comparison_node ) elif operand is right_operand : uses [ value ] [ \"upper_bound\" ] . add ( comparison_node ) elif operator in ( \">\" , \">=\" ) : if operand is left_operand : uses [ value ] [ \"upper_bound\" ] . add ( comparison_node ) elif operand is right_operand : uses [ value ] [ \"lower_bound\" ] . add ( comparison_node ) left_operand = right_operand uses = collections . defaultdict ( lambda : { \"lower_bound\" : set ( ) , \"upper_bound\" : set ( ) } ) for comparison_node in node . values : if isinstance ( comparison_node , astroid . Compare ) : _find_lower_upper_bounds ( comparison_node , uses ) for _ , bounds in uses . items ( ) : num_shared = len ( bounds [ \"lower_bound\" ] . intersection ( bounds [ \"upper_bound\" ] ) ) num_lower_bounds = len ( bounds [ \"lower_bound\" ] ) num_upper_bounds = len ( bounds [ \"upper_bound\" ] ) if num_shared < num_lower_bounds and num_shared < num_upper_bounds : self . add_message ( \"chained-comparison\" , node = node ) break", "nl": "Check if there is any chained comparison in the expression ."}}
{"translation": {"code": "def _filter_dependencies_graph ( self , internal ) : graph = collections . defaultdict ( set ) for importee , importers in self . stats [ \"dependencies\" ] . items ( ) : for importer in importers : package = self . _module_pkg . get ( importer , importer ) is_inside = importee . startswith ( package ) if is_inside and internal or not is_inside and not internal : graph [ importee ] . add ( importer ) return graph", "nl": "build the internal or the external depedency graph"}}
{"translation": {"code": "def process_tokens ( self , tokens ) : if not self . config . notes : return comments = ( token_info for token_info in tokens if token_info . type == tokenize . COMMENT ) for comment in comments : comment_text = comment . string [ 1 : ] . lstrip ( ) # trim '#' and whitespaces # handle pylint disable clauses disable_option_match = OPTION_RGX . search ( comment_text ) if disable_option_match : try : _ , value = disable_option_match . group ( 1 ) . split ( \"=\" , 1 ) values = [ _val . strip ( ) . upper ( ) for _val in value . split ( \",\" ) ] if set ( values ) & set ( self . config . notes ) : continue except ValueError : self . add_message ( \"bad-inline-option\" , args = disable_option_match . group ( 1 ) . strip ( ) , line = comment . string , ) continue # emit warnings if necessary match = self . _fixme_pattern . search ( \"#\" + comment_text . lower ( ) ) if match : note = match . group ( 1 ) self . add_message ( \"fixme\" , col_offset = comment . string . lower ( ) . index ( note . lower ( ) ) , args = comment_text , line = comment . start [ 0 ] , )", "nl": "inspect the source to find fixme problems"}}
{"translation": {"code": "def _is_raising ( body : typing . List ) -> bool : for node in body : if isinstance ( node , astroid . Raise ) : return True return False", "nl": "Return true if the given statement node raise an exception"}}
{"translation": {"code": "def format ( self , template ) : # For some reason, _asdict on derived namedtuples does not work with # Python 3.4. Needs some investigation. return template . format ( * * dict ( zip ( self . _fields , self ) ) )", "nl": "Format the message according to the given template ."}}
{"translation": {"code": "def handle_ignored_message ( self , state_scope , msgid , line , node , args , confidence ) : # pylint: disable=unused-argument if state_scope == MSG_STATE_SCOPE_MODULE : try : orig_line = self . _suppression_mapping [ ( msgid , line ) ] self . _ignored_msgs [ ( msgid , orig_line ) ] . add ( line ) except KeyError : pass", "nl": "Report an ignored message ."}}
{"translation": {"code": "def add_checker ( self , checker ) : # XXX : should be possible to merge needed_checkers and add_checker vcids = set ( ) lcids = set ( ) visits = self . visit_events leaves = self . leave_events for member in dir ( checker ) : cid = member [ 6 : ] if cid == \"default\" : continue if member . startswith ( \"visit_\" ) : v_meth = getattr ( checker , member ) # don't use visit_methods with no activated message: if self . _is_method_enabled ( v_meth ) : visits [ cid ] . append ( v_meth ) vcids . add ( cid ) elif member . startswith ( \"leave_\" ) : l_meth = getattr ( checker , member ) # don't use leave_methods with no activated message: if self . _is_method_enabled ( l_meth ) : leaves [ cid ] . append ( l_meth ) lcids . add ( cid ) visit_default = getattr ( checker , \"visit_default\" , None ) if visit_default : for cls in nodes . ALL_NODE_CLASSES : cid = cls . __name__ . lower ( ) if cid not in vcids : visits [ cid ] . append ( visit_default )", "nl": "walk to the checker s dir and collect visit and leave methods"}}
{"translation": {"code": "def walk ( self , astroid ) : cid = astroid . __class__ . __name__ . lower ( ) # Detect if the node is a new name for a deprecated alias. # In this case, favour the methods for the deprecated # alias if any,  in order to maintain backwards # compatibility. visit_events = self . visit_events . get ( cid , ( ) ) leave_events = self . leave_events . get ( cid , ( ) ) if astroid . is_statement : self . nbstatements += 1 # generate events for this node on each checker for cb in visit_events or ( ) : cb ( astroid ) # recurse on children for child in astroid . get_children ( ) : self . walk ( child ) for cb in leave_events or ( ) : cb ( astroid )", "nl": "call visit events of astroid checkers for the given node recurse on its children then leave events ."}}
{"translation": {"code": "def collect_block_lines ( self , msgs_store , module_node ) : for msg , lines in self . _module_msgs_state . items ( ) : self . _raw_module_msgs_state [ msg ] = lines . copy ( ) orig_state = self . _module_msgs_state . copy ( ) self . _module_msgs_state = { } self . _suppression_mapping = { } self . _effective_max_line_number = module_node . tolineno self . _collect_block_lines ( msgs_store , module_node , orig_state )", "nl": "Walk the AST to collect block level options line numbers ."}}
{"translation": {"code": "def may_be_emitted ( self ) : if self . minversion is not None and self . minversion > sys . version_info : return False if self . maxversion is not None and self . maxversion <= sys . version_info : return False return True", "nl": "return True if message may be emitted using the current interpreter"}}
{"translation": {"code": "def format_help ( self , checkerref = False ) : desc = self . descr if checkerref : desc += \" This message belongs to the %s checker.\" % self . checker . name title = self . msg if self . symbol : msgid = \"%s (%s)\" % ( self . symbol , self . msgid ) else : msgid = self . msgid if self . minversion or self . maxversion : restr = [ ] if self . minversion : restr . append ( \"< %s\" % \".\" . join ( [ str ( n ) for n in self . minversion ] ) ) if self . maxversion : restr . append ( \">= %s\" % \".\" . join ( [ str ( n ) for n in self . maxversion ] ) ) restr = \" or \" . join ( restr ) if checkerref : desc += \" It can't be emitted when using Python %s.\" % restr else : desc += \" This message can't be emitted when using Python %s.\" % restr desc = normalize_text ( \" \" . join ( desc . split ( ) ) , indent = \"  \" ) if title != \"%s\" : title = title . splitlines ( ) [ 0 ] return \":%s: *%s*\\n%s\" % ( msgid , title . rstrip ( \" \" ) , desc ) return \":%s:\\n%s\" % ( msgid , desc )", "nl": "return the help string for the given message id"}}
{"translation": {"code": "def make_reports ( self , stats , old_stats ) : sect = Section ( \"Report\" , \"%s statements analysed.\" % ( self . stats [ \"statement\" ] ) ) for checker in self . report_order ( ) : for reportid , r_title , r_cb in self . _reports [ checker ] : if not self . report_is_enabled ( reportid ) : continue report_sect = Section ( r_title ) try : r_cb ( report_sect , stats , old_stats ) except EmptyReportError : continue report_sect . report_id = reportid sect . append ( report_sect ) return sect", "nl": "render registered reports"}}
{"translation": {"code": "def is_message_enabled ( self , msg_descr , line = None , confidence = None ) : if self . config . confidence and confidence : if confidence . name not in self . config . confidence : return False try : message_definitions = self . msgs_store . get_message_definitions ( msg_descr ) msgids = [ md . msgid for md in message_definitions ] except UnknownMessageError : # The linter checks for messages that are not registered # due to version mismatch, just treat them as message IDs # for now. msgids = [ msg_descr ] for msgid in msgids : if self . is_one_message_enabled ( msgid , line ) : return True return False", "nl": "return true if the message associated to the given message id is enabled"}}
{"translation": {"code": "def add_message ( self , msg_descr , line = None , node = None , args = None , confidence = UNDEFINED , col_offset = None , ) : message_definitions = self . msgs_store . get_message_definitions ( msg_descr ) for message_definition in message_definitions : self . add_one_message ( message_definition , line , node , args , confidence , col_offset )", "nl": "Adds a message given by ID or name ."}}
{"translation": {"code": "def print_full_documentation ( self , stream = None ) : if not stream : stream = sys . stdout print ( \"Pylint global options and switches\" , file = stream ) print ( \"----------------------------------\" , file = stream ) print ( \"\" , file = stream ) print ( \"Pylint provides global options and switches.\" , file = stream ) print ( \"\" , file = stream ) by_checker = { } for checker in self . get_checkers ( ) : if checker . name == \"master\" : if checker . options : for section , options in checker . options_by_section ( ) : if section is None : title = \"General options\" else : title = \"%s options\" % section . capitalize ( ) print ( title , file = stream ) print ( \"~\" * len ( title ) , file = stream ) _rest_format_section ( stream , None , options ) print ( \"\" , file = stream ) else : name = checker . name try : by_checker [ name ] [ \"options\" ] += checker . options_and_values ( ) by_checker [ name ] [ \"msgs\" ] . update ( checker . msgs ) by_checker [ name ] [ \"reports\" ] += checker . reports except KeyError : by_checker [ name ] = { \"options\" : list ( checker . options_and_values ( ) ) , \"msgs\" : dict ( checker . msgs ) , \"reports\" : list ( checker . reports ) , } print ( \"Pylint checkers' options and switches\" , file = stream ) print ( \"-------------------------------------\" , file = stream ) print ( \"\" , file = stream ) print ( \"Pylint checkers can provide three set of features:\" , file = stream ) print ( \"\" , file = stream ) print ( \"* options that control their execution,\" , file = stream ) print ( \"* messages that they can raise,\" , file = stream ) print ( \"* reports that they can generate.\" , file = stream ) print ( \"\" , file = stream ) print ( \"Below is a list of all checkers and their features.\" , file = stream ) print ( \"\" , file = stream ) for checker , info in sorted ( by_checker . items ( ) ) : self . _print_checker_doc ( checker , info , stream = stream )", "nl": "output a full documentation in ReST format"}}
{"translation": {"code": "def _ini_format ( stream , options ) : for optname , optdict , value in options : value = _format_option_value ( optdict , value ) help_opt = optdict . get ( \"help\" ) if help_opt : help_opt = normalize_text ( help_opt , line_len = 79 , indent = \"# \" ) print ( file = stream ) print ( help_opt , file = stream ) else : print ( file = stream ) if value is None : print ( \"#%s=\" % optname , file = stream ) else : value = str ( value ) . strip ( ) if re . match ( r\"^([\\w-]+,)+[\\w-]+$\" , str ( value ) ) : separator = \"\\n \" + \" \" * len ( optname ) value = separator . join ( x + \",\" for x in str ( value ) . split ( \",\" ) ) # remove trailing ',' from last element of the list value = value [ : - 1 ] print ( \"%s=%s\" % ( optname , value ) , file = stream )", "nl": "format options using the INI format"}}
{"translation": {"code": "def _register_by_id_managed_msg ( self , msgid , line , is_disabled = True ) : try : message_definitions = self . msgs_store . get_message_definitions ( msgid ) for message_definition in message_definitions : if msgid == message_definition . msgid : MessagesHandlerMixIn . __by_id_managed_msgs . append ( ( self . current_name , message_definition . msgid , message_definition . symbol , line , is_disabled , ) ) except UnknownMessageError : pass", "nl": "If the msgid is a numeric one then register it to inform the user it could furnish instead a symbolic msgid ."}}
{"translation": {"code": "def get_module_and_frameid ( node ) : frame = node . frame ( ) module , obj = \"\" , [ ] while frame : if isinstance ( frame , Module ) : module = frame . name else : obj . append ( getattr ( frame , \"name\" , \"<lambda>\" ) ) try : frame = frame . parent . frame ( ) except AttributeError : frame = None obj . reverse ( ) return module , \".\" . join ( obj )", "nl": "return the module name and the frame id in the module"}}
{"translation": {"code": "def _basename_in_blacklist_re ( base_name , black_list_re ) : for file_pattern in black_list_re : if file_pattern . match ( base_name ) : return True return False", "nl": "Determines if the basename is matched in a regex blacklist"}}
{"translation": {"code": "def register_message ( self , message ) : self . _check_id_and_symbol_consistency ( message . msgid , message . symbol ) self . _check_symbol ( message . msgid , message . symbol ) self . _check_msgid ( message . msgid , message . symbol ) for old_name in message . old_names : self . _check_symbol ( message . msgid , old_name [ 1 ] ) self . _messages_definitions [ message . symbol ] = message self . _register_alternative_name ( message , message . msgid , message . symbol ) for old_id , old_symbol in message . old_names : self . _register_alternative_name ( message , old_id , old_symbol ) self . _msgs_by_category [ message . msgid [ 0 ] ] . append ( message . msgid )", "nl": "Register a MessageDefinition with consistency in mind ."}}
{"translation": {"code": "def _check_symbol ( self , msgid , symbol ) : other_message = self . _messages_definitions . get ( symbol ) if other_message : self . _raise_duplicate_msg_id ( symbol , msgid , other_message . msgid ) else : alternative_msgid = None alternative_message = self . _alternative_names . get ( symbol ) if alternative_message : if alternative_message . symbol == symbol : alternative_msgid = alternative_message . msgid else : for old_msgid , old_symbol in alternative_message . old_names : if old_symbol == symbol : alternative_msgid = old_msgid break if msgid != alternative_msgid : self . _raise_duplicate_msg_id ( symbol , msgid , alternative_msgid )", "nl": "Check that a symbol is not already used ."}}
{"translation": {"code": "def help_message ( self , msgids ) : for msgid in msgids : try : for message_definition in self . get_message_definitions ( msgid ) : print ( message_definition . format_help ( checkerref = True ) ) print ( \"\" ) except UnknownMessageError as ex : print ( ex ) print ( \"\" ) continue", "nl": "Display help messages for the given message identifiers"}}
{"translation": {"code": "def get_msg_display_string ( self , msgid ) : message_definitions = self . get_message_definitions ( msgid ) if len ( message_definitions ) == 1 : return repr ( message_definitions [ 0 ] . symbol ) return repr ( [ md . symbol for md in message_definitions ] )", "nl": "Generates a user - consumable representation of a message ."}}
{"translation": {"code": "def load_plugin_configuration ( self ) : for modname in self . _dynamic_plugins : module = modutils . load_module_from_name ( modname ) if hasattr ( module , \"load_configuration\" ) : module . load_configuration ( self )", "nl": "Call the configuration hook for plugins"}}
{"translation": {"code": "def cb_list_groups ( self , * args , * * kwargs ) : for check in self . linter . get_checker_names ( ) : print ( check ) sys . exit ( 0 )", "nl": "List all the check groups that pylint knows about"}}
{"translation": {"code": "def get_checker_names ( self ) : current_checkers = self . get_checkers ( ) return sorted ( { check . name for check in current_checkers if check . name != \"master\" } )", "nl": "Get all the checker names that this linter knows about ."}}
{"translation": {"code": "def display_reports ( self , layout ) : self . section = 0 if hasattr ( layout , \"report_id\" ) : layout . children [ 0 ] . children [ 0 ] . data += \" (%s)\" % layout . report_id self . _display ( layout )", "nl": "display results encapsulated in the layout tree"}}
{"translation": {"code": "def check_consistency ( self ) -> None : checker_id = None existing_ids = [ ] for message in self . messages : if checker_id is not None and checker_id != message . msgid [ 1 : 3 ] : error_msg = \"Inconsistent checker part in message id \" error_msg += \"'{}' (expected 'x{checker_id}xx' \" . format ( message . msgid , checker_id = checker_id ) error_msg += \"because we already had {existing_ids}).\" . format ( existing_ids = existing_ids ) raise InvalidMessageError ( error_msg ) checker_id = message . msgid [ 1 : 3 ] existing_ids . append ( message . msgid )", "nl": "Check the consistency of msgid ."}}
{"translation": {"code": "def _check_preferred_module ( self , node , mod_path ) : if mod_path in self . preferred_modules : self . add_message ( \"preferred-module\" , node = node , args = ( self . preferred_modules [ mod_path ] , mod_path ) , )", "nl": "check if the module has a preferred replacement"}}