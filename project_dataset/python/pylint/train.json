{"translation": {"code": "def get_packages ( directory , prefix ) : result = [ ] for package in os . listdir ( directory ) : absfile = join ( directory , package ) if isdir ( absfile ) : if exists ( join ( absfile , \"__init__.py\" ) ) : if prefix : result . append ( \"%s.%s\" % ( prefix , package ) ) else : result . append ( package ) result += get_packages ( absfile , result [ - 1 ] ) return result", "nl": "return a list of subpackages for the given directory"}}
{"translation": {"code": "def _compute_sims ( self ) : no_duplicates = defaultdict ( list ) for num , lineset1 , idx1 , lineset2 , idx2 in self . _iter_sims ( ) : duplicate = no_duplicates [ num ] for couples in duplicate : if ( lineset1 , idx1 ) in couples or ( lineset2 , idx2 ) in couples : couples . add ( ( lineset1 , idx1 ) ) couples . add ( ( lineset2 , idx2 ) ) break else : duplicate . append ( { ( lineset1 , idx1 ) , ( lineset2 , idx2 ) } ) sims = [ ] for num , ensembles in no_duplicates . items ( ) : for couples in ensembles : sims . append ( ( num , couples ) ) sims . sort ( ) sims . reverse ( ) return sims", "nl": "compute similarities in appended files"}}
{"translation": {"code": "def _display_sims ( self , sims ) : nb_lignes_dupliquees = 0 for num , couples in sims : print ( ) print ( num , \"similar lines in\" , len ( couples ) , \"files\" ) couples = sorted ( couples ) for lineset , idx in couples : print ( \"==%s:%s\" % ( lineset . name , idx ) ) # pylint: disable=W0631 for line in lineset . _real_lines [ idx : idx + num ] : print ( \"  \" , line . rstrip ( ) ) nb_lignes_dupliquees += num * ( len ( couples ) - 1 ) nb_total_lignes = sum ( [ len ( lineset ) for lineset in self . linesets ] ) print ( \"TOTAL lines=%s duplicates=%s percent=%.2f\" % ( nb_total_lignes , nb_lignes_dupliquees , nb_lignes_dupliquees * 100.0 / nb_total_lignes , ) )", "nl": "display computed similarities on stdout"}}
{"translation": {"code": "def _find_common ( self , lineset1 , lineset2 ) : lines1 = lineset1 . enumerate_stripped lines2 = lineset2 . enumerate_stripped find = lineset2 . find index1 = 0 min_lines = self . min_lines while index1 < len ( lineset1 ) : skip = 1 num = 0 for index2 in find ( lineset1 [ index1 ] ) : non_blank = 0 for num , ( ( _ , line1 ) , ( _ , line2 ) ) in enumerate ( zip ( lines1 ( index1 ) , lines2 ( index2 ) ) ) : if line1 != line2 : if non_blank > min_lines : yield num , lineset1 , index1 , lineset2 , index2 skip = max ( skip , num ) break if line1 : non_blank += 1 else : # we may have reach the end num += 1 if non_blank > min_lines : yield num , lineset1 , index1 , lineset2 , index2 skip = max ( skip , num ) index1 += skip", "nl": "find similarities in the two given linesets"}}
{"translation": {"code": "def _iter_sims ( self ) : for idx , lineset in enumerate ( self . linesets [ : - 1 ] ) : for lineset2 in self . linesets [ idx + 1 : ] : for sim in self . _find_common ( lineset , lineset2 ) : yield sim", "nl": "iterate on similarities among all files by making a cartesian product"}}
{"translation": {"code": "def enumerate_stripped ( self , start_at = 0 ) : idx = start_at if start_at : lines = self . _stripped_lines [ start_at : ] else : lines = self . _stripped_lines for line in lines : # if line: yield idx , line idx += 1", "nl": "return an iterator on stripped lines starting from a given index if specified else 0"}}
{"translation": {"code": "def _mk_index ( self ) : index = defaultdict ( list ) for line_no , line in enumerate ( self . _stripped_lines ) : if line : index [ line ] . append ( line_no ) return index", "nl": "create the index for this set"}}
{"translation": {"code": "def visit_classdef ( self , node ) : self . _check_bases_classes ( node ) # if not an exception or a metaclass if node . type == \"class\" and has_known_bases ( node ) : try : node . local_attr ( \"__init__\" ) except astroid . NotFoundError : self . add_message ( \"no-init\" , args = node , node = node ) self . _check_slots ( node ) self . _check_proper_bases ( node ) self . _check_consistent_mro ( node )", "nl": "init visit variable _accessed"}}
{"translation": {"code": "def visit_functiondef ( self , node ) : # ignore actual functions if not node . is_method ( ) : return self . _check_useless_super_delegation ( node ) klass = node . parent . frame ( ) self . _meth_could_be_func = True # check first argument is self if this is actually a method self . _check_first_arg_for_type ( node , klass . type == \"metaclass\" ) if node . name == \"__init__\" : self . _check_init ( node ) return # check signature if the method overloads inherited method for overridden in klass . local_attr_ancestors ( node . name ) : # get astroid for the searched method try : meth_node = overridden [ node . name ] except KeyError : # we have found the method but it's not in the local # dictionary. # This may happen with astroid build from living objects continue if not isinstance ( meth_node , astroid . FunctionDef ) : continue self . _check_signature ( node , meth_node , \"overridden\" , klass ) break if node . decorators : for decorator in node . decorators . nodes : if isinstance ( decorator , astroid . Attribute ) and decorator . attrname in ( \"getter\" , \"setter\" , \"deleter\" , ) : # attribute affectation will call this method, not hiding it return if isinstance ( decorator , astroid . Name ) : if decorator . name == \"property\" : # attribute affectation will either call a setter or raise # an attribute error, anyway not hiding the function return # Infer the decorator and see if it returns something useful inferred = safe_infer ( decorator ) if not inferred : return if isinstance ( inferred , astroid . FunctionDef ) : # Okay, it's a decorator, let's see what it can infer. try : inferred = next ( inferred . infer_call_result ( inferred ) ) except astroid . InferenceError : return try : if ( isinstance ( inferred , ( astroid . Instance , astroid . ClassDef ) ) and inferred . getattr ( \"__get__\" ) and inferred . getattr ( \"__set__\" ) ) : return except astroid . AttributeInferenceError : pass # check if the method is hidden by an attribute try : overridden = klass . instance_attr ( node . name ) [ 0 ] # XXX overridden_frame = overridden . frame ( ) if ( isinstance ( overridden_frame , astroid . FunctionDef ) and overridden_frame . type == \"method\" ) : overridden_frame = overridden_frame . parent . frame ( ) if isinstance ( overridden_frame , astroid . ClassDef ) and klass . is_subtype_of ( overridden_frame . qname ( ) ) : args = ( overridden . root ( ) . name , overridden . fromlineno ) self . add_message ( \"method-hidden\" , args = args , node = node ) except astroid . NotFoundError : pass", "nl": "check method arguments overriding"}}
{"translation": {"code": "def leave_functiondef ( self , node ) : if node . is_method ( ) : if node . args . args is not None : self . _first_attrs . pop ( ) if not self . linter . is_message_enabled ( \"no-self-use\" ) : return class_node = node . parent . frame ( ) if ( self . _meth_could_be_func and node . type == \"method\" and node . name not in PYMETHODS and not ( node . is_abstract ( ) or overrides_a_method ( class_node , node . name ) or decorated_with_property ( node ) or _has_bare_super_call ( node ) ) ) : self . add_message ( \"no-self-use\" , node = node )", "nl": "on method node check if this method couldn t be a function"}}
{"translation": {"code": "def visit_name ( self , node ) : if self . _first_attrs and ( node . name == self . _first_attrs [ - 1 ] or not self . _first_attrs [ - 1 ] ) : self . _meth_could_be_func = False", "nl": "check if the name handle an access to a class member if so register it"}}
{"translation": {"code": "def _check_accessed_members ( self , node , accessed ) : # XXX refactor, probably much simpler now that E0201 is in type checker excs = ( \"AttributeError\" , \"Exception\" , \"BaseException\" ) for attr , nodes in accessed . items ( ) : try : # is it a class attribute ? node . local_attr ( attr ) # yes, stop here continue except astroid . NotFoundError : pass # is it an instance attribute of a parent class ? try : next ( node . instance_attr_ancestors ( attr ) ) # yes, stop here continue except StopIteration : pass # is it an instance attribute ? try : defstmts = node . instance_attr ( attr ) except astroid . NotFoundError : pass else : # filter out augment assignment nodes defstmts = [ stmt for stmt in defstmts if stmt not in nodes ] if not defstmts : # only augment assignment for this node, no-member should be # triggered by the typecheck checker continue # filter defstmts to only pick the first one when there are # several assignments in the same scope scope = defstmts [ 0 ] . scope ( ) defstmts = [ stmt for i , stmt in enumerate ( defstmts ) if i == 0 or stmt . scope ( ) is not scope ] # if there are still more than one, don't attempt to be smarter # than we can be if len ( defstmts ) == 1 : defstmt = defstmts [ 0 ] # check that if the node is accessed in the same method as # it's defined, it's accessed after the initial assignment frame = defstmt . frame ( ) lno = defstmt . fromlineno for _node in nodes : if ( _node . frame ( ) is frame and _node . fromlineno < lno and not astroid . are_exclusive ( _node . statement ( ) , defstmt , excs ) ) : self . add_message ( \"access-member-before-definition\" , node = _node , args = ( attr , lno ) , )", "nl": "check that accessed members are defined"}}
{"translation": {"code": "def show_attr ( self , node ) : visibility = get_visibility ( getattr ( node , \"name\" , node ) ) return not self . __mode & VIS_MOD [ visibility ]", "nl": "return true if the node should be treated"}}
{"translation": {"code": "def insert_default_options ( ) : options = get_default_options ( ) options . reverse ( ) for arg in options : sys . argv . insert ( 1 , arg )", "nl": "insert default options to sys . argv"}}
{"translation": {"code": "def get_default_options ( ) : options = [ ] home = os . environ . get ( \"HOME\" , \"\" ) if home : rcfile = os . path . join ( home , RCFILE ) try : options = open ( rcfile ) . read ( ) . split ( ) except IOError : pass # ignore if no config file found return options", "nl": "Read config file and return list of options"}}
{"translation": {"code": "def _check_bases_classes ( self , node ) : def is_abstract ( method ) : return method . is_abstract ( pass_is_abstract = False ) # check if this class abstract if class_is_abstract ( node ) : return methods = sorted ( unimplemented_abstract_methods ( node , is_abstract ) . items ( ) , key = lambda item : item [ 0 ] , ) for name , method in methods : owner = method . parent . frame ( ) if owner is node : continue # owner is not this class, it must be a parent class # check that the ancestor's method is not abstract if name in node . locals : # it is redefined as an attribute or with a descriptor continue self . add_message ( \"abstract-method\" , node = node , args = ( name , owner . name ) )", "nl": "check that the given class node implements abstract methods from base classes"}}
{"translation": {"code": "def append_stream ( self , streamid , stream , encoding = None ) : if encoding is None : readlines = stream . readlines else : readlines = decoding_stream ( stream , encoding ) . readlines try : self . linesets . append ( LineSet ( streamid , readlines ( ) , self . ignore_comments , self . ignore_docstrings , self . ignore_imports , ) ) except UnicodeDecodeError : pass", "nl": "append a file to search for similarities"}}
{"translation": {"code": "def Run ( argv = None ) : if argv is None : argv = sys . argv [ 1 : ] from getopt import getopt s_opts = \"hdi\" l_opts = ( \"help\" , \"duplicates=\" , \"ignore-comments\" , \"ignore-imports\" , \"ignore-docstrings\" , ) min_lines = 4 ignore_comments = False ignore_docstrings = False ignore_imports = False opts , args = getopt ( argv , s_opts , l_opts ) for opt , val in opts : if opt in ( \"-d\" , \"--duplicates\" ) : min_lines = int ( val ) elif opt in ( \"-h\" , \"--help\" ) : usage ( ) elif opt in ( \"-i\" , \"--ignore-comments\" ) : ignore_comments = True elif opt in ( \"--ignore-docstrings\" , ) : ignore_docstrings = True elif opt in ( \"--ignore-imports\" , ) : ignore_imports = True if not args : usage ( 1 ) sim = Similar ( min_lines , ignore_comments , ignore_docstrings , ignore_imports ) for filename in args : with open ( filename ) as stream : sim . append_stream ( filename , stream ) sim . run ( ) sys . exit ( 0 )", "nl": "standalone command line access point"}}
{"translation": {"code": "def report_similarities ( sect , stats , old_stats ) : lines = [ \"\" , \"now\" , \"previous\" , \"difference\" ] lines += table_lines_from_stats ( stats , old_stats , ( \"nb_duplicated_lines\" , \"percent_duplicated_lines\" ) ) sect . append ( Table ( children = lines , cols = 4 , rheaders = 1 , cheaders = 1 ) )", "nl": "make a layout with some stats about duplication"}}
{"translation": {"code": "def leave_project ( self , node ) : # pylint: disable=unused-argument if self . pkgdiagram : return self . pkgdiagram , self . classdiagram return ( self . classdiagram , )", "nl": "leave the pyreverse . utils . Project node"}}
{"translation": {"code": "def handle_message ( self , msg ) : if msg . module not in self . _modules : color , style = self . _get_decoration ( \"S\" ) if msg . module : modsep = colorize_ansi ( \"************* Module %s\" % msg . module , color , style ) else : modsep = colorize_ansi ( \"************* %s\" % msg . module , color , style ) self . writeln ( modsep ) self . _modules . add ( msg . module ) color , style = self . _get_decoration ( msg . C ) msg = msg . _replace ( * * { attr : colorize_ansi ( getattr ( msg , attr ) , color , style ) for attr in ( \"msg\" , \"symbol\" , \"category\" , \"C\" ) } ) self . write_message ( msg )", "nl": "manage message of different types and colorize output using ansi escape codes"}}
{"translation": {"code": "def report_messages_stats ( sect , stats , _ ) : if not stats [ \"by_msg\" ] : # don't print this report when we didn't detected any errors raise exceptions . EmptyReportError ( ) in_order = sorted ( [ ( value , msg_id ) for msg_id , value in stats [ \"by_msg\" ] . items ( ) if not msg_id . startswith ( \"I\" ) ] ) in_order . reverse ( ) lines = ( \"message id\" , \"occurrences\" ) for value , msg_id in in_order : lines += ( msg_id , str ( value ) ) sect . append ( report_nodes . Table ( children = lines , cols = 2 , rheaders = 1 ) )", "nl": "make messages type report"}}
{"translation": {"code": "def load_plugin_modules ( self , modnames ) : for modname in modnames : if modname in self . _dynamic_plugins : continue self . _dynamic_plugins . add ( modname ) module = modutils . load_module_from_name ( modname ) module . register ( self )", "nl": "take a list of module names which are pylint plugins and load and register them"}}
{"translation": {"code": "def set_option ( self , optname , value , action = None , optdict = None ) : if optname in self . _options_methods or optname in self . _bw_options_methods : if value : try : meth = self . _options_methods [ optname ] except KeyError : meth = self . _bw_options_methods [ optname ] warnings . warn ( \"%s is deprecated, replace it by %s\" % ( optname , optname . split ( \"-\" ) [ 0 ] ) , DeprecationWarning , ) value = utils . _check_csv ( value ) if isinstance ( value , ( list , tuple ) ) : for _id in value : meth ( _id , ignore_unknown = True ) else : meth ( value ) return # no need to call set_option, disable/enable methods do it elif optname == \"output-format\" : self . _reporter_name = value # If the reporters are already available, load # the reporter class. if self . _reporters : self . _load_reporter ( ) try : checkers . BaseTokenChecker . set_option ( self , optname , value , action , optdict ) except config . UnsupportedAction : print ( \"option %s can't be read from config file\" % optname , file = sys . stderr )", "nl": "overridden from config . OptionsProviderMixin to handle some special options"}}
{"translation": {"code": "def register_checker ( self , checker ) : assert checker . priority <= 0 , \"checker priority can't be >= 0\" self . _checkers [ checker . name ] . append ( checker ) for r_id , r_title , r_cb in checker . reports : self . register_report ( r_id , r_title , r_cb , checker ) self . register_options_provider ( checker ) if hasattr ( checker , \"msgs\" ) : self . msgs_store . register_messages_from_checker ( checker ) checker . load_defaults ( ) # Register the checker, but disable all of its messages. # TODO(cpopa): we should have a better API for this. if not getattr ( checker , \"enabled\" , True ) : self . disable ( checker . name )", "nl": "register a new checker"}}
{"translation": {"code": "def visit_assign ( self , node ) : if not isinstance ( node . value , astroid . Call ) : return function_node = safe_infer ( node . value . func ) # skip class, generator and incomplete function definition funcs = ( astroid . FunctionDef , astroid . UnboundMethod , astroid . BoundMethod ) if not ( isinstance ( function_node , funcs ) and function_node . root ( ) . fully_defined ( ) and not function_node . decorators ) : return if ( function_node . is_generator ( ) or function_node . is_abstract ( pass_is_abstract = False ) or isinstance ( function_node , astroid . AsyncFunctionDef ) ) : return returns = list ( function_node . nodes_of_class ( astroid . Return , skip_klass = astroid . FunctionDef ) ) if not returns : self . add_message ( \"assignment-from-no-return\" , node = node ) else : for rnode in returns : if not ( isinstance ( rnode . value , astroid . Const ) and rnode . value . value is None or rnode . value is None ) : break else : self . add_message ( \"assignment-from-none\" , node = node )", "nl": "check that if assigning to a function call the function is possibly returning something valuable"}}
{"translation": {"code": "def visit_attribute ( self , node ) : for pattern in self . config . generated_members : # attribute is marked as generated, stop here if re . match ( pattern , node . attrname ) : return if re . match ( pattern , node . as_string ( ) ) : return try : inferred = list ( node . expr . infer ( ) ) except exceptions . InferenceError : return # list of (node, nodename) which are missing the attribute missingattr = set ( ) non_opaque_inference_results = [ owner for owner in inferred if owner is not astroid . Uninferable and not isinstance ( owner , astroid . nodes . Unknown ) ] if ( len ( non_opaque_inference_results ) != len ( inferred ) and self . config . ignore_on_opaque_inference ) : # There is an ambiguity in the inference. Since we can't # make sure that we won't emit a false positive, we just stop # whenever the inference returns an opaque inference object. return for owner in non_opaque_inference_results : name = getattr ( owner , \"name\" , None ) if _is_owner_ignored ( owner , name , self . config . ignored_classes , self . config . ignored_modules ) : continue try : if not [ n for n in owner . getattr ( node . attrname ) if not isinstance ( n . statement ( ) , astroid . AugAssign ) ] : missingattr . add ( ( owner , name ) ) continue except AttributeError : # XXX method / function continue except exceptions . NotFoundError : # This can't be moved before the actual .getattr call, # because there can be more values inferred and we are # stopping after the first one which has the attribute in question. # The problem is that if the first one has the attribute, # but we continue to the next values which doesn't have the # attribute, then we'll have a false positive. # So call this only after the call has been made. if not _emit_no_member ( node , owner , name , ignored_mixins = self . config . ignore_mixin_members , ignored_none = self . config . ignore_none , ) : continue missingattr . add ( ( owner , name ) ) continue # stop on the first found break else : # we have not found any node with the attributes, display the # message for infered nodes done = set ( ) for owner , name in missingattr : if isinstance ( owner , astroid . Instance ) : actual = owner . _proxied else : actual = owner if actual in done : continue done . add ( actual ) msg , hint = self . _get_nomember_msgid_hint ( node , owner ) self . add_message ( msg , node = node , args = ( owner . display_type ( ) , name , node . attrname , hint ) , confidence = INFERENCE , )", "nl": "check that the accessed attribute exists"}}
{"translation": {"code": "def _display ( self , layout ) : print ( file = self . out ) TextWriter ( ) . format ( layout , self . out )", "nl": "launch layouts display"}}
{"translation": {"code": "def set_current_module ( self , modname , filepath = None ) : if not modname and filepath is None : return self . reporter . on_set_current_module ( modname , filepath ) self . current_name = modname self . current_file = filepath or modname self . stats [ \"by_module\" ] [ modname ] = { } self . stats [ \"by_module\" ] [ modname ] [ \"statement\" ] = 0 for msg_cat in MSG_TYPES . values ( ) : self . stats [ \"by_module\" ] [ modname ] [ msg_cat ] = 0", "nl": "set the name of the currently analyzed module and init statistics for it"}}
{"translation": {"code": "def _report_evaluation ( self ) : # check with at least check 1 statements (usually 0 when there is a # syntax error preventing pylint from further processing) previous_stats = config . load_results ( self . file_state . base_name ) if self . stats [ \"statement\" ] == 0 : return # get a global note for the code evaluation = self . config . evaluation try : note = eval ( evaluation , { } , self . stats ) # pylint: disable=eval-used except Exception as ex : msg = \"An exception occurred while rating: %s\" % ex else : self . stats [ \"global_note\" ] = note msg = \"Your code has been rated at %.2f/10\" % note pnote = previous_stats . get ( \"global_note\" ) if pnote is not None : msg += \" (previous run: %.2f/10, %+.2f)\" % ( pnote , note - pnote ) if self . config . score : sect = report_nodes . EvaluationSection ( msg ) self . reporter . display_reports ( sect )", "nl": "make the global evaluation report"}}
{"translation": {"code": "def cb_help_message ( self , option , optname , value , parser ) : self . linter . msgs_store . help_message ( utils . _splitstrip ( value ) ) sys . exit ( 0 )", "nl": "optik callback for printing some help about a particular message"}}
{"translation": {"code": "def cb_list_messages ( self , option , optname , value , parser ) : # FIXME self . linter . msgs_store . list_messages ( ) sys . exit ( 0 )", "nl": "optik callback for printing available messages"}}
{"translation": {"code": "def visit_global ( self , node ) : frame = node . frame ( ) if isinstance ( frame , astroid . Module ) : self . add_message ( \"global-at-module-level\" , node = node ) return module = frame . root ( ) default_message = True locals_ = node . scope ( ) . locals for name in node . names : try : assign_nodes = module . getattr ( name ) except astroid . NotFoundError : # unassigned global, skip assign_nodes = [ ] not_defined_locally_by_import = not any ( isinstance ( local , astroid . node_classes . Import ) for local in locals_ . get ( name , ( ) ) ) if not assign_nodes and not_defined_locally_by_import : self . add_message ( \"global-variable-not-assigned\" , args = name , node = node ) default_message = False continue for anode in assign_nodes : if ( isinstance ( anode , astroid . AssignName ) and anode . name in module . special_attributes ) : self . add_message ( \"redefined-builtin\" , args = name , node = node ) break if anode . frame ( ) is module : # module level assignment break else : if not_defined_locally_by_import : # global undefined at the module scope self . add_message ( \"global-variable-undefined\" , args = name , node = node ) default_message = False if default_message : self . add_message ( \"global-statement\" , node = node )", "nl": "check names imported exists in the global scope"}}
{"translation": {"code": "def get_diadefs ( self , project , linker ) : #  read and interpret diagram definitions (Diadefs) diagrams = [ ] generator = ClassDiadefGenerator ( linker , self ) for klass in self . config . classes : diagrams . append ( generator . class_diagram ( project , klass ) ) if not diagrams : diagrams = DefaultDiadefGenerator ( linker , self ) . visit ( project ) for diagram in diagrams : diagram . extract_relationships ( ) return diagrams", "nl": "Get the diagrams configuration data"}}
{"translation": {"code": "def class_diagram ( self , project , klass ) : self . classdiagram = ClassDiagram ( klass , self . config . mode ) if len ( project . modules ) > 1 : module , klass = klass . rsplit ( \".\" , 1 ) module = project . get_module ( module ) else : module = project . modules [ 0 ] klass = klass . split ( \".\" ) [ - 1 ] klass = next ( module . ilookup ( klass ) ) anc_level , association_level = self . _get_levels ( ) self . extract_classes ( klass , anc_level , association_level ) return self . classdiagram", "nl": "return a class diagram definition for the given klass and its related klasses"}}
{"translation": {"code": "def install ( * * kwargs ) : if USE_SETUPTOOLS : if \"--force-manifest\" in sys . argv : sys . argv . remove ( \"--force-manifest\" ) packages = [ modname ] + get_packages ( join ( base_dir , \"pylint\" ) , modname ) if USE_SETUPTOOLS : if install_requires : kwargs [ \"install_requires\" ] = install_requires kwargs [ \"dependency_links\" ] = dependency_links kwargs [ \"entry_points\" ] = { \"console_scripts\" : [ \"pylint = pylint:run_pylint\" , \"epylint = pylint:run_epylint\" , \"pyreverse = pylint:run_pyreverse\" , \"symilar = pylint:run_symilar\" , ] } kwargs [ \"packages\" ] = packages cmdclass = { \"install_lib\" : MyInstallLib , \"build_py\" : build_py } if easy_install_lib : cmdclass [ \"easy_install\" ] = easy_install return setup ( name = distname , version = __pkginfo__ [ \"version\" ] , license = __pkginfo__ [ \"license\" ] , description = __pkginfo__ [ \"description\" ] , long_description = long_description , author = __pkginfo__ [ \"author\" ] , author_email = __pkginfo__ [ \"author_email\" ] , url = __pkginfo__ [ \"web\" ] , scripts = ensure_scripts ( scripts ) , classifiers = __pkginfo__ [ \"classifiers\" ] , data_files = data_files , ext_modules = ext_modules , cmdclass = cmdclass , extras_require = extras_require , test_suite = \"test\" , python_requires = \">=3.4.*\" , setup_requires = [ \"pytest-runner\" ] , tests_require = [ \"pytest\" ] , * * kwargs )", "nl": "setup entry point"}}
{"translation": {"code": "def check_astroid_module ( self , ast_node , walker , rawcheckers , tokencheckers ) : try : tokens = utils . tokenize_module ( ast_node ) except tokenize . TokenError as ex : self . add_message ( \"syntax-error\" , line = ex . args [ 1 ] [ 0 ] , args = ex . args [ 0 ] ) return None if not ast_node . pure_python : self . add_message ( \"raw-checker-failed\" , args = ast_node . name ) else : # assert astroid.file.endswith('.py') # invoke ITokenChecker interface on self to fetch module/block # level options self . process_tokens ( tokens ) if self . _ignore_file : return False # walk ast to collect line numbers self . file_state . collect_block_lines ( self . msgs_store , ast_node ) # run raw and tokens checkers for checker in rawcheckers : checker . process_module ( ast_node ) for checker in tokencheckers : checker . process_tokens ( tokens ) # generate events to astroid checkers walker . walk ( ast_node ) return True", "nl": "Check a module from its astroid representation ."}}
{"translation": {"code": "def _check_signature ( self , method1 , refmethod , class_type , cls ) : if not ( isinstance ( method1 , astroid . FunctionDef ) and isinstance ( refmethod , astroid . FunctionDef ) ) : self . add_message ( \"method-check-failed\" , args = ( method1 , refmethod ) , node = method1 ) return instance = cls . instantiate_class ( ) method1 = function_to_method ( method1 , instance ) refmethod = function_to_method ( refmethod , instance ) # Don't care about functions with unknown argument (builtins). if method1 . args . args is None or refmethod . args . args is None : return # Ignore private to class methods. if is_attr_private ( method1 . name ) : return # Ignore setters, they have an implicit extra argument, # which shouldn't be taken in consideration. if method1 . decorators : for decorator in method1 . decorators . nodes : if ( isinstance ( decorator , astroid . Attribute ) and decorator . attrname == \"setter\" ) : return if _different_parameters ( refmethod , method1 , dummy_parameter_regex = self . _dummy_rgx ) : self . add_message ( \"arguments-differ\" , args = ( class_type , method1 . name ) , node = method1 ) elif len ( method1 . args . defaults ) < len ( refmethod . args . defaults ) : self . add_message ( \"signature-differs\" , args = ( class_type , method1 . name ) , node = method1 )", "nl": "check that the signature of the two given methods match"}}
{"translation": {"code": "def _report_external_dependencies ( self , sect , _ , _dummy ) : dep_info = _make_tree_defs ( self . _external_dependencies_info ( ) . items ( ) ) if not dep_info : raise EmptyReportError ( ) tree_str = _repr_tree_defs ( dep_info ) sect . append ( VerbatimText ( tree_str ) )", "nl": "return a verbatim layout for displaying dependencies"}}
{"translation": {"code": "def _add_imported_module ( self , node , importedmodname ) : module_file = node . root ( ) . file context_name = node . root ( ) . name base = os . path . splitext ( os . path . basename ( module_file ) ) [ 0 ] try : importedmodname = astroid . modutils . get_module_part ( importedmodname , module_file ) except ImportError : pass if context_name == importedmodname : self . add_message ( \"import-self\" , node = node ) elif not astroid . modutils . is_standard_module ( importedmodname ) : # if this is not a package __init__ module if base != \"__init__\" and context_name not in self . _module_pkg : # record the module's parent, or the module itself if this is # a top level module, as the package it belongs to self . _module_pkg [ context_name ] = context_name . rsplit ( \".\" , 1 ) [ 0 ] # handle dependencies importedmodnames = self . stats [ \"dependencies\" ] . setdefault ( importedmodname , set ( ) ) if context_name not in importedmodnames : importedmodnames . add ( context_name ) # update import graph self . import_graph [ context_name ] . add ( importedmodname ) if not self . linter . is_message_enabled ( \"cyclic-import\" , line = node . lineno ) : self . _excluded_edges [ context_name ] . add ( importedmodname )", "nl": "notify an imported module used to analyze dependencies"}}
{"translation": {"code": "def module ( self , name ) : for mod in self . modules ( ) : if mod . node . name == name : return mod raise KeyError ( name )", "nl": "return a module by its name raise KeyError if not found"}}
{"translation": {"code": "def modules ( self ) : return [ o for o in self . objects if isinstance ( o . node , astroid . Module ) ]", "nl": "return all module nodes in the diagram"}}
{"translation": {"code": "def classe ( self , name ) : for klass in self . classes ( ) : if klass . node . name == name : return klass raise KeyError ( name )", "nl": "return a class by its name raise KeyError if not found"}}
{"translation": {"code": "def is_error ( node : astroid . node_classes . NodeNG ) -> bool : for child_node in node . get_children ( ) : if isinstance ( child_node , astroid . Raise ) : return True return False", "nl": "return true if the function does nothing but raising an exception"}}
{"translation": {"code": "def is_default_argument ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . scope ( ) if isinstance ( parent , ( astroid . FunctionDef , astroid . Lambda ) ) : for default_node in parent . args . defaults : for default_name_node in default_node . nodes_of_class ( astroid . Name ) : if default_name_node is node : return True return False", "nl": "return true if the given Name node is used in function or lambda default argument s value"}}
{"translation": {"code": "def classes ( self ) : return [ o for o in self . objects if isinstance ( o . node , astroid . ClassDef ) ]", "nl": "return all class nodes in the diagram"}}
{"translation": {"code": "def is_ancestor_name ( frame : astroid . node_classes . NodeNG , node : astroid . node_classes . NodeNG ) -> bool : try : bases = frame . bases except AttributeError : return False for base in bases : if node in base . nodes_of_class ( astroid . Name ) : return True return False", "nl": "return True if frame is an astroid . Class node with node in the subtree of its bases attribute"}}
{"translation": {"code": "def assign_parent ( node : astroid . node_classes . NodeNG ) -> astroid . node_classes . NodeNG : while node and isinstance ( node , ( astroid . AssignName , astroid . Tuple , astroid . List ) ) : node = node . parent return node", "nl": "return the higher parent which is not an AssignName Tuple or List node"}}
{"translation": {"code": "def add_object ( self , title , node ) : assert node not in self . _nodes ent = DiagramEntity ( title , node ) self . _nodes [ node ] = ent self . objects . append ( ent )", "nl": "create a diagram object"}}
{"translation": {"code": "def get_relationship ( self , from_object , relation_type ) : for rel in self . relationships . get ( relation_type , ( ) ) : if rel . from_object is from_object : return rel raise KeyError ( relation_type )", "nl": "return a relation ship or None"}}
{"translation": {"code": "def add_relationship ( self , from_object , to_object , relation_type , name = None ) : rel = Relationship ( from_object , to_object , relation_type , name ) self . relationships . setdefault ( relation_type , [ ] ) . append ( rel )", "nl": "create a relation ship"}}
{"translation": {"code": "def _check_unreachable ( self , node ) : unreach_stmt = node . next_sibling ( ) if unreach_stmt is not None : self . add_message ( \"unreachable\" , node = unreach_stmt )", "nl": "check unreachable code"}}
{"translation": {"code": "def _check_deprecated_module ( self , node , mod_path ) : for mod_name in self . config . deprecated_modules : if mod_path == mod_name or mod_path . startswith ( mod_name + \".\" ) : self . add_message ( \"deprecated-module\" , node = node , args = mod_path )", "nl": "check if the module is deprecated"}}
{"translation": {"code": "def report_by_type_stats ( sect , stats , _ ) : # percentage of different types documented and/or with a bad name nice_stats = { } for node_type in ( \"module\" , \"class\" , \"method\" , \"function\" ) : try : total = stats [ node_type ] except KeyError : raise exceptions . EmptyReportError ( ) nice_stats [ node_type ] = { } if total != 0 : try : documented = total - stats [ \"undocumented_\" + node_type ] percent = ( documented * 100.0 ) / total nice_stats [ node_type ] [ \"percent_documented\" ] = \"%.2f\" % percent except KeyError : nice_stats [ node_type ] [ \"percent_documented\" ] = \"NC\" try : percent = ( stats [ \"badname_\" + node_type ] * 100.0 ) / total nice_stats [ node_type ] [ \"percent_badname\" ] = \"%.2f\" % percent except KeyError : nice_stats [ node_type ] [ \"percent_badname\" ] = \"NC\" lines = ( \"type\" , \"number\" , \"old number\" , \"difference\" , \"%documented\" , \"%badname\" ) for node_type in ( \"module\" , \"class\" , \"method\" , \"function\" ) : new = stats [ node_type ] lines += ( node_type , str ( new ) , \"NC\" , \"NC\" , nice_stats [ node_type ] . get ( \"percent_documented\" , \"0\" ) , nice_stats [ node_type ] . get ( \"percent_badname\" , \"0\" ) , ) sect . append ( reporter_nodes . Table ( children = lines , cols = 6 , rheaders = 1 ) )", "nl": "make a report of"}}
{"translation": {"code": "def in_loop ( node ) : parent = node . parent while parent is not None : if isinstance ( parent , ( astroid . For , astroid . ListComp , astroid . SetComp , astroid . DictComp , astroid . GeneratorExp , ) , ) : return True parent = parent . parent return False", "nl": "return True if the node is inside a kind of for loop"}}
{"translation": {"code": "def open ( self ) : self . _tryfinallys = [ ] self . stats = self . linter . add_stats ( module = 0 , function = 0 , method = 0 , class_ = 0 )", "nl": "initialize visit variables and statistics"}}
{"translation": {"code": "def check_indent_level ( self , string , expected , line_num ) : indent = self . config . indent_string if indent == \"\\\\t\" : # \\t is not interpreted in the configuration file indent = \"\\t\" level = 0 unit_size = len ( indent ) while string [ : unit_size ] == indent : string = string [ unit_size : ] level += 1 suppl = \"\" while string and string [ 0 ] in \" \\t\" : if string [ 0 ] != indent [ 0 ] : if string [ 0 ] == \"\\t\" : args = ( \"tab\" , \"space\" ) else : args = ( \"space\" , \"tab\" ) self . add_message ( \"mixed-indentation\" , args = args , line = line_num ) return level suppl += string [ 0 ] string = string [ 1 : ] if level != expected or suppl : i_type = \"spaces\" if indent [ 0 ] == \"\\t\" : i_type = \"tabs\" self . add_message ( \"bad-indentation\" , line = line_num , args = ( level * unit_size + len ( suppl ) , i_type , expected * unit_size ) , ) return None", "nl": "return the indent level of the string"}}
{"translation": {"code": "def _check_relative_import ( self , modnode , importnode , importedmodnode , importedasname ) : if not self . linter . is_message_enabled ( \"relative-import\" ) : return None if importedmodnode . file is None : return False # built-in module if modnode is importedmodnode : return False # module importing itself if modnode . absolute_import_activated ( ) or getattr ( importnode , \"level\" , None ) : return False if importedmodnode . name != importedasname : # this must be a relative import... self . add_message ( \"relative-import\" , args = ( importedasname , importedmodnode . name ) , node = importnode , ) return None return None", "nl": "check relative import . node is either an Import or From node modname the imported module name ."}}
{"translation": {"code": "def visit_functiondef ( self , node ) : # ignore actual functions or method within a new style class if not node . is_method ( ) : return klass = node . parent . frame ( ) for stmt in node . nodes_of_class ( astroid . Call ) : if node_frame_class ( stmt ) != node_frame_class ( node ) : # Don't look down in other scopes. continue expr = stmt . func if not isinstance ( expr , astroid . Attribute ) : continue call = expr . expr # skip the test if using super if not ( isinstance ( call , astroid . Call ) and isinstance ( call . func , astroid . Name ) and call . func . name == \"super\" ) : continue if not klass . newstyle and has_known_bases ( klass ) : # super should not be used on an old style class continue else : # super first arg should be the class if not call . args : if sys . version_info [ 0 ] == 3 : # unless Python 3 continue else : self . add_message ( \"missing-super-argument\" , node = call ) continue # calling super(type(self), self) can lead to recursion loop # in derived classes arg0 = call . args [ 0 ] if ( isinstance ( arg0 , astroid . Call ) and isinstance ( arg0 . func , astroid . Name ) and arg0 . func . name == \"type\" ) : self . add_message ( \"bad-super-call\" , node = call , args = ( \"type\" , ) ) continue # calling super(self.__class__, self) can lead to recursion loop # in derived classes if ( len ( call . args ) >= 2 and isinstance ( call . args [ 1 ] , astroid . Name ) and call . args [ 1 ] . name == \"self\" and isinstance ( arg0 , astroid . Attribute ) and arg0 . attrname == \"__class__\" ) : self . add_message ( \"bad-super-call\" , node = call , args = ( \"self.__class__\" , ) ) continue try : supcls = call . args and next ( call . args [ 0 ] . infer ( ) , None ) except astroid . InferenceError : continue if klass is not supcls : name = None # if supcls is not Uninferable, then supcls was infered # and use its name. Otherwise, try to look # for call.args[0].name if supcls : name = supcls . name elif call . args and hasattr ( call . args [ 0 ] , \"name\" ) : name = call . args [ 0 ] . name if name : self . add_message ( \"bad-super-call\" , node = call , args = ( name , ) )", "nl": "check use of super"}}
{"translation": {"code": "def open ( self ) : self . stats = self . linter . add_stats ( ) self . _returns = [ ] self . _branches = defaultdict ( int ) self . _stmts = [ ]", "nl": "initialize visit variables"}}
{"translation": {"code": "def visit_classdef ( self , node ) : nb_parents = len ( list ( node . ancestors ( ) ) ) if nb_parents > self . config . max_parents : self . add_message ( \"too-many-ancestors\" , node = node , args = ( nb_parents , self . config . max_parents ) , ) if len ( node . instance_attrs ) > self . config . max_attributes : self . add_message ( \"too-many-instance-attributes\" , node = node , args = ( len ( node . instance_attrs ) , self . config . max_attributes ) , )", "nl": "check size of inheritance hierarchy and number of instance attributes"}}
{"translation": {"code": "def visit_importfrom ( self , node ) : basename = node . modname imported_module = self . _get_imported_module ( node , basename ) self . _check_import_as_rename ( node ) self . _check_misplaced_future ( node ) self . _check_deprecated_module ( node , basename ) self . _check_preferred_module ( node , basename ) self . _check_wildcard_imports ( node , imported_module ) self . _check_same_line_imports ( node ) self . _check_reimport ( node , basename = basename , level = node . level ) if isinstance ( node . parent , astroid . Module ) : # Allow imports nested self . _check_position ( node ) if isinstance ( node . scope ( ) , astroid . Module ) : self . _record_import ( node , imported_module ) if imported_module is None : return modnode = node . root ( ) self . _check_relative_import ( modnode , node , imported_module , basename ) for name , _ in node . names : if name != \"*\" : self . _add_imported_module ( node , \"%s.%s\" % ( imported_module . name , name ) ) else : self . _add_imported_module ( node , imported_module . name )", "nl": "triggered when a from statement is seen"}}
{"translation": {"code": "def visit_import ( self , node ) : self . _check_reimport ( node ) self . _check_import_as_rename ( node ) modnode = node . root ( ) names = [ name for name , _ in node . names ] if len ( names ) >= 2 : self . add_message ( \"multiple-imports\" , args = \", \" . join ( names ) , node = node ) for name in names : self . _check_deprecated_module ( node , name ) self . _check_preferred_module ( node , name ) imported_module = self . _get_imported_module ( node , name ) if isinstance ( node . parent , astroid . Module ) : # Allow imports nested self . _check_position ( node ) if isinstance ( node . scope ( ) , astroid . Module ) : self . _record_import ( node , imported_module ) if imported_module is None : continue self . _check_relative_import ( modnode , node , imported_module , name ) self . _add_imported_module ( node , imported_module . name )", "nl": "triggered when an import statement is seen"}}
{"translation": {"code": "def _make_graph ( filename , dep_info , sect , gtype ) : _dependencies_graph ( filename , dep_info ) sect . append ( Paragraph ( \"%simports graph has been written to %s\" % ( gtype , filename ) ) )", "nl": "generate a dependencies graph and add some information about it in the report s section"}}
{"translation": {"code": "def find_pylintrc ( ) : # is there a pylint rc file in the current directory ? if os . path . exists ( \"pylintrc\" ) : return os . path . abspath ( \"pylintrc\" ) if os . path . exists ( \".pylintrc\" ) : return os . path . abspath ( \".pylintrc\" ) if os . path . isfile ( \"__init__.py\" ) : curdir = os . path . abspath ( os . getcwd ( ) ) while os . path . isfile ( os . path . join ( curdir , \"__init__.py\" ) ) : curdir = os . path . abspath ( os . path . join ( curdir , \"..\" ) ) if os . path . isfile ( os . path . join ( curdir , \"pylintrc\" ) ) : return os . path . join ( curdir , \"pylintrc\" ) if os . path . isfile ( os . path . join ( curdir , \".pylintrc\" ) ) : return os . path . join ( curdir , \".pylintrc\" ) if \"PYLINTRC\" in os . environ and os . path . exists ( os . environ [ \"PYLINTRC\" ] ) : pylintrc = os . environ [ \"PYLINTRC\" ] else : user_home = os . path . expanduser ( \"~\" ) if user_home in ( \"~\" , \"/root\" ) : pylintrc = \".pylintrc\" else : pylintrc = os . path . join ( user_home , \".pylintrc\" ) if not os . path . isfile ( pylintrc ) : pylintrc = os . path . join ( user_home , \".config\" , \"pylintrc\" ) if not os . path . isfile ( pylintrc ) : if os . path . isfile ( \"/etc/pylintrc\" ) : pylintrc = \"/etc/pylintrc\" else : pylintrc = None return pylintrc", "nl": "search the pylint rc file and return its path if it find it else None"}}
{"translation": {"code": "def _repr_tree_defs ( data , indent_str = None ) : lines = [ ] nodes = data . items ( ) for i , ( mod , ( sub , files ) ) in enumerate ( sorted ( nodes , key = lambda x : x [ 0 ] ) ) : if not files : files = \"\" else : files = \"(%s)\" % \",\" . join ( sorted ( files ) ) if indent_str is None : lines . append ( \"%s %s\" % ( mod , files ) ) sub_indent_str = \"  \" else : lines . append ( r\"%s\\-%s %s\" % ( indent_str , mod , files ) ) if i == len ( nodes ) - 1 : sub_indent_str = \"%s  \" % indent_str else : sub_indent_str = \"%s| \" % indent_str if sub : lines . append ( _repr_tree_defs ( sub , sub_indent_str ) ) return \"\\n\" . join ( lines )", "nl": "return a string which represents imports as a tree"}}
{"translation": {"code": "def visit_if ( self , node ) : self . _check_boolean_expressions ( node ) branches = 1 # don't double count If nodes coming from some 'elif' if node . orelse and ( len ( node . orelse ) > 1 or not isinstance ( node . orelse [ 0 ] , If ) ) : branches += 1 self . _inc_branch ( node , branches ) self . _inc_all_stmts ( branches )", "nl": "increments the branches counter and checks boolean expressions"}}
{"translation": {"code": "def new_line ( self , tokens , line_end , line_start ) : if _last_token_on_line_is ( tokens , line_end , \";\" ) : self . add_message ( \"unnecessary-semicolon\" , line = tokens . start_line ( line_end ) ) line_num = tokens . start_line ( line_start ) line = tokens . line ( line_start ) if tokens . type ( line_start ) not in _JUNK_TOKENS : self . _lines [ line_num ] = line . split ( \"\\n\" ) [ 0 ] self . check_lines ( line , line_num )", "nl": "a new line has been encountered process it if necessary"}}
{"translation": {"code": "def visit_default ( self , node ) : if not node . is_statement : return if not node . root ( ) . pure_python : return # XXX block visit of child nodes prev_sibl = node . previous_sibling ( ) if prev_sibl is not None : prev_line = prev_sibl . fromlineno else : # The line on which a finally: occurs in a try/finally # is not directly represented in the AST. We infer it # by taking the last line of the body and adding 1, which # should be the line of finally: if ( isinstance ( node . parent , nodes . TryFinally ) and node in node . parent . finalbody ) : prev_line = node . parent . body [ 0 ] . tolineno + 1 else : prev_line = node . parent . statement ( ) . fromlineno line = node . fromlineno assert line , node if prev_line == line and self . _visited_lines . get ( line ) != 2 : self . _check_multi_statement_line ( node , line ) return if line in self . _visited_lines : return try : tolineno = node . blockstart_tolineno except AttributeError : tolineno = node . tolineno assert tolineno , node lines = [ ] for line in range ( line , tolineno + 1 ) : self . _visited_lines [ line ] = 1 try : lines . append ( self . _lines [ line ] . rstrip ( ) ) except KeyError : lines . append ( \"\" )", "nl": "check the node line number and check it if not yet done"}}
{"translation": {"code": "def check_lines ( self , lines , i ) : max_chars = self . config . max_line_length ignore_long_line = self . config . ignore_long_lines def check_line ( line , i ) : if not line . endswith ( \"\\n\" ) : self . add_message ( \"missing-final-newline\" , line = i ) else : # exclude \\f (formfeed) from the rstrip stripped_line = line . rstrip ( \"\\t\\n\\r\\v \" ) if not stripped_line and _EMPTY_LINE in self . config . no_space_check : # allow empty lines pass elif line [ len ( stripped_line ) : ] not in ( \"\\n\" , \"\\r\\n\" ) : self . add_message ( \"trailing-whitespace\" , line = i , col_offset = len ( stripped_line ) ) # Don't count excess whitespace in the line length. line = stripped_line mobj = OPTION_RGX . search ( line ) if mobj and \"=\" in line : front_of_equal , _ , back_of_equal = mobj . group ( 1 ) . partition ( \"=\" ) if front_of_equal . strip ( ) == \"disable\" : if \"line-too-long\" in { _msg_id . strip ( ) for _msg_id in back_of_equal . split ( \",\" ) } : return None line = line . rsplit ( \"#\" , 1 ) [ 0 ] . rstrip ( ) if len ( line ) > max_chars and not ignore_long_line . search ( line ) : self . add_message ( \"line-too-long\" , line = i , args = ( len ( line ) , max_chars ) ) return i + 1 unsplit_ends = { \"\\v\" , \"\\x0b\" , \"\\f\" , \"\\x0c\" , \"\\x1c\" , \"\\x1d\" , \"\\x1e\" , \"\\x85\" , \"\\u2028\" , \"\\u2029\" , } unsplit = [ ] for line in lines . splitlines ( True ) : if line [ - 1 ] in unsplit_ends : unsplit . append ( line ) continue if unsplit : unsplit . append ( line ) line = \"\" . join ( unsplit ) unsplit = [ ] i = check_line ( line , i ) if i is None : break if unsplit : check_line ( \"\" . join ( unsplit ) , i )", "nl": "check lines have less than a maximum number of characters"}}
{"translation": {"code": "def leave_classdef ( self , node ) : my_methods = sum ( 1 for method in node . mymethods ( ) if not method . name . startswith ( \"_\" ) ) # Does the class contain less than n public methods ? # This checks only the methods defined in the current class, # since the user might not have control over the classes # from the ancestors. It avoids some false positives # for classes such as unittest.TestCase, which provides # a lot of assert methods. It doesn't make sense to warn # when the user subclasses TestCase to add his own tests. if my_methods > self . config . max_public_methods : self . add_message ( \"too-many-public-methods\" , node = node , args = ( my_methods , self . config . max_public_methods ) , ) # Stop here for exception, metaclass, interface classes and other # classes for which we don't need to count the methods. if ( node . type != \"class\" or _is_enum_class ( node ) or _is_dataclass ( node ) or _is_typing_namedtuple ( node ) ) : return # Does the class contain more than n public methods ? # This checks all the methods defined by ancestors and # by the current class. all_methods = _count_methods_in_class ( node ) if all_methods < self . config . min_public_methods : self . add_message ( \"too-few-public-methods\" , node = node , args = ( all_methods , self . config . min_public_methods ) , )", "nl": "check number of public methods"}}
{"translation": {"code": "def handle_message ( self , msg ) : if msg . module not in self . _modules : if msg . module : self . writeln ( \"************* Module %s\" % msg . module ) self . _modules . add ( msg . module ) else : self . writeln ( \"************* \" ) self . write_message ( msg )", "nl": "manage message of different type and in the context of path"}}
{"translation": {"code": "def is_super ( node : astroid . node_classes . NodeNG ) -> bool : if getattr ( node , \"name\" , None ) == \"super\" and node . root ( ) . name == BUILTINS_NAME : return True return False", "nl": "return True if the node is referencing the super builtin function"}}
{"translation": {"code": "def visit_expr ( self , node ) : expr = node . value if isinstance ( expr , astroid . Const ) and isinstance ( expr . value , str ) : # treat string statement in a separated message # Handle PEP-257 attribute docstrings. # An attribute docstring is defined as being a string right after # an assignment at the module level, class level or __init__ level. scope = expr . scope ( ) if isinstance ( scope , ( astroid . ClassDef , astroid . Module , astroid . FunctionDef ) ) : if isinstance ( scope , astroid . FunctionDef ) and scope . name != \"__init__\" : pass else : sibling = expr . previous_sibling ( ) if ( sibling is not None and sibling . scope ( ) is scope and isinstance ( sibling , ( astroid . Assign , astroid . AnnAssign ) ) ) : return self . add_message ( \"pointless-string-statement\" , node = node ) return # Ignore if this is : # * a direct function call # * the unique child of a try/except body # * a yieldd statement # * an ellipsis (which can be used on Python 3 instead of pass) # warn W0106 if we have any underlying function call (we can't predict # side effects), else pointless-statement if isinstance ( expr , ( astroid . Yield , astroid . Await , astroid . Ellipsis , astroid . Call ) ) or ( isinstance ( node . parent , astroid . TryExcept ) and node . parent . body == [ node ] ) : return if any ( expr . nodes_of_class ( astroid . Call ) ) : self . add_message ( \"expression-not-assigned\" , node = node , args = expr . as_string ( ) ) else : self . add_message ( \"pointless-statement\" , node = node )", "nl": "check for various kind of statements without effect"}}
{"translation": {"code": "def expand_files ( self , modules ) : result , errors = utils . expand_modules ( modules , self . config . black_list , self . config . black_list_re ) for error in errors : message = modname = error [ \"mod\" ] key = error [ \"key\" ] self . set_current_module ( modname ) if key == \"fatal\" : message = str ( error [ \"ex\" ] ) . replace ( os . getcwd ( ) + os . sep , \"\" ) self . add_message ( key , args = message ) return result", "nl": "get modules and errors from a list of modules and handle errors"}}
{"translation": {"code": "def get_title ( self , node ) : title = node . name if self . module_names : title = \"%s.%s\" % ( node . root ( ) . name , title ) return title", "nl": "get title for objects"}}
{"translation": {"code": "def get_methods ( self , node ) : methods = [ m for m in node . values ( ) if isinstance ( m , astroid . FunctionDef ) and not decorated_with_property ( m ) and self . show_attr ( m . name ) ] return sorted ( methods , key = lambda n : n . name )", "nl": "return visible methods"}}
{"translation": {"code": "def get_attrs ( self , node ) : attrs = [ ] properties = [ ( n , m ) for n , m in node . items ( ) if isinstance ( m , astroid . FunctionDef ) and decorated_with_property ( m ) ] for node_name , associated_nodes in ( list ( node . instance_attrs_type . items ( ) ) + list ( node . locals_type . items ( ) ) + properties ) : if not self . show_attr ( node_name ) : continue names = self . class_names ( associated_nodes ) if names : node_name = \"%s : %s\" % ( node_name , \", \" . join ( names ) ) attrs . append ( node_name ) return sorted ( attrs )", "nl": "return visible attributes possibly with class name"}}
{"translation": {"code": "def class_names ( self , nodes ) : names = [ ] for node in nodes : if isinstance ( node , astroid . Instance ) : node = node . _proxied if ( isinstance ( node , astroid . ClassDef ) and hasattr ( node , \"name\" ) and not self . has_node ( node ) ) : if node . name not in names : node_name = node . name names . append ( node_name ) return names", "nl": "return class names if needed in diagram"}}
{"translation": {"code": "def add_from_depend ( self , node , from_module ) : mod_name = node . root ( ) . name obj = self . module ( mod_name ) if from_module not in obj . node . depends : obj . node . depends . append ( from_module )", "nl": "add dependencies created by from - imports"}}
{"translation": {"code": "def visit_importfrom ( self , node ) : if self . pkgdiagram : self . pkgdiagram . add_from_depend ( node , node . modname )", "nl": "visit astroid . ImportFrom and catch modules for package diagram"}}
{"translation": {"code": "def write_packages ( self , diagram ) : # sorted to get predictable (hence testable) results for i , obj in enumerate ( sorted ( diagram . modules ( ) , key = lambda x : x . title ) ) : self . printer . emit_node ( i , label = self . get_title ( obj ) , shape = \"box\" ) obj . fig_id = i # package dependencies for rel in diagram . get_relationships ( \"depends\" ) : self . printer . emit_edge ( rel . from_object . fig_id , rel . to_object . fig_id , * * self . pkg_edges )", "nl": "write a package diagram"}}
{"translation": {"code": "def set_printer ( self , file_name , basename ) : self . graph_file = open ( file_name , \"w+\" ) self . printer = VCGPrinter ( self . graph_file ) self . printer . open_graph ( title = basename , layoutalgorithm = \"dfs\" , late_edge_labels = \"yes\" , port_sharing = \"no\" , manhattan_edges = \"yes\" , ) self . printer . emit_node = self . printer . node self . printer . emit_edge = self . printer . edge", "nl": "initialize VCGWriter for a UML graph"}}
{"translation": {"code": "def set_printer ( self , file_name , basename ) : layout = dict ( rankdir = \"BT\" ) self . printer = DotBackend ( basename , additional_param = layout ) self . file_name = file_name", "nl": "initialize DotWriter and add options for layout ."}}
{"translation": {"code": "def write_classes ( self , diagram ) : # sorted to get predictable (hence testable) results for i , obj in enumerate ( sorted ( diagram . objects , key = lambda x : x . title ) ) : self . printer . emit_node ( i , * * self . get_values ( obj ) ) obj . fig_id = i # inheritance links for rel in diagram . get_relationships ( \"specialization\" ) : self . printer . emit_edge ( rel . from_object . fig_id , rel . to_object . fig_id , * * self . inh_edges ) # implementation links for rel in diagram . get_relationships ( \"implements\" ) : self . printer . emit_edge ( rel . from_object . fig_id , rel . to_object . fig_id , * * self . imp_edges ) # generate associations for rel in diagram . get_relationships ( \"association\" ) : self . printer . emit_edge ( rel . from_object . fig_id , rel . to_object . fig_id , label = rel . name , * * self . association_edges )", "nl": "write a class diagram"}}
{"translation": {"code": "def _set_default_options ( self ) : self . module_names = self . _set_option ( self . config . module_names ) all_ancestors = self . _set_option ( self . config . all_ancestors ) all_associated = self . _set_option ( self . config . all_associated ) anc_level , association_level = ( 0 , 0 ) if all_ancestors : anc_level = - 1 if all_associated : association_level = - 1 if self . config . show_ancestors is not None : anc_level = self . config . show_ancestors if self . config . show_associated is not None : association_level = self . config . show_associated self . anc_level , self . association_level = anc_level , association_level", "nl": "set different default options with _default dictionary"}}
{"translation": {"code": "def get_ancestors ( self , node , level ) : if level == 0 : return for ancestor in node . ancestors ( recurs = False ) : if not self . show_node ( ancestor ) : continue yield ancestor", "nl": "return ancestor nodes of a class node"}}
{"translation": {"code": "def get_associated ( self , klass_node , level ) : if level == 0 : return for association_nodes in list ( klass_node . instance_attrs_type . values ( ) ) + list ( klass_node . locals_type . values ( ) ) : for node in association_nodes : if isinstance ( node , astroid . Instance ) : node = node . _proxied if not ( isinstance ( node , astroid . ClassDef ) and self . show_node ( node ) ) : continue yield node", "nl": "return associated nodes of a class node"}}
{"translation": {"code": "def add_class ( self , node ) : self . linker . visit ( node ) self . classdiagram . add_object ( self . get_title ( node ) , node )", "nl": "visit one class and add it to diagram"}}
{"translation": {"code": "def extract_classes ( self , klass_node , anc_level , association_level ) : if self . classdiagram . has_node ( klass_node ) or not self . show_node ( klass_node ) : return self . add_class ( klass_node ) for ancestor in self . get_ancestors ( klass_node , anc_level ) : self . extract_classes ( ancestor , anc_level - 1 , association_level ) for node in self . get_associated ( klass_node , association_level ) : self . extract_classes ( node , anc_level , association_level - 1 )", "nl": "extract recursively classes related to klass_node"}}
{"translation": {"code": "def show_node ( self , node ) : if self . config . show_builtin : return True return node . root ( ) . name != BUILTINS_NAME", "nl": "true if builtins and not show_builtins"}}
{"translation": {"code": "def get_module ( self , name , node ) : for mod in self . modules ( ) : mod_name = mod . node . name if mod_name == name : return mod # search for fullname of relative import modules package = node . root ( ) . name if mod_name == \"%s.%s\" % ( package , name ) : return mod if mod_name == \"%s.%s\" % ( package . rsplit ( \".\" , 1 ) [ 0 ] , name ) : return mod raise KeyError ( name )", "nl": "return a module by its name looking also for relative imports ; raise KeyError if not found"}}
{"translation": {"code": "def run ( self , args ) : if not args : print ( self . help ( ) ) return 1 # insert current working directory to the python path to recognize # dependencies to local modules even if cwd is not in the PYTHONPATH sys . path . insert ( 0 , os . getcwd ( ) ) try : project = project_from_files ( args , project_name = self . config . project , black_list = self . config . black_list , ) linker = Linker ( project , tag = True ) handler = DiadefsHandler ( self . config ) diadefs = handler . get_diadefs ( project , linker ) finally : sys . path . pop ( 0 ) if self . config . output_format == \"vcg\" : writer . VCGWriter ( self . config ) . write ( diadefs ) else : writer . DotWriter ( self . config ) . write ( diadefs ) return 0", "nl": "checking arguments and run project"}}
{"translation": {"code": "def overridden_method ( klass , name ) : try : parent = next ( klass . local_attr_ancestors ( name ) ) except ( StopIteration , KeyError ) : return None try : meth_node = parent [ name ] except KeyError : # We have found an ancestor defining <name> but it's not in the local # dictionary. This may happen with astroid built from living objects. return None if isinstance ( meth_node , astroid . FunctionDef ) : return meth_node return None", "nl": "get overridden method if any"}}
{"translation": {"code": "def is_func_decorator ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Decorators ) : return True if parent . is_statement or isinstance ( parent , ( astroid . Lambda , scoped_nodes . ComprehensionScope , scoped_nodes . ListComp ) , ) : break parent = parent . parent return False", "nl": "return true if the name is used in function decorator"}}
{"translation": {"code": "def visit_lambda ( self , node ) : # if the body of the lambda is a call expression with the same # argument list as the lambda itself, then the lambda is # possibly unnecessary and at least suspicious. if node . args . defaults : # If the arguments of the lambda include defaults, then a # judgment cannot be made because there is no way to check # that the defaults defined by the lambda are the same as # the defaults defined by the function called in the body # of the lambda. return call = node . body if not isinstance ( call , astroid . Call ) : # The body of the lambda must be a function call expression # for the lambda to be unnecessary. return if isinstance ( node . body . func , astroid . Attribute ) and isinstance ( node . body . func . expr , astroid . Call ) : # Chained call, the intermediate call might # return something else (but we don't check that, yet). return call_site = CallSite . from_call ( call ) ordinary_args = list ( node . args . args ) new_call_args = list ( self . _filter_vararg ( node , call . args ) ) if node . args . kwarg : if self . _has_variadic_argument ( call . kwargs , node . args . kwarg ) : return if node . args . vararg : if self . _has_variadic_argument ( call . starargs , node . args . vararg ) : return elif call . starargs : return if call . keywords : # Look for additional keyword arguments that are not part # of the lambda's signature lambda_kwargs = { keyword . name for keyword in node . args . defaults } if len ( lambda_kwargs ) != len ( call_site . keyword_arguments ) : # Different lengths, so probably not identical return if set ( call_site . keyword_arguments ) . difference ( lambda_kwargs ) : return # The \"ordinary\" arguments must be in a correspondence such that: # ordinary_args[i].name == call.args[i].name. if len ( ordinary_args ) != len ( new_call_args ) : return for arg , passed_arg in zip ( ordinary_args , new_call_args ) : if not isinstance ( passed_arg , astroid . Name ) : return if arg . name != passed_arg . name : return self . add_message ( \"unnecessary-lambda\" , line = node . fromlineno , node = node )", "nl": "check whether or not the lambda is suspicious"}}
{"translation": {"code": "def lint ( filename , options = ( ) ) : # traverse downwards until we are out of a python package full_path = osp . abspath ( filename ) parent_path = osp . dirname ( full_path ) child_path = osp . basename ( full_path ) while parent_path != \"/\" and osp . exists ( osp . join ( parent_path , \"__init__.py\" ) ) : child_path = osp . join ( osp . basename ( parent_path ) , child_path ) parent_path = osp . dirname ( parent_path ) # Start pylint # Ensure we use the python and pylint associated with the running epylint run_cmd = \"import sys; from pylint.lint import Run; Run(sys.argv[1:])\" cmd = ( [ sys . executable , \"-c\" , run_cmd ] + [ \"--msg-template\" , \"{path}:{line}: {category} ({msg_id}, {symbol}, {obj}) {msg}\" , \"-r\" , \"n\" , child_path , ] + list ( options ) ) process = Popen ( cmd , stdout = PIPE , cwd = parent_path , env = _get_env ( ) , universal_newlines = True ) for line in process . stdout : # remove pylintrc warning if line . startswith ( \"No config file found\" ) : continue # modify the file name thats output to reverse the path traversal we made parts = line . split ( \":\" ) if parts and parts [ 0 ] == child_path : line = \":\" . join ( [ filename ] + parts [ 1 : ] ) print ( line , end = \" \" ) process . wait ( ) return process . returncode", "nl": "Pylint the given file ."}}
{"translation": {"code": "def _check_proper_bases ( self , node ) : for base in node . bases : ancestor = safe_infer ( base ) if ancestor in ( astroid . Uninferable , None ) : continue if isinstance ( ancestor , astroid . Instance ) and ancestor . is_subtype_of ( \"%s.type\" % ( BUILTINS , ) ) : continue if not isinstance ( ancestor , astroid . ClassDef ) or _is_invalid_base_class ( ancestor ) : self . add_message ( \"inherit-non-class\" , args = base . as_string ( ) , node = node ) if ancestor . name == object . __name__ : self . add_message ( \"useless-object-inheritance\" , args = node . name , node = node )", "nl": "Detect that a class inherits something which is not a class or a type ."}}
{"translation": {"code": "def visit_import ( self , node ) : for module , as_name in node . names : if module in self . _logging_modules : self . _logging_names . add ( as_name or module )", "nl": "Checks to see if this module uses Python s built - in logging ."}}
{"translation": {"code": "def visit_module ( self , node ) : # pylint: disable=unused-argument # The code being checked can just as easily \"import logging as foo\", # so it is necessary to process the imports and store in this field # what name the logging module is actually given. self . _logging_names = set ( ) logging_mods = self . config . logging_modules self . _format_style = self . config . logging_format_style self . _logging_modules = set ( logging_mods ) self . _from_imports = { } for logging_mod in logging_mods : parts = logging_mod . rsplit ( \".\" , 1 ) if len ( parts ) > 1 : self . _from_imports [ parts [ 0 ] ] = parts [ 1 ]", "nl": "Clears any state left in this checker from last module checked ."}}
{"translation": {"code": "def visit_dict ( self , node ) : keys = set ( ) for k , _ in node . items : if isinstance ( k , astroid . Const ) : key = k . value if key in keys : self . add_message ( \"duplicate-key\" , node = node , args = key ) keys . add ( key )", "nl": "check duplicate key in dictionary"}}
{"translation": {"code": "def cb_full_documentation ( self , option , optname , value , parser ) : self . linter . print_full_documentation ( ) sys . exit ( 0 )", "nl": "optik callback for printing full documentation"}}
{"translation": {"code": "def py_run ( command_options = \"\" , return_std = False , stdout = None , stderr = None ) : # Detect if we use Python as executable or not, else default to `python` executable = sys . executable if \"python\" in sys . executable else \"python\" # Create command line to call pylint epylint_part = [ executable , \"-c\" , \"from pylint import epylint;epylint.Run()\" ] options = shlex . split ( command_options , posix = not sys . platform . startswith ( \"win\" ) ) cli = epylint_part + options # Providing standard output and/or error if not set if stdout is None : if return_std : stdout = PIPE else : stdout = sys . stdout if stderr is None : if return_std : stderr = PIPE else : stderr = sys . stderr # Call pylint in a subprocess process = Popen ( cli , shell = False , stdout = stdout , stderr = stderr , env = _get_env ( ) , universal_newlines = True , ) proc_stdout , proc_stderr = process . communicate ( ) # Return standard output and error if return_std : return StringIO ( proc_stdout ) , StringIO ( proc_stderr ) return None", "nl": "Run pylint from python"}}
{"translation": {"code": "def _check_not_in_finally ( self , node , node_name , breaker_classes = ( ) ) : # if self._tryfinallys is empty, we're not an in try...finally block if not self . _tryfinallys : return # the node could be a grand-grand...-children of the try...finally _parent = node . parent _node = node while _parent and not isinstance ( _parent , breaker_classes ) : if hasattr ( _parent , \"finalbody\" ) and _node in _parent . finalbody : self . add_message ( \"lost-exception\" , node = node , args = node_name ) return _node = _parent _parent = _node . parent", "nl": "check that a node is not inside a finally clause of a try ... finally statement . If we found before a try ... finally bloc a parent which its type is in breaker_classes we skip the whole check ."}}
{"translation": {"code": "def visit_assert ( self , node ) : if ( node . fail is None and isinstance ( node . test , astroid . Tuple ) and len ( node . test . elts ) == 2 ) : self . add_message ( \"assert-on-tuple\" , node = node )", "nl": "check the use of an assert statement on a tuple ."}}
{"translation": {"code": "def _check_name ( self , node_type , name , node , confidence = interfaces . HIGH ) : def _should_exempt_from_invalid_name ( node ) : if node_type == \"variable\" : inferred = utils . safe_infer ( node ) if isinstance ( inferred , astroid . ClassDef ) : return True return False if utils . is_inside_except ( node ) : clobbering , _ = utils . clobber_in_except ( node ) if clobbering : return if name in self . config . good_names : return if name in self . config . bad_names : self . stats [ \"badname_\" + node_type ] += 1 self . add_message ( \"blacklisted-name\" , node = node , args = name ) return regexp = self . _name_regexps [ node_type ] match = regexp . match ( name ) if _is_multi_naming_match ( match , node_type , confidence ) : name_group = self . _find_name_group ( node_type ) bad_name_group = self . _bad_names . setdefault ( name_group , { } ) warnings = bad_name_group . setdefault ( match . lastgroup , [ ] ) warnings . append ( ( node , node_type , name , confidence ) ) if match is None and not _should_exempt_from_invalid_name ( node ) : self . _raise_name_warning ( node , node_type , name , confidence )", "nl": "check for a name using the type s regexp"}}
{"translation": {"code": "def _check_in_loop ( self , node , node_name ) : _node = node . parent while _node : if isinstance ( _node , ( astroid . For , astroid . While ) ) : if node not in _node . orelse : return if isinstance ( _node , ( astroid . ClassDef , astroid . FunctionDef ) ) : break if ( isinstance ( _node , astroid . TryFinally ) and node in _node . finalbody and isinstance ( node , astroid . Continue ) ) : self . add_message ( \"continue-in-finally\" , node = node ) _node = _node . parent self . add_message ( \"not-in-loop\" , node = node , args = node_name )", "nl": "check that a node is inside a for or while loop"}}
{"translation": {"code": "def _check_docstring ( self , node_type , node , report_missing = True , confidence = interfaces . HIGH ) : docstring = node . doc if docstring is None : if not report_missing : return lines = utils . get_node_last_lineno ( node ) - node . lineno if node_type == \"module\" and not lines : # If the module has no body, there's no reason # to require a docstring. return max_lines = self . config . docstring_min_length if node_type != \"module\" and max_lines > - 1 and lines < max_lines : return self . stats [ \"undocumented_\" + node_type ] += 1 if ( node . body and isinstance ( node . body [ 0 ] , astroid . Expr ) and isinstance ( node . body [ 0 ] . value , astroid . Call ) ) : # Most likely a string with a format call. Let's see. func = utils . safe_infer ( node . body [ 0 ] . value . func ) if isinstance ( func , astroid . BoundMethod ) and isinstance ( func . bound , astroid . Instance ) : # Strings in Python 3, others in Python 2. if PY3K and func . bound . name == \"str\" : return if func . bound . name in ( \"str\" , \"unicode\" , \"bytes\" ) : return self . add_message ( \"missing-docstring\" , node = node , args = ( node_type , ) , confidence = confidence ) elif not docstring . strip ( ) : self . stats [ \"undocumented_\" + node_type ] += 1 self . add_message ( \"empty-docstring\" , node = node , args = ( node_type , ) , confidence = confidence )", "nl": "check the node has a non empty docstring"}}
{"translation": {"code": "def visit_assignname ( self , node ) : self . _check_assign_to_new_keyword_violation ( node . name , node ) frame = node . frame ( ) assign_type = node . assign_type ( ) if isinstance ( assign_type , astroid . Comprehension ) : self . _check_name ( \"inlinevar\" , node . name , node ) elif isinstance ( frame , astroid . Module ) : if isinstance ( assign_type , astroid . Assign ) and not in_loop ( assign_type ) : if isinstance ( utils . safe_infer ( assign_type . value ) , astroid . ClassDef ) : self . _check_name ( \"class\" , node . name , node ) else : if not _redefines_import ( node ) : # Don't emit if the name redefines an import # in an ImportError except handler. self . _check_name ( \"const\" , node . name , node ) elif isinstance ( assign_type , astroid . ExceptHandler ) : self . _check_name ( \"variable\" , node . name , node ) elif isinstance ( frame , astroid . FunctionDef ) : # global introduced variable aren't in the function locals if node . name in frame and node . name not in frame . argnames ( ) : if not _redefines_import ( node ) : self . _check_name ( \"variable\" , node . name , node ) elif isinstance ( frame , astroid . ClassDef ) : if not list ( frame . local_attr_ancestors ( node . name ) ) : self . _check_name ( \"class_attribute\" , node . name , node )", "nl": "check module level assigned names"}}
{"translation": {"code": "def run ( self ) : install_lib . install_lib . run ( self ) # manually install included directories if any if include_dirs : for directory in include_dirs : dest = join ( self . install_dir , directory ) if sys . version_info >= ( 3 , 0 ) : exclude = { \"invalid_encoded_data*\" , \"unknown_encoding*\" } else : exclude = set ( ) shutil . rmtree ( dest , ignore_errors = True ) shutil . copytree ( directory , dest , ignore = shutil . ignore_patterns ( * exclude ) )", "nl": "overridden from install_lib class"}}
{"translation": {"code": "def prepare_checkers ( self ) : if not self . config . reports : self . disable_reporters ( ) # get needed checkers neededcheckers = [ self ] for checker in self . get_checkers ( ) [ 1 : ] : messages = { msg for msg in checker . msgs if self . is_message_enabled ( msg ) } if messages or any ( self . report_is_enabled ( r [ 0 ] ) for r in checker . reports ) : neededcheckers . append ( checker ) # Sort checkers by priority neededcheckers = sorted ( neededcheckers , key = operator . attrgetter ( \"priority\" ) , reverse = True ) return neededcheckers", "nl": "return checkers needed for activated messages and reports"}}
{"translation": {"code": "def get_checkers ( self ) : return [ self ] + [ c for _checkers in self . _checkers . values ( ) for c in _checkers if c is not self ]", "nl": "return all available checkers as a list"}}
{"translation": {"code": "def check_messages ( * messages : str ) -> Callable : def store_messages ( func ) : func . checks_msgs = messages return func return store_messages", "nl": "decorator to store messages that are handled by a checker method"}}
{"translation": {"code": "def disable_reporters ( self ) : for _reporters in self . _reports . values ( ) : for report_id , _ , _ in _reporters : self . disable_report ( report_id )", "nl": "disable all reporters"}}
{"translation": {"code": "def _check_format_string ( self , node , format_arg ) : num_args = _count_supplied_tokens ( node . args [ format_arg + 1 : ] ) if not num_args : # If no args were supplied the string is not interpolated and can contain # formatting characters - it's used verbatim. Don't check any further. return format_string = node . args [ format_arg ] . value if not isinstance ( format_string , str ) : # If the log format is constant non-string (e.g. logging.debug(5)), # ensure there are no arguments. required_num_args = 0 else : try : if self . _format_style == \"old\" : keyword_args , required_num_args , _ , _ = utils . parse_format_string ( format_string ) if keyword_args : # Keyword checking on logging strings is complicated by # special keywords - out of scope. return elif self . _format_style == \"new\" : keyword_arguments , implicit_pos_args , explicit_pos_args = utils . parse_format_method_string ( format_string ) keyword_args_cnt = len ( set ( k for k , l in keyword_arguments if not isinstance ( k , int ) ) ) required_num_args = ( keyword_args_cnt + implicit_pos_args + explicit_pos_args ) except utils . UnsupportedFormatCharacter as ex : char = format_string [ ex . index ] self . add_message ( \"logging-unsupported-format\" , node = node , args = ( char , ord ( char ) , ex . index ) , ) return except utils . IncompleteFormatString : self . add_message ( \"logging-format-truncated\" , node = node ) return if num_args > required_num_args : self . add_message ( \"logging-too-many-args\" , node = node ) elif num_args < required_num_args : self . add_message ( \"logging-too-few-args\" , node = node )", "nl": "Checks that format string tokens match the supplied arguments ."}}
{"translation": {"code": "def is_inside_except ( node ) : current = node while current and not isinstance ( current . parent , astroid . ExceptHandler ) : current = current . parent return current and current is current . parent . name", "nl": "Returns true if node is inside the name of an except handler ."}}
{"translation": {"code": "def clobber_in_except ( node : astroid . node_classes . NodeNG ) -> Tuple [ bool , Tuple [ str , str ] ] : if isinstance ( node , astroid . AssignAttr ) : return True , ( node . attrname , \"object %r\" % ( node . expr . as_string ( ) , ) ) if isinstance ( node , astroid . AssignName ) : name = node . name if is_builtin ( name ) : return ( True , ( name , \"builtins\" ) ) stmts = node . lookup ( name ) [ 1 ] if stmts and not isinstance ( stmts [ 0 ] . assign_type ( ) , ( astroid . Assign , astroid . AugAssign , astroid . ExceptHandler ) , ) : return True , ( name , \"outer scope (line %s)\" % stmts [ 0 ] . fromlineno ) return False , None", "nl": "Checks if an assignment node in an except handler clobbers an existing variable ."}}
{"translation": {"code": "def redefined_by_decorator ( node ) : if node . decorators : for decorator in node . decorators . nodes : if ( isinstance ( decorator , astroid . Attribute ) and getattr ( decorator . expr , \"name\" , None ) == node . name ) : return True return False", "nl": "return True if the object is a method redefined via decorator ."}}
{"translation": {"code": "def in_for_else_branch ( parent , stmt ) : return isinstance ( parent , astroid . For ) and any ( else_stmt . parent_of ( stmt ) or else_stmt == stmt for else_stmt in parent . orelse )", "nl": "Returns True if stmt in inside the else branch for a parent For stmt ."}}
{"translation": {"code": "def _is_mandatory_method_param ( self , node ) : return ( self . _first_attrs and isinstance ( node , astroid . Name ) and node . name == self . _first_attrs [ - 1 ] )", "nl": "Check if astroid . Name corresponds to first attribute variable name"}}
{"translation": {"code": "def get_all_elements ( node : astroid . node_classes . NodeNG ) -> Iterable [ astroid . node_classes . NodeNG ] : if isinstance ( node , ( astroid . Tuple , astroid . List ) ) : for child in node . elts : for e in get_all_elements ( child ) : yield e else : yield node", "nl": "Recursively returns all atoms in nested lists and tuples ."}}
{"translation": {"code": "def process_non_raw_string_token ( self , prefix , string_body , start_row ) : # Walk through the string; if we see a backslash then escape the next # character, and skip over it.  If we see a non-escaped character, # alert, and continue. # # Accept a backslash when it escapes a backslash, or a quote, or # end-of-line, or one of the letters that introduce a special escape # sequence <http://docs.python.org/reference/lexical_analysis.html> # # TODO(mbp): Maybe give a separate warning about the rarely-used # \\a \\b \\v \\f? # # TODO(mbp): We could give the column of the problem character, but # add_message doesn't seem to have a way to pass it through at present. i = 0 while True : i = string_body . find ( \"\\\\\" , i ) if i == - 1 : break # There must be a next character; having a backslash at the end # of the string would be a SyntaxError. next_char = string_body [ i + 1 ] match = string_body [ i : i + 2 ] if next_char in self . UNICODE_ESCAPE_CHARACTERS : if \"u\" in prefix : pass elif ( _PY3K or self . _unicode_literals ) and \"b\" not in prefix : pass # unicode by default else : self . add_message ( \"anomalous-unicode-escape-in-string\" , line = start_row , args = ( match , ) , ) elif next_char not in self . ESCAPE_CHARACTERS : self . add_message ( \"anomalous-backslash-in-string\" , line = start_row , args = ( match , ) ) # Whether it was a valid escape or not, backslash followed by # another character can always be consumed whole: the second # character can never be the start of a new backslash escape. i += 2", "nl": "check for bad escapes in a non - raw string ."}}
{"translation": {"code": "def _check_new_format ( self , node , func ) : # TODO: skip (for now) format nodes which don't have #       an explicit string on the left side of the format operation. #       We do this because our inference engine can't properly handle #       redefinitions of the original string. #       For more details, see issue 287. # # Note that there may not be any left side at all, if the format method # has been assigned to another variable. See issue 351. For example: # #    fmt = 'some string {}'.format #    fmt('arg') if isinstance ( node . func , astroid . Attribute ) and not isinstance ( node . func . expr , astroid . Const ) : return if node . starargs or node . kwargs : return try : strnode = next ( func . bound . infer ( ) ) except astroid . InferenceError : return if not ( isinstance ( strnode , astroid . Const ) and isinstance ( strnode . value , str ) ) : return try : call_site = CallSite . from_call ( node ) except astroid . InferenceError : return try : fields , num_args , manual_pos = utils . parse_format_method_string ( strnode . value ) except utils . IncompleteFormatString : self . add_message ( \"bad-format-string\" , node = node ) return positional_arguments = call_site . positional_arguments named_arguments = call_site . keyword_arguments named_fields = { field [ 0 ] for field in fields if isinstance ( field [ 0 ] , str ) } if num_args and manual_pos : self . add_message ( \"format-combined-specification\" , node = node ) return check_args = False # Consider \"{[0]} {[1]}\" as num_args. num_args += sum ( 1 for field in named_fields if field == \"\" ) if named_fields : for field in named_fields : if field and field not in named_arguments : self . add_message ( \"missing-format-argument-key\" , node = node , args = ( field , ) ) for field in named_arguments : if field not in named_fields : self . add_message ( \"unused-format-string-argument\" , node = node , args = ( field , ) ) # num_args can be 0 if manual_pos is not. num_args = num_args or manual_pos if positional_arguments or num_args : empty = any ( True for field in named_fields if field == \"\" ) if named_arguments or empty : # Verify the required number of positional arguments # only if the .format got at least one keyword argument. # This means that the format strings accepts both # positional and named fields and we should warn # when one of the them is missing or is extra. check_args = True else : check_args = True if check_args : # num_args can be 0 if manual_pos is not. num_args = num_args or manual_pos if len ( positional_arguments ) > num_args : self . add_message ( \"too-many-format-args\" , node = node ) elif len ( positional_arguments ) < num_args : self . add_message ( \"too-few-format-args\" , node = node ) self . _detect_vacuous_formatting ( node , positional_arguments ) self . _check_new_format_specifiers ( node , fields , named_arguments )", "nl": "Check the new string formatting ."}}
{"translation": {"code": "def _loop_exits_early ( loop ) : loop_nodes = ( astroid . For , astroid . While ) definition_nodes = ( astroid . FunctionDef , astroid . ClassDef ) inner_loop_nodes = [ _node for _node in loop . nodes_of_class ( loop_nodes , skip_klass = definition_nodes ) if _node != loop ] return any ( _node for _node in loop . nodes_of_class ( astroid . Break , skip_klass = definition_nodes ) if _get_break_loop_node ( _node ) not in inner_loop_nodes )", "nl": "Returns true if a loop may ends up in a break statement ."}}
{"translation": {"code": "def _check_else_on_loop ( self , node ) : if node . orelse and not _loop_exits_early ( node ) : self . add_message ( \"useless-else-on-loop\" , node = node , # This is not optimal, but the line previous # to the first statement in the else clause # will usually be the one that contains the else:. line = node . orelse [ 0 ] . lineno - 1 , )", "nl": "Check that any loop with an else clause has a break statement ."}}
{"translation": {"code": "def process_module ( self , module ) : if module . file_encoding : encoding = module . file_encoding else : encoding = \"ascii\" with module . stream ( ) as stream : for lineno , line in enumerate ( stream ) : self . _check_encoding ( lineno + 1 , line , encoding )", "nl": "inspect the source file to find encoding problem"}}
{"translation": {"code": "def get_argument_from_call ( call_node : astroid . Call , position : int = None , keyword : str = None ) -> astroid . Name : if position is None and keyword is None : raise ValueError ( \"Must specify at least one of: position or keyword.\" ) if position is not None : try : return call_node . args [ position ] except IndexError : pass if keyword and call_node . keywords : for arg in call_node . keywords : if arg . arg == keyword : return arg . value raise NoSuchArgumentError", "nl": "Returns the specified argument from a function call ."}}
{"translation": {"code": "def _check_open_mode ( self , node ) : try : mode_arg = utils . get_argument_from_call ( node , position = 1 , keyword = \"mode\" ) except utils . NoSuchArgumentError : return if mode_arg : mode_arg = utils . safe_infer ( mode_arg ) if isinstance ( mode_arg , astroid . Const ) and not _check_mode_str ( mode_arg . value ) : self . add_message ( \"bad-open-mode\" , node = node , args = mode_arg . value )", "nl": "Check that the mode argument of an open or file call is valid ."}}
{"translation": {"code": "def register ( linter ) : linter . register_reporter ( TextReporter ) linter . register_reporter ( ParseableTextReporter ) linter . register_reporter ( VSTextReporter ) linter . register_reporter ( ColorizedTextReporter )", "nl": "Register the reporter classes with the linter ."}}
{"translation": {"code": "def _determine_function_name_type ( node , config = None ) : property_classes , property_names = _get_properties ( config ) if not node . is_method ( ) : return \"function\" if node . decorators : decorators = node . decorators . nodes else : decorators = [ ] for decorator in decorators : # If the function is a property (decorated with @property # or @abc.abstractproperty), the name type is 'attr'. if isinstance ( decorator , astroid . Name ) or ( isinstance ( decorator , astroid . Attribute ) and decorator . attrname in property_names ) : infered = utils . safe_infer ( decorator ) if infered and infered . qname ( ) in property_classes : return \"attr\" # If the function is decorated using the prop_method.{setter,getter} # form, treat it like an attribute as well. elif isinstance ( decorator , astroid . Attribute ) and decorator . attrname in ( \"setter\" , \"deleter\" , ) : return \"attr\" return \"method\"", "nl": "Determine the name type whose regex the a function s name should match ."}}
{"translation": {"code": "def _check_unpacking ( self , infered , node , targets ) : if utils . is_inside_abstract_class ( node ) : return if utils . is_comprehension ( node ) : return if infered is astroid . Uninferable : return if ( isinstance ( infered . parent , astroid . Arguments ) and isinstance ( node . value , astroid . Name ) and node . value . name == infered . parent . vararg ) : # Variable-length argument, we can't determine the length. return if isinstance ( infered , ( astroid . Tuple , astroid . List ) ) : # attempt to check unpacking is properly balanced values = infered . itered ( ) if len ( targets ) != len ( values ) : # Check if we have starred nodes. if any ( isinstance ( target , astroid . Starred ) for target in targets ) : return self . add_message ( \"unbalanced-tuple-unpacking\" , node = node , args = ( _get_unpacking_extra_info ( node , infered ) , len ( targets ) , len ( values ) , ) , ) # attempt to check unpacking may be possible (ie RHS is iterable) else : if not utils . is_iterable ( infered ) : self . add_message ( \"unpacking-non-sequence\" , node = node , args = ( _get_unpacking_extra_info ( node , infered ) , ) , )", "nl": "Check for unbalanced tuple unpacking and unpacking non sequences ."}}
{"translation": {"code": "def _check_multi_statement_line ( self , node , line ) : # Do not warn about multiple nested context managers # in with statements. if isinstance ( node , nodes . With ) : return # For try... except... finally..., the two nodes # appear to be on the same line due to how the AST is built. if isinstance ( node , nodes . TryExcept ) and isinstance ( node . parent , nodes . TryFinally ) : return if ( isinstance ( node . parent , nodes . If ) and not node . parent . orelse and self . config . single_line_if_stmt ) : return if ( isinstance ( node . parent , nodes . ClassDef ) and len ( node . parent . body ) == 1 and self . config . single_line_class_stmt ) : return self . add_message ( \"multiple-statements\" , node = node ) self . _visited_lines [ line ] = 2", "nl": "Check for lines containing multiple statements ."}}
{"translation": {"code": "def _check_keyword_parentheses ( self , tokens , start ) : # If the next token is not a paren, we're fine. if self . _inside_brackets ( \":\" ) and tokens [ start ] [ 1 ] == \"for\" : self . _pop_token ( ) if tokens [ start + 1 ] [ 1 ] != \"(\" : return found_and_or = False depth = 0 keyword_token = str ( tokens [ start ] [ 1 ] ) line_num = tokens [ start ] [ 2 ] [ 0 ] for i in range ( start , len ( tokens ) - 1 ) : token = tokens [ i ] # If we hit a newline, then assume any parens were for continuation. if token [ 0 ] == tokenize . NL : return if token [ 1 ] == \"(\" : depth += 1 elif token [ 1 ] == \")\" : depth -= 1 if depth : continue # ')' can't happen after if (foo), since it would be a syntax error. if tokens [ i + 1 ] [ 1 ] in ( \":\" , \")\" , \"]\" , \"}\" , \"in\" ) or tokens [ i + 1 ] [ 0 ] in ( tokenize . NEWLINE , tokenize . ENDMARKER , tokenize . COMMENT ) : # The empty tuple () is always accepted. if i == start + 2 : return if keyword_token == \"not\" : if not found_and_or : self . add_message ( \"superfluous-parens\" , line = line_num , args = keyword_token ) elif keyword_token in ( \"return\" , \"yield\" ) : self . add_message ( \"superfluous-parens\" , line = line_num , args = keyword_token ) elif keyword_token not in self . _keywords_with_parens : if not found_and_or : self . add_message ( \"superfluous-parens\" , line = line_num , args = keyword_token ) return elif depth == 1 : # This is a tuple, which is always acceptable. if token [ 1 ] == \",\" : return # 'and' and 'or' are the only boolean operators with lower precedence # than 'not', so parens are only required when they are found. if token [ 1 ] in ( \"and\" , \"or\" ) : found_and_or = True # A yield inside an expression must always be in parentheses, # quit early without error. elif token [ 1 ] == \"yield\" : return # A generator expression always has a 'for' token in it, and # the 'for' token is only legal inside parens when it is in a # generator expression.  The parens are necessary here, so bail # without an error. elif token [ 1 ] == \"for\" : return", "nl": "Check that there are not unnecessary parens after a keyword ."}}
{"translation": {"code": "def _check_surrounded_by_space ( self , tokens , i ) : self . _check_space ( tokens , i , ( _MUST , _MUST ) )", "nl": "Check that a binary operator is surrounded by exactly one space ."}}
{"translation": {"code": "def _check_equals_spacing ( self , tokens , i ) : if self . _has_valid_type_annotation ( tokens , i ) : self . _check_space ( tokens , i , ( _MUST , _MUST ) ) elif self . _inside_brackets ( \"(\" ) or self . _inside_brackets ( \"lambda\" ) : self . _check_space ( tokens , i , ( _MUST_NOT , _MUST_NOT ) ) else : self . _check_space ( tokens , i , ( _MUST , _MUST ) )", "nl": "Check the spacing of a single equals sign ."}}
{"translation": {"code": "def _get_unpacking_extra_info ( node , infered ) : more = \"\" infered_module = infered . root ( ) . name if node . root ( ) . name == infered_module : if node . lineno == infered . lineno : more = \" %s\" % infered . as_string ( ) elif infered . lineno : more = \" defined at line %s\" % infered . lineno elif infered . lineno : more = \" defined at line %s of %s\" % ( infered . lineno , infered_module ) return more", "nl": "return extra information to add to the message for unpacking - non - sequence and unbalanced - tuple - unpacking errors"}}
{"translation": {"code": "def _get_env ( ) : env = dict ( os . environ ) env [ \"PYTHONPATH\" ] = os . pathsep . join ( sys . path ) return env", "nl": "Extracts the environment PYTHONPATH and appends the current sys . path to those ."}}
{"translation": {"code": "def visit_importfrom ( self , node ) : try : logging_name = self . _from_imports [ node . modname ] for module , as_name in node . names : if module == logging_name : self . _logging_names . add ( as_name or module ) except KeyError : pass", "nl": "Checks to see if a module uses a non - Python logging module ."}}
{"translation": {"code": "def visit_call ( self , node ) : def is_logging_name ( ) : return ( isinstance ( node . func , astroid . Attribute ) and isinstance ( node . func . expr , astroid . Name ) and node . func . expr . name in self . _logging_names ) def is_logger_class ( ) : try : for inferred in node . func . infer ( ) : if isinstance ( inferred , astroid . BoundMethod ) : parent = inferred . _proxied . parent if isinstance ( parent , astroid . ClassDef ) and ( parent . qname ( ) == \"logging.Logger\" or any ( ancestor . qname ( ) == \"logging.Logger\" for ancestor in parent . ancestors ( ) ) ) : return True , inferred . _proxied . name except astroid . exceptions . InferenceError : pass return False , None if is_logging_name ( ) : name = node . func . attrname else : result , name = is_logger_class ( ) if not result : return self . _check_log_method ( node , name )", "nl": "Checks calls to logging methods ."}}
{"translation": {"code": "def _get_indent_hint_line ( bar_positions , bad_position ) : if not bar_positions : return ( \"\" , \"\" ) # TODO tabs should not be replaced by some random (8) number of spaces bar_positions = [ _get_indent_length ( indent ) for indent in bar_positions ] bad_position = _get_indent_length ( bad_position ) delta_message = \"\" markers = [ ( pos , \"|\" ) for pos in bar_positions ] if len ( markers ) == 1 : # if we have only one marker we'll provide an extra hint on how to fix expected_position = markers [ 0 ] [ 0 ] delta = abs ( expected_position - bad_position ) direction = \"add\" if expected_position > bad_position else \"remove\" delta_message = _CONTINUATION_HINT_MESSAGE % ( direction , delta , \"s\" if delta > 1 else \"\" , ) markers . append ( ( bad_position , \"^\" ) ) markers . sort ( ) line = [ \" \" ] * ( markers [ - 1 ] [ 0 ] + 1 ) for position , marker in markers : line [ position ] = marker return ( \"\" . join ( line ) , delta_message )", "nl": "Return a line with |s for each of the positions in the given lists ."}}
{"translation": {"code": "def handle_line_start ( self , pos ) : if self . _line_start > - 1 : return check_token_position = pos if self . _tokens . token ( pos ) == _ASYNC_TOKEN : check_token_position += 1 self . _is_block_opener = ( self . _tokens . token ( check_token_position ) in _CONTINUATION_BLOCK_OPENERS ) self . _line_start = pos", "nl": "Record the first non - junk token at the start of a line ."}}
{"translation": {"code": "def get_valid_indentations ( self , idx ) : # The closing brace on a dict or the 'for' in a dict comprehension may # reset two indent levels because the dict value is ended implicitly stack_top = - 1 if ( self . _tokens . token ( idx ) in ( \"}\" , \"for\" ) and self . _cont_stack [ - 1 ] . token == \":\" ) : stack_top = - 2 indent = self . _cont_stack [ stack_top ] if self . _tokens . token ( idx ) in _CLOSING_BRACKETS : valid_indentations = indent . valid_outdent_strings else : valid_indentations = indent . valid_continuation_strings return indent , valid_indentations . copy ( )", "nl": "Returns the valid offsets for the token at the given position ."}}
{"translation": {"code": "def _hanging_indent_after_bracket ( self , bracket , position ) : indentation = self . _tokens . line_indent ( position ) if ( self . _is_block_opener and self . _continuation_string == self . _block_indent_string ) : return _ContinuedIndent ( HANGING_BLOCK , bracket , position , _Indentations ( indentation + self . _continuation_string , indentation ) , _BeforeBlockIndentations ( indentation + self . _continuation_string , indentation + self . _continuation_string * 2 , ) , ) if bracket == \":\" : # If the dict key was on the same line as the open brace, the new # correct indent should be relative to the key instead of the # current indent level paren_align = self . _cont_stack [ - 1 ] . valid_outdent_strings next_align = self . _cont_stack [ - 1 ] . valid_continuation_strings . copy ( ) next_align_keys = list ( next_align . keys ( ) ) next_align [ next_align_keys [ 0 ] + self . _continuation_string ] = True # Note that the continuation of # d = { #       'a': 'b' #            'c' # } # is handled by the special-casing for hanging continued string indents. return _ContinuedIndent ( HANGING_DICT_VALUE , bracket , position , paren_align , next_align ) return _ContinuedIndent ( HANGING , bracket , position , _Indentations ( indentation , indentation + self . _continuation_string ) , _Indentations ( indentation + self . _continuation_string ) , )", "nl": "Extracts indentation information for a hanging indent"}}
{"translation": {"code": "def _continuation_inside_bracket ( self , bracket , position ) : indentation = self . _tokens . line_indent ( position ) token_indent = self . _tokens . token_indent ( position ) next_token_indent = self . _tokens . token_indent ( position + 1 ) if ( self . _is_block_opener and next_token_indent == indentation + self . _block_indent_string ) : return _ContinuedIndent ( CONTINUED_BLOCK , bracket , position , _Indentations ( token_indent ) , _BeforeBlockIndentations ( next_token_indent , next_token_indent + self . _continuation_string ) , ) return _ContinuedIndent ( CONTINUED , bracket , position , _Indentations ( token_indent , next_token_indent ) , _Indentations ( next_token_indent ) , )", "nl": "Extracts indentation information for a continued indent ."}}
{"translation": {"code": "def _get_indent_length ( line ) : result = 0 for char in line : if char == \" \" : result += 1 elif char == \"\\t\" : result += _TAB_LENGTH else : break return result", "nl": "Return the length of the indentation on the given token s line ."}}
{"translation": {"code": "def push_token ( self , token , position ) : if _token_followed_by_eol ( self . _tokens , position ) : self . _cont_stack . append ( self . _hanging_indent_after_bracket ( token , position ) ) else : self . _cont_stack . append ( self . _continuation_inside_bracket ( token , position ) )", "nl": "Pushes a new token for continued indentation on the stack ."}}
{"translation": {"code": "def _check_uninferable_call ( self , node ) : if not isinstance ( node . func , astroid . Attribute ) : return # Look for properties. First, obtain # the lhs of the Attribute node and search the attribute # there. If that attribute is a property or a subclass of properties, # then most likely it's not callable. # TODO: since astroid doesn't understand descriptors very well # we will not handle them here, right now. expr = node . func . expr klass = safe_infer ( expr ) if ( klass is None or klass is astroid . Uninferable or not isinstance ( klass , astroid . Instance ) ) : return try : attrs = klass . _proxied . getattr ( node . func . attrname ) except exceptions . NotFoundError : return for attr in attrs : if attr is astroid . Uninferable : continue if not isinstance ( attr , astroid . FunctionDef ) : continue # Decorated, see if it is decorated with a property. # Also, check the returns and see if they are callable. if decorated_with_property ( attr ) : try : all_returns_are_callable = all ( return_node . callable ( ) or return_node is astroid . Uninferable for return_node in attr . infer_call_result ( node ) ) except astroid . InferenceError : continue if not all_returns_are_callable : self . add_message ( \"not-callable\" , node = node , args = node . func . as_string ( ) ) break", "nl": "Check that the given uninferable Call node does not call an actual function ."}}
{"translation": {"code": "def _check_in_slots ( self , node ) : inferred = safe_infer ( node . expr ) if not isinstance ( inferred , astroid . Instance ) : return klass = inferred . _proxied if not has_known_bases ( klass ) : return if \"__slots__\" not in klass . locals or not klass . newstyle : return slots = klass . slots ( ) if slots is None : return # If any ancestor doesn't use slots, the slots # defined for this class are superfluous. if any ( \"__slots__\" not in ancestor . locals and ancestor . name != \"object\" for ancestor in klass . ancestors ( ) ) : return if not any ( slot . value == node . attrname for slot in slots ) : # If we have a '__dict__' in slots, then # assigning any name is valid. if not any ( slot . value == \"__dict__\" for slot in slots ) : if _is_attribute_property ( node . attrname , klass ) : # Properties circumvent the slots mechanism, # so we should not emit a warning for them. return if node . attrname in klass . locals and _has_data_descriptor ( klass , node . attrname ) : # Descriptors circumvent the slots mechanism as well. return if node . attrname == \"__class__\" and _has_same_layout_slots ( slots , node . parent . value ) : return self . add_message ( \"assigning-non-slot\" , args = ( node . attrname , ) , node = node )", "nl": "Check that the given AssignAttr node is defined in the class slots ."}}
{"translation": {"code": "def _detect_global_scope ( node , frame , defframe ) : def_scope = scope = None if frame and frame . parent : scope = frame . parent . scope ( ) if defframe and defframe . parent : def_scope = defframe . parent . scope ( ) if isinstance ( frame , astroid . FunctionDef ) : # If the parent of the current node is a # function, then it can be under its scope # (defined in, which doesn't concern us) or # the `->` part of annotations. The same goes # for annotations of function arguments, they'll have # their parent the Arguments node. if not isinstance ( node . parent , ( astroid . FunctionDef , astroid . Arguments ) ) : return False elif any ( not isinstance ( f , ( astroid . ClassDef , astroid . Module ) ) for f in ( frame , defframe ) ) : # Not interested in other frames, since they are already # not in a global scope. return False break_scopes = [ ] for s in ( scope , def_scope ) : # Look for parent scopes. If there is anything different # than a module or a class scope, then they frames don't # share a global scope. parent_scope = s while parent_scope : if not isinstance ( parent_scope , ( astroid . ClassDef , astroid . Module ) ) : break_scopes . append ( parent_scope ) break if parent_scope . parent : parent_scope = parent_scope . parent . scope ( ) else : break if break_scopes and len ( set ( break_scopes ) ) != 1 : # Store different scopes than expected. # If the stored scopes are, in fact, the very same, then it means # that the two frames (frame and defframe) shares the same scope, # and we could apply our lineno analysis over them. # For instance, this works when they are inside a function, the node # that uses a definition and the definition itself. return False # At this point, we are certain that frame and defframe shares a scope # and the definition of the first depends on the second. return frame . lineno < defframe . lineno", "nl": "Detect that the given frames shares a global scope ."}}
{"translation": {"code": "def _check_docstring ( self , node ) : docstring = node . doc if not docstring : return start_line = node . lineno + 1 # Go through lines of docstring for idx , line in enumerate ( docstring . splitlines ( ) ) : self . _check_spelling ( \"wrong-spelling-in-docstring\" , line , start_line + idx )", "nl": "check the node has any spelling errors"}}
{"translation": {"code": "def visit_call ( self , node ) : try : for inferred in node . func . infer ( ) : self . _check_inferred_class_is_abstract ( inferred , node ) except astroid . InferenceError : return", "nl": "Check instantiating abstract class with abc . ABCMeta as metaclass ."}}
{"translation": {"code": "def _check_reversed ( self , node ) : try : argument = utils . safe_infer ( utils . get_argument_from_call ( node , position = 0 ) ) except utils . NoSuchArgumentError : pass else : if argument is astroid . Uninferable : return if argument is None : # Nothing was infered. # Try to see if we have iter(). if isinstance ( node . args [ 0 ] , astroid . Call ) : try : func = next ( node . args [ 0 ] . func . infer ( ) ) except astroid . InferenceError : return if getattr ( func , \"name\" , None ) == \"iter\" and utils . is_builtin_object ( func ) : self . add_message ( \"bad-reversed-sequence\" , node = node ) return if isinstance ( argument , ( astroid . List , astroid . Tuple ) ) : return if isinstance ( argument , astroid . Instance ) : if argument . _proxied . name == \"dict\" and utils . is_builtin_object ( argument . _proxied ) : self . add_message ( \"bad-reversed-sequence\" , node = node ) return if any ( ancestor . name == \"dict\" and utils . is_builtin_object ( ancestor ) for ancestor in argument . _proxied . ancestors ( ) ) : # Mappings aren't accepted by reversed(), unless # they provide explicitly a __reversed__ method. try : argument . locals [ REVERSED_PROTOCOL_METHOD ] except KeyError : self . add_message ( \"bad-reversed-sequence\" , node = node ) return if hasattr ( argument , \"getattr\" ) : # everything else is not a proper sequence for reversed() for methods in REVERSED_METHODS : for meth in methods : try : argument . getattr ( meth ) except astroid . NotFoundError : break else : break else : self . add_message ( \"bad-reversed-sequence\" , node = node ) else : self . add_message ( \"bad-reversed-sequence\" , node = node )", "nl": "check that the argument to reversed is a sequence"}}
{"translation": {"code": "def inherit_from_std_ex ( node : astroid . node_classes . NodeNG ) -> bool : ancestors = node . ancestors ( ) if hasattr ( node , \"ancestors\" ) else [ ] for ancestor in itertools . chain ( [ node ] , ancestors ) : if ( ancestor . name in ( \"Exception\" , \"BaseException\" ) and ancestor . root ( ) . name == EXCEPTIONS_MODULE ) : return True return False", "nl": "Return true if the given class node is subclass of exceptions . Exception ."}}
{"translation": {"code": "def error_of_type ( handler : astroid . ExceptHandler , error_type ) -> bool : def stringify_error ( error ) : if not isinstance ( error , str ) : return error . __name__ return error if not isinstance ( error_type , tuple ) : error_type = ( error_type , ) # type: ignore expected_errors = { stringify_error ( error ) for error in error_type } # type: ignore if not handler . type : return True return handler . catch ( expected_errors )", "nl": "Check if the given exception handler catches the given error_type ."}}
{"translation": {"code": "def _check_datetime ( self , node ) : try : infered = next ( node . infer ( ) ) except astroid . InferenceError : return if isinstance ( infered , Instance ) and infered . qname ( ) == \"datetime.time\" : self . add_message ( \"boolean-datetime\" , node = node )", "nl": "Check that a datetime was infered . If so emit boolean - datetime warning ."}}
{"translation": {"code": "def visit_name ( self , node ) : found_node , _ = node . lookup ( node . name ) if not _is_builtin ( found_node ) : return if node . name not in self . _bad_builtins : return if node_ignores_exception ( node ) or isinstance ( find_try_except_wrapper_node ( node ) , astroid . ExceptHandler ) : return message = node . name . lower ( ) + \"-builtin\" self . add_message ( message , node = node )", "nl": "Detect when a bad built - in is referenced ."}}
{"translation": {"code": "def decorated_with_property ( node : astroid . FunctionDef ) -> bool : if not node . decorators : return False for decorator in node . decorators . nodes : if not isinstance ( decorator , astroid . Name ) : continue try : if _is_property_decorator ( decorator ) : return True except astroid . InferenceError : pass return False", "nl": "Detect if the given function node is decorated with a property ."}}
{"translation": {"code": "def fix_import_path ( args ) : orig = list ( sys . path ) changes = [ ] for arg in args : path = _get_python_path ( arg ) if path in changes : continue else : changes . append ( path ) sys . path [ : ] = changes + [ \".\" ] + sys . path try : yield finally : sys . path [ : ] = orig", "nl": "Prepare sys . path for running the linter checks ."}}
{"translation": {"code": "def handle_message ( self , msg ) : self . messages . append ( { \"type\" : msg . category , \"module\" : msg . module , \"obj\" : msg . obj , \"line\" : msg . line , \"column\" : msg . column , \"path\" : msg . path , \"symbol\" : msg . symbol , \"message\" : html . escape ( msg . msg or \"\" , quote = False ) , \"message-id\" : msg . msg_id , } )", "nl": "Manage message of different type and in the context of path ."}}
{"translation": {"code": "def display_messages ( self , layout ) : print ( json . dumps ( self . messages , indent = 4 ) , file = self . out )", "nl": "Launch layouts display"}}
{"translation": {"code": "def visit_subscript ( self , node ) : try : for inferred in node . value . infer ( ) : if not isinstance ( inferred , astroid . Instance ) : continue if utils . inherit_from_std_ex ( inferred ) : self . add_message ( \"indexing-exception\" , node = node ) except astroid . InferenceError : return", "nl": "Look for indexing exceptions ."}}
{"translation": {"code": "def visit_excepthandler ( self , node ) : def _is_used_in_except_block ( node ) : scope = node . scope ( ) current = node while ( current and current != scope and not isinstance ( current , astroid . ExceptHandler ) ) : current = current . parent return isinstance ( current , astroid . ExceptHandler ) and current . type != node if isinstance ( node . name , ( astroid . Tuple , astroid . List ) ) : self . add_message ( \"unpacking-in-except\" , node = node ) return if not node . name : return # Find any names scope = node . parent . scope ( ) scope_names = scope . nodes_of_class ( astroid . Name , skip_klass = astroid . FunctionDef ) scope_names = list ( scope_names ) potential_leaked_names = [ scope_name for scope_name in scope_names if scope_name . name == node . name . name and scope_name . lineno > node . lineno and not _is_used_in_except_block ( scope_name ) ] reassignments_for_same_name = { assign_name . lineno for assign_name in scope . nodes_of_class ( astroid . AssignName , skip_klass = astroid . FunctionDef ) if assign_name . name == node . name . name } for leaked_name in potential_leaked_names : if any ( node . lineno < elem < leaked_name . lineno for elem in reassignments_for_same_name ) : continue self . add_message ( \"exception-escape\" , node = leaked_name )", "nl": "Visit an except handler block and check for exception unpacking ."}}
{"translation": {"code": "def visit_raise ( self , node ) : # Ignore empty raise. if node . exc is None : return expr = node . exc if self . _check_raise_value ( node , expr ) : return try : value = next ( astroid . unpack_infer ( expr ) ) except astroid . InferenceError : return self . _check_raise_value ( node , value )", "nl": "Visit a raise statement and check for raising strings or old - raise - syntax ."}}
{"translation": {"code": "def is_method_call ( func , types = ( ) , methods = ( ) ) : return ( isinstance ( func , astroid . BoundMethod ) and isinstance ( func . bound , astroid . Instance ) and ( func . bound . name in types if types else True ) and ( func . name in methods if methods else True ) )", "nl": "Determines if a BoundMethod node represents a method call ."}}
{"translation": {"code": "def visit_call ( self , node ) : try : for inferred in node . func . infer ( ) : if inferred is astroid . Uninferable : continue elif inferred . root ( ) . name == OPEN_MODULE : if getattr ( node . func , \"name\" , None ) in OPEN_FILES : self . _check_open_mode ( node ) elif inferred . root ( ) . name == UNITTEST_CASE : self . _check_redundant_assert ( node , inferred ) elif isinstance ( inferred , astroid . ClassDef ) : if inferred . qname ( ) == THREADING_THREAD : self . _check_bad_thread_instantiation ( node ) elif inferred . qname ( ) == SUBPROCESS_POPEN : self . _check_for_preexec_fn_in_popen ( node ) elif isinstance ( inferred , astroid . FunctionDef ) : name = inferred . qname ( ) if name == COPY_COPY : self . _check_shallow_copy_environ ( node ) elif name in ENV_GETTERS : self . _check_env_function ( node , inferred ) elif name == SUBPROCESS_RUN and PY35 : self . _check_for_check_kw_in_run ( node ) self . _check_deprecated_method ( node , inferred ) except astroid . InferenceError : return", "nl": "Visit a Call node ."}}
{"translation": {"code": "def _check_bad_exception_context ( self , node ) : cause = utils . safe_infer ( node . cause ) if cause in ( astroid . Uninferable , None ) : return if isinstance ( cause , astroid . Const ) : if cause . value is not None : self . add_message ( \"bad-exception-context\" , node = node ) elif not isinstance ( cause , astroid . ClassDef ) and not utils . inherit_from_std_ex ( cause ) : self . add_message ( \"bad-exception-context\" , node = node )", "nl": "Verify that the exception context is properly set ."}}
{"translation": {"code": "def _in_iterating_context ( node ) : parent = node . parent # Since a call can't be the loop variant we only need to know if the node's # parent is a 'for' loop to know it's being used as the iterator for the # loop. if isinstance ( parent , astroid . For ) : return True # Need to make sure the use of the node is in the iterator part of the # comprehension. if isinstance ( parent , astroid . Comprehension ) : if parent . iter == node : return True # Various built-ins can take in an iterable or list and lead to the same # value. elif isinstance ( parent , astroid . Call ) : if isinstance ( parent . func , astroid . Name ) : parent_scope = parent . func . lookup ( parent . func . name ) [ 0 ] if _is_builtin ( parent_scope ) and parent . func . name in _ACCEPTS_ITERATOR : return True elif isinstance ( parent . func , astroid . Attribute ) : if parent . func . attrname in ATTRIBUTES_ACCEPTS_ITERATOR : return True inferred = utils . safe_infer ( parent . func ) if inferred : if inferred . qname ( ) in _BUILTIN_METHOD_ACCEPTS_ITERATOR : return True root = inferred . root ( ) if root and root . name == \"itertools\" : return True # If the call is in an unpacking, there's no need to warn, # since it can be considered iterating. elif isinstance ( parent , astroid . Assign ) and isinstance ( parent . targets [ 0 ] , ( astroid . List , astroid . Tuple ) ) : if len ( parent . targets [ 0 ] . elts ) > 1 : return True # If the call is in a containment check, we consider that to # be an iterating context elif ( isinstance ( parent , astroid . Compare ) and len ( parent . ops ) == 1 and parent . ops [ 0 ] [ 0 ] == \"in\" ) : return True # Also if it's an `yield from`, that's fair elif isinstance ( parent , astroid . YieldFrom ) : return True if isinstance ( parent , astroid . Starred ) : return True return False", "nl": "Check if the node is being used as an iterator ."}}
{"translation": {"code": "def python3_porting_mode ( self ) : self . disable ( \"all\" ) self . enable ( \"python3\" ) if self . _error_mode : # The error mode was activated, using the -E flag. # So we'll need to enable only the errors from the # Python 3 porting checker. for msg_id in self . _checker_messages ( \"python3\" ) : if msg_id . startswith ( \"E\" ) : self . enable ( msg_id ) else : self . disable ( msg_id ) config_parser = self . cfgfile_parser if config_parser . has_option ( \"MESSAGES CONTROL\" , \"disable\" ) : value = config_parser . get ( \"MESSAGES CONTROL\" , \"disable\" ) self . global_set_option ( \"disable\" , value ) self . _python3_porting_mode = True", "nl": "Disable all other checkers and enable Python 3 warnings ."}}
{"translation": {"code": "def decorated_with ( func : astroid . FunctionDef , qnames : Iterable [ str ] ) -> bool : decorators = func . decorators . nodes if func . decorators else [ ] for decorator_node in decorators : try : if any ( i is not None and i . qname ( ) in qnames for i in decorator_node . infer ( ) ) : return True except astroid . InferenceError : continue return False", "nl": "Determine if the func node has a decorator with the qualified name qname ."}}
{"translation": {"code": "def _is_from_future_import ( stmt , name ) : try : module = stmt . do_import_module ( stmt . modname ) except astroid . AstroidBuildingException : return None for local_node in module . locals . get ( name , [ ] ) : if isinstance ( local_node , astroid . ImportFrom ) and local_node . modname == FUTURE : return True return None", "nl": "Check if the name is a future import from another module ."}}
{"translation": {"code": "def _emit_no_member ( node , owner , owner_name , ignored_mixins = True , ignored_none = True ) : # pylint: disable=too-many-return-statements if node_ignores_exception ( node , AttributeError ) : return False if ignored_none and isinstance ( owner , astroid . Const ) and owner . value is None : return False if is_super ( owner ) or getattr ( owner , \"type\" , None ) == \"metaclass\" : return False if ignored_mixins and owner_name [ - 5 : ] . lower ( ) == \"mixin\" : return False if isinstance ( owner , astroid . FunctionDef ) and owner . decorators : return False if isinstance ( owner , ( astroid . Instance , astroid . ClassDef ) ) : if owner . has_dynamic_getattr ( ) : # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not # invoked at this point. try : metaclass = owner . metaclass ( ) except exceptions . MroError : return False if metaclass : return metaclass . qname ( ) == \"enum.EnumMeta\" return False if not has_known_bases ( owner ) : return False if isinstance ( owner , objects . Super ) : # Verify if we are dealing with an invalid Super object. # If it is invalid, then there's no point in checking that # it has the required attribute. Also, don't fail if the # MRO is invalid. try : owner . super_mro ( ) except ( exceptions . MroError , exceptions . SuperError ) : return False if not all ( map ( has_known_bases , owner . type . mro ( ) ) ) : return False if isinstance ( owner , astroid . Module ) : try : owner . getattr ( \"__getattr__\" ) return False except astroid . NotFoundError : pass if node . attrname . startswith ( \"_\" + owner_name ) : # Test if an attribute has been mangled ('private' attribute) unmangled_name = node . attrname . split ( \"_\" + owner_name ) [ - 1 ] try : if owner . getattr ( unmangled_name , context = None ) is not None : return False except astroid . NotFoundError : return True return True", "nl": "Try to see if no - member should be emitted for the given owner ."}}
{"translation": {"code": "def _check_consistent_mro ( self , node ) : try : node . mro ( ) except InconsistentMroError : self . add_message ( \"inconsistent-mro\" , args = node . name , node = node ) except DuplicateBasesError : self . add_message ( \"duplicate-bases\" , args = node . name , node = node ) except NotImplementedError : # Old style class, there's no mro so don't do anything. pass", "nl": "Detect that a class has a consistent mro or duplicate bases ."}}
{"translation": {"code": "def _ignore_class_scope ( self , node ) : # Detect if we are in a local class scope, as an assignment. # For example, the following is fair game. # # class A: #    b = 1 #    c = lambda b=b: b * b # # class B: #    tp = 1 #    def func(self, arg: tp): #        ... # class C: #    tp = 2 #    def func(self, arg=tp): #        ... name = node . name frame = node . statement ( ) . scope ( ) in_annotation_or_default = self . _defined_in_function_definition ( node , frame ) if in_annotation_or_default : frame_locals = frame . parent . scope ( ) . locals else : frame_locals = frame . locals return not ( ( isinstance ( frame , astroid . ClassDef ) or in_annotation_or_default ) and name in frame_locals )", "nl": "Return True if the node is in a local class scope as an assignment ."}}
{"translation": {"code": "def find_try_except_wrapper_node ( node : astroid . node_classes . NodeNG ) -> Union [ astroid . ExceptHandler , astroid . TryExcept ] : current = node ignores = ( astroid . ExceptHandler , astroid . TryExcept ) while current and not isinstance ( current . parent , ignores ) : current = current . parent if current and isinstance ( current . parent , ignores ) : return current . parent return None", "nl": "Return the ExceptHandler or the TryExcept node in which the node is ."}}
{"translation": {"code": "def visit_unaryop ( self , node ) : for error in node . type_errors ( ) : # Let the error customize its output. self . add_message ( \"invalid-unary-operand-type\" , args = str ( error ) , node = node )", "nl": "Detect TypeErrors for unary operands ."}}
{"translation": {"code": "def visit_import ( self , node ) : context_file = node . root ( ) . file for name in node . names : relative = modutils . is_relative ( name [ 0 ] , context_file ) self . _imported_module ( node , name [ 0 ] , relative )", "nl": "visit an astroid . Import node"}}
{"translation": {"code": "def visit_importfrom ( self , node ) : basename = node . modname context_file = node . root ( ) . file if context_file is not None : relative = modutils . is_relative ( basename , context_file ) else : relative = False for name in node . names : if name [ 0 ] == \"*\" : continue # analyze dependencies fullname = \"%s.%s\" % ( basename , name [ 0 ] ) if fullname . find ( \".\" ) > - 1 : try : # TODO: don't use get_module_part, # missing package precedence fullname = modutils . get_module_part ( fullname , context_file ) except ImportError : continue if fullname != basename : self . _imported_module ( node , fullname , relative )", "nl": "visit an astroid . ImportFrom node"}}
{"translation": {"code": "def compute_module ( self , context_name , mod_path ) : package_dir = os . path . dirname ( self . project . path ) if context_name == mod_path : return 0 if modutils . is_standard_module ( mod_path , ( package_dir , ) ) : return 1 return 0", "nl": "return true if the module should be added to dependencies"}}
{"translation": {"code": "def visit_package ( self , node ) : if self . tag : node . uid = self . generate_id ( ) for subelmt in node . values ( ) : self . visit ( subelmt )", "nl": "visit an astroid . Package node"}}
{"translation": {"code": "def visit_functiondef ( self , node ) : if hasattr ( node , \"locals_type\" ) : return node . locals_type = collections . defaultdict ( list ) if self . tag : node . uid = self . generate_id ( )", "nl": "visit an astroid . Function node"}}
{"translation": {"code": "def visit_assignname ( self , node ) : # avoid double parsing done by different Linkers.visit # running over the same project: if hasattr ( node , \"_handled\" ) : return node . _handled = True if node . name in node . frame ( ) : frame = node . frame ( ) else : # the name has been defined as 'global' in the frame and belongs # there. frame = node . root ( ) try : if not hasattr ( frame , \"locals_type\" ) : # If the frame doesn't have a locals_type yet, # it means it wasn't yet visited. Visit it now # to add what's missing from it. if isinstance ( frame , astroid . ClassDef ) : self . visit_classdef ( frame ) elif isinstance ( frame , astroid . FunctionDef ) : self . visit_functiondef ( frame ) else : self . visit_module ( frame ) current = frame . locals_type [ node . name ] values = set ( node . infer ( ) ) frame . locals_type [ node . name ] = list ( set ( current ) | values ) except astroid . InferenceError : pass", "nl": "visit an astroid . AssignName node"}}
{"translation": {"code": "def handle_assignattr_type ( node , parent ) : try : values = set ( node . infer ( ) ) current = set ( parent . instance_attrs_type [ node . attrname ] ) parent . instance_attrs_type [ node . attrname ] = list ( current | values ) except astroid . InferenceError : pass", "nl": "handle an astroid . assignattr node"}}
{"translation": {"code": "def _imported_module ( self , node , mod_path , relative ) : module = node . root ( ) context_name = module . name if relative : mod_path = \"%s.%s\" % ( \".\" . join ( context_name . split ( \".\" ) [ : - 1 ] ) , mod_path ) if self . compute_module ( context_name , mod_path ) : # handle dependencies if not hasattr ( module , \"depends\" ) : module . depends = [ ] mod_paths = module . depends if mod_path not in mod_paths : mod_paths . append ( mod_path )", "nl": "Notify an imported module used to analyze dependencies"}}
{"translation": {"code": "def get_callbacks ( self , node ) : klass = node . __class__ methods = self . _cache . get ( klass ) if methods is None : handler = self . handler kid = klass . __name__ . lower ( ) e_method = getattr ( handler , \"visit_%s\" % kid , getattr ( handler , \"visit_default\" , None ) ) l_method = getattr ( handler , \"leave_%s\" % kid , getattr ( handler , \"leave_default\" , None ) ) self . _cache [ klass ] = ( e_method , l_method ) else : e_method , l_method = methods return e_method , l_method", "nl": "get callbacks from handler for the visited node"}}
{"translation": {"code": "def visit ( self , node ) : if node in self . _visited : return None self . _visited [ node ] = 1 # FIXME: use set ? methods = self . get_callbacks ( node ) if methods [ 0 ] is not None : methods [ 0 ] ( node ) if hasattr ( node , \"locals\" ) : # skip Instance and other proxy for local_node in node . values ( ) : self . visit ( local_node ) if methods [ 1 ] is not None : return methods [ 1 ] ( node ) return None", "nl": "launch the visit starting from the given node"}}
{"translation": {"code": "def visit_starred ( self , node ) : if isinstance ( node . parent , astroid . Call ) : # f(*args) is converted to Call(args=[Starred]), so ignore # them for this check. return if PY35 and isinstance ( node . parent , ( astroid . List , astroid . Tuple , astroid . Set , astroid . Dict ) ) : # PEP 448 unpacking. return stmt = node . statement ( ) if not isinstance ( stmt , astroid . Assign ) : return if stmt . value is node or stmt . value . parent_of ( node ) : self . add_message ( \"star-needs-assignment-target\" , node = node )", "nl": "Check that a Starred expression is used in an assignment target ."}}
{"translation": {"code": "def project_from_files ( files , func_wrapper = _astroid_wrapper , project_name = \"no name\" , black_list = ( \"CVS\" , ) ) : # build the project representation astroid_manager = manager . AstroidManager ( ) project = Project ( project_name ) for something in files : if not os . path . exists ( something ) : fpath = modutils . file_from_modpath ( something . split ( \".\" ) ) elif os . path . isdir ( something ) : fpath = os . path . join ( something , \"__init__.py\" ) else : fpath = something ast = func_wrapper ( astroid_manager . ast_from_file , fpath ) if ast is None : continue # XXX why is first file defining the project.path ? project . path = project . path or ast . file project . add_module ( ast ) base_name = ast . name # recurse in package except if __init__ was explicitly given if ast . package and something . find ( \"__init__\" ) == - 1 : # recurse on others packages / modules if this is a package for fpath in modutils . get_module_files ( os . path . dirname ( ast . file ) , black_list ) : ast = func_wrapper ( astroid_manager . ast_from_file , fpath ) if ast is None or ast . name == base_name : continue project . add_module ( ast ) return project", "nl": "return a Project from a list of files or modules"}}
{"translation": {"code": "def interfaces ( node , herited = True , handler_func = _iface_hdlr ) : # FIXME: what if __implements__ = (MyIFace, MyParent.__implements__)... try : implements = bases . Instance ( node ) . getattr ( \"__implements__\" ) [ 0 ] except exceptions . NotFoundError : return if not herited and implements . frame ( ) is not node : return found = set ( ) missing = False for iface in node_classes . unpack_infer ( implements ) : if iface is astroid . Uninferable : missing = True continue if iface not in found and handler_func ( iface ) : found . add ( iface ) yield iface if missing : raise exceptions . InferenceError ( )", "nl": "Return an iterator on interfaces implemented by the given class node ."}}
{"translation": {"code": "def _check_nonlocal_and_global ( self , node ) : def same_scope ( current ) : return current . scope ( ) is node from_iter = itertools . chain . from_iterable nonlocals = set ( from_iter ( child . names for child in node . nodes_of_class ( astroid . Nonlocal ) if same_scope ( child ) ) ) if not nonlocals : return global_vars = set ( from_iter ( child . names for child in node . nodes_of_class ( astroid . Global ) if same_scope ( child ) ) ) for name in nonlocals . intersection ( global_vars ) : self . add_message ( \"nonlocal-and-global\" , args = ( name , ) , node = node )", "nl": "Check that a name is both nonlocal and global ."}}
{"translation": {"code": "def _is_owner_ignored ( owner , name , ignored_classes , ignored_modules ) : ignored_modules = set ( ignored_modules ) module_name = owner . root ( ) . name module_qname = owner . root ( ) . qname ( ) if any ( module_name in ignored_modules or module_qname in ignored_modules or fnmatch . fnmatch ( module_qname , ignore ) for ignore in ignored_modules ) : return True ignored_classes = set ( ignored_classes ) if hasattr ( owner , \"qname\" ) : qname = owner . qname ( ) else : qname = \"\" return any ( ignore in ( name , qname ) for ignore in ignored_classes )", "nl": "Check if the given owner should be ignored"}}
{"translation": {"code": "def _get_import_name ( importnode , modname ) : if isinstance ( importnode , astroid . ImportFrom ) : if importnode . level : root = importnode . root ( ) if isinstance ( root , astroid . Module ) : modname = root . relative_to_absolute_name ( modname , level = importnode . level ) return modname", "nl": "Get a prepared module name from the given import node"}}
{"translation": {"code": "def _get_ansi_code ( color = None , style = None ) : ansi_code = [ ] if style : style_attrs = utils . _splitstrip ( style ) for effect in style_attrs : ansi_code . append ( ANSI_STYLES [ effect ] ) if color : if color . isdigit ( ) : ansi_code . extend ( [ \"38\" , \"5\" ] ) ansi_code . append ( color ) else : ansi_code . append ( ANSI_COLORS [ color ] ) if ansi_code : return ANSI_PREFIX + \";\" . join ( ansi_code ) + ANSI_END return \"\"", "nl": "return ansi escape code corresponding to color and style"}}
{"translation": {"code": "def colorize_ansi ( msg , color = None , style = None ) : # If both color and style are not defined, then leave the text as is if color is None and style is None : return msg escape_code = _get_ansi_code ( color , style ) # If invalid (or unknown) color, don't wrap msg with ansi codes if escape_code : return \"%s%s%s\" % ( escape_code , msg , ANSI_RESET ) return msg", "nl": "colorize message by wrapping it with ansi escape codes"}}
{"translation": {"code": "def open_graph ( self , * * args ) : self . _stream . write ( \"%sgraph:{\\n\" % self . _indent ) self . _inc_indent ( ) self . _write_attributes ( GRAPH_ATTRS , * * args )", "nl": "open a vcg graph"}}
{"translation": {"code": "def node ( self , title , * * args ) : self . _stream . write ( '%snode: {title:\"%s\"' % ( self . _indent , title ) ) self . _write_attributes ( NODE_ATTRS , * * args ) self . _stream . write ( \"}\\n\" )", "nl": "draw a node"}}
{"translation": {"code": "def edge ( self , from_node , to_node , edge_type = \"\" , * * args ) : self . _stream . write ( '%s%sedge: {sourcename:\"%s\" targetname:\"%s\"' % ( self . _indent , edge_type , from_node , to_node ) ) self . _write_attributes ( EDGE_ATTRS , * * args ) self . _stream . write ( \"}\\n\" )", "nl": "draw an edge from a node to another ."}}
{"translation": {"code": "def generate ( self , outputfile = None , dotfile = None , mapfile = None ) : import subprocess # introduced in py 2.4 name = self . graphname if not dotfile : # if 'outputfile' is a dot file use it as 'dotfile' if outputfile and outputfile . endswith ( \".dot\" ) : dotfile = outputfile else : dotfile = \"%s.dot\" % name if outputfile is not None : storedir , _ , target = target_info_from_filename ( outputfile ) if target != \"dot\" : pdot , dot_sourcepath = tempfile . mkstemp ( \".dot\" , name ) os . close ( pdot ) else : dot_sourcepath = osp . join ( storedir , dotfile ) else : target = \"png\" pdot , dot_sourcepath = tempfile . mkstemp ( \".dot\" , name ) ppng , outputfile = tempfile . mkstemp ( \".png\" , name ) os . close ( pdot ) os . close ( ppng ) pdot = codecs . open ( dot_sourcepath , \"w\" , encoding = \"utf8\" ) pdot . write ( self . source ) pdot . close ( ) if target != \"dot\" : use_shell = sys . platform == \"win32\" if mapfile : subprocess . call ( [ self . renderer , \"-Tcmapx\" , \"-o\" , mapfile , \"-T\" , target , dot_sourcepath , \"-o\" , outputfile , ] , shell = use_shell , ) else : subprocess . call ( [ self . renderer , \"-T\" , target , dot_sourcepath , \"-o\" , outputfile ] , shell = use_shell , ) os . unlink ( dot_sourcepath ) return outputfile", "nl": "Generates a graph file ."}}
{"translation": {"code": "def _get_cycles ( graph_dict , path , visited , result , vertice ) : if vertice in path : cycle = [ vertice ] for node in path [ : : - 1 ] : if node == vertice : break cycle . insert ( 0 , node ) # make a canonical representation start_from = min ( cycle ) index = cycle . index ( start_from ) cycle = cycle [ index : ] + cycle [ 0 : index ] # append it to result if not already in if cycle not in result : result . append ( cycle ) return path . append ( vertice ) try : for node in graph_dict [ vertice ] : # don't check already visited nodes again if node not in visited : _get_cycles ( graph_dict , path , visited , result , node ) visited . add ( node ) except KeyError : pass path . pop ( )", "nl": "recursive function doing the real work for get_cycles"}}
{"translation": {"code": "def get_source ( self ) : if self . _source is None : self . emit ( \"}\\n\" ) self . _source = \"\\n\" . join ( self . lines ) del self . lines return self . _source", "nl": "returns self . _source"}}
{"translation": {"code": "def options_by_section ( self ) : sections = { } for optname , optdict in self . options : sections . setdefault ( optdict . get ( \"group\" ) , [ ] ) . append ( ( optname , optdict , self . option_value ( optname ) ) ) if None in sections : yield None , sections . pop ( None ) for section , options in sorted ( sections . items ( ) ) : yield section . upper ( ) , options", "nl": "return an iterator on options grouped by section"}}
{"translation": {"code": "def load_defaults ( self ) : for opt , optdict in self . options : action = optdict . get ( \"action\" ) if action != \"callback\" : # callback action have no default if optdict is None : optdict = self . get_option_def ( opt ) default = optdict . get ( \"default\" ) self . set_option ( opt , default , action , optdict )", "nl": "initialize the provider using default values"}}
{"translation": {"code": "def get_option_def ( self , opt ) : assert self . options for option in self . options : if option [ 0 ] == opt : return option [ 1 ] raise optparse . OptionError ( \"no such option %s in section %r\" % ( opt , self . name ) , opt )", "nl": "return the dictionary defining an option given its name"}}
{"translation": {"code": "def option_attrname ( self , opt , optdict = None ) : if optdict is None : optdict = self . get_option_def ( opt ) return optdict . get ( \"dest\" , opt . replace ( \"-\" , \"_\" ) )", "nl": "get the config attribute corresponding to opt"}}
{"translation": {"code": "def load_command_line_configuration ( self , args = None ) : with _patch_optparse ( ) : if args is None : args = sys . argv [ 1 : ] else : args = list ( args ) ( options , args ) = self . cmdline_parser . parse_args ( args = args ) for provider in self . _nocallback_options : config = provider . config for attr in config . __dict__ . keys ( ) : value = getattr ( options , attr , None ) if value is None : continue setattr ( config , attr , value ) return args", "nl": "Override configuration according to command line parameters"}}
{"translation": {"code": "def load_config_file ( self ) : parser = self . cfgfile_parser for section in parser . sections ( ) : for option , value in parser . items ( section ) : try : self . global_set_option ( option , value ) except ( KeyError , optparse . OptionError ) : # TODO handle here undeclared options appearing in the config file continue", "nl": "dispatch values previously read from a configuration file to each options provider )"}}
{"translation": {"code": "def generate_config ( self , stream = None , skipsections = ( ) , encoding = None ) : options_by_section = { } sections = [ ] for provider in self . options_providers : for section , options in provider . options_by_section ( ) : if section is None : section = provider . name if section in skipsections : continue options = [ ( n , d , v ) for ( n , d , v ) in options if d . get ( \"type\" ) is not None and not d . get ( \"deprecated\" ) ] if not options : continue if section not in sections : sections . append ( section ) alloptions = options_by_section . setdefault ( section , [ ] ) alloptions += options stream = stream or sys . stdout printed = False for section in sections : if printed : print ( \"\\n\" , file = stream ) utils . format_section ( stream , section . upper ( ) , sorted ( options_by_section [ section ] ) ) printed = True", "nl": "write a configuration file according to the current configuration into the given stream or stdout"}}
{"translation": {"code": "def global_set_option ( self , opt , value ) : self . _all_options [ opt ] . set_option ( opt , value )", "nl": "set option on the correct option provider"}}
{"translation": {"code": "def cb_set_provider_option ( self , option , opt , value , parser ) : if opt . startswith ( \"--\" ) : # remove -- on long option opt = opt [ 2 : ] else : # short option, get its long equivalent opt = self . _short_options [ opt [ 1 : ] ] # trick since we can't set action='store_true' on options if value is None : value = 1 self . global_set_option ( opt , value )", "nl": "optik callback for option setting"}}
{"translation": {"code": "def _expand_default ( self , option ) : if self . parser is None or not self . default_tag : return option . help optname = option . _long_opts [ 0 ] [ 2 : ] try : provider = self . parser . options_manager . _all_options [ optname ] except KeyError : value = None else : optdict = provider . get_option_def ( optname ) optname = provider . option_attrname ( optname , optdict ) value = getattr ( provider . config , optname , optdict ) value = utils . _format_option_value ( optdict , value ) if value is optparse . NO_DEFAULT or not value : value = self . NO_DEFAULT_VALUE return option . help . replace ( self . default_tag , str ( value ) )", "nl": "Patch OptionParser . expand_default with custom behaviour"}}
{"translation": {"code": "def register_options_provider ( self , provider , own_group = True ) : assert provider . priority <= 0 , \"provider's priority can't be >= 0\" for i in range ( len ( self . options_providers ) ) : if provider . priority > self . options_providers [ i ] . priority : self . options_providers . insert ( i , provider ) break else : self . options_providers . append ( provider ) non_group_spec_options = [ option for option in provider . options if \"group\" not in option [ 1 ] ] groups = getattr ( provider , \"option_groups\" , ( ) ) if own_group and non_group_spec_options : self . add_option_group ( provider . name . upper ( ) , provider . __doc__ , non_group_spec_options , provider , ) else : for opt , optdict in non_group_spec_options : self . add_optik_option ( provider , self . cmdline_parser , opt , optdict ) for gname , gdoc in groups : gname = gname . upper ( ) goptions = [ option for option in provider . options if option [ 1 ] . get ( \"group\" , \"\" ) . upper ( ) == gname ] self . add_option_group ( gname , gdoc , goptions , provider )", "nl": "register an options provider"}}
{"translation": {"code": "def _validate ( value , optdict , name = \"\" ) : try : _type = optdict [ \"type\" ] except KeyError : # FIXME return value return _call_validator ( _type , optdict , name , value )", "nl": "return a validated value for an option according to its type"}}
{"translation": {"code": "def help ( self , level = 0 ) : self . cmdline_parser . formatter . output_level = level with _patch_optparse ( ) : return self . cmdline_parser . format_help ( )", "nl": "return the usage string for available options"}}
{"translation": {"code": "def add_help_section ( self , title , description , level = 0 ) : group = optparse . OptionGroup ( self . cmdline_parser , title = title . capitalize ( ) , description = description ) group . level = level self . _maxlevel = max ( self . _maxlevel , level ) self . cmdline_parser . add_option_group ( group )", "nl": "add a dummy option section for help purpose"}}
{"translation": {"code": "def visit_table ( self , layout ) : table_content = self . get_table_content ( layout ) # get columns width cols_width = [ 0 ] * len ( table_content [ 0 ] ) for row in table_content : for index , col in enumerate ( row ) : cols_width [ index ] = max ( cols_width [ index ] , len ( col ) ) self . default_table ( layout , table_content , cols_width ) self . writeln ( )", "nl": "display a table as text"}}
{"translation": {"code": "def format ( self , layout , stream = None , encoding = None ) : if stream is None : stream = sys . stdout if not encoding : encoding = getattr ( stream , \"encoding\" , \"UTF-8\" ) self . encoding = encoding or \"UTF-8\" self . out = stream self . begin_format ( ) layout . accept ( self ) self . end_format ( )", "nl": "format and write the given layout into the stream object"}}
{"translation": {"code": "def parents ( self ) : assert self . parent is not self if self . parent is None : return [ ] return [ self . parent ] + self . parent . parents ( )", "nl": "return the ancestor nodes"}}
{"translation": {"code": "def append ( self , child ) : assert child not in self . parents ( ) VNode . append ( self , child )", "nl": "overridden to detect problems easily"}}
{"translation": {"code": "def default_table ( self , layout , table_content , cols_width ) : cols_width = [ size + 1 for size in cols_width ] format_strings = \" \" . join ( [ \"%%-%ss\" ] * len ( cols_width ) ) format_strings = format_strings % tuple ( cols_width ) format_strings = format_strings . split ( \" \" ) table_linesep = \"\\n+\" + \"+\" . join ( [ \"-\" * w for w in cols_width ] ) + \"+\\n\" headsep = \"\\n+\" + \"+\" . join ( [ \"=\" * w for w in cols_width ] ) + \"+\\n\" # FIXME: layout.cheaders self . write ( table_linesep ) for index , line in enumerate ( table_content ) : self . write ( \"|\" ) for line_index , at_index in enumerate ( line ) : self . write ( format_strings [ line_index ] % at_index ) self . write ( \"|\" ) if index == 0 and layout . rheaders : self . write ( headsep ) else : self . write ( table_linesep )", "nl": "format a table"}}
{"translation": {"code": "def get_table_content ( self , table ) : result = [ [ ] ] cols = table . cols for cell in self . compute_content ( table ) : if cols == 0 : result . append ( [ ] ) cols = table . cols cols -= 1 result [ - 1 ] . append ( cell ) # fill missing cells while len ( result [ - 1 ] ) < cols : result [ - 1 ] . append ( \"\" ) return result", "nl": "trick to get table content without actually writing it"}}
{"translation": {"code": "def compute_content ( self , layout ) : # Patch the underlying output stream with a fresh-generated stream, # which is used to store a temporary representation of a child # node. out = self . out try : for child in layout . children : stream = StringIO ( ) self . out = stream child . accept ( self ) yield stream . getvalue ( ) finally : self . out = out", "nl": "trick to compute the formatting of children layout before actually writing it"}}
{"translation": {"code": "def visit_section ( self , layout ) : self . section += 1 self . writeln ( ) self . format_children ( layout ) self . section -= 1 self . writeln ( )", "nl": "display a section as text"}}
{"translation": {"code": "def _match_long_opt ( self , opt ) : if opt not in self . _long_opt : raise optparse . BadOptionError ( opt ) return opt", "nl": "Disable abbreviations ."}}
{"translation": {"code": "def insert ( self , index , child ) : self . children . insert ( index , child ) child . parent = self", "nl": "insert a child node"}}
{"translation": {"code": "def _is_one_arg_pos_call ( call ) : return isinstance ( call , astroid . Call ) and len ( call . args ) == 1 and not call . keywords", "nl": "Is this a call with exactly 1 argument where that argument is positional?"}}
{"translation": {"code": "def class_is_abstract ( node : astroid . ClassDef ) -> bool : for method in node . methods ( ) : if method . parent . frame ( ) is node : if method . is_abstract ( pass_is_abstract = False ) : return True return False", "nl": "return true if the given class node should be considered as an abstract class"}}
{"translation": {"code": "def _check_boolean_expressions ( self , node ) : condition = node . test if not isinstance ( condition , BoolOp ) : return nb_bool_expr = _count_boolean_expressions ( condition ) if nb_bool_expr > self . config . max_bool_expr : self . add_message ( \"too-many-boolean-expressions\" , node = condition , args = ( nb_bool_expr , self . config . max_bool_expr ) , )", "nl": "Go through if node node and counts its boolean expressions"}}
{"translation": {"code": "def _safe_infer_call_result ( node , caller , context = None ) : try : inferit = node . infer_call_result ( caller , context = context ) value = next ( inferit ) except astroid . InferenceError : return None # inference failed except StopIteration : return None # no values infered try : next ( inferit ) return None # there is ambiguity on the inferred node except astroid . InferenceError : return None # there is some kind of ambiguity except StopIteration : return value", "nl": "Safely infer the return value of a function ."}}
{"translation": {"code": "def _check_imports_order ( self , _module_node ) : std_imports = [ ] third_party_imports = [ ] first_party_imports = [ ] # need of a list that holds third or first party ordered import external_imports = [ ] local_imports = [ ] third_party_not_ignored = [ ] first_party_not_ignored = [ ] local_not_ignored = [ ] isort_obj = isort . SortImports ( file_contents = \"\" , known_third_party = self . config . known_third_party , known_standard_library = self . config . known_standard_library , ) for node , modname in self . _imports_stack : if modname . startswith ( \".\" ) : package = \".\" + modname . split ( \".\" ) [ 1 ] else : package = modname . split ( \".\" ) [ 0 ] nested = not isinstance ( node . parent , astroid . Module ) ignore_for_import_order = not self . linter . is_message_enabled ( \"wrong-import-order\" , node . fromlineno ) import_category = isort_obj . place_module ( package ) node_and_package_import = ( node , package ) if import_category in ( \"FUTURE\" , \"STDLIB\" ) : std_imports . append ( node_and_package_import ) wrong_import = ( third_party_not_ignored or first_party_not_ignored or local_not_ignored ) if self . _is_fallback_import ( node , wrong_import ) : continue if wrong_import and not nested : self . add_message ( \"wrong-import-order\" , node = node , args = ( 'standard import \"%s\"' % node . as_string ( ) , '\"%s\"' % wrong_import [ 0 ] [ 0 ] . as_string ( ) , ) , ) elif import_category == \"THIRDPARTY\" : third_party_imports . append ( node_and_package_import ) external_imports . append ( node_and_package_import ) if not nested and not ignore_for_import_order : third_party_not_ignored . append ( node_and_package_import ) wrong_import = first_party_not_ignored or local_not_ignored if wrong_import and not nested : self . add_message ( \"wrong-import-order\" , node = node , args = ( 'third party import \"%s\"' % node . as_string ( ) , '\"%s\"' % wrong_import [ 0 ] [ 0 ] . as_string ( ) , ) , ) elif import_category == \"FIRSTPARTY\" : first_party_imports . append ( node_and_package_import ) external_imports . append ( node_and_package_import ) if not nested and not ignore_for_import_order : first_party_not_ignored . append ( node_and_package_import ) wrong_import = local_not_ignored if wrong_import and not nested : self . add_message ( \"wrong-import-order\" , node = node , args = ( 'first party import \"%s\"' % node . as_string ( ) , '\"%s\"' % wrong_import [ 0 ] [ 0 ] . as_string ( ) , ) , ) elif import_category == \"LOCALFOLDER\" : local_imports . append ( ( node , package ) ) if not nested and not ignore_for_import_order : local_not_ignored . append ( ( node , package ) ) return std_imports , external_imports , local_imports", "nl": "Checks imports of module node are grouped by category"}}
{"translation": {"code": "def _check_position ( self , node ) : # if a first non-import instruction has already been encountered, # it means the import comes after it and therefore is not well placed if self . _first_non_import_node : self . add_message ( \"wrong-import-position\" , node = node , args = node . as_string ( ) )", "nl": "Check node import or importfrom node position is correct"}}
{"translation": {"code": "def safe_infer ( node : astroid . node_classes . NodeNG , context = None ) -> Optional [ astroid . node_classes . NodeNG ] : try : inferit = node . infer ( context = context ) value = next ( inferit ) except astroid . InferenceError : return None try : next ( inferit ) return None # None if there is ambiguity on the inferred node except astroid . InferenceError : return None # there is some kind of ambiguity except StopIteration : return value", "nl": "Return the inferred value for the given node ."}}
{"translation": {"code": "def _record_import ( self , node , importedmodnode ) : if isinstance ( node , astroid . ImportFrom ) : importedname = node . modname else : importedname = importedmodnode . name if importedmodnode else None if not importedname : importedname = node . names [ 0 ] [ 0 ] . split ( \".\" ) [ 0 ] if isinstance ( node , astroid . ImportFrom ) and ( node . level or 0 ) >= 1 : # We need the importedname with first point to detect local package # Example of node: #  'from .my_package1 import MyClass1' #  the output should be '.my_package1' instead of 'my_package1' # Example of node: #  'from . import my_package2' #  the output should be '.my_package2' instead of '{pyfile}' importedname = \".\" + importedname self . _imports_stack . append ( ( node , importedname ) )", "nl": "Record the package node imports from"}}
{"translation": {"code": "def _qualified_names ( modname ) : names = modname . split ( \".\" ) return [ \".\" . join ( names [ 0 : i + 1 ] ) for i in range ( len ( names ) ) ]", "nl": "Split the names of the given module into subparts"}}
{"translation": {"code": "def _check_graphviz_available ( output_format ) : try : subprocess . call ( [ \"dot\" , \"-V\" ] , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) except OSError : print ( \"The output format '%s' is currently not available.\\n\" \"Please install 'Graphviz' to have other output formats \" \"than 'dot' or 'vcg'.\" % output_format ) sys . exit ( 32 )", "nl": "check if we need graphviz for different output format"}}
{"translation": {"code": "def visit_evaluationsection ( self , layout ) : self . section += 1 self . format_children ( layout ) self . section -= 1 self . writeln ( )", "nl": "Display an evaluation section as a text ."}}
{"translation": {"code": "def _subgraph_parse ( self , node , pathnode , extra_blocks ) : # pylint: disable=unused-argument loose_ends = [ ] self . tail = node self . dispatch_list ( node . body ) loose_ends . append ( self . tail ) for extra in extra_blocks : self . tail = node self . dispatch_list ( extra . body ) loose_ends . append ( self . tail ) if node . orelse : self . tail = node self . dispatch_list ( node . orelse ) loose_ends . append ( self . tail ) else : loose_ends . append ( node ) if node : bottom = \"%s\" % self . _bottom_counter self . _bottom_counter += 1 for le in loose_ends : self . graph . connect ( le , bottom ) self . tail = bottom", "nl": "parse the body and any else block of if and for statements"}}
{"translation": {"code": "def visit_module ( self , node ) : visitor = PathGraphingAstVisitor ( ) for child in node . body : visitor . preorder ( child , visitor ) for graph in visitor . graphs . values ( ) : complexity = graph . complexity ( ) node = graph . root if hasattr ( node , \"name\" ) : node_name = \"'%s'\" % node . name else : node_name = \"This '%s'\" % node . __class__ . __name__ . lower ( ) if complexity <= self . config . max_complexity : continue self . add_message ( \"too-complex\" , node = node , confidence = HIGH , args = ( node_name , complexity ) )", "nl": "visit an astroid . Module node to check too complex rating and add message if is greather than max_complexity stored from options"}}
{"translation": {"code": "def _subgraph ( self , node , name , extra_blocks = ( ) ) : if self . graph is None : # global loop self . graph = PathGraph ( node ) self . _subgraph_parse ( node , node , extra_blocks ) self . graphs [ \"%s%s\" % ( self . classname , name ) ] = self . graph self . reset ( ) else : self . _append_node ( node ) self . _subgraph_parse ( node , node , extra_blocks )", "nl": "create the subgraphs representing any if and for statements"}}
{"translation": {"code": "def possible_exc_types ( node ) : excs = [ ] if isinstance ( node . exc , astroid . Name ) : inferred = utils . safe_infer ( node . exc ) if inferred : excs = [ inferred . name ] elif node . exc is None : handler = node . parent while handler and not isinstance ( handler , astroid . ExceptHandler ) : handler = handler . parent if handler and handler . type : inferred_excs = astroid . unpack_infer ( handler . type ) excs = ( exc . name for exc in inferred_excs if exc is not astroid . Uninferable ) else : target = _get_raise_target ( node ) if isinstance ( target , astroid . ClassDef ) : excs = [ target . name ] elif isinstance ( target , astroid . FunctionDef ) : for ret in target . nodes_of_class ( astroid . Return ) : if ret . frame ( ) != target : # return from inner function - ignore it continue val = utils . safe_infer ( ret . value ) if ( val and isinstance ( val , ( astroid . Instance , astroid . ClassDef ) ) and utils . inherit_from_std_ex ( val ) ) : excs . append ( val . name ) try : return { exc for exc in excs if not utils . node_ignores_exception ( node , exc ) } except astroid . InferenceError : return set ( )", "nl": "Gets all of the possible raised exception types for the given raise node ."}}
{"translation": {"code": "def is_from_fallback_block ( node : astroid . node_classes . NodeNG ) -> bool : context = find_try_except_wrapper_node ( node ) if not context : return False if isinstance ( context , astroid . ExceptHandler ) : other_body = context . parent . body handlers = context . parent . handlers else : other_body = itertools . chain . from_iterable ( handler . body for handler in context . handlers ) handlers = context . handlers has_fallback_imports = any ( isinstance ( import_node , ( astroid . ImportFrom , astroid . Import ) ) for import_node in other_body ) ignores_import_error = _except_handlers_ignores_exception ( handlers , ImportError ) return ignores_import_error or has_fallback_imports", "nl": "Check if the given node is from a fallback import block ."}}
{"translation": {"code": "def returns_something ( return_node ) : returns = return_node . value if returns is None : return False return not ( isinstance ( returns , astroid . Const ) and returns . value is None )", "nl": "Check if a return node returns a value other than None ."}}
{"translation": {"code": "def _is_name_used_as_variadic ( name , variadics ) : return any ( variadic . value == name or variadic . value . parent_of ( name ) for variadic in variadics )", "nl": "Check if the given name is used as a variadic argument ."}}
{"translation": {"code": "def _has_parent_of_type ( node , node_type , statement ) : parent = node . parent while not isinstance ( parent , node_type ) and statement . parent_of ( parent ) : parent = parent . parent return isinstance ( parent , node_type )", "nl": "Check if the given node has a parent of the given type ."}}
{"translation": {"code": "def _no_context_variadic ( node , variadic_name , variadic_type , variadics ) : statement = node . statement ( ) for name in statement . nodes_of_class ( astroid . Name ) : if name . name != variadic_name : continue inferred = safe_infer ( name ) if isinstance ( inferred , ( astroid . List , astroid . Tuple ) ) : length = len ( inferred . elts ) elif isinstance ( inferred , astroid . Dict ) : length = len ( inferred . items ) else : continue inferred_statement = inferred . statement ( ) if not length and isinstance ( inferred_statement , astroid . FunctionDef ) : is_in_starred_context = _has_parent_of_type ( node , variadic_type , statement ) used_as_starred_argument = _is_name_used_as_variadic ( name , variadics ) if is_in_starred_context or used_as_starred_argument : return True return False", "nl": "Verify if the given call node has variadic nodes without context"}}
{"translation": {"code": "def _get_properties ( config ) : property_classes = { BUILTIN_PROPERTY } property_names = set ( ) # Not returning 'property', it has its own check. if config is not None : property_classes . update ( config . property_classes ) property_names . update ( ( prop . rsplit ( \".\" , 1 ) [ - 1 ] for prop in config . property_classes ) ) return property_classes , property_names", "nl": "Returns a tuple of property classes and names ."}}
{"translation": {"code": "def _different_parameters ( original , overridden , dummy_parameter_regex ) : original_parameters = _positional_parameters ( original ) overridden_parameters = _positional_parameters ( overridden ) different_positional = _has_different_parameters ( original_parameters , overridden_parameters , dummy_parameter_regex ) different_kwonly = _has_different_parameters ( original . args . kwonlyargs , overridden . args . kwonlyargs , dummy_parameter_regex ) if original . name in PYMETHODS : # Ignore the difference for special methods. If the parameter # numbers are different, then that is going to be caught by # unexpected-special-method-signature. # If the names are different, it doesn't matter, since they can't # be used as keyword arguments anyway. different_positional = different_kwonly = False # Both or none should have extra variadics, otherwise the method # loses or gains capabilities that are not reflected into the parent method, # leading to potential inconsistencies in the code. different_kwarg = ( sum ( 1 for param in ( original . args . kwarg , overridden . args . kwarg ) if not param ) == 1 ) different_vararg = ( sum ( 1 for param in ( original . args . vararg , overridden . args . vararg ) if not param ) == 1 ) return any ( ( different_positional , different_kwarg , different_vararg , different_kwonly ) )", "nl": "Determine if the two methods have different parameters"}}
{"translation": {"code": "def builder_inited ( app ) : # PACKAGE/docs/exts/pylint_extensions.py --> PACKAGE/ base_path = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) # PACKAGE/ --> PACKAGE/pylint/extensions ext_path = os . path . join ( base_path , \"pylint\" , \"extensions\" ) modules = [ ] doc_files = { } for filename in os . listdir ( ext_path ) : name , ext = os . path . splitext ( filename ) if name [ 0 ] == \"_\" or name in DEPRECATED_MODULES : continue if ext == \".py\" : modules . append ( \"pylint.extensions.%s\" % name ) elif ext == \".rst\" : doc_files [ \"pylint.extensions.\" + name ] = os . path . join ( ext_path , filename ) modules . sort ( ) if not modules : sys . exit ( \"No Pylint extensions found?\" ) linter = PyLinter ( ) linter . load_plugin_modules ( modules ) extensions_doc = os . path . join ( base_path , \"doc\" , \"technical_reference\" , \"extensions.rst\" ) with open ( extensions_doc , \"w\" ) as stream : stream . write ( \"Optional Pylint checkers in the extensions module\\n\" ) stream . write ( \"=================================================\\n\\n\" ) stream . write ( \"Pylint provides the following optional plugins:\\n\\n\" ) for module in modules : stream . write ( \"- :ref:`{}`\\n\" . format ( module ) ) stream . write ( \"\\n\" ) stream . write ( \"You can activate any or all of these extensions \" \"by adding a ``load-plugins`` line to the ``MASTER`` \" \"section of your ``.pylintrc``, for example::\\n\" ) stream . write ( \"\\n    load-plugins=pylint.extensions.docparams,\" \"pylint.extensions.docstyle\\n\\n\" ) by_module = get_plugins_info ( linter , doc_files ) for module , info in sorted ( by_module . items ( ) ) : linter . _print_checker_doc ( info [ \"name\" ] , info , stream = stream )", "nl": "Output full documentation in ReST format for all extension modules"}}
{"translation": {"code": "def _check_literal_comparison ( self , literal , node ) : nodes = ( astroid . List , astroid . Tuple , astroid . Dict , astroid . Set ) is_other_literal = isinstance ( literal , nodes ) is_const = False if isinstance ( literal , astroid . Const ) : if isinstance ( literal . value , bool ) or literal . value is None : # Not interested in this values. return is_const = isinstance ( literal . value , ( bytes , str , int , float ) ) if is_const or is_other_literal : self . add_message ( \"literal-comparison\" , node = node )", "nl": "Check if we compare to a literal which is usually what we do not want to do ."}}
{"translation": {"code": "def _check_useless_super_delegation ( self , function ) : if ( not function . is_method ( ) # With decorators is a change of use or function . decorators ) : return body = function . body if len ( body ) != 1 : # Multiple statements, which means this overridden method # could do multiple things we are not aware of. return statement = body [ 0 ] if not isinstance ( statement , ( astroid . Expr , astroid . Return ) ) : # Doing something else than what we are interested into. return call = statement . value if ( not isinstance ( call , astroid . Call ) # Not a super() attribute access. or not isinstance ( call . func , astroid . Attribute ) ) : return # Should be a super call. try : super_call = next ( call . func . expr . infer ( ) ) except astroid . InferenceError : return else : if not isinstance ( super_call , objects . Super ) : return # The name should be the same. if call . func . attrname != function . name : return # Should be a super call with the MRO pointer being the # current class and the type being the current instance. current_scope = function . parent . scope ( ) if ( super_call . mro_pointer != current_scope or not isinstance ( super_call . type , astroid . Instance ) or super_call . type . name != current_scope . name ) : return # \u00a0Check values of default args klass = function . parent . frame ( ) meth_node = None for overridden in klass . local_attr_ancestors ( function . name ) : # get astroid for the searched method try : meth_node = overridden [ function . name ] except KeyError : # we have found the method but it's not in the local # dictionary. # This may happen with astroid build from living objects continue if ( not isinstance ( meth_node , astroid . FunctionDef ) # If the method have an ancestor which is not a # function then it is legitimate to redefine it or _has_different_parameters_default_value ( meth_node . args , function . args ) ) : return break # Detect if the parameters are the same as the call's arguments. params = _signature_from_arguments ( function . args ) args = _signature_from_call ( call ) if meth_node is not None : def form_annotations ( annotations ) : return [ annotation . as_string ( ) for annotation in filter ( None , annotations ) ] called_annotations = form_annotations ( function . args . annotations ) overridden_annotations = form_annotations ( meth_node . args . annotations ) if called_annotations and overridden_annotations : if called_annotations != overridden_annotations : return if _definition_equivalent_to_call ( params , args ) : self . add_message ( \"useless-super-delegation\" , node = function , args = ( function . name , ) )", "nl": "Check if the given function node is an useless method override"}}
{"translation": {"code": "def _definition_equivalent_to_call ( definition , call ) : if definition . kwargs : same_kw_variadics = definition . kwargs in call . starred_kws else : same_kw_variadics = not call . starred_kws if definition . varargs : same_args_variadics = definition . varargs in call . starred_args else : same_args_variadics = not call . starred_args same_kwonlyargs = all ( kw in call . kws for kw in definition . kwonlyargs ) same_args = definition . args == call . args no_additional_kwarg_arguments = True if call . kws : for keyword in call . kws : is_arg = keyword in call . args is_kwonly = keyword in definition . kwonlyargs if not is_arg and not is_kwonly : # Maybe this argument goes into **kwargs, # or it is an extraneous argument. # In any case, the signature is different than # the call site, which stops our search. no_additional_kwarg_arguments = False break return all ( ( same_args , same_kwonlyargs , same_args_variadics , same_kw_variadics , no_additional_kwarg_arguments , ) )", "nl": "Check if a definition signature is equivalent to a call ."}}
{"translation": {"code": "def node_type ( node : astroid . node_classes . NodeNG ) -> Optional [ type ] : # check there is only one possible type for the assign node. Else we # don't handle it for now types = set ( ) try : for var_type in node . infer ( ) : if var_type == astroid . Uninferable or is_none ( var_type ) : continue types . add ( var_type ) if len ( types ) > 1 : return None except astroid . InferenceError : return None return types . pop ( ) if types else None", "nl": "Return the inferred type for node"}}
{"translation": {"code": "def visit_for ( self , node ) : # Verify that we have a `range([start], len(...), [stop])` call and # that the object which is iterated is used as a subscript in the # body of the for. # Is it a proper range call? if not isinstance ( node . iter , astroid . Call ) : return if not self . _is_builtin ( node . iter . func , \"range\" ) : return if len ( node . iter . args ) == 2 and not _is_constant_zero ( node . iter . args [ 0 ] ) : return if len ( node . iter . args ) > 2 : return # Is it a proper len call? if not isinstance ( node . iter . args [ - 1 ] , astroid . Call ) : return second_func = node . iter . args [ - 1 ] . func if not self . _is_builtin ( second_func , \"len\" ) : return len_args = node . iter . args [ - 1 ] . args if not len_args or len ( len_args ) != 1 : return iterating_object = len_args [ 0 ] if not isinstance ( iterating_object , astroid . Name ) : return # If we're defining __iter__ on self, enumerate won't work scope = node . scope ( ) if iterating_object . name == \"self\" and scope . name == \"__iter__\" : return # Verify that the body of the for loop uses a subscript # with the object that was iterated. This uses some heuristics # in order to make sure that the same object is used in the # for body. for child in node . body : for subscript in child . nodes_of_class ( astroid . Subscript ) : if not isinstance ( subscript . value , astroid . Name ) : continue if not isinstance ( subscript . slice , astroid . Index ) : continue if not isinstance ( subscript . slice . value , astroid . Name ) : continue if subscript . slice . value . name != node . target . name : continue if iterating_object . name != subscript . value . name : continue if subscript . value . scope ( ) != node . scope ( ) : # Ignore this subscript if it's not in the same # scope. This means that in the body of the for # loop, another scope was created, where the same # name for the iterating object was used. continue self . add_message ( \"consider-using-enumerate\" , node = node ) return", "nl": "Emit a convention whenever range and len are used for indexing ."}}
{"translation": {"code": "def _check_simplifiable_if ( self , node ) : if self . _is_actual_elif ( node ) : # Not interested in if statements with multiple branches. return if len ( node . orelse ) != 1 or len ( node . body ) != 1 : return # Check if both branches can be reduced. first_branch = node . body [ 0 ] else_branch = node . orelse [ 0 ] if isinstance ( first_branch , astroid . Return ) : if not isinstance ( else_branch , astroid . Return ) : return first_branch_is_bool = self . _is_bool_const ( first_branch ) else_branch_is_bool = self . _is_bool_const ( else_branch ) reduced_to = \"'return bool(test)'\" elif isinstance ( first_branch , astroid . Assign ) : if not isinstance ( else_branch , astroid . Assign ) : return # Check if we assign to the same value first_branch_targets = [ target . name for target in first_branch . targets if isinstance ( target , astroid . AssignName ) ] else_branch_targets = [ target . name for target in else_branch . targets if isinstance ( target , astroid . AssignName ) ] if not first_branch_targets or not else_branch_targets : return if sorted ( first_branch_targets ) != sorted ( else_branch_targets ) : return first_branch_is_bool = self . _is_bool_const ( first_branch ) else_branch_is_bool = self . _is_bool_const ( else_branch ) reduced_to = \"'var = bool(test)'\" else : return if not first_branch_is_bool or not else_branch_is_bool : return if not first_branch . value . value : # This is a case that can't be easily simplified and # if it can be simplified, it will usually result in a # code that's harder to understand and comprehend. # Let's take for instance `arg and arg <= 3`. This could theoretically be # reduced to `not arg or arg > 3`, but the net result is that now the # condition is harder to understand, because it requires understanding of # an extra clause: #   * first, there is the negation of truthness with `not arg` #   * the second clause is `arg > 3`, which occurs when arg has a #     a truth value, but it implies that `arg > 3` is equivalent #     with `arg and arg > 3`, which means that the user must #     think about this assumption when evaluating `arg > 3`. #     The original form is easier to grasp. return self . add_message ( \"simplifiable-if-statement\" , node = node , args = ( reduced_to , ) )", "nl": "Check if the given if node can be simplified ."}}
{"translation": {"code": "def _check_nested_blocks ( self , node ) : # only check block levels inside functions or methods if not isinstance ( node . scope ( ) , astroid . FunctionDef ) : return # messages are triggered on leaving the nested block. Here we save the # stack in case the current node isn't nested in the previous one nested_blocks = self . _nested_blocks [ : ] if node . parent == node . scope ( ) : self . _nested_blocks = [ node ] else : # go through ancestors from the most nested to the less for ancestor_node in reversed ( self . _nested_blocks ) : if ancestor_node == node . parent : break self . _nested_blocks . pop ( ) # if the node is an elif, this should not be another nesting level if isinstance ( node , astroid . If ) and self . _is_actual_elif ( node ) : if self . _nested_blocks : self . _nested_blocks . pop ( ) self . _nested_blocks . append ( node ) # send message only once per group of nested blocks if len ( nested_blocks ) > len ( self . _nested_blocks ) : self . _emit_nested_blocks_message_if_needed ( nested_blocks )", "nl": "Update and check the number of nested blocks"}}
{"translation": {"code": "def _is_actual_elif ( self , node ) : if isinstance ( node . parent , astroid . If ) : orelse = node . parent . orelse # current if node must directly follow an \"else\" if orelse and orelse == [ node ] : if ( node . lineno , node . col_offset ) in self . _elifs : return True return False", "nl": "Check if the given node is an actual elif"}}
{"translation": {"code": "def _check_consider_merging_isinstance ( self , node ) : if node . op != \"or\" : return first_args = self . _duplicated_isinstance_types ( node ) for duplicated_name , class_names in first_args . items ( ) : names = sorted ( name for name in class_names ) self . add_message ( \"consider-merging-isinstance\" , node = node , args = ( duplicated_name , \", \" . join ( names ) ) , )", "nl": "Check isinstance calls which can be merged together ."}}
{"translation": {"code": "def _duplicated_isinstance_types ( node ) : duplicated_objects = set ( ) all_types = collections . defaultdict ( set ) for call in node . values : if not isinstance ( call , astroid . Call ) or len ( call . args ) != 2 : continue inferred = utils . safe_infer ( call . func ) if not inferred or not utils . is_builtin_object ( inferred ) : continue if inferred . name != \"isinstance\" : continue isinstance_object = call . args [ 0 ] . as_string ( ) isinstance_types = call . args [ 1 ] if isinstance_object in all_types : duplicated_objects . add ( isinstance_object ) if isinstance ( isinstance_types , astroid . Tuple ) : elems = [ class_type . as_string ( ) for class_type in isinstance_types . itered ( ) ] else : elems = [ isinstance_types . as_string ( ) ] all_types [ isinstance_object ] . update ( elems ) # Remove all keys which not duplicated return { key : value for key , value in all_types . items ( ) if key in duplicated_objects }", "nl": "Get the duplicated types from the underlying isinstance calls ."}}
{"translation": {"code": "def _similar_names ( owner , attrname , distance_threshold , max_choices ) : possible_names = [ ] names = _node_names ( owner ) for name in names : if name == attrname : continue distance = _string_distance ( attrname , name ) if distance <= distance_threshold : possible_names . append ( ( name , distance ) ) # Now get back the values with a minimum, up to the given # limit or choices. picked = [ name for ( name , _ ) in heapq . nsmallest ( max_choices , possible_names , key = operator . itemgetter ( 1 ) ) ] return sorted ( picked )", "nl": "Given an owner and a name try to find similar names"}}
{"translation": {"code": "def visit_attribute ( self , node ) : if node . attrname == \"xreadlines\" : self . add_message ( \"xreadlines-attribute\" , node = node ) return exception_message = \"message\" try : for inferred in node . expr . infer ( ) : if isinstance ( inferred , astroid . Instance ) and utils . inherit_from_std_ex ( inferred ) : if node . attrname == exception_message : # Exceptions with .message clearly defined are an exception if exception_message in inferred . instance_attrs : continue self . add_message ( \"exception-message-attribute\" , node = node ) if isinstance ( inferred , astroid . Module ) : self . _warn_if_deprecated ( node , inferred . name , { node . attrname } , report_on_modules = False ) except astroid . InferenceError : return", "nl": "Look for removed attributes"}}
{"translation": {"code": "def is_registered_in_singledispatch_function ( node : astroid . FunctionDef ) -> bool : singledispatch_qnames = ( \"functools.singledispatch\" , \"singledispatch.singledispatch\" , ) if not isinstance ( node , astroid . FunctionDef ) : return False decorators = node . decorators . nodes if node . decorators else [ ] for decorator in decorators : # func.register are function calls if not isinstance ( decorator , astroid . Call ) : continue func = decorator . func if not isinstance ( func , astroid . Attribute ) or func . attrname != \"register\" : continue try : func_def = next ( func . expr . infer ( ) ) except astroid . InferenceError : continue if isinstance ( func_def , astroid . FunctionDef ) : # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here return decorated_with ( func_def , singledispatch_qnames ) return False", "nl": "Check if the given function node is a singledispatch function ."}}
{"translation": {"code": "def set_accessed ( self , node ) : frame = node_frame_class ( node ) if frame is None : # The node does not live in a class. return self . _scopes [ frame ] [ node . attrname ] . append ( node )", "nl": "Set the given node as accessed ."}}
{"translation": {"code": "def _is_conditional_import ( node ) : parent = node . parent return isinstance ( parent , ( astroid . TryExcept , astroid . ExceptHandler , astroid . If , astroid . IfExp ) )", "nl": "Checks if an import node is in the context of a conditional ."}}
{"translation": {"code": "def _check_metaclasses ( self , node ) : consumed = [ ] # [(scope_locals, consumed_key)] for child_node in node . get_children ( ) : if isinstance ( child_node , astroid . ClassDef ) : consumed . extend ( self . _check_classdef_metaclasses ( child_node , node ) ) # Pop the consumed items, in order to avoid having # unused-import and unused-variable false positives for scope_locals , name in consumed : scope_locals . pop ( name , None )", "nl": "Update consumption analysis for metaclasses ."}}
{"translation": {"code": "def _is_and_or_ternary ( node ) : return ( isinstance ( node , astroid . BoolOp ) and node . op == \"or\" and len ( node . values ) == 2 and isinstance ( node . values [ 0 ] , astroid . BoolOp ) and not isinstance ( node . values [ 1 ] , astroid . BoolOp ) and node . values [ 0 ] . op == \"and\" and not isinstance ( node . values [ 0 ] . values [ 1 ] , astroid . BoolOp ) and len ( node . values [ 0 ] . values ) == 2 )", "nl": "Returns true if node is condition and true_value or false_value form ."}}
{"translation": {"code": "def _has_valid_type_annotation ( self , tokens , i ) : if not self . _inside_brackets ( \"(\" ) : return False # token_info # type string start end line #  0      1     2    3    4 bracket_level = 0 for token in tokens [ i - 1 : : - 1 ] : if token [ 1 ] == \":\" : return True if token [ 1 ] == \"(\" : return False if token [ 1 ] == \"]\" : bracket_level += 1 elif token [ 1 ] == \"[\" : bracket_level -= 1 elif token [ 1 ] == \",\" : if not bracket_level : return False elif token [ 1 ] in ( \".\" , \"...\" ) : continue elif token [ 0 ] not in ( tokenize . NAME , tokenize . STRING , tokenize . NL ) : return False return False", "nl": "Extended check of PEP - 484 type hint presence"}}
{"translation": {"code": "def is_complex_format_str ( node ) : inferred = utils . safe_infer ( node ) if inferred is None or not isinstance ( inferred . value , str ) : return True try : parsed = list ( string . Formatter ( ) . parse ( inferred . value ) ) except ValueError : # This format string is invalid return False for _ , _ , format_spec , _ in parsed : if format_spec : return True return False", "nl": "Checks if node represents a string with complex formatting specs ."}}
{"translation": {"code": "def _assigned_locally ( name_node ) : assign_stmts = name_node . scope ( ) . nodes_of_class ( astroid . AssignName ) return any ( a . name == name_node . name for a in assign_stmts )", "nl": "Checks if name_node has corresponding assign statement in same scope"}}
{"translation": {"code": "def get_setters_property_name ( node ) : decorators = node . decorators . nodes if node . decorators else [ ] for decorator in decorators : if ( isinstance ( decorator , astroid . Attribute ) and decorator . attrname == \"setter\" and isinstance ( decorator . expr , astroid . Name ) ) : return decorator . expr . name return None", "nl": "Get the name of the property that the given node is a setter for ."}}
{"translation": {"code": "def get_setters_property ( node ) : property_ = None property_name = get_setters_property_name ( node ) class_node = utils . node_frame_class ( node ) if property_name and class_node : class_attrs = class_node . getattr ( node . name ) for attr in class_attrs : if utils . decorated_with_property ( attr ) : property_ = attr break return property_", "nl": "Get the property node for the given setter node ."}}
{"translation": {"code": "def _check_stop_iteration_inside_generator ( self , node ) : frame = node . frame ( ) if not isinstance ( frame , astroid . FunctionDef ) or not frame . is_generator ( ) : return if utils . node_ignores_exception ( node , StopIteration ) : return if not node . exc : return exc = utils . safe_infer ( node . exc ) if exc is None or exc is astroid . Uninferable : return if self . _check_exception_inherit_from_stopiteration ( exc ) : self . add_message ( \"stop-iteration-return\" , node = node )", "nl": "Check if an exception of type StopIteration is raised inside a generator"}}
{"translation": {"code": "def _check_exception_inherit_from_stopiteration ( exc ) : stopiteration_qname = \"{}.StopIteration\" . format ( utils . EXCEPTIONS_MODULE ) return any ( _class . qname ( ) == stopiteration_qname for _class in exc . mro ( ) )", "nl": "Return True if the exception node in argument inherit from StopIteration"}}
{"translation": {"code": "def _check_raising_stopiteration_in_generator_next_call ( self , node ) : def _looks_like_infinite_iterator ( param ) : inferred = utils . safe_infer ( param ) if inferred : return inferred . qname ( ) in KNOWN_INFINITE_ITERATORS return False if isinstance ( node . func , astroid . Attribute ) : # A next() method, which is now what we want. return inferred = utils . safe_infer ( node . func ) if getattr ( inferred , \"name\" , \"\" ) == \"next\" : frame = node . frame ( ) # The next builtin can only have up to two # positional arguments and no keyword arguments has_sentinel_value = len ( node . args ) > 1 if ( isinstance ( frame , astroid . FunctionDef ) and frame . is_generator ( ) and not has_sentinel_value and not utils . node_ignores_exception ( node , StopIteration ) and not _looks_like_infinite_iterator ( node . args [ 0 ] ) ) : self . add_message ( \"stop-iteration-return\" , node = node )", "nl": "Check if a StopIteration exception is raised by the call to next function"}}