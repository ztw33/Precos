{"translation": {"code": "def get_exception_handlers ( node : astroid . node_classes . NodeNG , exception = Exception ) -> List [ astroid . ExceptHandler ] : context = find_try_except_wrapper_node ( node ) if isinstance ( context , astroid . TryExcept ) : return [ handler for handler in context . handlers if error_of_type ( handler , exception ) ] return None", "nl": "Return the collections of handlers handling the exception in arguments ."}}
{"translation": {"code": "def _check_arg_equality ( node_a , node_b , attr_name ) : return getattr ( node_a , attr_name ) == getattr ( node_b , attr_name )", "nl": "Check equality of nodes based on the comparison of their attributes named attr_name ."}}
{"translation": {"code": "def mark_as_consumed ( self , name , new_node ) : self . consumed [ name ] = new_node del self . to_consume [ name ]", "nl": "Mark the name as consumed and delete it from the to_consume dictionary"}}
{"translation": {"code": "def _is_node_return_ended ( self , node ) : # \u00a0Recursion base case if isinstance ( node , astroid . Return ) : return True if isinstance ( node , astroid . Call ) : try : funcdef_node = node . func . inferred ( ) [ 0 ] if self . _is_function_def_never_returning ( funcdef_node ) : return True except astroid . InferenceError : pass # Avoid the check inside while loop as we don't know # \u00a0if they will be completed if isinstance ( node , astroid . While ) : return True if isinstance ( node , astroid . Raise ) : # a Raise statement doesn't need to end with a return statement # but if the exception raised is handled, then the handler has to # ends with a return statement if not node . exc : # Ignore bare raises return True if not utils . is_node_inside_try_except ( node ) : # If the raise statement is not inside a try/except statement # \u00a0then the exception is raised and cannot be caught. No need # \u00a0to infer it. return True exc = utils . safe_infer ( node . exc ) if exc is None or exc is astroid . Uninferable : return False exc_name = exc . pytype ( ) . split ( \".\" ) [ - 1 ] handlers = utils . get_exception_handlers ( node , exc_name ) handlers = list ( handlers ) if handlers is not None else [ ] if handlers : # among all the handlers handling the exception at least one # must end with a return statement return any ( self . _is_node_return_ended ( _handler ) for _handler in handlers ) # if no handlers handle the exception then it's ok return True if isinstance ( node , astroid . If ) : # if statement is returning if there are exactly two return statements in its # \u00a0children : one for the body part, the other for the orelse part # Do not check if inner function definition are return ended. is_orelse_returning = any ( self . _is_node_return_ended ( _ore ) for _ore in node . orelse if not isinstance ( _ore , astroid . FunctionDef ) ) is_if_returning = any ( self . _is_node_return_ended ( _ifn ) for _ifn in node . body if not isinstance ( _ifn , astroid . FunctionDef ) ) return is_if_returning and is_orelse_returning # \u00a0recurses on the children of the node except for those which are except handler # because one cannot be sure that the handler will really be used return any ( self . _is_node_return_ended ( _child ) for _child in node . get_children ( ) if not isinstance ( _child , astroid . ExceptHandler ) )", "nl": "Check if the node ends with an explicit return statement ."}}
{"translation": {"code": "def process_module ( self , module ) : managed_msgs = MessagesHandlerMixIn . get_by_id_managed_msgs ( ) for ( mod_name , msg_id , msg_symbol , lineno , is_disabled ) in managed_msgs : if mod_name == module . name : if is_disabled : txt = \"Id '{ident}' is used to disable '{symbol}' message emission\" . format ( ident = msg_id , symbol = msg_symbol ) else : txt = \"Id '{ident}' is used to enable '{symbol}' message emission\" . format ( ident = msg_id , symbol = msg_symbol ) self . add_message ( \"use-symbolic-message-instead\" , line = lineno , args = txt ) MessagesHandlerMixIn . clear_by_id_managed_msgs ( )", "nl": "inspect the source file to find messages activated or deactivated by id ."}}
{"translation": {"code": "def token_indent ( self , idx ) : line_indent = self . line_indent ( idx ) return line_indent + \" \" * ( self . start_col ( idx ) - len ( line_indent ) )", "nl": "Get an indentation string for hanging indentation consisting of the line - indent plus a number of spaces to fill up to the column of this token ."}}
{"translation": {"code": "def is_postponed_evaluation_enabled ( node : astroid . node_classes . NodeNG ) -> bool : name = \"annotations\" module = node . root ( ) stmt = module . locals . get ( name ) return ( stmt and isinstance ( stmt [ 0 ] , astroid . ImportFrom ) and stmt [ 0 ] . modname == \"__future__\" )", "nl": "Check if the postponed evaluation of annotations is enabled"}}
{"translation": {"code": "def is_inside_lambda ( node : astroid . node_classes . NodeNG ) -> bool : parent = node . parent while parent is not None : if isinstance ( parent , astroid . Lambda ) : return True parent = parent . parent return False", "nl": "Return true if given node is inside lambda"}}
{"translation": {"code": "def _is_enum_class ( node : astroid . ClassDef ) -> bool : for base in node . bases : try : inferred_bases = base . inferred ( ) except astroid . InferenceError : continue for ancestor in inferred_bases : if not isinstance ( ancestor , astroid . ClassDef ) : continue if ancestor . name == \"Enum\" and ancestor . root ( ) . name == \"enum\" : return True return False", "nl": "Check if a class definition defines an Enum class ."}}
{"translation": {"code": "def _is_dataclass ( node : astroid . ClassDef ) -> bool : if not node . decorators : return False root_locals = node . root ( ) . locals for decorator in node . decorators . nodes : if isinstance ( decorator , astroid . Call ) : decorator = decorator . func if not isinstance ( decorator , ( astroid . Name , astroid . Attribute ) ) : continue if isinstance ( decorator , astroid . Name ) : name = decorator . name else : name = decorator . attrname if name == DATACLASS_DECORATOR and DATACLASS_DECORATOR in root_locals : return True return False", "nl": "Check if a class definition defines a Python 3 . 7 + dataclass"}}
{"translation": {"code": "def _is_typing_namedtuple ( node : astroid . ClassDef ) -> bool : for base in node . ancestors ( ) : if base . qname ( ) == TYPING_NAMEDTUPLE : return True return False", "nl": "Check if a class node is a typing . NamedTuple class"}}
{"translation": {"code": "def _cpu_count ( ) -> int : sched_getaffinity = getattr ( os , \"sched_getaffinity\" , None ) # pylint: disable=not-callable,using-constant-test if sched_getaffinity : return len ( sched_getaffinity ( 0 ) ) if multiprocessing : return multiprocessing . cpu_count ( ) return 1", "nl": "Use sched_affinity if available for virtualized or containerized environments ."}}
{"translation": {"code": "def collect_string_fields ( format_string ) -> Iterable [ Optional [ str ] ] : formatter = string . Formatter ( ) try : parseiterator = formatter . parse ( format_string ) for result in parseiterator : if all ( item is None for item in result [ 1 : ] ) : # not a replacement format continue name = result [ 1 ] nested = result [ 2 ] yield name if nested : for field in collect_string_fields ( nested ) : yield field except ValueError as exc : # Probably the format string is invalid. if exc . args [ 0 ] . startswith ( \"cannot switch from manual\" ) : # On Jython, parsing a string with both manual # and automatic positions will fail with a ValueError, # while on CPython it will simply return the fields, # the validation being done in the interpreter (?). # We're just returning two mixed fields in order # to trigger the format-combined-specification check. yield \"\" yield \"1\" return raise IncompleteFormatString ( format_string )", "nl": "Given a format string return an iterator of all the valid format fields . It handles nested fields as well ."}}
{"translation": {"code": "def register_report ( self , reportid , r_title , r_cb , checker ) : reportid = reportid . upper ( ) self . _reports [ checker ] . append ( ( reportid , r_title , r_cb ) )", "nl": "register a report"}}
{"translation": {"code": "def add_stats ( self , * * kwargs ) : for key , value in kwargs . items ( ) : if key [ - 1 ] == \"_\" : key = key [ : - 1 ] assert key not in self . stats self . stats [ key ] = value return self . stats", "nl": "add some stats entries to the statistic dictionary raise an AssertionError if there is a key conflict"}}
{"translation": {"code": "def disable ( self , msgid , scope = \"package\" , line = None , ignore_unknown = False ) : self . _set_msg_status ( msgid , enable = False , scope = scope , line = line , ignore_unknown = ignore_unknown ) self . _register_by_id_managed_msg ( msgid , line )", "nl": "don t output message of the given id"}}
{"translation": {"code": "def enable ( self , msgid , scope = \"package\" , line = None , ignore_unknown = False ) : self . _set_msg_status ( msgid , enable = True , scope = scope , line = line , ignore_unknown = ignore_unknown ) self . _register_by_id_managed_msg ( msgid , line , is_disabled = False )", "nl": "reenable message of the given id"}}
{"translation": {"code": "def _message_symbol ( self , msgid ) : try : return [ md . symbol for md in self . msgs_store . get_message_definitions ( msgid ) ] except UnknownMessageError : return msgid", "nl": "Get the message symbol of the given message id"}}
{"translation": {"code": "def _print_checker_doc ( checker_name , info , stream = None ) : if not stream : stream = sys . stdout doc = info . get ( \"doc\" ) module = info . get ( \"module\" ) msgs = info . get ( \"msgs\" ) options = info . get ( \"options\" ) reports = info . get ( \"reports\" ) checker_title = \"%s checker\" % ( checker_name . replace ( \"_\" , \" \" ) . title ( ) ) if module : # Provide anchor to link against print ( \".. _%s:\\n\" % module , file = stream ) print ( checker_title , file = stream ) print ( \"~\" * len ( checker_title ) , file = stream ) print ( \"\" , file = stream ) if module : print ( \"This checker is provided by ``%s``.\" % module , file = stream ) print ( \"Verbatim name of the checker is ``%s``.\" % checker_name , file = stream ) print ( \"\" , file = stream ) if doc : # Provide anchor to link against title = \"{} Documentation\" . format ( checker_title ) print ( title , file = stream ) print ( \"^\" * len ( title ) , file = stream ) print ( cleandoc ( doc ) , file = stream ) print ( \"\" , file = stream ) if options : title = \"{} Options\" . format ( checker_title ) print ( title , file = stream ) print ( \"^\" * len ( title ) , file = stream ) _rest_format_section ( stream , None , options ) print ( \"\" , file = stream ) if msgs : title = \"{} Messages\" . format ( checker_title ) print ( title , file = stream ) print ( \"^\" * len ( title ) , file = stream ) for msgid , msg in sorted ( msgs . items ( ) , key = lambda kv : ( _MSG_ORDER . index ( kv [ 0 ] [ 0 ] ) , kv [ 1 ] ) ) : msg = build_message_definition ( checker_name , msgid , msg ) print ( msg . format_help ( checkerref = False ) , file = stream ) print ( \"\" , file = stream ) if reports : title = \"{} Reports\" . format ( checker_title ) print ( title , file = stream ) print ( \"^\" * len ( title ) , file = stream ) for report in reports : print ( \":%s: %s\" % report [ : 2 ] , file = stream ) print ( \"\" , file = stream ) print ( \"\" , file = stream )", "nl": "Helper method for print_full_documentation ."}}
{"translation": {"code": "def safe_decode ( line , encoding , * args , * * kwargs ) : try : return line . decode ( encoding or sys . getdefaultencoding ( ) , * args , * * kwargs ) except LookupError : return line . decode ( sys . getdefaultencoding ( ) , * args , * * kwargs )", "nl": "return decoded line from encoding or decode with default encoding"}}
{"translation": {"code": "def _format_option_value ( optdict , value ) : if isinstance ( value , ( list , tuple ) ) : value = \",\" . join ( _format_option_value ( optdict , item ) for item in value ) elif isinstance ( value , dict ) : value = \",\" . join ( \"%s:%s\" % ( k , v ) for k , v in value . items ( ) ) elif hasattr ( value , \"match\" ) : # optdict.get('type') == 'regexp' # compiled regexp value = value . pattern elif optdict . get ( \"type\" ) == \"yn\" : value = \"yes\" if value else \"no\" elif isinstance ( value , str ) and value . isspace ( ) : value = \"'%s'\" % value return value", "nl": "return the user input s value from a compiled value"}}
{"translation": {"code": "def register_plugins ( linter , directory ) : imported = { } for filename in listdir ( directory ) : base , extension = splitext ( filename ) if base in imported or base == \"__pycache__\" : continue if ( extension in PY_EXTS and base != \"__init__\" or ( not extension and isdir ( join ( directory , base ) ) ) ) : try : module = modutils . load_module_from_file ( join ( directory , filename ) ) except ValueError : # empty module name (usually emacs auto-save files) continue except ImportError as exc : print ( \"Problem importing module %s: %s\" % ( filename , exc ) , file = sys . stderr ) else : if hasattr ( module , \"register\" ) : module . register ( linter ) imported [ base ] = 1", "nl": "load all module and package in the given directory looking for a register function in each one used to register pylint checkers"}}
{"translation": {"code": "def _comment ( string ) : lines = [ line . strip ( ) for line in string . splitlines ( ) ] return \"# \" + ( \"%s# \" % linesep ) . join ( lines )", "nl": "return string as a comment"}}
{"translation": {"code": "def format_section ( stream , section , options , doc = None ) : if doc : print ( _comment ( doc ) , file = stream ) print ( \"[%s]\" % section , file = stream ) _ini_format ( stream , options )", "nl": "format an options section using the INI format"}}
{"translation": {"code": "def _raise_duplicate_msg_id ( symbol , msgid , other_msgid ) : msgids = [ msgid , other_msgid ] msgids . sort ( ) error_message = \"Message symbol '{symbol}' cannot be used for \" . format ( symbol = symbol ) error_message += \"'{other_msgid}' and '{msgid}' at the same time.\" . format ( other_msgid = msgids [ 0 ] , msgid = msgids [ 1 ] ) raise InvalidMessageError ( error_message )", "nl": "Raise an error when a msgid is duplicated ."}}
{"translation": {"code": "def add_renamed_message ( self , old_id , old_symbol , new_symbol ) : message_definition = self . get_message_definitions ( new_symbol ) [ 0 ] message_definition . old_names . append ( ( old_id , old_symbol ) ) self . _register_alternative_name ( message_definition , old_id , old_symbol )", "nl": "Register the old ID and symbol for a warning that was renamed ."}}
{"translation": {"code": "def register_messages_from_checker ( self , checker ) : checker . check_consistency ( ) for message in checker . messages : self . register_message ( message )", "nl": "Register all messages from a checker ."}}
{"translation": {"code": "def _raise_duplicate_symbol ( msgid , symbol , other_symbol ) : symbols = [ symbol , other_symbol ] symbols . sort ( ) error_message = \"Message id '{msgid}' cannot have both \" . format ( msgid = msgid ) error_message += \"'{other_symbol}' and '{symbol}' as symbolic name.\" . format ( other_symbol = symbols [ 0 ] , symbol = symbols [ 1 ] ) raise InvalidMessageError ( error_message )", "nl": "Raise an error when a symbol is duplicated ."}}
{"translation": {"code": "def list_messages ( self ) : messages = sorted ( self . _messages_definitions . values ( ) , key = lambda m : m . msgid ) for message in messages : if not message . may_be_emitted ( ) : continue print ( message . format_help ( checkerref = False ) ) print ( \"\" )", "nl": "Output full messages list documentation in ReST format ."}}
{"translation": {"code": "def get_message_definitions ( self , msgid_or_symbol : str ) -> list : if msgid_or_symbol [ 1 : ] . isdigit ( ) : msgid_or_symbol = msgid_or_symbol . upper ( ) for source in ( self . _alternative_names , self . _messages_definitions ) : try : return [ source [ msgid_or_symbol ] ] except KeyError : pass error_msg = \"No such message id or symbol '{msgid_or_symbol}'.\" . format ( msgid_or_symbol = msgid_or_symbol ) raise UnknownMessageError ( error_msg )", "nl": "Returns the Message object for this message ."}}
{"translation": {"code": "def _rest_format_section ( stream , section , options , doc = None ) : if section : print ( \"%s\\n%s\" % ( section , \"'\" * len ( section ) ) , file = stream ) if doc : print ( normalize_text ( doc , line_len = 79 , indent = \"\" ) , file = stream ) print ( file = stream ) for optname , optdict , value in options : help_opt = optdict . get ( \"help\" ) print ( \":%s:\" % optname , file = stream ) if help_opt : help_opt = normalize_text ( help_opt , line_len = 79 , indent = \"  \" ) print ( help_opt , file = stream ) if value : value = str ( _format_option_value ( optdict , value ) ) print ( file = stream ) print ( \"  Default: ``%s``\" % value . replace ( \"`` \" , \"```` ``\" ) , file = stream )", "nl": "format an options section using as ReST formatted output"}}
{"translation": {"code": "def normalize_text ( text , line_len = 80 , indent = \"\" ) : return \"\\n\" . join ( textwrap . wrap ( text , width = line_len , initial_indent = indent , subsequent_indent = indent ) )", "nl": "Wrap the text on the given line length ."}}
{"translation": {"code": "def _is_trailing_comma ( tokens , index ) : token = tokens [ index ] if token . exact_type != tokenize . COMMA : return False # Must have remaining tokens on the same line such as NEWLINE left_tokens = itertools . islice ( tokens , index + 1 , None ) same_line_remaining_tokens = list ( itertools . takewhile ( lambda other_token , _token = token : other_token . start [ 0 ] == _token . start [ 0 ] , left_tokens , ) ) # Note: If the newline is tokenize.NEWLINE and not tokenize.NL # then the newline denotes the end of expression is_last_element = all ( other_token . type in ( tokenize . NEWLINE , tokenize . COMMENT ) for other_token in same_line_remaining_tokens ) if not same_line_remaining_tokens or not is_last_element : return False def get_curline_index_start ( ) : \"\"\"Get the index denoting the start of the current line\"\"\" for subindex , token in enumerate ( reversed ( tokens [ : index ] ) ) : # See Lib/tokenize.py and Lib/token.py in cpython for more info if token . type in ( tokenize . NEWLINE , tokenize . NL ) : return index - subindex return 0 curline_start = get_curline_index_start ( ) expected_tokens = { \"return\" , \"yield\" } for prevtoken in tokens [ curline_start : index ] : if \"=\" in prevtoken . string or prevtoken . string in expected_tokens : return True return False", "nl": "Check if the given token is a trailing comma"}}