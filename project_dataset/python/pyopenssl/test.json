{"translation": {"code": "def set_alpn_protos ( self , protos ) : # Take the list of protocols and join them together, prefixing them # with their lengths. protostr = b'' . join ( chain . from_iterable ( ( int2byte ( len ( p ) ) , p ) for p in protos ) ) # Build a C string from the list. We don't need to save this off # because OpenSSL immediately copies the data out. input_str = _ffi . new ( \"unsigned char[]\" , protostr ) _lib . SSL_set_alpn_protos ( self . _ssl , input_str , len ( protostr ) )", "nl": "Specify the client s ALPN protocol list ."}}
{"translation": {"code": "def get_alpn_proto_negotiated ( self ) : data = _ffi . new ( \"unsigned char **\" ) data_len = _ffi . new ( \"unsigned int *\" ) _lib . SSL_get0_alpn_selected ( self . _ssl , data , data_len ) if not data_len : return b'' return _ffi . buffer ( data [ 0 ] , data_len [ 0 ] ) [ : ]", "nl": "Get the protocol that was negotiated by ALPN ."}}
{"translation": {"code": "def _init ( self ) : ret = _lib . X509_STORE_CTX_init ( self . _store_ctx , self . _store . _store , self . _cert . _x509 , _ffi . NULL ) if ret <= 0 : _raise_current_error ( )", "nl": "Set up the store context for a subsequent verification operation ."}}
{"translation": {"code": "def verify_certificate ( self ) : # Always re-initialize the store context in case # :meth:`verify_certificate` is called multiple times. # # :meth:`_init` is called in :meth:`__init__` so _cleanup is called # before _init to ensure memory is not leaked. self . _cleanup ( ) self . _init ( ) ret = _lib . X509_verify_cert ( self . _store_ctx ) self . _cleanup ( ) if ret <= 0 : raise self . _exception_from_context ( )", "nl": "Verify a certificate in a context ."}}
{"translation": {"code": "def dump_publickey ( type , pkey ) : bio = _new_mem_buf ( ) if type == FILETYPE_PEM : write_bio = _lib . PEM_write_bio_PUBKEY elif type == FILETYPE_ASN1 : write_bio = _lib . i2d_PUBKEY_bio else : raise ValueError ( \"type argument must be FILETYPE_PEM or FILETYPE_ASN1\" ) result_code = write_bio ( bio , pkey . _pkey ) if result_code != 1 : # pragma: no cover _raise_current_error ( ) return _bio_to_string ( bio )", "nl": "Dump a public key to a buffer ."}}
{"translation": {"code": "def add_crl ( self , crl ) : _openssl_assert ( _lib . X509_STORE_add_crl ( self . _store , crl . _crl ) != 0 )", "nl": "Add a certificate revocation list to this store ."}}
{"translation": {"code": "def to_cryptography_key ( self ) : backend = _get_backend ( ) if self . _only_public : return backend . _evp_pkey_to_public_key ( self . _pkey ) else : return backend . _evp_pkey_to_private_key ( self . _pkey )", "nl": "Export as a cryptography key ."}}
{"translation": {"code": "def set_ocsp_client_callback ( self , callback , data = None ) : helper = _OCSPClientCallbackHelper ( callback ) self . _set_ocsp_callback ( helper , data )", "nl": "Set a callback to validate OCSP data stapled to the TLS handshake on the client side ."}}
{"translation": {"code": "def _set_ocsp_callback ( self , helper , data ) : self . _ocsp_helper = helper self . _ocsp_callback = helper . callback if data is None : self . _ocsp_data = _ffi . NULL else : self . _ocsp_data = _ffi . new_handle ( data ) rc = _lib . SSL_CTX_set_tlsext_status_cb ( self . _context , self . _ocsp_callback ) _openssl_assert ( rc == 1 ) rc = _lib . SSL_CTX_set_tlsext_status_arg ( self . _context , self . _ocsp_data ) _openssl_assert ( rc == 1 )", "nl": "This internal helper does the common work for set_ocsp_server_callback and set_ocsp_client_callback which is almost all of it ."}}
{"translation": {"code": "def to_cryptography ( self ) : from cryptography . hazmat . backends . openssl . x509 import _Certificate backend = _get_backend ( ) return _Certificate ( backend , self . _x509 )", "nl": "Export as a cryptography certificate ."}}
{"translation": {"code": "def to_cryptography ( self ) : from cryptography . hazmat . backends . openssl . x509 import ( _CertificateSigningRequest ) backend = _get_backend ( ) return _CertificateSigningRequest ( backend , self . _req )", "nl": "Export as a cryptography certificate signing request ."}}
{"translation": {"code": "def export_keying_material ( self , label , olen , context = None ) : outp = _no_zero_allocator ( \"unsigned char[]\" , olen ) context_buf = _ffi . NULL context_len = 0 use_context = 0 if context is not None : context_buf = context context_len = len ( context ) use_context = 1 success = _lib . SSL_export_keying_material ( self . _ssl , outp , olen , label , len ( label ) , context_buf , context_len , use_context ) _openssl_assert ( success == 1 ) return _ffi . buffer ( outp , olen ) [ : ]", "nl": "Obtain keying material for application use ."}}
{"translation": {"code": "def set_tlsext_use_srtp ( self , profiles ) : if not isinstance ( profiles , bytes ) : raise TypeError ( \"profiles must be a byte string.\" ) _openssl_assert ( _lib . SSL_CTX_set_tlsext_use_srtp ( self . _context , profiles ) == 0 )", "nl": "Enable support for negotiating SRTP keying material ."}}