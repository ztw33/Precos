{"translation": {"code": "def createCertRequest ( pkey , digest = \"sha256\" , * * name ) : req = crypto . X509Req ( ) subj = req . get_subject ( ) for key , value in name . items ( ) : setattr ( subj , key , value ) req . set_pubkey ( pkey ) req . sign ( pkey , digest ) return req", "nl": "Create a certificate request ."}}
{"translation": {"code": "def createCertificate ( req , issuerCertKey , serial , validityPeriod , digest = \"sha256\" ) : issuerCert , issuerKey = issuerCertKey notBefore , notAfter = validityPeriod cert = crypto . X509 ( ) cert . set_serial_number ( serial ) cert . gmtime_adj_notBefore ( notBefore ) cert . gmtime_adj_notAfter ( notAfter ) cert . set_issuer ( issuerCert . get_subject ( ) ) cert . set_subject ( req . get_subject ( ) ) cert . set_pubkey ( req . get_pubkey ( ) ) cert . sign ( issuerKey , digest ) return cert", "nl": "Generate a certificate given a certificate request ."}}
{"translation": {"code": "def check_exception ( self ) : for i in xrange ( self . iterations ) : cert = X509 ( ) try : cert . get_pubkey ( ) except Error : pass", "nl": "Call the method repeatedly such that it will raise an exception ."}}
{"translation": {"code": "def check_success ( self ) : small = xrange ( 3 ) for i in xrange ( self . iterations ) : key = PKey ( ) key . generate_key ( TYPE_DSA , 256 ) for i in small : cert = X509 ( ) cert . set_pubkey ( key ) for i in small : cert . get_pubkey ( )", "nl": "Call the method repeatedly such that it will return a PKey object ."}}
{"translation": {"code": "def check_load_privatekey_callback ( self ) : for i in xrange ( self . iterations * 10 ) : load_privatekey ( FILETYPE_PEM , self . ENCRYPTED_PEM , lambda * args : \"hello, secret\" )", "nl": "Call the function with an encrypted PEM and a passphrase callback ."}}
{"translation": {"code": "def check_load_privatekey_callback_incorrect ( self ) : for i in xrange ( self . iterations * 10 ) : try : load_privatekey ( FILETYPE_PEM , self . ENCRYPTED_PEM , lambda * args : \"hello, public\" ) except Error : pass", "nl": "Call the function with an encrypted PEM and a passphrase callback which returns the wrong passphrase ."}}
{"translation": {"code": "def check_load_privatekey_callback_wrong_type ( self ) : for i in xrange ( self . iterations * 10 ) : try : load_privatekey ( FILETYPE_PEM , self . ENCRYPTED_PEM , lambda * args : { } ) except ValueError : pass", "nl": "Call the function with an encrypted PEM and a passphrase callback which returns a non - string ."}}
{"translation": {"code": "def check ( self ) : if self . _only_public : raise TypeError ( \"public key only\" ) if _lib . EVP_PKEY_type ( self . type ( ) ) != _lib . EVP_PKEY_RSA : raise TypeError ( \"key type unsupported\" ) rsa = _lib . EVP_PKEY_get1_RSA ( self . _pkey ) rsa = _ffi . gc ( rsa , _lib . RSA_free ) result = _lib . RSA_check_key ( rsa ) if result : return True _raise_current_error ( )", "nl": "Check the consistency of an RSA private key ."}}
{"translation": {"code": "def set_version ( self , version ) : if not isinstance ( version , int ) : raise TypeError ( \"version must be an integer\" ) _lib . X509_set_version ( self . _x509 , version )", "nl": "Set the version number of the certificate . Note that the version value is zero - based eg . a value of 0 is V1 ."}}
{"translation": {"code": "def get_serial_number ( self ) : asn1_serial = _lib . X509_get_serialNumber ( self . _x509 ) bignum_serial = _lib . ASN1_INTEGER_to_BN ( asn1_serial , _ffi . NULL ) try : hex_serial = _lib . BN_bn2hex ( bignum_serial ) try : hexstring_serial = _ffi . string ( hex_serial ) serial = int ( hexstring_serial , 16 ) return serial finally : _lib . OPENSSL_free ( hex_serial ) finally : _lib . BN_free ( bignum_serial )", "nl": "Return the serial number of this certificate ."}}
{"translation": {"code": "def gmtime_adj_notAfter ( self , amount ) : if not isinstance ( amount , int ) : raise TypeError ( \"amount must be an integer\" ) notAfter = _lib . X509_get_notAfter ( self . _x509 ) _lib . X509_gmtime_adj ( notAfter , amount )", "nl": "Adjust the time stamp on which the certificate stops being valid ."}}
{"translation": {"code": "def has_expired ( self ) : time_string = _native ( self . get_notAfter ( ) ) not_after = datetime . datetime . strptime ( time_string , \"%Y%m%d%H%M%SZ\" ) return not_after < datetime . datetime . utcnow ( )", "nl": "Check whether the certificate has expired ."}}
{"translation": {"code": "def set_serial_number ( self , serial ) : if not isinstance ( serial , _integer_types ) : raise TypeError ( \"serial must be an integer\" ) hex_serial = hex ( serial ) [ 2 : ] if not isinstance ( hex_serial , bytes ) : hex_serial = hex_serial . encode ( 'ascii' ) bignum_serial = _ffi . new ( \"BIGNUM**\" ) # BN_hex2bn stores the result in &bignum.  Unless it doesn't feel like # it.  If bignum is still NULL after this call, then the return value # is actually the result.  I hope.  -exarkun small_serial = _lib . BN_hex2bn ( bignum_serial , hex_serial ) if bignum_serial [ 0 ] == _ffi . NULL : set_result = _lib . ASN1_INTEGER_set ( _lib . X509_get_serialNumber ( self . _x509 ) , small_serial ) if set_result : # TODO Not tested _raise_current_error ( ) else : asn1_serial = _lib . BN_to_ASN1_INTEGER ( bignum_serial [ 0 ] , _ffi . NULL ) _lib . BN_free ( bignum_serial [ 0 ] ) if asn1_serial == _ffi . NULL : # TODO Not tested _raise_current_error ( ) asn1_serial = _ffi . gc ( asn1_serial , _lib . ASN1_INTEGER_free ) set_result = _lib . X509_set_serialNumber ( self . _x509 , asn1_serial ) _openssl_assert ( set_result == 1 )", "nl": "Set the serial number of the certificate ."}}
{"translation": {"code": "def _bio_to_string ( bio ) : result_buffer = _ffi . new ( 'char**' ) buffer_length = _lib . BIO_get_mem_data ( bio , result_buffer ) return _ffi . buffer ( result_buffer [ 0 ] , buffer_length ) [ : ]", "nl": "Copy the contents of an OpenSSL BIO object into a Python byte string ."}}
{"translation": {"code": "def generate_key ( self , type , bits ) : if not isinstance ( type , int ) : raise TypeError ( \"type must be an integer\" ) if not isinstance ( bits , int ) : raise TypeError ( \"bits must be an integer\" ) if type == TYPE_RSA : if bits <= 0 : raise ValueError ( \"Invalid number of bits\" ) # TODO Check error return exponent = _lib . BN_new ( ) exponent = _ffi . gc ( exponent , _lib . BN_free ) _lib . BN_set_word ( exponent , _lib . RSA_F4 ) rsa = _lib . RSA_new ( ) result = _lib . RSA_generate_key_ex ( rsa , bits , exponent , _ffi . NULL ) _openssl_assert ( result == 1 ) result = _lib . EVP_PKEY_assign_RSA ( self . _pkey , rsa ) _openssl_assert ( result == 1 ) elif type == TYPE_DSA : dsa = _lib . DSA_new ( ) _openssl_assert ( dsa != _ffi . NULL ) dsa = _ffi . gc ( dsa , _lib . DSA_free ) res = _lib . DSA_generate_parameters_ex ( dsa , bits , _ffi . NULL , 0 , _ffi . NULL , _ffi . NULL , _ffi . NULL ) _openssl_assert ( res == 1 ) _openssl_assert ( _lib . DSA_generate_key ( dsa ) == 1 ) _openssl_assert ( _lib . EVP_PKEY_set1_DSA ( self . _pkey , dsa ) == 1 ) else : raise Error ( \"No such key type\" ) self . _initialized = True", "nl": "Generate a key pair of the given type with the given number of bits ."}}
{"translation": {"code": "def sign ( self , pkey , digest ) : if not isinstance ( pkey , PKey ) : raise TypeError ( \"pkey must be a PKey instance\" ) if pkey . _only_public : raise ValueError ( \"Key only has public part\" ) if not pkey . _initialized : raise ValueError ( \"Key is uninitialized\" ) evp_md = _lib . EVP_get_digestbyname ( _byte_string ( digest ) ) if evp_md == _ffi . NULL : raise ValueError ( \"No such digest method\" ) sign_result = _lib . X509_sign ( self . _x509 , pkey . _pkey , evp_md ) _openssl_assert ( sign_result > 0 )", "nl": "Sign the certificate with this key and digest type ."}}
{"translation": {"code": "def set_pubkey ( self , pkey ) : if not isinstance ( pkey , PKey ) : raise TypeError ( \"pkey must be a PKey instance\" ) set_result = _lib . X509_set_pubkey ( self . _x509 , pkey . _pkey ) _openssl_assert ( set_result == 1 )", "nl": "Set the public key of the certificate ."}}
{"translation": {"code": "def get_pubkey ( self ) : pkey = PKey . __new__ ( PKey ) pkey . _pkey = _lib . X509_get_pubkey ( self . _x509 ) if pkey . _pkey == _ffi . NULL : _raise_current_error ( ) pkey . _pkey = _ffi . gc ( pkey . _pkey , _lib . EVP_PKEY_free ) pkey . _only_public = True return pkey", "nl": "Get the public key of the certificate ."}}
{"translation": {"code": "def digest ( self , digest_name ) : digest = _lib . EVP_get_digestbyname ( _byte_string ( digest_name ) ) if digest == _ffi . NULL : raise ValueError ( \"No such digest method\" ) result_buffer = _ffi . new ( \"unsigned char[]\" , _lib . EVP_MAX_MD_SIZE ) result_length = _ffi . new ( \"unsigned int[]\" , 1 ) result_length [ 0 ] = len ( result_buffer ) digest_result = _lib . X509_digest ( self . _x509 , digest , result_buffer , result_length ) _openssl_assert ( digest_result == 1 ) return b\":\" . join ( [ b16encode ( ch ) . upper ( ) for ch in _ffi . buffer ( result_buffer , result_length [ 0 ] ) ] )", "nl": "Return the digest of the X509 object ."}}
{"translation": {"code": "def get_signature_algorithm ( self ) : algor = _lib . X509_get0_tbs_sigalg ( self . _x509 ) nid = _lib . OBJ_obj2nid ( algor . algorithm ) if nid == _lib . NID_undef : raise ValueError ( \"Undefined signature algorithm\" ) return _ffi . string ( _lib . OBJ_nid2ln ( nid ) )", "nl": "Return the signature algorithm used in the certificate ."}}
{"translation": {"code": "def get_subject ( self ) : name = self . _get_name ( _lib . X509_get_subject_name ) self . _subject_invalidator . add ( name ) return name", "nl": "Return the subject of this certificate ."}}
{"translation": {"code": "def set_subject ( self , subject ) : self . _set_name ( _lib . X509_set_subject_name , subject ) self . _subject_invalidator . clear ( )", "nl": "Set the subject of this certificate ."}}
{"translation": {"code": "def der ( self ) : result_buffer = _ffi . new ( 'unsigned char**' ) encode_result = _lib . i2d_X509_NAME ( self . _name , result_buffer ) _openssl_assert ( encode_result >= 0 ) string_result = _ffi . buffer ( result_buffer [ 0 ] , encode_result ) [ : ] _lib . OPENSSL_free ( result_buffer [ 0 ] ) return string_result", "nl": "Return the DER encoding of this name ."}}
{"translation": {"code": "def get_components ( self ) : result = [ ] for i in range ( _lib . X509_NAME_entry_count ( self . _name ) ) : ent = _lib . X509_NAME_get_entry ( self . _name , i ) fname = _lib . X509_NAME_ENTRY_get_object ( ent ) fval = _lib . X509_NAME_ENTRY_get_data ( ent ) nid = _lib . OBJ_obj2nid ( fname ) name = _lib . OBJ_nid2sn ( nid ) # ffi.string does not handle strings containing NULL bytes # (which may have been generated by old, broken software) value = _ffi . buffer ( _lib . ASN1_STRING_data ( fval ) , _lib . ASN1_STRING_length ( fval ) ) [ : ] result . append ( ( _ffi . string ( name ) , value ) ) return result", "nl": "Returns the components of this name as a sequence of 2 - tuples ."}}
{"translation": {"code": "def set_issuer ( self , issuer ) : self . _set_name ( _lib . X509_set_issuer_name , issuer ) self . _issuer_invalidator . clear ( )", "nl": "Set the issuer of this certificate ."}}
{"translation": {"code": "def get_issuer ( self ) : name = self . _get_name ( _lib . X509_get_issuer_name ) self . _issuer_invalidator . add ( name ) return name", "nl": "Return the issuer of this certificate ."}}
{"translation": {"code": "def gmtime_adj_notBefore ( self , amount ) : if not isinstance ( amount , int ) : raise TypeError ( \"amount must be an integer\" ) notBefore = _lib . X509_get_notBefore ( self . _x509 ) _lib . X509_gmtime_adj ( notBefore , amount )", "nl": "Adjust the timestamp on which the certificate starts being valid ."}}
{"translation": {"code": "def get_short_name ( self ) : obj = _lib . X509_EXTENSION_get_object ( self . _extension ) nid = _lib . OBJ_obj2nid ( obj ) return _ffi . string ( _lib . OBJ_nid2sn ( nid ) )", "nl": "Returns the short type name of this X . 509 extension ."}}
{"translation": {"code": "def add_extensions ( self , extensions ) : for ext in extensions : if not isinstance ( ext , X509Extension ) : raise ValueError ( \"One of the elements is not an X509Extension\" ) add_result = _lib . X509_add_ext ( self . _x509 , ext . _extension , - 1 ) if not add_result : _raise_current_error ( )", "nl": "Add extensions to the certificate ."}}
{"translation": {"code": "def get_extension ( self , index ) : ext = X509Extension . __new__ ( X509Extension ) ext . _extension = _lib . X509_get_ext ( self . _x509 , index ) if ext . _extension == _ffi . NULL : raise IndexError ( \"extension index out of bounds\" ) extension = _lib . X509_EXTENSION_dup ( ext . _extension ) ext . _extension = _ffi . gc ( extension , _lib . X509_EXTENSION_free ) return ext", "nl": "Get a specific extension of the certificate by index ."}}
{"translation": {"code": "def get_subject ( self ) : name = X509Name . __new__ ( X509Name ) name . _name = _lib . X509_REQ_get_subject_name ( self . _req ) _openssl_assert ( name . _name != _ffi . NULL ) # The name is owned by the X509Req structure.  As long as the X509Name # Python object is alive, keep the X509Req Python object alive. name . _owner = self return name", "nl": "Return the subject of this certificate signing request ."}}
{"translation": {"code": "def get_pubkey ( self ) : pkey = PKey . __new__ ( PKey ) pkey . _pkey = _lib . X509_REQ_get_pubkey ( self . _req ) _openssl_assert ( pkey . _pkey != _ffi . NULL ) pkey . _pkey = _ffi . gc ( pkey . _pkey , _lib . EVP_PKEY_free ) pkey . _only_public = True return pkey", "nl": "Get the public key of the certificate signing request ."}}
{"translation": {"code": "def set_pubkey ( self , pkey ) : set_result = _lib . X509_REQ_set_pubkey ( self . _req , pkey . _pkey ) _openssl_assert ( set_result == 1 )", "nl": "Set the public key of the certificate signing request ."}}
{"translation": {"code": "def add_extensions ( self , extensions ) : stack = _lib . sk_X509_EXTENSION_new_null ( ) _openssl_assert ( stack != _ffi . NULL ) stack = _ffi . gc ( stack , _lib . sk_X509_EXTENSION_free ) for ext in extensions : if not isinstance ( ext , X509Extension ) : raise ValueError ( \"One of the elements is not an X509Extension\" ) # TODO push can fail (here and elsewhere) _lib . sk_X509_EXTENSION_push ( stack , ext . _extension ) add_result = _lib . X509_REQ_add_extensions ( self . _req , stack ) _openssl_assert ( add_result == 1 )", "nl": "Add extensions to the certificate signing request ."}}
{"translation": {"code": "def get_data ( self ) : octet_result = _lib . X509_EXTENSION_get_data ( self . _extension ) string_result = _ffi . cast ( 'ASN1_STRING*' , octet_result ) char_result = _lib . ASN1_STRING_data ( string_result ) result_length = _lib . ASN1_STRING_length ( string_result ) return _ffi . buffer ( char_result , result_length ) [ : ]", "nl": "Returns the data of the X509 extension encoded as ASN . 1 ."}}
{"translation": {"code": "def verify ( cert , signature , data , digest ) : data = _text_to_bytes_and_warn ( \"data\" , data ) digest_obj = _lib . EVP_get_digestbyname ( _byte_string ( digest ) ) if digest_obj == _ffi . NULL : raise ValueError ( \"No such digest method\" ) pkey = _lib . X509_get_pubkey ( cert . _x509 ) _openssl_assert ( pkey != _ffi . NULL ) pkey = _ffi . gc ( pkey , _lib . EVP_PKEY_free ) md_ctx = _lib . Cryptography_EVP_MD_CTX_new ( ) md_ctx = _ffi . gc ( md_ctx , _lib . Cryptography_EVP_MD_CTX_free ) _lib . EVP_VerifyInit ( md_ctx , digest_obj ) _lib . EVP_VerifyUpdate ( md_ctx , data , len ( data ) ) verify_result = _lib . EVP_VerifyFinal ( md_ctx , signature , len ( signature ) , pkey ) if verify_result != 1 : _raise_current_error ( )", "nl": "Verify the signature for a data string ."}}
{"translation": {"code": "def sign ( pkey , data , digest ) : data = _text_to_bytes_and_warn ( \"data\" , data ) digest_obj = _lib . EVP_get_digestbyname ( _byte_string ( digest ) ) if digest_obj == _ffi . NULL : raise ValueError ( \"No such digest method\" ) md_ctx = _lib . Cryptography_EVP_MD_CTX_new ( ) md_ctx = _ffi . gc ( md_ctx , _lib . Cryptography_EVP_MD_CTX_free ) _lib . EVP_SignInit ( md_ctx , digest_obj ) _lib . EVP_SignUpdate ( md_ctx , data , len ( data ) ) length = _lib . EVP_PKEY_size ( pkey . _pkey ) _openssl_assert ( length > 0 ) signature_buffer = _ffi . new ( \"unsigned char[]\" , length ) signature_length = _ffi . new ( \"unsigned int *\" ) final_result = _lib . EVP_SignFinal ( md_ctx , signature_buffer , signature_length , pkey . _pkey ) _openssl_assert ( final_result == 1 ) return _ffi . buffer ( signature_buffer , signature_length [ 0 ] ) [ : ]", "nl": "Sign a data string using the given key and message digest ."}}
{"translation": {"code": "def get_revoked ( self ) : results = [ ] revoked_stack = _lib . X509_CRL_get_REVOKED ( self . _crl ) for i in range ( _lib . sk_X509_REVOKED_num ( revoked_stack ) ) : revoked = _lib . sk_X509_REVOKED_value ( revoked_stack , i ) revoked_copy = _lib . Cryptography_X509_REVOKED_dup ( revoked ) pyrev = Revoked . __new__ ( Revoked ) pyrev . _revoked = _ffi . gc ( revoked_copy , _lib . X509_REVOKED_free ) results . append ( pyrev ) if results : return tuple ( results )", "nl": "Return the revocations in this certificate revocation list ."}}
{"translation": {"code": "def get_serial ( self ) : bio = _new_mem_buf ( ) asn1_int = _lib . X509_REVOKED_get0_serialNumber ( self . _revoked ) _openssl_assert ( asn1_int != _ffi . NULL ) result = _lib . i2a_ASN1_INTEGER ( bio , asn1_int ) _openssl_assert ( result >= 0 ) return _bio_to_string ( bio )", "nl": "Get the serial number ."}}
{"translation": {"code": "def set_reason ( self , reason ) : if reason is None : self . _delete_reason ( ) elif not isinstance ( reason , bytes ) : raise TypeError ( \"reason must be None or a byte string\" ) else : reason = reason . lower ( ) . replace ( b' ' , b'' ) reason_code = [ r . lower ( ) for r in self . _crl_reasons ] . index ( reason ) new_reason_ext = _lib . ASN1_ENUMERATED_new ( ) _openssl_assert ( new_reason_ext != _ffi . NULL ) new_reason_ext = _ffi . gc ( new_reason_ext , _lib . ASN1_ENUMERATED_free ) set_result = _lib . ASN1_ENUMERATED_set ( new_reason_ext , reason_code ) _openssl_assert ( set_result != _ffi . NULL ) self . _delete_reason ( ) add_result = _lib . X509_REVOKED_add1_ext_i2d ( self . _revoked , _lib . NID_crl_reason , new_reason_ext , 0 , 0 ) _openssl_assert ( add_result == 1 )", "nl": "Set the reason of this revocation ."}}
{"translation": {"code": "def get_reason ( self ) : for i in range ( _lib . X509_REVOKED_get_ext_count ( self . _revoked ) ) : ext = _lib . X509_REVOKED_get_ext ( self . _revoked , i ) obj = _lib . X509_EXTENSION_get_object ( ext ) if _lib . OBJ_obj2nid ( obj ) == _lib . NID_crl_reason : bio = _new_mem_buf ( ) print_result = _lib . X509V3_EXT_print ( bio , ext , 0 , 0 ) if not print_result : print_result = _lib . M_ASN1_OCTET_STRING_print ( bio , _lib . X509_EXTENSION_get_data ( ext ) ) _openssl_assert ( print_result != 0 ) return _bio_to_string ( bio )", "nl": "Get the reason of this revocation ."}}
{"translation": {"code": "def set_rev_date ( self , when ) : dt = _lib . X509_REVOKED_get0_revocationDate ( self . _revoked ) return _set_asn1_time ( dt , when )", "nl": "Set the revocation timestamp ."}}
{"translation": {"code": "def get_issuer ( self ) : _issuer = _lib . X509_NAME_dup ( _lib . X509_CRL_get_issuer ( self . _crl ) ) _openssl_assert ( _issuer != _ffi . NULL ) _issuer = _ffi . gc ( _issuer , _lib . X509_NAME_free ) issuer = X509Name . __new__ ( X509Name ) issuer . _name = _issuer return issuer", "nl": "Get the CRL s issuer ."}}
{"translation": {"code": "def _get_asn1_time ( timestamp ) : string_timestamp = _ffi . cast ( 'ASN1_STRING*' , timestamp ) if _lib . ASN1_STRING_length ( string_timestamp ) == 0 : return None elif ( _lib . ASN1_STRING_type ( string_timestamp ) == _lib . V_ASN1_GENERALIZEDTIME ) : return _ffi . string ( _lib . ASN1_STRING_data ( string_timestamp ) ) else : generalized_timestamp = _ffi . new ( \"ASN1_GENERALIZEDTIME**\" ) _lib . ASN1_TIME_to_generalizedtime ( timestamp , generalized_timestamp ) if generalized_timestamp [ 0 ] == _ffi . NULL : # This may happen: #   - if timestamp was not an ASN1_TIME #   - if allocating memory for the ASN1_GENERALIZEDTIME failed #   - if a copy of the time data from timestamp cannot be made for #     the newly allocated ASN1_GENERALIZEDTIME # # These are difficult to test.  cffi enforces the ASN1_TIME type. # Memory allocation failures are a pain to trigger # deterministically. _untested_error ( \"ASN1_TIME_to_generalizedtime\" ) else : string_timestamp = _ffi . cast ( \"ASN1_STRING*\" , generalized_timestamp [ 0 ] ) string_data = _lib . ASN1_STRING_data ( string_timestamp ) string_result = _ffi . string ( string_data ) _lib . ASN1_GENERALIZEDTIME_free ( generalized_timestamp [ 0 ] ) return string_result", "nl": "Retrieve the time value of an ASN1 time object ."}}
{"translation": {"code": "def _set_asn1_time ( boundary , when ) : if not isinstance ( when , bytes ) : raise TypeError ( \"when must be a byte string\" ) set_result = _lib . ASN1_TIME_set_string ( boundary , when ) if set_result == 0 : raise ValueError ( \"Invalid string\" )", "nl": "The the time value of an ASN1 time object ."}}
{"translation": {"code": "def export ( self , cert , key , type = FILETYPE_PEM , days = 100 , digest = _UNSPECIFIED ) : if not isinstance ( cert , X509 ) : raise TypeError ( \"cert must be an X509 instance\" ) if not isinstance ( key , PKey ) : raise TypeError ( \"key must be a PKey instance\" ) if not isinstance ( type , int ) : raise TypeError ( \"type must be an integer\" ) if digest is _UNSPECIFIED : raise TypeError ( \"digest must be provided\" ) digest_obj = _lib . EVP_get_digestbyname ( digest ) if digest_obj == _ffi . NULL : raise ValueError ( \"No such digest method\" ) bio = _lib . BIO_new ( _lib . BIO_s_mem ( ) ) _openssl_assert ( bio != _ffi . NULL ) # A scratch time object to give different values to different CRL # fields sometime = _lib . ASN1_TIME_new ( ) _openssl_assert ( sometime != _ffi . NULL ) _lib . X509_gmtime_adj ( sometime , 0 ) _lib . X509_CRL_set_lastUpdate ( self . _crl , sometime ) _lib . X509_gmtime_adj ( sometime , days * 24 * 60 * 60 ) _lib . X509_CRL_set_nextUpdate ( self . _crl , sometime ) _lib . X509_CRL_set_issuer_name ( self . _crl , _lib . X509_get_subject_name ( cert . _x509 ) ) sign_result = _lib . X509_CRL_sign ( self . _crl , key . _pkey , digest_obj ) if not sign_result : _raise_current_error ( ) return dump_crl ( type , self )", "nl": "Export the CRL as a string ."}}
{"translation": {"code": "def set_serial ( self , hex_str ) : bignum_serial = _ffi . gc ( _lib . BN_new ( ) , _lib . BN_free ) bignum_ptr = _ffi . new ( \"BIGNUM**\" ) bignum_ptr [ 0 ] = bignum_serial bn_result = _lib . BN_hex2bn ( bignum_ptr , hex_str ) if not bn_result : raise ValueError ( \"bad hex string\" ) asn1_serial = _ffi . gc ( _lib . BN_to_ASN1_INTEGER ( bignum_serial , _ffi . NULL ) , _lib . ASN1_INTEGER_free ) _lib . X509_REVOKED_set_serialNumber ( self . _revoked , asn1_serial )", "nl": "Set the serial number ."}}
{"translation": {"code": "def get_pubkey ( self ) : pkey = PKey . __new__ ( PKey ) pkey . _pkey = _lib . NETSCAPE_SPKI_get_pubkey ( self . _spki ) _openssl_assert ( pkey . _pkey != _ffi . NULL ) pkey . _pkey = _ffi . gc ( pkey . _pkey , _lib . EVP_PKEY_free ) pkey . _only_public = True return pkey", "nl": "Get the public key of this certificate ."}}
{"translation": {"code": "def b64_encode ( self ) : encoded = _lib . NETSCAPE_SPKI_b64_encode ( self . _spki ) result = _ffi . string ( encoded ) _lib . OPENSSL_free ( encoded ) return result", "nl": "Generate a base64 encoded representation of this SPKI object ."}}
{"translation": {"code": "def verify ( self , key ) : answer = _lib . NETSCAPE_SPKI_verify ( self . _spki , key . _pkey ) if answer <= 0 : _raise_current_error ( ) return True", "nl": "Verifies a signature on a certificate request ."}}
{"translation": {"code": "def sign ( self , pkey , digest ) : if pkey . _only_public : raise ValueError ( \"Key has only public part\" ) if not pkey . _initialized : raise ValueError ( \"Key is uninitialized\" ) digest_obj = _lib . EVP_get_digestbyname ( _byte_string ( digest ) ) if digest_obj == _ffi . NULL : raise ValueError ( \"No such digest method\" ) sign_result = _lib . NETSCAPE_SPKI_sign ( self . _spki , pkey . _pkey , digest_obj ) _openssl_assert ( sign_result > 0 )", "nl": "Sign the certificate request with this key and digest type ."}}
{"translation": {"code": "def set_pubkey ( self , pkey ) : set_result = _lib . NETSCAPE_SPKI_set_pubkey ( self . _spki , pkey . _pkey ) _openssl_assert ( set_result == 1 )", "nl": "Set the public key of the certificate"}}
{"translation": {"code": "def export ( self , passphrase = None , iter = 2048 , maciter = 1 ) : passphrase = _text_to_bytes_and_warn ( \"passphrase\" , passphrase ) if self . _cacerts is None : cacerts = _ffi . NULL else : cacerts = _lib . sk_X509_new_null ( ) cacerts = _ffi . gc ( cacerts , _lib . sk_X509_free ) for cert in self . _cacerts : _lib . sk_X509_push ( cacerts , cert . _x509 ) if passphrase is None : passphrase = _ffi . NULL friendlyname = self . _friendlyname if friendlyname is None : friendlyname = _ffi . NULL if self . _pkey is None : pkey = _ffi . NULL else : pkey = self . _pkey . _pkey if self . _cert is None : cert = _ffi . NULL else : cert = self . _cert . _x509 pkcs12 = _lib . PKCS12_create ( passphrase , friendlyname , pkey , cert , cacerts , _lib . NID_pbe_WithSHA1And3_Key_TripleDES_CBC , _lib . NID_pbe_WithSHA1And3_Key_TripleDES_CBC , iter , maciter , 0 ) if pkcs12 == _ffi . NULL : _raise_current_error ( ) pkcs12 = _ffi . gc ( pkcs12 , _lib . PKCS12_free ) bio = _new_mem_buf ( ) _lib . i2d_PKCS12_bio ( bio , pkcs12 ) return _bio_to_string ( bio )", "nl": "Dump a PKCS12 object as a string ."}}
{"translation": {"code": "def set_ca_certificates ( self , cacerts ) : if cacerts is None : self . _cacerts = None else : cacerts = list ( cacerts ) for cert in cacerts : if not isinstance ( cert , X509 ) : raise TypeError ( \"iterable must only contain X509 instances\" ) self . _cacerts = cacerts", "nl": "Replace or set the CA certificates within the PKCS12 object ."}}
{"translation": {"code": "def get_type_name ( self ) : nid = _lib . OBJ_obj2nid ( self . _pkcs7 . type ) string_type = _lib . OBJ_nid2sn ( nid ) return _ffi . string ( string_type )", "nl": "Returns the type name of the PKCS7 structure"}}
{"translation": {"code": "def set_cipher_list ( self , cipher_list ) : cipher_list = _text_to_bytes_and_warn ( \"cipher_list\" , cipher_list ) if not isinstance ( cipher_list , bytes ) : raise TypeError ( \"cipher_list must be a byte string.\" ) _openssl_assert ( _lib . SSL_CTX_set_cipher_list ( self . _context , cipher_list ) == 1 ) # In OpenSSL 1.1.1 setting the cipher list will always return TLS 1.3 # ciphers even if you pass an invalid cipher. Applications (like # Twisted) have tests that depend on an error being raised if an # invalid cipher string is passed, but without the following check # for the TLS 1.3 specific cipher suites it would never error. tmpconn = Connection ( self , None ) if ( tmpconn . get_cipher_list ( ) == [ 'TLS_AES_256_GCM_SHA384' , 'TLS_CHACHA20_POLY1305_SHA256' , 'TLS_AES_128_GCM_SHA256' ] ) : raise Error ( [ ( 'SSL routines' , 'SSL_CTX_set_cipher_list' , 'no cipher match' , ) , ] , )", "nl": "Set the list of ciphers to be used in this context ."}}
{"translation": {"code": "def load_tmp_dh ( self , dhfile ) : dhfile = _path_string ( dhfile ) bio = _lib . BIO_new_file ( dhfile , b\"r\" ) if bio == _ffi . NULL : _raise_current_error ( ) bio = _ffi . gc ( bio , _lib . BIO_free ) dh = _lib . PEM_read_bio_DHparams ( bio , _ffi . NULL , _ffi . NULL , _ffi . NULL ) dh = _ffi . gc ( dh , _lib . DH_free ) _lib . SSL_CTX_set_tmp_dh ( self . _context , dh )", "nl": "Load parameters for Ephemeral Diffie - Hellman"}}
{"translation": {"code": "def set_passwd_cb ( self , callback , userdata = None ) : if not callable ( callback ) : raise TypeError ( \"callback must be callable\" ) self . _passphrase_helper = self . _wrap_callback ( callback ) self . _passphrase_callback = self . _passphrase_helper . callback _lib . SSL_CTX_set_default_passwd_cb ( self . _context , self . _passphrase_callback ) self . _passphrase_userdata = userdata", "nl": "Set the passphrase callback . This function will be called when a private key with a passphrase is loaded ."}}
{"translation": {"code": "def set_verify_depth ( self , depth ) : if not isinstance ( depth , integer_types ) : raise TypeError ( \"depth must be an integer\" ) _lib . SSL_CTX_set_verify_depth ( self . _context , depth )", "nl": "Set the maximum depth for the certificate chain verification that shall be allowed for this Context object ."}}
{"translation": {"code": "def set_tlsext_servername_callback ( self , callback ) : @ wraps ( callback ) def wrapper ( ssl , alert , arg ) : callback ( Connection . _reverse_mapping [ ssl ] ) return 0 self . _tlsext_servername_callback = _ffi . callback ( \"int (*)(SSL *, int *, void *)\" , wrapper ) _lib . SSL_CTX_set_tlsext_servername_callback ( self . _context , self . _tlsext_servername_callback )", "nl": "Specify a callback function to be called when clients specify a server name ."}}
{"translation": {"code": "def use_certificate ( self , cert ) : if not isinstance ( cert , X509 ) : raise TypeError ( \"cert must be an X509 instance\" ) use_result = _lib . SSL_CTX_use_certificate ( self . _context , cert . _x509 ) if not use_result : _raise_current_error ( )", "nl": "Load a certificate from a X509 object"}}
{"translation": {"code": "def load_client_ca ( self , cafile ) : ca_list = _lib . SSL_load_client_CA_file ( _text_to_bytes_and_warn ( \"cafile\" , cafile ) ) _openssl_assert ( ca_list != _ffi . NULL ) _lib . SSL_CTX_set_client_CA_list ( self . _context , ca_list )", "nl": "Load the trusted certificates that will be sent to the client . Does not actually imply any of the certificates are trusted ; that must be configured separately ."}}
{"translation": {"code": "def use_privatekey ( self , pkey ) : if not isinstance ( pkey , PKey ) : raise TypeError ( \"pkey must be a PKey instance\" ) use_result = _lib . SSL_CTX_use_PrivateKey ( self . _context , pkey . _pkey ) if not use_result : self . _raise_passphrase_exception ( )", "nl": "Load a private key from a PKey object"}}
{"translation": {"code": "def use_certificate_file ( self , certfile , filetype = FILETYPE_PEM ) : certfile = _path_string ( certfile ) if not isinstance ( filetype , integer_types ) : raise TypeError ( \"filetype must be an integer\" ) use_result = _lib . SSL_CTX_use_certificate_file ( self . _context , certfile , filetype ) if not use_result : _raise_current_error ( )", "nl": "Load a certificate from a file"}}
{"translation": {"code": "def add_extra_chain_cert ( self , certobj ) : if not isinstance ( certobj , X509 ) : raise TypeError ( \"certobj must be an X509 instance\" ) copy = _lib . X509_dup ( certobj . _x509 ) add_result = _lib . SSL_CTX_add_extra_chain_cert ( self . _context , copy ) if not add_result : # TODO: This is untested. _lib . X509_free ( copy ) _raise_current_error ( )", "nl": "Add certificate to chain"}}
{"translation": {"code": "def load_verify_locations ( self , cafile , capath = None ) : if cafile is None : cafile = _ffi . NULL else : cafile = _path_string ( cafile ) if capath is None : capath = _ffi . NULL else : capath = _path_string ( capath ) load_result = _lib . SSL_CTX_load_verify_locations ( self . _context , cafile , capath ) if not load_result : _raise_current_error ( )", "nl": "Let SSL know where we can find trusted certificates for the certificate chain . Note that the certificates have to be in PEM format ."}}
{"translation": {"code": "def use_certificate_chain_file ( self , certfile ) : certfile = _path_string ( certfile ) result = _lib . SSL_CTX_use_certificate_chain_file ( self . _context , certfile ) if not result : _raise_current_error ( )", "nl": "Load a certificate chain from a file ."}}
{"translation": {"code": "def use_privatekey_file ( self , keyfile , filetype = _UNSPECIFIED ) : keyfile = _path_string ( keyfile ) if filetype is _UNSPECIFIED : filetype = FILETYPE_PEM elif not isinstance ( filetype , integer_types ) : raise TypeError ( \"filetype must be an integer\" ) use_result = _lib . SSL_CTX_use_PrivateKey_file ( self . _context , keyfile , filetype ) if not use_result : self . _raise_passphrase_exception ( )", "nl": "Load a private key from a file"}}
{"translation": {"code": "def set_client_ca_list ( self , certificate_authorities ) : name_stack = _lib . sk_X509_NAME_new_null ( ) _openssl_assert ( name_stack != _ffi . NULL ) try : for ca_name in certificate_authorities : if not isinstance ( ca_name , X509Name ) : raise TypeError ( \"client CAs must be X509Name objects, not %s \" \"objects\" % ( type ( ca_name ) . __name__ , ) ) copy = _lib . X509_NAME_dup ( ca_name . _name ) _openssl_assert ( copy != _ffi . NULL ) push_result = _lib . sk_X509_NAME_push ( name_stack , copy ) if not push_result : _lib . X509_NAME_free ( copy ) _raise_current_error ( ) except Exception : _lib . sk_X509_NAME_free ( name_stack ) raise _lib . SSL_CTX_set_client_CA_list ( self . _context , name_stack )", "nl": "Set the list of preferred client certificate signers for this server context ."}}
{"translation": {"code": "def add_client_ca ( self , certificate_authority ) : if not isinstance ( certificate_authority , X509 ) : raise TypeError ( \"certificate_authority must be an X509 instance\" ) add_result = _lib . SSL_CTX_add_client_CA ( self . _context , certificate_authority . _x509 ) _openssl_assert ( add_result == 1 )", "nl": "Add the CA certificate to the list of preferred signers for this context ."}}
{"translation": {"code": "def get_servername ( self ) : name = _lib . SSL_get_servername ( self . _ssl , _lib . TLSEXT_NAMETYPE_host_name ) if name == _ffi . NULL : return None return _ffi . string ( name )", "nl": "Retrieve the servername extension value if provided in the client hello message or None if there wasn t one ."}}
{"translation": {"code": "def set_tlsext_host_name ( self , name ) : if not isinstance ( name , bytes ) : raise TypeError ( \"name must be a byte string\" ) elif b\"\\0\" in name : raise TypeError ( \"name must not contain NUL byte\" ) # XXX I guess this can fail sometimes? _lib . SSL_set_tlsext_host_name ( self . _ssl , name )", "nl": "Set the value of the servername extension to send in the client hello ."}}
{"translation": {"code": "def recv ( self , bufsiz , flags = None ) : buf = _no_zero_allocator ( \"char[]\" , bufsiz ) if flags is not None and flags & socket . MSG_PEEK : result = _lib . SSL_peek ( self . _ssl , buf , bufsiz ) else : result = _lib . SSL_read ( self . _ssl , buf , bufsiz ) self . _raise_ssl_error ( self . _ssl , result ) return _ffi . buffer ( buf , result ) [ : ]", "nl": "Receive data on the connection ."}}
{"translation": {"code": "def get_session ( self ) : session = _lib . SSL_get1_session ( self . _ssl ) if session == _ffi . NULL : return None pysession = Session . __new__ ( Session ) pysession . _session = _ffi . gc ( session , _lib . SSL_SESSION_free ) return pysession", "nl": "Returns the Session currently used ."}}
{"translation": {"code": "def master_key ( self ) : session = _lib . SSL_get_session ( self . _ssl ) if session == _ffi . NULL : return None length = _lib . SSL_SESSION_get_master_key ( session , _ffi . NULL , 0 ) assert length > 0 outp = _no_zero_allocator ( \"unsigned char[]\" , length ) _lib . SSL_SESSION_get_master_key ( session , outp , length ) return _ffi . buffer ( outp , length ) [ : ]", "nl": "Retrieve the value of the master key for this session ."}}
{"translation": {"code": "def client_random ( self ) : session = _lib . SSL_get_session ( self . _ssl ) if session == _ffi . NULL : return None length = _lib . SSL_get_client_random ( self . _ssl , _ffi . NULL , 0 ) assert length > 0 outp = _no_zero_allocator ( \"unsigned char[]\" , length ) _lib . SSL_get_client_random ( self . _ssl , outp , length ) return _ffi . buffer ( outp , length ) [ : ]", "nl": "Retrieve the random value used with the client hello message ."}}
{"translation": {"code": "def server_random ( self ) : session = _lib . SSL_get_session ( self . _ssl ) if session == _ffi . NULL : return None length = _lib . SSL_get_server_random ( self . _ssl , _ffi . NULL , 0 ) assert length > 0 outp = _no_zero_allocator ( \"unsigned char[]\" , length ) _lib . SSL_get_server_random ( self . _ssl , outp , length ) return _ffi . buffer ( outp , length ) [ : ]", "nl": "Retrieve the random value used with the server hello message ."}}
{"translation": {"code": "def set_shutdown ( self , state ) : if not isinstance ( state , integer_types ) : raise TypeError ( \"state must be an integer\" ) _lib . SSL_set_shutdown ( self . _ssl , state )", "nl": "Set the shutdown state of the Connection ."}}
{"translation": {"code": "def get_client_ca_list ( self ) : ca_names = _lib . SSL_get_client_CA_list ( self . _ssl ) if ca_names == _ffi . NULL : # TODO: This is untested. return [ ] result = [ ] for i in range ( _lib . sk_X509_NAME_num ( ca_names ) ) : name = _lib . sk_X509_NAME_value ( ca_names , i ) copy = _lib . X509_NAME_dup ( name ) _openssl_assert ( copy != _ffi . NULL ) pyname = X509Name . __new__ ( X509Name ) pyname . _name = _ffi . gc ( copy , _lib . X509_NAME_free ) result . append ( pyname ) return result", "nl": "Get CAs whose certificates are suggested for client authentication ."}}
{"translation": {"code": "def get_cipher_list ( self ) : ciphers = [ ] for i in count ( ) : result = _lib . SSL_get_cipher_list ( self . _ssl , i ) if result == _ffi . NULL : break ciphers . append ( _native ( _ffi . string ( result ) ) ) return ciphers", "nl": "Retrieve the list of ciphers used by the Connection object ."}}
{"translation": {"code": "def shutdown ( self ) : result = _lib . SSL_shutdown ( self . _ssl ) if result < 0 : self . _raise_ssl_error ( self . _ssl , result ) elif result > 0 : return True else : return False", "nl": "Send the shutdown message to the Connection ."}}
{"translation": {"code": "def renegotiate ( self ) : if not self . renegotiate_pending ( ) : _openssl_assert ( _lib . SSL_renegotiate ( self . _ssl ) == 1 ) return True return False", "nl": "Renegotiate the session ."}}
{"translation": {"code": "def set_context ( self , context ) : if not isinstance ( context , Context ) : raise TypeError ( \"context must be a Context instance\" ) _lib . SSL_set_SSL_CTX ( self . _ssl , context . _context ) self . _context = context", "nl": "Switch this connection to a new session context ."}}
{"translation": {"code": "def bio_read ( self , bufsiz ) : if self . _from_ssl is None : raise TypeError ( \"Connection sock was not None\" ) if not isinstance ( bufsiz , integer_types ) : raise TypeError ( \"bufsiz must be an integer\" ) buf = _no_zero_allocator ( \"char[]\" , bufsiz ) result = _lib . BIO_read ( self . _from_ssl , buf , bufsiz ) if result <= 0 : self . _handle_bio_errors ( self . _from_ssl , result ) return _ffi . buffer ( buf , result ) [ : ]", "nl": "If the Connection was created with a memory BIO this method can be used to read bytes from the write end of that memory BIO . Many Connection methods will add bytes which must be read in this manner or the buffer will eventually fill up and the Connection will be able to take no further actions ."}}
{"translation": {"code": "def add_cert ( self , cert ) : if not isinstance ( cert , X509 ) : raise TypeError ( ) # As of OpenSSL 1.1.0i adding the same cert to the store more than # once doesn't cause an error. Accordingly, this code now silences # the error for OpenSSL < 1.1.0i as well. if _lib . X509_STORE_add_cert ( self . _store , cert . _x509 ) == 0 : code = _lib . ERR_peek_error ( ) err_reason = _lib . ERR_GET_REASON ( code ) _openssl_assert ( err_reason == _lib . X509_R_CERT_ALREADY_IN_HASH_TABLE ) _lib . ERR_clear_error ( )", "nl": "Adds a trusted certificate to this store ."}}
{"translation": {"code": "def verify ( self , pkey ) : if not isinstance ( pkey , PKey ) : raise TypeError ( \"pkey must be a PKey instance\" ) result = _lib . X509_REQ_verify ( self . _req , pkey . _pkey ) if result <= 0 : _raise_current_error ( ) return result", "nl": "Verifies the signature on this certificate signing request ."}}
{"translation": {"code": "def exception_from_error_queue ( exception_type ) : errors = [ ] while True : error = lib . ERR_get_error ( ) if error == 0 : break errors . append ( ( text ( lib . ERR_lib_error_string ( error ) ) , text ( lib . ERR_func_error_string ( error ) ) , text ( lib . ERR_reason_error_string ( error ) ) ) ) raise exception_type ( errors )", "nl": "Convert an OpenSSL library failure into a Python exception ."}}
{"translation": {"code": "def _new_mem_buf ( buffer = None ) : if buffer is None : bio = _lib . BIO_new ( _lib . BIO_s_mem ( ) ) free = _lib . BIO_free else : data = _ffi . new ( \"char[]\" , buffer ) bio = _lib . BIO_new_mem_buf ( data , len ( buffer ) ) # Keep the memory alive as long as the bio is alive! def free ( bio , ref = data ) : return _lib . BIO_free ( bio ) _openssl_assert ( bio != _ffi . NULL ) bio = _ffi . gc ( bio , free ) return bio", "nl": "Allocate a new OpenSSL memory BIO ."}}
{"translation": {"code": "def get_extensions ( self ) : exts = [ ] native_exts_obj = _lib . X509_REQ_get_extensions ( self . _req ) for i in range ( _lib . sk_X509_EXTENSION_num ( native_exts_obj ) ) : ext = X509Extension . __new__ ( X509Extension ) ext . _extension = _lib . sk_X509_EXTENSION_value ( native_exts_obj , i ) exts . append ( ext ) return exts", "nl": "Get X . 509 extensions in the certificate signing request ."}}
{"translation": {"code": "def get_cipher_name ( self ) : cipher = _lib . SSL_get_current_cipher ( self . _ssl ) if cipher == _ffi . NULL : return None else : name = _ffi . string ( _lib . SSL_CIPHER_get_name ( cipher ) ) return name . decode ( \"utf-8\" )", "nl": "Obtain the name of the currently used cipher ."}}
{"translation": {"code": "def get_cipher_bits ( self ) : cipher = _lib . SSL_get_current_cipher ( self . _ssl ) if cipher == _ffi . NULL : return None else : return _lib . SSL_CIPHER_get_bits ( cipher , _ffi . NULL )", "nl": "Obtain the number of secret bits of the currently used cipher ."}}
{"translation": {"code": "def get_cipher_version ( self ) : cipher = _lib . SSL_get_current_cipher ( self . _ssl ) if cipher == _ffi . NULL : return None else : version = _ffi . string ( _lib . SSL_CIPHER_get_version ( cipher ) ) return version . decode ( \"utf-8\" )", "nl": "Obtain the protocol version of the currently used cipher ."}}
{"translation": {"code": "def check_get_revoked ( self ) : crl = CRL ( ) for i in xrange ( 100 ) : crl . add_revoked ( Revoked ( ) ) for i in xrange ( self . iterations ) : crl . get_revoked ( )", "nl": "Create a CRL object with 100 Revoked objects then call the get_revoked method repeatedly ."}}
{"translation": {"code": "def check_X509_REVOKED_dup ( self ) : for i in xrange ( self . iterations * 100 ) : revoked_copy = _X509_REVOKED_dup ( Revoked ( ) . _revoked ) _lib . X509_REVOKED_free ( revoked_copy )", "nl": "Copy an empty Revoked object repeatedly . The copy is not garbage collected therefore it needs to be manually freed ."}}
{"translation": {"code": "def set_npn_select_callback ( self , callback ) : _warn_npn ( ) self . _npn_select_helper = _NpnSelectHelper ( callback ) self . _npn_select_callback = self . _npn_select_helper . callback _lib . SSL_CTX_set_next_proto_select_cb ( self . _context , self . _npn_select_callback , _ffi . NULL )", "nl": "Specify a callback function that will be called when a server offers Next Protocol Negotiation options ."}}
{"translation": {"code": "def get_next_proto_negotiated ( self ) : _warn_npn ( ) data = _ffi . new ( \"unsigned char **\" ) data_len = _ffi . new ( \"unsigned int *\" ) _lib . SSL_get0_next_proto_negotiated ( self . _ssl , data , data_len ) return _ffi . buffer ( data [ 0 ] , data_len [ 0 ] ) [ : ]", "nl": "Get the protocol that was negotiated by NPN ."}}
{"translation": {"code": "def _load_elliptic_curves ( cls , lib ) : num_curves = lib . EC_get_builtin_curves ( _ffi . NULL , 0 ) builtin_curves = _ffi . new ( 'EC_builtin_curve[]' , num_curves ) # The return value on this call should be num_curves again.  We # could check it to make sure but if it *isn't* then.. what could # we do? Abort the whole process, I suppose...?  -exarkun lib . EC_get_builtin_curves ( builtin_curves , num_curves ) return set ( cls . from_nid ( lib , c . nid ) for c in builtin_curves )", "nl": "Get the curves supported by OpenSSL ."}}
{"translation": {"code": "def get_elliptic_curve ( name ) : for curve in get_elliptic_curves ( ) : if curve . name == name : return curve raise ValueError ( \"unknown curve name\" , name )", "nl": "Return a single curve object selected by name ."}}
{"translation": {"code": "def _to_EC_KEY ( self ) : key = self . _lib . EC_KEY_new_by_curve_name ( self . _nid ) return _ffi . gc ( key , _lib . EC_KEY_free )", "nl": "Create a new OpenSSL EC_KEY structure initialized to use this curve ."}}
{"translation": {"code": "def _get_elliptic_curves ( cls , lib ) : if cls . _curves is None : cls . _curves = cls . _load_elliptic_curves ( lib ) return cls . _curves", "nl": "Get cache and return the curves supported by OpenSSL ."}}