{"translation": {"code": "def set_alpn_select_callback ( self , callback ) : self . _alpn_select_helper = _ALPNSelectHelper ( callback ) self . _alpn_select_callback = self . _alpn_select_helper . callback _lib . SSL_CTX_set_alpn_select_cb ( self . _context , self . _alpn_select_callback , _ffi . NULL )", "nl": "Specify a callback function that will be called on the server when a client offers protocols using ALPN ."}}
{"translation": {"code": "def set_alpn_protos ( self , protos ) : # Take the list of protocols and join them together, prefixing them # with their lengths. protostr = b'' . join ( chain . from_iterable ( ( int2byte ( len ( p ) ) , p ) for p in protos ) ) # Build a C string from the list. We don't need to save this off # because OpenSSL immediately copies the data out. input_str = _ffi . new ( \"unsigned char[]\" , protostr ) _lib . SSL_CTX_set_alpn_protos ( self . _context , input_str , len ( protostr ) )", "nl": "Specify the protocols that the client is prepared to speak after the TLS connection has been negotiated using Application Layer Protocol Negotiation ."}}
{"translation": {"code": "def recv_into ( self , buffer , nbytes = None , flags = None ) : if nbytes is None : nbytes = len ( buffer ) else : nbytes = min ( nbytes , len ( buffer ) ) # We need to create a temporary buffer. This is annoying, it would be # better if we could pass memoryviews straight into the SSL_read call, # but right now we can't. Revisit this if CFFI gets that ability. buf = _no_zero_allocator ( \"char[]\" , nbytes ) if flags is not None and flags & socket . MSG_PEEK : result = _lib . SSL_peek ( self . _ssl , buf , nbytes ) else : result = _lib . SSL_read ( self . _ssl , buf , nbytes ) self . _raise_ssl_error ( self . _ssl , result ) # This strange line is all to avoid a memory copy. The buffer protocol # should allow us to assign a CFFI buffer to the LHS of this line, but # on CPython 3.3+ that segfaults. As a workaround, we can temporarily # wrap it in a memoryview. buffer [ : result ] = memoryview ( _ffi . buffer ( buf , result ) ) return result", "nl": "Receive data on the connection and copy it directly into the provided buffer rather than creating a new string ."}}
{"translation": {"code": "def _exception_from_context ( self ) : errors = [ _lib . X509_STORE_CTX_get_error ( self . _store_ctx ) , _lib . X509_STORE_CTX_get_error_depth ( self . _store_ctx ) , _native ( _ffi . string ( _lib . X509_verify_cert_error_string ( _lib . X509_STORE_CTX_get_error ( self . _store_ctx ) ) ) ) , ] # A context error should always be associated with a certificate, so we # expect this call to never return :class:`None`. _x509 = _lib . X509_STORE_CTX_get_current_cert ( self . _store_ctx ) _cert = _lib . X509_dup ( _x509 ) pycert = X509 . _from_raw_x509_ptr ( _cert ) return X509StoreContextError ( errors , pycert )", "nl": "Convert an OpenSSL native context error failure into a Python exception ."}}
{"translation": {"code": "def text_to_bytes_and_warn ( label , obj ) : if isinstance ( obj , text_type ) : warnings . warn ( _TEXT_WARNING . format ( label ) , category = DeprecationWarning , stacklevel = 3 ) return obj . encode ( 'utf-8' ) return obj", "nl": "If obj is text emit a warning that it should be bytes instead and try to convert it to bytes automatically ."}}
{"translation": {"code": "def _make_requires ( flag , error ) : def _requires_decorator ( func ) : if not flag : @ wraps ( func ) def explode ( * args , * * kwargs ) : raise NotImplementedError ( error ) return explode else : return func return _requires_decorator", "nl": "Builds a decorator that ensures that functions that rely on OpenSSL functions that are not present in this build raise NotImplementedError rather than AttributeError coming out of cryptography ."}}
{"translation": {"code": "def get_protocol_version_name ( self ) : version = _ffi . string ( _lib . SSL_get_version ( self . _ssl ) ) return version . decode ( \"utf-8\" )", "nl": "Retrieve the protocol version of the current connection ."}}
{"translation": {"code": "def dump_crl ( type , crl ) : bio = _new_mem_buf ( ) if type == FILETYPE_PEM : ret = _lib . PEM_write_bio_X509_CRL ( bio , crl . _crl ) elif type == FILETYPE_ASN1 : ret = _lib . i2d_X509_CRL_bio ( bio , crl . _crl ) elif type == FILETYPE_TEXT : ret = _lib . X509_CRL_print ( bio , crl . _crl ) else : raise ValueError ( \"type argument must be FILETYPE_PEM, FILETYPE_ASN1, or \" \"FILETYPE_TEXT\" ) assert ret == 1 return _bio_to_string ( bio )", "nl": "Dump a certificate revocation list to a buffer ."}}
{"translation": {"code": "def load_publickey ( type , buffer ) : if isinstance ( buffer , _text_type ) : buffer = buffer . encode ( \"ascii\" ) bio = _new_mem_buf ( buffer ) if type == FILETYPE_PEM : evp_pkey = _lib . PEM_read_bio_PUBKEY ( bio , _ffi . NULL , _ffi . NULL , _ffi . NULL ) elif type == FILETYPE_ASN1 : evp_pkey = _lib . d2i_PUBKEY_bio ( bio , _ffi . NULL ) else : raise ValueError ( \"type argument must be FILETYPE_PEM or FILETYPE_ASN1\" ) if evp_pkey == _ffi . NULL : _raise_current_error ( ) pkey = PKey . __new__ ( PKey ) pkey . _pkey = _ffi . gc ( evp_pkey , _lib . EVP_PKEY_free ) pkey . _only_public = True return pkey", "nl": "Load a public key from a buffer ."}}
{"translation": {"code": "def sign ( self , issuer_cert , issuer_key , digest ) : digest_obj = _lib . EVP_get_digestbyname ( digest ) _openssl_assert ( digest_obj != _ffi . NULL ) _lib . X509_CRL_set_issuer_name ( self . _crl , _lib . X509_get_subject_name ( issuer_cert . _x509 ) ) _lib . X509_CRL_sort ( self . _crl ) result = _lib . X509_CRL_sign ( self . _crl , issuer_key . _pkey , digest_obj ) _openssl_assert ( result != 0 )", "nl": "Sign the CRL ."}}
{"translation": {"code": "def set_time ( self , vfy_time ) : param = _lib . X509_VERIFY_PARAM_new ( ) param = _ffi . gc ( param , _lib . X509_VERIFY_PARAM_free ) _lib . X509_VERIFY_PARAM_set_time ( param , int ( vfy_time . strftime ( '%s' ) ) ) _openssl_assert ( _lib . X509_STORE_set1_param ( self . _store , param ) != 0 )", "nl": "Set the time against which the certificates are verified ."}}
{"translation": {"code": "def set_ocsp_server_callback ( self , callback , data = None ) : helper = _OCSPServerCallbackHelper ( callback ) self . _set_ocsp_callback ( helper , data )", "nl": "Set a callback to provide OCSP data to be stapled to the TLS handshake on the server side ."}}
{"translation": {"code": "def to_cryptography ( self ) : from cryptography . hazmat . backends . openssl . x509 import ( _CertificateRevocationList ) backend = _get_backend ( ) return _CertificateRevocationList ( backend , self . _crl )", "nl": "Export as a cryptography CRL ."}}