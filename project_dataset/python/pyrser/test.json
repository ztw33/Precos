{"translation": {"code": "def __update_count ( self ) : self . _ntypes = self . count_types ( ) self . _nvars = self . count_vars ( ) self . _nfuns = self . count_funs ( )", "nl": "Update internal counters"}}
{"translation": {"code": "def count_funs ( self ) -> int : n = 0 for s in self . _hsig . values ( ) : if hasattr ( s , 'is_fun' ) and s . is_fun : n += 1 return n", "nl": "Count function define by this scope"}}
{"translation": {"code": "def callInjector ( self , old : Node , trans : Translator ) -> Node : if self . astTranslatorInjector is None : if self . parent is not None : # TODO: think if we forward for all StateScope # forward to parent scope return self . parent ( ) . callInjector ( old , trans ) else : raise TypeError ( \"Must define an Translator Injector\" ) return self . astTranslatorInjector ( old , trans )", "nl": "If don t have injector call from parent"}}
{"translation": {"code": "def pred_eq ( self , n , val ) : v1 = n . value v2 = val if hasattr ( val , 'value' ) : v2 = val . value if isinstance ( v1 , int ) and not isinstance ( v2 , int ) : return v1 == int ( v2 ) return v1 == v2", "nl": "Test if a node set with setint or setstr equal a certain value"}}
{"translation": {"code": "def get_subnode ( self , dst , ast , expr ) : dst . value = eval ( 'ast' + expr ) return True", "nl": "get the value of subnode"}}
{"translation": {"code": "def nextstate ( self , newstate , treenode = None , user_data = None ) : if newstate is None : return self if isinstance ( newstate , State ) and id ( newstate ) != id ( self ) : return newstate elif isinstance ( newstate , StateEvent ) : self . state_register . named_events [ newstate . name ] = True return newstate . st elif isinstance ( newstate , StatePrecond ) : return newstate . st elif isinstance ( newstate , StateHook ) : # final API using PSL newstate . call ( treenode , user_data ) return newstate . st return self", "nl": "Manage transition of state ."}}
{"translation": {"code": "def to_fmt ( self ) -> str : infos = fmt . end ( \";\\n\" , [ ] ) s = fmt . sep ( ', ' , [ ] ) for ids in sorted ( self . states . keys ( ) ) : s . lsdata . append ( str ( ids ) ) infos . lsdata . append ( fmt . block ( '(' , ')' , [ s ] ) ) infos . lsdata . append ( \"events:\" + repr ( self . events ) ) infos . lsdata . append ( \"named_events:\" + repr ( list ( self . named_events . keys ( ) ) ) ) infos . lsdata . append ( \"uid_events:\" + repr ( list ( self . uid_events . keys ( ) ) ) ) return infos", "nl": "Provide a useful representation of the register ."}}
{"translation": {"code": "def to_dot_file ( self , fname : str ) : with open ( fname , 'w' ) as f : f . write ( self . to_dot ( ) )", "nl": "write a . dot file ."}}
{"translation": {"code": "def build_state_tree ( self , tree : list , sr : state . StateRegister ) : all_seq = [ ] # for all statements populate a list # from deeper to nearer of MatchExpr instances. for stmt in self . stmts : part_seq = list ( ) stmt . build_state_tree ( part_seq ) all_seq . append ( part_seq ) # Walk on all MatchExpr instance # and create State instance into the StateRegister self . root_edge = populate_state_register ( all_seq , sr )", "nl": "main function for creating a bottom - up tree automata for a block of matching statements ."}}
{"translation": {"code": "def resetLivingState ( self ) : # TODO: add some test to control number of instanciation of LivingState # clean all living state on S0 must_delete = [ ] l = len ( self . ls ) for idx , ls in zip ( range ( l ) , self . ls ) : # TODO: alive by default on False, change to True on the first match ids = id ( ls [ 1 ] . thestate ( ) ) if ids == id ( ls [ 0 ] ) and ( ls [ 1 ] . have_finish or not ls [ 1 ] . alive ) : must_delete . append ( idx ) elif ls [ 1 ] . alive : ls [ 1 ] . alive = False for delete in reversed ( must_delete ) : self . ls . pop ( delete ) self . init_all ( )", "nl": "Only one Living State on the S0 of each StateRegister"}}
{"translation": {"code": "def rvalues ( self ) : tmp = self while tmp is not None : yield tmp . data tmp = tmp . prev", "nl": "in reversed order"}}
{"translation": {"code": "def set_node_as_int ( self , dst , src ) : dst . value = self . value ( src ) return True", "nl": "Set a node to a value captured from another node"}}