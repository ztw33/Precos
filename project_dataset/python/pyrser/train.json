{"translation": {"code": "def visit_Rep0N ( self , node : parsing . Rep0N ) -> [ ast . stmt ] : cl_ast = self . visit ( node . pt ) if isinstance ( cl_ast , ast . expr ) : return [ ast . While ( cl_ast , [ ast . Pass ( ) ] , [ ] ) ] self . in_loop += 1 clause = self . _clause ( self . visit ( node . pt ) ) self . in_loop -= 1 return [ ast . While ( ast . Name ( 'True' , ast . Load ( ) ) , clause , [ ] ) ]", "nl": "Generates python code for a clause repeated 0 or more times ."}}
{"translation": {"code": "def visit_RepOptional ( self , node : parsing . RepOptional ) -> ( [ ast . stmt ] or ast . expr ) : cl_ast = self . visit ( node . pt ) if isinstance ( cl_ast , ast . expr ) : return ast . BoolOp ( ast . Or ( ) , [ cl_ast , ast . Name ( 'True' , ast . Load ( ) ) ] ) self . in_optional += 1 cl_ast = self . visit ( node . pt ) self . in_optional -= 1 return cl_ast", "nl": "Generates python code for an optional clause ."}}
{"translation": {"code": "def visit_Alt ( self , node : parsing . Alt ) -> [ ast . stmt ] : clauses = [ self . visit ( clause ) for clause in node . ptlist ] for clause in clauses : if not isinstance ( clause , ast . expr ) : break else : return ast . BoolOp ( ast . Or ( ) , clauses ) res = ast . Try ( [ ] , [ ast . ExceptHandler ( ast . Name ( 'AltTrue' , ast . Load ( ) ) , None , [ ast . Pass ( ) ] ) ] , [ ] , [ ] ) alt_true = [ ast . Raise ( ast . Call ( ast . Name ( 'AltTrue' , ast . Load ( ) ) , [ ] , [ ] , None , None ) , None ) ] alt_false = [ ast . ExceptHandler ( ast . Name ( 'AltFalse' , ast . Load ( ) ) , None , [ ast . Pass ( ) ] ) ] self . in_try += 1 for clause in node . ptlist : res . body . append ( ast . Try ( self . _clause ( self . visit ( clause ) ) + alt_true , alt_false , [ ] , [ ] ) ) self . in_try -= 1 res . body . append ( self . __exit_scope ( ) ) return [ res ]", "nl": "Generates python code for alternatives ."}}
{"translation": {"code": "def visit_Scope ( self , node : parsing . Capture ) -> [ ast . stmt ] or ast . expr : return ast . Name ( 'scope_not_implemented' , ast . Load ( ) ) raise NotImplementedError ( )", "nl": "Generates python code for a scope ."}}
{"translation": {"code": "def visit_Capture ( self , node : parsing . Capture ) -> [ ast . stmt ] or ast . expr : begintag = ast . Attribute ( ast . Name ( 'self' , ast . Load ( ) ) , 'beginTag' , ast . Load ( ) ) endtag = ast . Attribute ( ast . Name ( 'self' , ast . Load ( ) ) , 'endTag' , ast . Load ( ) ) begin = ast . Call ( begintag , [ ast . Str ( node . tagname ) ] , [ ] , None , None ) end = ast . Call ( endtag , [ ast . Str ( node . tagname ) ] , [ ] , None , None ) result = [ begin , self . visit ( node . pt ) , end ] for clause in result : if not isinstance ( clause , ast . expr ) : break else : return ast . BoolOp ( ast . And ( ) , result ) res = [ ] for stmt in map ( self . _clause , result ) : res . extend ( stmt ) return res", "nl": "Generates python code to capture text consumed by a clause ."}}
{"translation": {"code": "def visit_Rule ( self , node : parsing . Rule ) -> ast . expr : return ast . Call ( ast . Attribute ( ast . Name ( 'self' , ast . Load ( ) ) , 'evalRule' , ast . Load ( ) ) , [ ast . Str ( node . name ) ] , [ ] , None , None )", "nl": "Generates python code calling a rule ."}}
{"translation": {"code": "def visit_Rep1N ( self , node : parsing . Rep0N ) -> [ ast . stmt ] : clause = self . visit ( node . pt ) if isinstance ( clause , ast . expr ) : return ( self . _clause ( clause ) + self . visit_Rep0N ( node ) ) self . in_loop += 1 clause = self . _clause ( self . visit ( node . pt ) ) self . in_loop -= 1 return self . _clause ( self . visit ( node . pt ) ) + [ ast . While ( ast . Name ( 'True' , ast . Load ( ) ) , clause , [ ] ) ]", "nl": "Generates python code for a clause repeated 1 or more times ."}}
{"translation": {"code": "def parserrule_topython ( parser : parsing . BasicParser , rulename : str ) -> ast . FunctionDef : visitor = RuleVisitor ( ) rule = parser . _rules [ rulename ] fn_args = ast . arguments ( [ ast . arg ( 'self' , None ) ] , None , None , [ ] , None , None , [ ] , [ ] ) body = visitor . _clause ( rule_topython ( rule ) ) body . append ( ast . Return ( ast . Name ( 'True' , ast . Load ( ) ) ) ) return ast . FunctionDef ( rulename , fn_args , body , [ ] , None )", "nl": "Generates code for a rule ."}}
{"translation": {"code": "def add_method ( cls ) : def wrapper ( f ) : #if hasattr(cls, f.__name__): #    raise AttributeError(\"{} already has a '{}' attribute\".format( #        cls.__name__, f.__name__)) setattr ( cls , f . __name__ , f ) return f return wrapper", "nl": "Attach a method to a class ."}}
{"translation": {"code": "def _clause ( self , pt : parsing . ParserTree ) -> [ ast . stmt ] : if isinstance ( pt , list ) : return pt return [ ast . If ( ast . UnaryOp ( ast . Not ( ) , pt ) , [ self . __exit_scope ( ) ] , [ ] ) ]", "nl": "Normalize a test expression into a statements list ."}}
{"translation": {"code": "def rule ( cls , rulename = None , erase = False ) : if not hasattr ( cls , '_rules' ) : raise TypeError ( \"%s didn't seems to be a BasicParser subsclasse\" % cls . __name__ ) class_hook_list = cls . _hooks class_rule_list = cls . _rules def wrapper ( f ) : nonlocal rulename add_method ( cls ) ( f ) if rulename is None : rulename = f . __name__ if not erase and ( rulename in class_hook_list or rulename in class_rule_list ) : raise TypeError ( \"%s is already define has rule or hook\" % rulename ) if '.' not in rulename : rulename = cls . __module__ + '.' + cls . __name__ + '.' + rulename set_one ( class_rule_list , rulename , f ) return f return wrapper", "nl": "Attach a method to a parsing class and register it as a parser rule ."}}
{"translation": {"code": "def read_eol ( self ) -> bool : if self . read_eof ( ) : return False self . _stream . save_context ( ) self . read_char ( '\\r' ) if self . read_char ( '\\n' ) : return self . _stream . validate_context ( ) return self . _stream . restore_context ( )", "nl": "Return True if the parser can consume an EOL byte sequence ."}}
{"translation": {"code": "def push_rule_nodes ( self ) -> bool : if self . rule_nodes is None : self . rule_nodes = collections . ChainMap ( ) self . tag_cache = collections . ChainMap ( ) self . id_cache = collections . ChainMap ( ) else : self . rule_nodes = self . rule_nodes . new_child ( ) self . tag_cache = self . tag_cache . new_child ( ) self . id_cache = self . id_cache . new_child ( ) return True", "nl": "Push context variable to store rule nodes ."}}
{"translation": {"code": "def pop_rule_nodes ( self ) -> bool : self . rule_nodes = self . rule_nodes . parents self . tag_cache = self . tag_cache . parents self . id_cache = self . id_cache . parents return True", "nl": "Pop context variable that store rule nodes"}}
{"translation": {"code": "def parsed_stream ( self , content : str , name : str = None ) : self . _streams . append ( Stream ( content , name ) )", "nl": "Push a new Stream into the parser . All subsequent called functions will parse this new stream until the popStream function is called ."}}
{"translation": {"code": "def visit_Seq ( self , node : parsing . Seq ) -> [ ast . stmt ] or ast . expr : exprs , stmts = [ ] , [ ] for clause in node . ptlist : clause_ast = self . visit ( clause ) if isinstance ( clause_ast , ast . expr ) : exprs . append ( clause_ast ) else : if exprs : stmts . extend ( self . combine_exprs_for_clauses ( exprs ) ) exprs = [ ] stmts . extend ( self . _clause ( clause_ast ) ) if not stmts : return ast . BoolOp ( ast . And ( ) , exprs ) if exprs : stmts . extend ( self . combine_exprs_for_clauses ( exprs ) ) return stmts", "nl": "Generates python code for clauses ."}}
{"translation": {"code": "def set_rules ( cls , rules : dict ) -> bool : cls . _rules = cls . _rules . new_child ( ) for rule_name , rule_pt in rules . items ( ) : if '.' not in rule_name : rule_name = cls . __module__ + '.' + cls . __name__ + '.' + rule_name meta . set_one ( cls . _rules , rule_name , rule_pt ) return True", "nl": "Merge internal rules set with the given rules"}}
{"translation": {"code": "def set_hooks ( cls , hooks : dict ) -> bool : cls . _hooks = cls . _hooks . new_child ( ) for hook_name , hook_pt in hooks . items ( ) : if '.' not in hook_name : hook_name = cls . __module__ + '.' + cls . __name__ + '.' + hook_name meta . set_one ( cls . _hooks , hook_name , hook_pt ) return True", "nl": "Merge internal hooks set with the given hooks"}}
{"translation": {"code": "def set_directives ( cls , directives : dict ) -> bool : meta . _directives = meta . _directives . new_child ( ) for dir_name , dir_pt in directives . items ( ) : meta . set_one ( meta . _directives , dir_name , dir_pt ) dir_pt . ns_name = dir_name return True", "nl": "Merge internal directives set with the given directives . For working directives attach it only in the dsl . Parser class"}}
{"translation": {"code": "def eval_rule ( self , name : str ) -> Node : # context created by caller n = Node ( ) id_n = id ( n ) self . rule_nodes [ '_' ] = n self . id_cache [ id_n ] = '_' # TODO: other behavior for  empty rules? if name not in self . __class__ . _rules : self . diagnostic . notify ( error . Severity . ERROR , \"Unknown rule : %s\" % name , error . LocationInfo . from_stream ( self . _stream , is_error = True ) ) raise self . diagnostic self . _lastRule = name rule_to_eval = self . __class__ . _rules [ name ] # TODO: add packrat cache here, same rule - same pos == same res res = rule_to_eval ( self ) if res : res = self . rule_nodes [ '_' ] return res", "nl": "Evaluate a rule by name ."}}
{"translation": {"code": "def read_char ( self , c : str ) -> bool : if self . read_eof ( ) : return False self . _stream . save_context ( ) if c == self . _stream . peek_char : self . _stream . incpos ( ) return self . _stream . validate_context ( ) return self . _stream . restore_context ( )", "nl": "Consume the c head byte increment current index and return True else return False . It use peekchar and it s the same as in BNF ."}}
{"translation": {"code": "def visit_Call ( self , node : parsing . Call ) -> ast . expr : return ast . Call ( ast . Attribute ( ast . Name ( 'self' , ast . Load ) , node . callObject . __name__ , ast . Load ( ) ) , [ ast . Str ( param ) for param in node . params ] , [ ] , None , None )", "nl": "Generates python code calling the function ."}}
{"translation": {"code": "def read_until_eof ( self ) -> bool : if self . read_eof ( ) : return True # TODO: read ALL self . _stream . save_context ( ) while not self . read_eof ( ) : self . _stream . incpos ( ) return self . _stream . validate_context ( )", "nl": "Consume all the stream . Same as EOF in BNF ."}}
{"translation": {"code": "def add_ruleclause_name ( self , ns_name , rid ) -> bool : ns_name . parser_tree = parsing . Rule ( self . value ( rid ) ) return True", "nl": "Create a tree . Rule"}}
{"translation": {"code": "def add_rules ( self , bnf , r ) -> bool : bnf [ r . rulename ] = r . parser_tree return True", "nl": "Attach a parser tree to the dict of rules"}}
{"translation": {"code": "def add_rule ( self , rule , rn , alts ) -> bool : rule . rulename = self . value ( rn ) rule . parser_tree = alts . parser_tree return True", "nl": "Add the rule name"}}
{"translation": {"code": "def hook ( cls , hookname = None , erase = False ) : if not hasattr ( cls , '_hooks' ) : raise TypeError ( \"%s didn't seems to be a BasicParser subsclasse\" % cls . __name__ ) class_hook_list = cls . _hooks class_rule_list = cls . _rules def wrapper ( f ) : nonlocal hookname add_method ( cls ) ( f ) if hookname is None : hookname = f . __name__ if not erase and ( hookname in class_hook_list or hookname in class_rule_list ) : raise TypeError ( \"%s is already define has rule or hook\" % hookname ) if '.' not in hookname : hookname = '.' . join ( [ cls . __module__ , cls . __name__ , hookname ] ) set_one ( class_hook_list , hookname , f ) return f return wrapper", "nl": "Attach a method to a parsing class and register it as a parser hook ."}}
{"translation": {"code": "def add_alt ( self , alternatives , alt ) -> bool : if not hasattr ( alternatives , 'parser_tree' ) : # forward sublevel of alt as is if hasattr ( alt , 'parser_tree' ) : alternatives . parser_tree = alt . parser_tree else : alternatives . parser_tree = alt else : oldnode = alternatives if isinstance ( oldnode . parser_tree , parsing . Alt ) : oldpt = list ( oldnode . parser_tree . ptlist ) else : oldpt = [ oldnode . parser_tree ] oldpt . append ( alt . parser_tree ) alternatives . parser_tree = parsing . Alt ( * tuple ( oldpt ) ) return True", "nl": "Create a tree . Alt"}}
{"translation": {"code": "def add_range ( self , sequence , begin , end ) : sequence . parser_tree = parsing . Range ( self . value ( begin ) . strip ( \"'\" ) , self . value ( end ) . strip ( \"'\" ) ) return True", "nl": "Add a read_range primitive"}}
{"translation": {"code": "def add_rpt ( self , sequence , mod , pt ) : modstr = self . value ( mod ) if modstr == '!!' : # cursor on the REPEATER self . _stream . restore_context ( ) # log the error self . diagnostic . notify ( error . Severity . ERROR , \"Cannot repeat a lookahead rule\" , error . LocationInfo . from_stream ( self . _stream , is_error = True ) ) raise self . diagnostic if modstr == '!' : # cursor on the REPEATER self . _stream . restore_context ( ) # log the error self . diagnostic . notify ( error . Severity . ERROR , \"Cannot repeat a negated rule\" , error . LocationInfo . from_stream ( self . _stream , is_error = True ) ) raise self . diagnostic oldnode = sequence sequence . parser_tree = pt . functor ( oldnode . parser_tree ) return True", "nl": "Add a repeater to the previous sequence"}}
{"translation": {"code": "def add_capture ( self , sequence , cpt ) : cpt_value = self . value ( cpt ) sequence . parser_tree = parsing . Capture ( cpt_value , sequence . parser_tree ) return True", "nl": "Create a tree . Capture"}}
{"translation": {"code": "def visit_Hook ( self , node : parsing . Hook ) -> ast . expr : return ast . Call ( ast . Attribute ( ast . Name ( 'self' , ast . Load ( ) ) , 'evalHook' , ast . Load ( ) ) , [ ast . Str ( node . name ) , ast . Subscript ( ast . Attribute ( ast . Name ( 'self' , ast . Load ( ) ) , 'ruleNodes' , ast . Load ( ) ) , ast . Index ( ast . UnaryOp ( ast . USub ( ) , ast . Num ( 1 ) ) ) , ast . Load ( ) ) ] , [ ] , None , None )", "nl": "Generates python code calling a hook ."}}
{"translation": {"code": "def visit_CallTrue ( self , node : parsing . CallTrue ) -> ast . expr : return ast . Lambda ( ast . arguments ( [ ] , None , None , [ ] , None , None , [ ] , [ ] ) , ast . BoolOp ( ast . Or ( ) , [ self . visit_Call ( node ) , ast . Name ( 'True' , ast . Load ( ) ) ] ) )", "nl": "Generates python code calling the function and returning True ."}}
{"translation": {"code": "def __exit_scope ( self ) -> ast . stmt : if self . in_optional : return ast . Pass ( ) if self . in_try : return ast . Raise ( ast . Call ( ast . Name ( 'AltFalse' , ast . Load ( ) ) , [ ] , [ ] , None , None ) , None ) if self . in_loop : return ast . Break ( ) return ast . Return ( ast . Name ( 'False' , ast . Load ( ) ) )", "nl": "Create the appropriate scope exiting statement ."}}
{"translation": {"code": "def ignore_blanks ( self ) -> bool : self . _stream . save_context ( ) if not self . read_eof ( ) and self . _stream . peek_char in \" \\t\\v\\f\\r\\n\" : while ( not self . read_eof ( ) and self . _stream . peek_char in \" \\t\\v\\f\\r\\n\" ) : self . _stream . incpos ( ) return self . _stream . validate_context ( ) return self . _stream . validate_context ( )", "nl": "Consume whitespace characters ."}}
{"translation": {"code": "def add_sequences ( self , sequences , cla ) -> bool : if not hasattr ( sequences , 'parser_tree' ) : # forward sublevel of sequence as is sequences . parser_tree = cla . parser_tree else : oldnode = sequences if isinstance ( oldnode . parser_tree , parsing . Seq ) : oldpt = list ( oldnode . parser_tree . ptlist ) else : oldpt = [ oldnode . parser_tree ] oldpt . append ( cla . parser_tree ) sequences . parser_tree = parsing . Seq ( * tuple ( oldpt ) ) return True", "nl": "Create a tree . Seq"}}
{"translation": {"code": "def position ( self ) -> Position : return Position ( self . _index , self . _lineno , self . _col_offset )", "nl": "The current position of the cursor ."}}
{"translation": {"code": "def step_next_char ( self ) : self . _index += 1 self . _col_offset += 1 if self . _index > self . _maxindex : self . _maxindex = self . _index self . _maxcol = self . _col_offset self . _maxline = self . _lineno", "nl": "Puts the cursor on the next character ."}}
{"translation": {"code": "def restore_context ( self ) -> bool : self . _cursor . position = self . _contexts . pop ( ) return False", "nl": "Rollback to previous saved position ."}}
{"translation": {"code": "def save_context ( self ) -> bool : self . _contexts . append ( self . _cursor . position ) return True", "nl": "Save current position ."}}
{"translation": {"code": "def step_next_line ( self ) : self . _eol . append ( self . position ) self . _lineno += 1 self . _col_offset = 0", "nl": "Sets cursor as beginning of next line ."}}
{"translation": {"code": "def step_prev_line ( self ) : #TODO(bps): raise explicit error for unregistered eol #assert self._eol[-1].index == self._index if len ( self . _eol ) > 0 : self . position = self . _eol . pop ( )", "nl": "Sets cursor as end of previous line ."}}
{"translation": {"code": "def incpos ( self , length : int = 1 ) -> int : if length < 0 : raise ValueError ( \"length must be positive\" ) i = 0 while ( i < length ) : if self . _cursor . index < self . _len : if self . peek_char == '\\n' : self . _cursor . step_next_line ( ) self . _cursor . step_next_char ( ) i += 1 return self . _cursor . index", "nl": "Increment the cursor to the next character ."}}
{"translation": {"code": "def add_hook ( self , sequence , h ) : sequence . parser_tree = parsing . Hook ( h . name , h . listparam ) return True", "nl": "Create a tree . Hook"}}
{"translation": {"code": "def param_str ( self , param , s ) : param . pair = ( self . value ( s ) . strip ( '\"' ) , str ) return True", "nl": "Parse a str in parameter list"}}
{"translation": {"code": "def param_char ( self , param , c ) : param . pair = ( self . value ( c ) . strip ( \"'\" ) , str ) return True", "nl": "Parse a char in parameter list"}}
{"translation": {"code": "def param_id ( self , param , i ) : param . pair = ( self . value ( i ) , parsing . Node ) return True", "nl": "Parse a node name in parameter list"}}
{"translation": {"code": "def hook_name ( self , hook , n ) : hook . name = self . value ( n ) hook . listparam = [ ] return True", "nl": "Parse a hook name"}}
{"translation": {"code": "def hook_param ( self , hook , p ) : hook . listparam . append ( p . pair ) return True", "nl": "Parse a hook parameter"}}
{"translation": {"code": "def param_num ( self , param , n ) : param . pair = ( int ( self . value ( n ) ) , int ) return True", "nl": "Parse a int in parameter list"}}
{"translation": {"code": "def directive ( directname = None ) : global _directives class_dir_list = _directives def wrapper ( f ) : nonlocal directname if directname is None : directname = f . __name__ f . ns_name = directname set_one ( class_dir_list , directname , f ) return f return wrapper", "nl": "Attach a class to a parsing class and register it as a parser directive ."}}
{"translation": {"code": "def parse ( self , source : str = None , entry : str = None ) -> parsing . Node : self . from_string = True if source is not None : self . parsed_stream ( source ) if entry is None : entry = self . entry if entry is None : raise ValueError ( \"No entry rule name defined for {}\" . format ( self . __class__ . __name__ ) ) return self . _do_parse ( entry )", "nl": "Parse source using the grammar"}}
{"translation": {"code": "def checktypes ( func ) : sig = inspect . signature ( func ) types = { } for param in sig . parameters . values ( ) : # Iterate through function's parameters and build the list of # arguments types param_type = param . annotation if param_type is param . empty or not inspect . isclass ( param_type ) : # Missing annotation or not a type, skip it continue types [ param . name ] = param_type # If the argument has a type specified, let's check that its # default value (if present) conforms with the type. if ( param . default is not param . empty and not isinstance ( param . default , param_type ) ) : raise ValueError ( \"{func}: wrong type of a default value for {arg!r}\" . format ( func = func . __qualname__ , arg = param . name ) ) def check_type ( sig , arg_name , arg_type , arg_value ) : # Internal function that encapsulates arguments type checking if not isinstance ( arg_value , arg_type ) : raise ValueError ( \"{func}: wrong type of {arg!r} argument, \" \"{exp!r} expected, got {got!r}\" . format ( func = func . __qualname__ , arg = arg_name , exp = arg_type . __name__ , got = type ( arg_value ) . __name__ ) ) @ functools . wraps ( func ) def wrapper ( * args , * * kwargs ) : # Let's bind the arguments ba = sig . bind ( * args , * * kwargs ) for arg_name , arg in ba . arguments . items ( ) : # And iterate through the bound arguments try : type_ = types [ arg_name ] except KeyError : continue else : # OK, we have a type for the argument, lets get the # corresponding parameter description from the signature object param = sig . parameters [ arg_name ] if param . kind == param . VAR_POSITIONAL : # If this parameter is a variable-argument parameter, # then we need to check each of its values for value in arg : check_type ( sig , arg_name , type_ , value ) elif param . kind == param . VAR_KEYWORD : # If this parameter is a variable-keyword-argument # parameter: for subname , value in arg . items ( ) : check_type ( sig , arg_name + ':' + subname , type_ , value ) else : # And, finally, if this parameter a regular one: check_type ( sig , arg_name , type_ , arg ) result = func ( * ba . args , * * ba . kwargs ) # The last bit - let's check that the result is correct return_type = sig . return_annotation if ( return_type is not sig . empty and isinstance ( return_type , type ) and not isinstance ( result , return_type ) ) : raise ValueError ( '{func}: wrong return type, {exp} expected, got {got}' . format ( func = func . __qualname__ , exp = return_type . __name__ , got = type ( result ) . __name__ ) ) return result return wrapper", "nl": "Decorator to verify arguments and return types ."}}
{"translation": {"code": "def end_tag ( self , name : str ) -> Node : self . tag_cache [ name ] . set_end ( self . _stream . index ) return True", "nl": "Extract the string between saved and current index ."}}
{"translation": {"code": "def eval_hook ( self , name : str , ctx : list ) -> Node : if name not in self . __class__ . _hooks : # TODO: don't always throw error, could have return True by default self . diagnostic . notify ( error . Severity . ERROR , \"Unknown hook : %s\" % name , error . LocationInfo . from_stream ( self . _stream , is_error = True ) ) raise self . diagnostic self . _lastRule = '#' + name res = self . __class__ . _hooks [ name ] ( self , * ctx ) if type ( res ) is not bool : raise TypeError ( \"Your hook %r didn't return a bool value\" % name ) return res", "nl": "Evaluate the hook by its name"}}
{"translation": {"code": "def peek_text ( self , text : str ) -> bool : start = self . _stream . index stop = start + len ( text ) if stop > self . _stream . eos_index : return False return self . _stream [ self . _stream . index : stop ] == text", "nl": "Same as readText but doesn t consume the stream ."}}
{"translation": {"code": "def begin_tag ( self , name : str ) -> Node : # Check if we could attach tag cache to current rule_nodes scope self . tag_cache [ name ] = Tag ( self . _stream , self . _stream . index ) return True", "nl": "Save the current index under the given name ."}}
{"translation": {"code": "def get_rules ( self ) -> parsing . Node : res = None try : res = self . eval_rule ( 'bnf_dsl' ) if not res : # we fail to parse, but error is not set self . diagnostic . notify ( error . Severity . ERROR , \"Parse error in '%s' in EBNF bnf\" % self . _lastRule , error . LocationInfo . from_maxstream ( self . _stream ) ) raise self . diagnostic except error . Diagnostic as d : d . notify ( error . Severity . ERROR , \"Parse error in '%s' in EBNF bnf\" % self . _lastRule ) raise d return res", "nl": "Parse the DSL and provide a dictionnaries of all resulting rules . Call by the MetaGrammar class ."}}
{"translation": {"code": "def set_one ( chainmap , thing_name , callobject ) : namespaces = reversed ( thing_name . split ( \".\" ) ) lstname = [ ] for name in namespaces : lstname . insert ( 0 , name ) strname = '.' . join ( lstname ) chainmap [ strname ] = callobject", "nl": "Add a mapping with key thing_name for callobject in chainmap with namespace handling ."}}
{"translation": {"code": "def set ( self , othernode ) : self . __class__ = othernode . __class__ self . clean ( ) if len ( othernode ) > 0 : for k , v in othernode . items ( ) : self [ k ] = v for k , v in vars ( othernode ) . items ( ) : setattr ( self , k , v )", "nl": "allow to completly mutate the node into any subclasses of Node"}}
{"translation": {"code": "def last_readed_line ( self ) -> str : mpos = self . _cursor . max_readed_position mindex = mpos . index # search last \\n prevline = mindex - 1 if mindex == self . eos_index else mindex while prevline >= 0 and self . _content [ prevline ] != '\\n' : prevline -= 1 # search next \\n nextline = mindex while nextline < self . eos_index and self . _content [ nextline ] != '\\n' : nextline += 1 last_line = self . _content [ prevline + 1 : nextline ] return last_line", "nl": "Usefull string to compute error message ."}}
{"translation": {"code": "def max_readed_position ( self ) -> Position : return Position ( self . _maxindex , self . _maxline , self . _maxcol )", "nl": "The index of the deepest character readed ."}}
{"translation": {"code": "def enum ( * sequential , * * named ) : #: build enums from parameter enums = dict ( zip ( sequential , range ( len ( sequential ) ) ) , * * named ) enums [ 'map' ] = copy . copy ( enums ) #: build reverse mapping enums [ 'rmap' ] = { } for key , value in enums . items ( ) : if type ( value ) is int : enums [ 'rmap' ] [ value ] = key return type ( 'Enum' , ( ) , enums )", "nl": "Build an enum statement"}}
{"translation": {"code": "def set_node ( self , dst , src ) : if not isinstance ( src , Node ) : dst . value = src else : dst . set ( src ) idsrc = id ( src ) iddst = id ( dst ) if iddst not in self . id_cache : print ( \"DST: %s\" % repr ( dst ) ) print ( \"RULE_NODES %s\" % repr ( self . rule_nodes ) ) print ( \"IDCACHE %s\" % repr ( self . id_cache ) ) if idsrc in self . id_cache : k = self . id_cache [ idsrc ] k2 = self . id_cache [ iddst ] if k in self . rule_nodes : self . tag_cache [ k2 ] = self . tag_cache [ k ] return True", "nl": "Basically copy one node to another . usefull to transmit a node from a terminal rule as result of the current rule ."}}
{"translation": {"code": "def echo_nodes ( self , * rest ) : txt = \"\" for thing in rest : if isinstance ( thing , Node ) : txt += self . value ( thing ) else : txt += str ( thing ) print ( txt ) return True", "nl": "Print nodes ."}}
{"translation": {"code": "def ignore_cxx ( self ) -> bool : self . _stream . save_context ( ) while not self . read_eof ( ) : idxref = self . _stream . index if self . _stream . peek_char in \" \\t\\v\\f\\r\\n\" : while ( not self . read_eof ( ) and self . _stream . peek_char in \" \\t\\v\\f\\r\\n\" ) : self . _stream . incpos ( ) if self . peek_text ( \"//\" ) : while not self . read_eof ( ) and not self . peek_char ( \"\\n\" ) : self . _stream . incpos ( ) if not self . read_char ( \"\\n\" ) and self . read_eof ( ) : return self . _stream . validate_context ( ) if self . peek_text ( \"/*\" ) : while not self . read_eof ( ) and not self . peek_text ( \"*/\" ) : self . _stream . incpos ( ) if not self . read_text ( \"*/\" ) and self . read_eof ( ) : return self . _stream . restore_context ( ) if idxref == self . _stream . index : break return self . _stream . validate_context ( )", "nl": "Consume comments and whitespace characters ."}}
{"translation": {"code": "def from_file ( fn : str , entry = None , * optional_inherit ) -> Grammar : import os . path if os . path . exists ( fn ) : f = open ( fn , 'r' ) bnf = f . read ( ) f . close ( ) inherit = [ Grammar ] + list ( optional_inherit ) scope = { 'grammar' : bnf , 'entry' : entry , 'source' : fn } return build_grammar ( tuple ( inherit ) , scope ) raise Exception ( \"File not Found!\" )", "nl": "Create a Grammar from a file"}}
{"translation": {"code": "def from_string ( bnf : str , entry = None , * optional_inherit ) -> Grammar : inherit = [ Grammar ] + list ( optional_inherit ) scope = { 'grammar' : bnf , 'entry' : entry } return build_grammar ( tuple ( inherit ) , scope )", "nl": "Create a Grammar from a string"}}
{"translation": {"code": "def parse_file ( self , filename : str , entry : str = None ) -> parsing . Node : self . from_string = False import os . path with open ( filename , 'r' ) as f : self . parsed_stream ( f . read ( ) , os . path . abspath ( filename ) ) if entry is None : entry = self . entry if entry is None : raise ValueError ( \"No entry rule name defined for {}\" . format ( self . __class__ . __name__ ) ) return self . _do_parse ( entry )", "nl": "Parse filename using the grammar"}}
{"translation": {"code": "def list_set_indent ( lst : list , indent : int = 1 ) : for i in lst : if isinstance ( i , indentable ) : i . set_indent ( indent ) if isinstance ( i , list ) : list_set_indent ( i , indent )", "nl": "recurs into list for indentation"}}
{"translation": {"code": "def list_to_str ( lst : list , content : str , indent : int = 1 ) : for i in lst : if isinstance ( i , indentable ) : content = i . to_str ( content , indent ) elif isinstance ( i , list ) : content = list_to_str ( i , content , indent ) elif isinstance ( i , str ) : content = catend ( content , i , indent ) return content", "nl": "recurs into list for string computing"}}
{"translation": {"code": "def catend ( dst : str , src : str , indent ) -> str : res = dst txtsrc = src if not isinstance ( src , str ) : txtsrc = str ( src ) for c in list ( txtsrc ) : if len ( res ) > 0 and res [ - 1 ] == '\\n' : res += ( indentable . char_indent * indentable . num_indent ) * ( indent - 1 ) + c else : res += c return res", "nl": "cat two strings but handle \\ n for tabulation"}}
{"translation": {"code": "def value ( self , n : Node ) -> str : id_n = id ( n ) idcache = self . id_cache if id_n not in idcache : return \"\" name = idcache [ id_n ] tag_cache = self . tag_cache if name not in tag_cache : raise Exception ( \"Incoherent tag cache\" ) tag = tag_cache [ name ] k = \"%d:%d\" % ( tag . _begin , tag . _end ) valcache = self . _streams [ - 1 ] . value_cache if k not in valcache : valcache [ k ] = str ( tag ) return valcache [ k ]", "nl": "Return the text value of the node"}}
{"translation": {"code": "def update ( self , sig : list or Scope ) -> Scope : values = sig if hasattr ( sig , 'values' ) : values = sig . values ( ) for s in values : if self . is_namespace : s . set_parent ( self ) if isinstance ( s , Scope ) : s . state = StateScope . EMBEDDED self . _hsig [ s . internal_name ( ) ] = s self . __update_count ( ) return self", "nl": "Update the Set with values of another Set"}}
{"translation": {"code": "def symmetric_difference ( self , sig : Scope ) -> Scope : new = Scope ( sig = self . _hsig . values ( ) , state = self . state ) new ^= sig return new", "nl": "Create a new Set with values present in only one Set"}}
{"translation": {"code": "def union ( self , sig : Scope ) -> Scope : new = Scope ( sig = self . _hsig . values ( ) , state = self . state ) new |= sig return new", "nl": "Create a new Set produce by the union of 2 Set"}}
{"translation": {"code": "def intersection_update ( self , oset : Scope ) -> Scope : keys = list ( self . _hsig . keys ( ) ) for k in keys : if k not in oset : del self . _hsig [ k ] else : self . _hsig [ k ] = oset . get ( k ) return self", "nl": "Update Set with common values of another Set"}}
{"translation": {"code": "def intersection ( self , sig : Scope ) -> Scope : new = Scope ( sig = self . _hsig . values ( ) , state = self . state ) new &= sig return new", "nl": "Create a new Set produce by the intersection of 2 Set"}}
{"translation": {"code": "def difference_update ( self , oset : Scope ) -> Scope : keys = list ( self . _hsig . keys ( ) ) for k in keys : if k in oset : del self . _hsig [ k ] return self", "nl": "Remove values common with another Set"}}
{"translation": {"code": "def difference ( self , sig : Scope ) -> Scope : new = Scope ( sig = self . _hsig . values ( ) , state = self . state ) new -= sig return new", "nl": "Create a new Set produce by a Set subtracted by another Set"}}
{"translation": {"code": "def symmetric_difference_update ( self , oset : Scope ) -> Scope : skey = set ( ) keys = list ( self . _hsig . keys ( ) ) for k in keys : if k in oset : skey . add ( k ) for k in oset . _hsig . keys ( ) : if k not in skey : self . _hsig [ k ] = oset . get ( k ) for k in skey : del self . _hsig [ k ] return self", "nl": "Remove common values and Update specific values from another Set"}}
{"translation": {"code": "def get ( self , key : str , default = None ) -> Signature : item = default if key in self . _hsig : item = self . _hsig [ key ] return item", "nl": "Get a signature instance by its internal_name"}}
{"translation": {"code": "def add ( self , it : Signature ) -> bool : if isinstance ( it , Scope ) : it . state = StateScope . EMBEDDED txt = it . internal_name ( ) it . set_parent ( self ) if self . is_namespace : txt = it . internal_name ( ) if txt == \"\" : txt = '_' + str ( len ( self . _hsig ) ) if txt in self . _hsig : raise KeyError ( \"Already exists %s\" % txt ) self . _hsig [ txt ] = it self . __update_count ( ) return True", "nl": "Add it to the Set"}}
{"translation": {"code": "def remove ( self , it : Signature ) -> bool : txt = it . internal_name ( ) if txt not in self . _hsig : raise KeyError ( it . show_name ( ) + ' not in Set' ) sig = self . _hsig [ txt ] if isinstance ( sig , Scope ) : sig . state = StateScope . LINKED del self . _hsig [ txt ] return True", "nl": "Remove it but raise KeyError if not found"}}
{"translation": {"code": "def get_by_symbol_name ( self , name : str ) -> Scope : lst = [ ] for s in self . values ( ) : if s . name == name : # create an EvalCtx only when necessary lst . append ( EvalCtx . from_sig ( s ) ) # include parent # TODO: see all case of local redefinition for #       global overloads # possible algos... take all with different internal_name if len ( lst ) == 0 : p = self . get_parent ( ) if p is not None : return p . get_by_symbol_name ( name ) rscope = Scope ( sig = lst , state = StateScope . LINKED , is_namespace = False ) # inherit type/translation from parent rscope . set_parent ( self ) return rscope", "nl": "Retrieve a Set of all signature by symbol name"}}
{"translation": {"code": "def discard ( self , it : Signature ) -> bool : txt = it . internal_name ( ) if txt in self . _hsig : sig = self . _hsig [ txt ] if isinstance ( sig , Scope ) : sig . state = StateScope . LINKED del self . _hsig [ txt ] return True return False", "nl": "Remove it only if present"}}
{"translation": {"code": "def bind ( self , dst : str , src : Node ) -> bool : for m in self . rule_nodes . maps : for k , v in m . items ( ) : if k == dst : m [ k ] = src return True raise Exception ( '%s not found' % dst )", "nl": "Allow to alias a node to another name ."}}
{"translation": {"code": "def add_bind ( self , sequence , cpt ) : cpt_value = self . value ( cpt ) sequence . parser_tree = parsing . Bind ( cpt_value , sequence . parser_tree ) return True", "nl": "Create a tree . Bind"}}
{"translation": {"code": "def dump_nodes ( self ) : print ( \"DUMP NODE LOCAL INFOS\" ) try : print ( \"map Id->node name\" ) for k , v in self . id_cache . items ( ) : print ( \"[%d]=%s\" % ( k , v ) ) print ( \"map tag->capture infos\" ) for k , v in self . tag_cache . items ( ) : print ( \"[%s]=%s\" % ( k , v ) ) print ( \"map nodes->tag resolution\" ) for k , v in self . rule_nodes . items ( ) : txt = \"['%s']=%d\" % ( k , id ( v ) ) if k in self . tag_cache : tag = self . tag_cache [ k ] txt += \" tag <%s>\" % tag k = \"%d:%d\" % ( tag . _begin , tag . _end ) if k in self . _stream . value_cache : txt += \" cache <%s>\" % self . _stream . value_cache [ k ] print ( txt ) except Exception as err : print ( \"RECV Exception %s\" % err ) import sys sys . stdout . flush ( ) return True", "nl": "Dump tag rule id and value cache . For debug ."}}
{"translation": {"code": "def infer_literal ( self , args , diagnostic = None ) : literal , t = args #self.type_node.add(EvalCtx.from_sig(Val(literal, t))) self . infer_node . scope_node . add ( EvalCtx . from_sig ( Val ( literal , t ) ) )", "nl": "Infer type from an LITERAL! Type of literal depend of language . We adopt a basic convention"}}
{"translation": {"code": "def get_all_polymorphic_return ( self ) -> bool : lst = [ ] for s in self . values ( ) : if hasattr ( s , 'tret' ) and s . tret . is_polymorphic : # encapsulate s into a EvalCtx for meta-var resolution lst . append ( EvalCtx . from_sig ( s ) ) rscope = Scope ( sig = lst , state = StateScope . LINKED , is_namespace = False ) # inherit type/translation from parent rscope . set_parent ( self ) return rscope", "nl": "For now polymorphic return type are handle by symbol artefact ."}}
{"translation": {"code": "def infer_id ( self , ident , diagnostic = None ) : # check if ID is declared #defined = self.type_node.get_by_symbol_name(ident) defined = self . infer_node . scope_node . get_by_symbol_name ( ident ) if len ( defined ) > 0 : # set from matchings declarations #self.type_node.update(defined) self . infer_node . scope_node . update ( defined ) else : diagnostic . notify ( Severity . ERROR , \"%s never declared\" % self . value , self . info )", "nl": "Infer type from an ID! - check if ID is declarated in the scope - if no ID is polymorphic type"}}
{"translation": {"code": "def infer_block ( self , body , diagnostic = None ) : # RootBlockStmt has his own .infer_node (created via infer_type) for e in body : e . infer_node = InferNode ( parent = self . infer_node ) e . infer_type ( diagnostic = diagnostic )", "nl": "Infer type on block is to type each of is sub - element"}}
{"translation": {"code": "def infer_subexpr ( self , expr , diagnostic = None ) : expr . infer_node = InferNode ( parent = self . infer_node ) expr . infer_type ( diagnostic = diagnostic )", "nl": "Infer type on the subexpr"}}
{"translation": {"code": "def resolve ( self ) : # collect types for resolution t2resolv = [ ] if hasattr ( self . _sig , 'tret' ) : t2resolv . append ( self . _sig . tret ) if hasattr ( self . _sig , 'tparams' ) and self . _sig . tparams is not None : for p in self . _sig . tparams : t2resolv . append ( p ) if self . _translate_to is not None : t2resolv . append ( self . _translate_to . target ) if self . _variadic_types is not None : for t in self . _variadic_types : t2resolv . append ( t ) for t in t2resolv : for c in t . components : if c not in self . resolution or self . resolution [ c ] is None : # try to find what is c parent = self . get_parent ( ) if parent is not None : sc = parent . get_by_symbol_name ( c ) if len ( sc ) == 1 : sc = list ( sc . values ( ) ) [ 0 ] # unwrap EvalCtx around Type if isinstance ( sc , EvalCtx ) : sc = sc . _sig rtyp = weakref . ref ( sc ) self . resolution [ c ] = rtyp continue # unresolved self . resolution [ c ] = None", "nl": "Process the signature and find definition for type ."}}
{"translation": {"code": "def get_compute_sig ( self ) -> Signature : tret = [ ] tparams = [ ] for t in self . tret . components : if t in self . resolution and self . resolution [ t ] is not None : tret . append ( self . resolution [ t ] ( ) . show_name ( ) ) else : tret . append ( t ) if hasattr ( self , 'tparams' ) : for p in self . tparams : tp = [ ] for t in p . components : if t in self . resolution and self . resolution [ t ] is not None : tp . append ( self . resolution [ t ] ( ) . show_name ( ) ) else : tp . append ( t ) tparams . append ( \" \" . join ( tp ) ) if self . variadic : if self . _variadic_types is None : raise ValueError ( \"Can't compute the sig \" + \"with unresolved variadic argument\" ) for p in self . _variadic_types : tp = [ ] for t in p . components : if ( t in self . resolution and self . resolution [ t ] is not None ) : tp . append ( self . resolution [ t ] ( ) . show_name ( ) ) else : tp . append ( t ) tparams . append ( \" \" . join ( tp ) ) ret = Fun ( self . name , \" \" . join ( tret ) , tparams ) # transform as-is into our internal Signature (Val, Var, whatever) ret . __class__ = self . _sig . __class__ return ret", "nl": "Compute a signature Using resolution!!!"}}
{"translation": {"code": "def set_resolved_name ( self , ref : dict , type_name2solve : TypeName , type_name_ref : TypeName ) : if self . resolution [ type_name2solve . value ] is None : self . resolution [ type_name2solve . value ] = ref [ type_name_ref . value ]", "nl": "Warning!!! Need to rethink it when global poly type"}}
{"translation": {"code": "def get_resolved_names ( self , type_name : TypeName ) -> list : if not isinstance ( type_name , TypeName ) : raise Exception ( \"Take a TypeName as parameter not a %s\" % type ( type_name ) ) rnames = [ ] for name in type_name . components : if name not in self . resolution : raise Exception ( \"Unknown type %s in a EvalCtx\" % name ) rname = self . resolution [ name ] if rname is not None : rname = rname ( ) . show_name ( ) else : rname = name rnames . append ( rname ) return rnames", "nl": "Use self . resolution to subsitute type_name . Allow to instanciate polymorphic type ?1 ?toto"}}
{"translation": {"code": "def decorator ( directname = None ) : global _decorators class_deco_list = _decorators def wrapper ( f ) : nonlocal directname if directname is None : directname = f . __name__ f . ns_name = directname set_one ( class_deco_list , directname , f ) return wrapper", "nl": "Attach a class to a parsing decorator and register it to the global decorator list . The class is registered with its name unless directname is provided"}}
{"translation": {"code": "def last ( self ) -> Signature : k = sorted ( self . _hsig . keys ( ) ) return self . _hsig [ k [ - 1 ] ]", "nl": "Retrieve the last Signature ordered by mangling descendant"}}
{"translation": {"code": "def first ( self ) -> Signature : k = sorted ( self . _hsig . keys ( ) ) return self . _hsig [ k [ 0 ] ]", "nl": "Retrieve the first Signature ordered by mangling descendant"}}
{"translation": {"code": "def getsig_by_symbol_name ( self , name : str ) -> Signature : subscope = self . get_by_symbol_name ( name ) if len ( subscope ) != 1 : raise KeyError ( \"%s have multiple candidates in scope\" % name ) v = list ( subscope . values ( ) ) return v [ 0 ]", "nl": "Retrieve the unique Signature of a symbol . Fail if the Signature is not unique"}}