{"translation": {"code": "def count_vars ( self ) -> int : n = 0 for s in self . _hsig . values ( ) : if hasattr ( s , 'is_var' ) and s . is_var : n += 1 return n", "nl": "Count var define by this scope"}}
{"translation": {"code": "def set_name ( self , name : str ) : self . name = name # update internal names lsig = self . _hsig . values ( ) self . _hsig = { } for s in lsig : self . _hsig [ s . internal_name ( ) ] = s", "nl": "You could set the name after construction"}}
{"translation": {"code": "def values ( self ) -> [ Signature ] : if self . state == StateScope . EMBEDDED and self . parent is not None : return list ( self . _hsig . values ( ) ) + list ( self . parent ( ) . values ( ) ) else : return self . _hsig . values ( )", "nl": "Retrieve all values"}}
{"translation": {"code": "def to_png_file ( self , fname : str ) : cmd = pipes . Template ( ) cmd . append ( 'dot -Tpng > %s' % fname , '-.' ) with cmd . open ( 'pipefile' , 'w' ) as f : f . write ( self . to_dot ( ) )", "nl": "write a . png file ."}}
{"translation": {"code": "def populate_from_sequence ( seq : list , r : ref ( Edge ) , sr : state . StateRegister ) : base_state = r # we need to detect the last state of the sequence idxlast = len ( seq ) - 1 idx = 0 for m in seq : # alternatives are represented by builtin list if isinstance ( m , list ) : # so recursively connect all states of each alternative sequences. for item in m : populate_from_sequence ( item , r , sr ) elif isinstance ( m , MatchExpr ) : # from the current state, have we a existing edge for this event? eX = r ( ) . get_next_edge ( m ) if eX is None : sX = None if idx != idxlast : sX = state . State ( sr ) sX . matchDefault ( base_state ( ) . s ) else : # last state of sequence return to the base sX = base_state ( ) . s eX = Edge ( sX ) r ( ) . next_edge [ id ( sX ) ] = eX m . attach ( r ( ) . s , sX , sr ) r = ref ( eX ) idx += 1", "nl": "function that connect each other one sequence of MatchExpr ."}}
{"translation": {"code": "def populate_state_register ( all_seq : [ list ] , sr : state . StateRegister ) -> Edge : # Basic State s0 = state . State ( sr ) # loop on himself s0 . matchDefault ( s0 ) # this is default sr . set_default_state ( s0 ) # use Edge to store connection e0 = Edge ( s0 ) for seq in all_seq : r = ref ( e0 ) # merge all sequences into one tree automata populate_from_sequence ( seq , r , sr ) # return edge for debug purpose return e0", "nl": "function that create a state for all instance of MatchExpr in the given list and connect each others ."}}
{"translation": {"code": "def to_dot ( self ) -> str : txt = \"\" txt += \"digraph S%d {\\n\" % id ( self ) if self . label is not None : txt += '\\tlabel=\"%s\";\\n' % ( self . label + '\\l' ) . replace ( '\\n' , '\\l' ) txt += \"\\trankdir=LR;\\n\" #txt += '\\tlabelloc=\"t\";\\n' txt += '\\tgraph [labeljust=l, labelloc=t, nojustify=true];\\n' txt += \"\\tesep=1;\\n\" txt += '\\tranksep=\"equally\";\\n' txt += \"\\tnode [shape = circle];\\n\" txt += \"\\tsplines = ortho;\\n\" for s in self . states . values ( ) : txt += s [ 1 ] . to_dot ( ) txt += \"}\\n\" return txt", "nl": "Provide a . dot representation of all State in the register ."}}
{"translation": {"code": "def add_state ( self , s : State ) : ids = id ( s ) uid = len ( self . states ) if ids not in self . states : self . states [ ids ] = ( uid , s )", "nl": "all state in the register have a uid"}}
{"translation": {"code": "def to_fmt ( self , with_from = False ) -> fmt . indentable : txt = fmt . sep ( \"\\n\" , [ fmt . sep ( \" \" , [ self . _type_source , \"to\" , self . _type_target , '=' , self . _fun . to_fmt ( ) ] ) , self . _notify . get_content ( with_from ) ] ) return txt", "nl": "Return a Fmt representation of Translator for pretty - printing"}}
{"translation": {"code": "def normalize ( ast : Node ) -> Node : res = ast typemap = { DictNode , ListNode , TupleNode } if type ( ast ) is dict : res = DictNode ( ast ) elif type ( ast ) is list : res = ListNode ( ast ) elif type ( ast ) is tuple : res = TupleNode ( ast ) # in-depth change if hasattr ( res , 'items' ) : for k , v in res . items ( ) : res [ k ] = normalize ( v ) elif hasattr ( res , '__getitem__' ) : for idx , v in zip ( range ( len ( res ) ) , res ) : res [ idx ] = normalize ( v ) if type ( res ) not in typemap and hasattr ( res , '__dict__' ) : subattr = vars ( res ) for k , v in subattr . items ( ) : setattr ( res , k , normalize ( v ) ) return res", "nl": "Normalize an AST nodes ."}}
{"translation": {"code": "def one_char ( self ) -> bool : if self . read_eof ( ) : return False self . _stream . incpos ( ) return True", "nl": "Read one byte in stream"}}