{"translation": {"code": "def euler_angles_1q ( unitary_matrix ) : if unitary_matrix . shape != ( 2 , 2 ) : raise QiskitError ( \"euler_angles_1q: expected 2x2 matrix\" ) phase = la . det ( unitary_matrix ) ** ( - 1.0 / 2.0 ) U = phase * unitary_matrix # U in SU(2) # OpenQASM SU(2) parameterization: # U[0, 0] = exp(-i(phi+lambda)/2) * cos(theta/2) # U[0, 1] = -exp(-i(phi-lambda)/2) * sin(theta/2) # U[1, 0] = exp(i(phi-lambda)/2) * sin(theta/2) # U[1, 1] = exp(i(phi+lambda)/2) * cos(theta/2) # Find theta if abs ( U [ 0 , 0 ] ) > _CUTOFF_PRECISION : theta = 2 * math . acos ( abs ( U [ 0 , 0 ] ) ) else : theta = 2 * math . asin ( abs ( U [ 1 , 0 ] ) ) # Find phi and lambda phase11 = 0.0 phase10 = 0.0 if abs ( math . cos ( theta / 2.0 ) ) > _CUTOFF_PRECISION : phase11 = U [ 1 , 1 ] / math . cos ( theta / 2.0 ) if abs ( math . sin ( theta / 2.0 ) ) > _CUTOFF_PRECISION : phase10 = U [ 1 , 0 ] / math . sin ( theta / 2.0 ) phiplambda = 2 * math . atan2 ( np . imag ( phase11 ) , np . real ( phase11 ) ) phimlambda = 2 * math . atan2 ( np . imag ( phase10 ) , np . real ( phase10 ) ) phi = 0.0 if abs ( U [ 0 , 0 ] ) > _CUTOFF_PRECISION and abs ( U [ 1 , 0 ] ) > _CUTOFF_PRECISION : phi = ( phiplambda + phimlambda ) / 2.0 lamb = ( phiplambda - phimlambda ) / 2.0 else : if abs ( U [ 0 , 0 ] ) < _CUTOFF_PRECISION : lamb = - phimlambda else : lamb = phiplambda # Check the solution Rzphi = np . array ( [ [ np . exp ( - 1j * phi / 2.0 ) , 0 ] , [ 0 , np . exp ( 1j * phi / 2.0 ) ] ] , dtype = complex ) Rytheta = np . array ( [ [ np . cos ( theta / 2.0 ) , - np . sin ( theta / 2.0 ) ] , [ np . sin ( theta / 2.0 ) , np . cos ( theta / 2.0 ) ] ] , dtype = complex ) Rzlambda = np . array ( [ [ np . exp ( - 1j * lamb / 2.0 ) , 0 ] , [ 0 , np . exp ( 1j * lamb / 2.0 ) ] ] , dtype = complex ) V = np . dot ( Rzphi , np . dot ( Rytheta , Rzlambda ) ) if la . norm ( V - U ) > _CUTOFF_PRECISION : raise QiskitError ( \"euler_angles_1q: incorrect result\" ) return theta , phi , lamb", "nl": "Compute Euler angles for a single - qubit gate ."}}
{"translation": {"code": "def random_unitary ( dim , seed = None ) : if dim == 0 or not math . log2 ( dim ) . is_integer ( ) : raise QiskitError ( \"Desired unitary dimension not a positive power of 2.\" ) matrix = np . zeros ( [ dim , dim ] , dtype = complex ) for j in range ( dim ) : if j == 0 : a = random_state ( dim , seed ) else : a = random_state ( dim ) matrix [ : , j ] = np . copy ( a ) # Grahm-Schmidt Orthogonalize i = j - 1 while i >= 0 : dc = np . vdot ( matrix [ : , i ] , a ) matrix [ : , j ] = matrix [ : , j ] - dc * matrix [ : , i ] i = i - 1 # normalize matrix [ : , j ] = matrix [ : , j ] * ( 1.0 / np . sqrt ( np . vdot ( matrix [ : , j ] , matrix [ : , j ] ) ) ) return Operator ( matrix )", "nl": "Return a random dim x dim unitary Operator from the Haar measure ."}}
{"translation": {"code": "def __random_density_hs ( N , rank = None , seed = None ) : G = __ginibre_matrix ( N , rank , seed ) G = G . dot ( G . conj ( ) . T ) return G / np . trace ( G )", "nl": "Generate a random density matrix from the Hilbert - Schmidt metric ."}}
{"translation": {"code": "def __ginibre_matrix ( nrow , ncol = None , seed = None ) : if ncol is None : ncol = nrow if seed is not None : np . random . seed ( seed ) G = np . random . normal ( size = ( nrow , ncol ) ) + np . random . normal ( size = ( nrow , ncol ) ) * 1j return G", "nl": "Return a normally distributed complex random matrix ."}}
{"translation": {"code": "def format_level_1_memory ( memory ) : formatted_memory = _list_to_complex_array ( memory ) # infer meas_return from shape of returned data. if not 1 <= len ( formatted_memory . shape ) <= 2 : raise QiskitError ( 'Level one memory is not of correct shape.' ) return formatted_memory", "nl": "Format an experiment result memory object for measurement level 1 ."}}
{"translation": {"code": "def _update_annotations ( discretized_pulse : Callable ) -> Callable : undecorated_annotations = list ( discretized_pulse . __annotations__ . items ( ) ) decorated_annotations = undecorated_annotations [ 1 : ] decorated_annotations . insert ( 0 , ( 'duration' , int ) ) discretized_pulse . __annotations__ = dict ( decorated_annotations ) return discretized_pulse", "nl": "Update annotations of discretized continuous pulse function with duration ."}}
{"translation": {"code": "def sampler ( sample_function : Callable ) -> Callable : def generate_sampler ( continuous_pulse : Callable ) -> Callable : \"\"\"Return a decorated sampler function.\"\"\" @ functools . wraps ( continuous_pulse ) def call_sampler ( duration : int , * args , * * kwargs ) -> commands . SamplePulse : \"\"\"Replace the call to the continuous function with a call to the sampler applied\n            to the anlytic pulse function.\"\"\" sampled_pulse = sample_function ( continuous_pulse , duration , * args , * * kwargs ) return np . asarray ( sampled_pulse , dtype = np . complex_ ) # Update type annotations for wrapped continuous function to be discrete call_sampler = _update_annotations ( call_sampler ) # Update docstring with that of the sampler and include sampled function documentation. call_sampler = _update_docstring ( call_sampler , sample_function ) # Unset wrapped to return base sampler signature # but still get rest of benefits of wraps # such as __name__, __qualname__ call_sampler . __dict__ . pop ( '__wrapped__' ) # wrap with functional pulse return commands . functional_pulse ( call_sampler ) return generate_sampler", "nl": "Sampler decorator base method ."}}
{"translation": {"code": "def bind_parameters ( self , value_dict ) : new_circuit = self . copy ( ) if value_dict . keys ( ) > self . parameters : raise QiskitError ( 'Cannot bind parameters ({}) not present in the circuit.' . format ( [ str ( p ) for p in value_dict . keys ( ) - self . parameters ] ) ) for parameter , value in value_dict . items ( ) : new_circuit . _bind_parameter ( parameter , value ) # clear evaluated expressions for parameter in value_dict : del new_circuit . _parameter_table [ parameter ] return new_circuit", "nl": "Assign parameters to values yielding a new circuit ."}}
{"translation": {"code": "def shift ( self , time : int ) -> 'Timeslot' : return Timeslot ( self . interval . shift ( time ) , self . channel )", "nl": "Return a new Timeslot shifted by time ."}}
{"translation": {"code": "def to_operator ( self ) : # Place import here to avoid cyclic import from circuit visualization from qiskit . quantum_info . operators . operator import Operator return Operator ( self . to_matrix ( ) )", "nl": "Convert to Operator object ."}}
{"translation": {"code": "def _init_transformer ( cls , data ) : # This handles common conversion for all QuantumChannel subclasses. # If the input is already a QuantumChannel subclass it will return # the original object if isinstance ( data , QuantumChannel ) : return data if hasattr ( data , 'to_quantumchannel' ) : # If the data object is not a QuantumChannel it will give # preference to a 'to_quantumchannel' attribute that allows # an arbitrary object to define its own conversion to any # quantum channel subclass. return data . to_channel ( ) if hasattr ( data , 'to_channel' ) : # TODO: this 'to_channel' method is the same case as the above # but is used by current version of Aer. It should be removed # once Aer is nupdated to use `to_quantumchannel` # instead of `to_channel`, return data . to_channel ( ) # Finally if the input is not a QuantumChannel and doesn't have a # 'to_quantumchannel' conversion method we try and initialize it as a # regular matrix Operator which can be converted into a QuantumChannel. return Operator ( data )", "nl": "Convert input into a QuantumChannel subclass object or Operator object"}}
{"translation": {"code": "def constant ( times : np . ndarray , amp : complex ) -> np . ndarray : return np . full ( len ( times ) , amp , dtype = np . complex_ )", "nl": "Continuous constant pulse ."}}
{"translation": {"code": "def constant ( duration : int , amp : complex , name : str = None ) -> SamplePulse : return _sampled_constant_pulse ( duration , amp , name = name )", "nl": "Generates constant - sampled SamplePulse ."}}
{"translation": {"code": "def zero ( duration : int , name : str = None ) -> SamplePulse : return _sampled_zero_pulse ( duration , name = name )", "nl": "Generates zero - sampled SamplePulse ."}}
{"translation": {"code": "def square ( duration : int , amp : complex , period : float = None , phase : float = 0 , name : str = None ) -> SamplePulse : if period is None : period = duration return _sampled_square_pulse ( duration , amp , period , phase = phase , name = name )", "nl": "Generates square wave SamplePulse ."}}
{"translation": {"code": "def triangle ( times : np . ndarray , amp : complex , period : float , phase : float = 0 ) -> np . ndarray : return amp * ( - 2 * np . abs ( sawtooth ( times , 1 , period , ( phase - np . pi / 2 ) / 2 ) ) + 1 ) . astype ( np . complex_ )", "nl": "Continuous triangle wave ."}}
{"translation": {"code": "def cos ( duration : int , amp : complex , freq : float = None , phase : float = 0 , name : str = None ) -> SamplePulse : if freq is None : freq = 1 / duration return _sampled_cos_pulse ( duration , amp , freq , phase = phase , name = name )", "nl": "Generates cosine wave SamplePulse ."}}
{"translation": {"code": "def triangle ( duration : int , amp : complex , period : float = None , phase : float = 0 , name : str = None ) -> SamplePulse : if period is None : period = duration return _sampled_triangle_pulse ( duration , amp , period , phase = phase , name = name )", "nl": "Generates triangle wave SamplePulse ."}}
{"translation": {"code": "def sin ( duration : int , amp : complex , freq : float = None , phase : float = 0 , name : str = None ) -> SamplePulse : if freq is None : freq = 1 / duration return _sampled_sin_pulse ( duration , amp , freq , phase = phase , name = name )", "nl": "Generates sine wave SamplePulse ."}}
{"translation": {"code": "def merged ( self , timeslots : 'TimeslotCollection' ) -> 'TimeslotCollection' : slots = [ Timeslot ( slot . interval , slot . channel ) for slot in self . timeslots ] slots . extend ( [ Timeslot ( slot . interval , slot . channel ) for slot in timeslots . timeslots ] ) return TimeslotCollection ( * slots )", "nl": "Return a new TimeslotCollection merged with a specified timeslots"}}
{"translation": {"code": "def convert_snapshot ( self , shift , instruction ) : command_dict = { 'name' : 'snapshot' , 't0' : shift + instruction . start_time , 'label' : instruction . name , 'type' : instruction . type } return self . _qobj_model ( * * command_dict )", "nl": "Return converted Snapshot ."}}
{"translation": {"code": "def convert_drive ( self , shift , instruction ) : command_dict = { 'name' : instruction . command . name , 't0' : shift + instruction . start_time , 'ch' : instruction . channels [ 0 ] . name } return self . _qobj_model ( * * command_dict )", "nl": "Return converted PulseInstruction ."}}
{"translation": {"code": "def convert_frame_change ( self , shift , instruction ) : command_dict = { 'name' : 'fc' , 't0' : shift + instruction . start_time , 'ch' : instruction . channels [ 0 ] . name , 'phase' : instruction . command . phase } return self . _qobj_model ( * * command_dict )", "nl": "Return converted FrameChangeInstruction ."}}
{"translation": {"code": "def get_meas_los ( self , user_lo_config ) : try : _m_los = self . default_meas_los . copy ( ) except KeyError : raise PulseError ( 'Default measurement frequencies not exist.' ) for channel , lo_freq in user_lo_config . meas_lo_dict ( ) . items ( ) : _m_los [ channel . index ] = lo_freq if _m_los == self . default_meas_los : return None return _m_los", "nl": "Embed default meas LO frequencies from backend and format them to list object . If configured lo frequency is the same as default this method returns None ."}}
{"translation": {"code": "def get_qubit_los ( self , user_lo_config ) : try : _q_los = self . default_qubit_los . copy ( ) except KeyError : raise PulseError ( 'Qubit default frequencies not exist.' ) for channel , lo_freq in user_lo_config . qubit_lo_dict ( ) . items ( ) : _q_los [ channel . index ] = lo_freq if _q_los == self . default_qubit_los : return None return _q_los", "nl": "Embed default qubit LO frequencies from backend and format them to list object . If configured lo frequency is the same as default this method returns None ."}}
{"translation": {"code": "def disassemble ( qobj ) : run_config = qobj . config . to_dict ( ) user_qobj_header = qobj . header . to_dict ( ) circuits = _experiments_to_circuits ( qobj ) return circuits , run_config , user_qobj_header", "nl": "Dissasemble a qobj and return the circuits run_config and user header"}}
{"translation": {"code": "def assemble ( experiments , backend = None , qobj_id = None , qobj_header = None , # common run options shots = 1024 , memory = False , max_credits = None , seed_simulator = None , default_qubit_los = None , default_meas_los = None , # schedule run options schedule_los = None , meas_level = 2 , meas_return = 'avg' , memory_slots = None , memory_slot_size = 100 , rep_time = None , parameter_binds = None , config = None , seed = None , # deprecated * * run_config ) : # deprecation matter if config : warnings . warn ( 'config is not used anymore. Set all configs in ' 'run_config.' , DeprecationWarning ) run_config = run_config or config if seed : warnings . warn ( 'seed is deprecated in favor of seed_simulator.' , DeprecationWarning ) seed_simulator = seed_simulator or seed # Get RunConfig(s) that will be inserted in Qobj to configure the run experiments = experiments if isinstance ( experiments , list ) else [ experiments ] qobj_id , qobj_header , run_config = _parse_run_args ( backend , qobj_id , qobj_header , shots , memory , max_credits , seed_simulator , default_qubit_los , default_meas_los , schedule_los , meas_level , meas_return , memory_slots , memory_slot_size , rep_time , parameter_binds , * * run_config ) # assemble either circuits or schedules if all ( isinstance ( exp , QuantumCircuit ) for exp in experiments ) : # If circuits are parameterized, bind parameters and remove from run_config bound_experiments , run_config = _expand_parameters ( circuits = experiments , run_config = run_config ) return assemble_circuits ( circuits = bound_experiments , qobj_id = qobj_id , qobj_header = qobj_header , run_config = run_config ) elif all ( isinstance ( exp , Schedule ) for exp in experiments ) : return assemble_schedules ( schedules = experiments , qobj_id = qobj_id , qobj_header = qobj_header , run_config = run_config ) else : raise QiskitError ( \"bad input to assemble() function; \" \"must be either circuits or schedules\" )", "nl": "Assemble a list of circuits or pulse schedules into a Qobj ."}}
{"translation": {"code": "def _transpile_circuit ( circuit_config_tuple ) : circuit , transpile_config = circuit_config_tuple # if the pass manager is not already selected, choose an appropriate one. if transpile_config . pass_manager : pass_manager = transpile_config . pass_manager elif transpile_config . coupling_map : pass_manager = default_pass_manager ( transpile_config . basis_gates , transpile_config . coupling_map , transpile_config . initial_layout , transpile_config . seed_transpiler ) else : pass_manager = default_pass_manager_simulator ( transpile_config . basis_gates ) return pass_manager . run ( circuit )", "nl": "Select a PassManager and run a single circuit through it ."}}
{"translation": {"code": "def _instruction_to_superop ( cls , instruction ) : # Convert circuit to an instruction if isinstance ( instruction , QuantumCircuit ) : instruction = instruction . to_instruction ( ) # Initialize an identity superoperator of the correct size # of the circuit op = SuperOp ( np . eye ( 4 ** instruction . num_qubits ) ) op . _append_instruction ( instruction ) return op", "nl": "Convert a QuantumCircuit or Instruction to a SuperOp ."}}
{"translation": {"code": "def _instruction_to_operator ( cls , instruction ) : # Convert circuit to an instruction if isinstance ( instruction , QuantumCircuit ) : instruction = instruction . to_instruction ( ) # Initialize an identity operator of the correct size of the circuit op = Operator ( np . eye ( 2 ** instruction . num_qubits ) ) op . _append_instruction ( instruction ) return op", "nl": "Convert a QuantumCircuit or Instruction to an Operator ."}}
{"translation": {"code": "def flatten ( schedule : ScheduleComponent , name : str = None ) -> Schedule : if name is None : name = schedule . name return Schedule ( * schedule . instructions , name = name )", "nl": "Create a flattened schedule ."}}
{"translation": {"code": "def ch_stop_time ( self , * channels : List [ Channel ] ) -> int : return self . timeslots . ch_stop_time ( * channels )", "nl": "Return maximum start time for supplied channels ."}}
{"translation": {"code": "def insert ( self , start_time : int , schedule : ScheduleComponent ) -> 'ScheduleComponent' : return ops . insert ( self , start_time , schedule )", "nl": "Return a new schedule with schedule inserted within self at start_time ."}}
{"translation": {"code": "def get_bound_method ( self , instruction ) : try : return self . _bound_instructions [ type ( instruction ) ] except KeyError : raise PulseError ( 'Qobj conversion method for %s is not found.' % instruction )", "nl": "Get conversion method for instruction ."}}
{"translation": {"code": "def shift ( schedule : ScheduleComponent , time : int , name : str = None ) -> Schedule : if name is None : name = schedule . name return union ( ( time , schedule ) , name = name )", "nl": "Return schedule shifted by time ."}}
{"translation": {"code": "def _define ( self ) : if self . num_qubits == 1 : q = QuantumRegister ( 1 , \"q\" ) angles = euler_angles_1q ( self . to_matrix ( ) ) self . definition = [ ( U3Gate ( * angles ) , [ q [ 0 ] ] , [ ] ) ] if self . num_qubits == 2 : self . definition = two_qubit_kak ( self . to_matrix ( ) )", "nl": "Calculate a subcircuit that implements this unitary ."}}
{"translation": {"code": "def to_instruction ( self ) : from qiskit . circuit . instruction import Instruction # Check if input is an N-qubit CPTP channel. n_qubits = int ( np . log2 ( self . _input_dim ) ) if self . _input_dim != self . _output_dim or 2 ** n_qubits != self . _input_dim : raise QiskitError ( 'Cannot convert QuantumChannel to Instruction: channel is not an N-qubit channel.' ) if not self . is_cptp ( ) : raise QiskitError ( 'Cannot convert QuantumChannel to Instruction: channel is not CPTP.' ) # Next we convert to the Kraus representation. Since channel is CPTP we know # that there is only a single set of Kraus operators kraus , _ = _to_kraus ( self . rep , self . _data , * self . dim ) # If we only have a single Kraus operator then the channel is # a unitary channel so can be converted to a UnitaryGate. We do this by # converting to an Operator and using its to_instruction method if len ( kraus ) == 1 : return Operator ( kraus [ 0 ] ) . to_instruction ( ) return Instruction ( 'kraus' , n_qubits , 0 , kraus )", "nl": "Convert to a Kraus or UnitaryGate circuit instruction ."}}
{"translation": {"code": "def to_instruction ( self ) : from qiskit . circuit import QuantumCircuit , QuantumRegister from qiskit . extensions . standard import IdGate , XGate , YGate , ZGate gates = { 'I' : IdGate ( ) , 'X' : XGate ( ) , 'Y' : YGate ( ) , 'Z' : ZGate ( ) } label = self . to_label ( ) n_qubits = self . numberofqubits qreg = QuantumRegister ( n_qubits ) circuit = QuantumCircuit ( qreg , name = 'Pauli:{}' . format ( label ) ) for i , pauli in enumerate ( reversed ( label ) ) : circuit . append ( gates [ pauli ] , [ qreg [ i ] ] ) return circuit . to_instruction ( )", "nl": "Convert to Pauli circuit instruction ."}}
{"translation": {"code": "def quantum_predecessors ( self , node ) : predecessors = [ ] for predecessor in self . predecessors ( node ) : if isinstance ( self . _multi_graph . get_edge_data ( predecessor , node , key = 0 ) [ 'wire' ] [ 0 ] , QuantumRegister ) : predecessors . append ( predecessor ) return predecessors", "nl": "Returns list of the predecessors of a node that are connected by a quantum edge as DAGNodes ."}}
{"translation": {"code": "def add_physical_qubit ( self , physical_qubit ) : if not isinstance ( physical_qubit , int ) : raise CouplingError ( \"Physical qubits should be integers.\" ) if physical_qubit in self . physical_qubits : raise CouplingError ( \"The physical qubit %s is already in the coupling graph\" % physical_qubit ) self . graph . add_node ( physical_qubit ) self . _dist_matrix = None # invalidate self . _qubit_list = None", "nl": "Add a physical qubit to the coupling graph as a node ."}}
{"translation": {"code": "def add_edge ( self , src , dst ) : if src not in self . physical_qubits : self . add_physical_qubit ( src ) if dst not in self . physical_qubits : self . add_physical_qubit ( dst ) self . graph . add_edge ( src , dst ) self . _dist_matrix = None", "nl": "Add directed edge to coupling graph ."}}
{"translation": {"code": "def combine_into_edge_map ( self , another_layout ) : edge_map = dict ( ) for virtual , physical in self . get_virtual_bits ( ) . items ( ) : if physical not in another_layout . _p2v : raise LayoutError ( 'The wire_map_from_layouts() method does not support when the' ' other layout (another_layout) is smaller.' ) edge_map [ virtual ] = another_layout [ physical ] return edge_map", "nl": "Combines self and another_layout into an edge map ."}}
{"translation": {"code": "def is_virtual ( value ) : return value is None or isinstance ( value , tuple ) and len ( value ) == 2 and isinstance ( value [ 0 ] , Register ) and isinstance ( value [ 1 ] , int )", "nl": "Checks if value has the format of a virtual qubit"}}