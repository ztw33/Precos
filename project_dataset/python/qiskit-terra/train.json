{"translation": {"code": "def _check_edgemap_registers ( self , edge_map , keyregs , valregs , valreg = True ) : # FIXME: some mixing of objects and strings here are awkward (due to # self.qregs/self.cregs still keying on string. add_regs = set ( ) reg_frag_chk = { } for v in keyregs . values ( ) : reg_frag_chk [ v ] = { j : False for j in range ( len ( v ) ) } for k in edge_map . keys ( ) : if k [ 0 ] . name in keyregs : reg_frag_chk [ k [ 0 ] ] [ k [ 1 ] ] = True for k , v in reg_frag_chk . items ( ) : s = set ( v . values ( ) ) if len ( s ) == 2 : raise DAGCircuitError ( \"edge_map fragments reg %s\" % k ) elif s == set ( [ False ] ) : if k in self . qregs . values ( ) or k in self . cregs . values ( ) : raise DAGCircuitError ( \"unmapped duplicate reg %s\" % k ) else : # Add registers that appear only in keyregs add_regs . add ( k ) else : if valreg : # If mapping to a register not in valregs, add it. # (k,0) exists in edge_map because edge_map doesn't # fragment k if not edge_map [ ( k , 0 ) ] [ 0 ] . name in valregs : size = max ( map ( lambda x : x [ 1 ] , filter ( lambda x : x [ 0 ] == edge_map [ ( k , 0 ) ] [ 0 ] , edge_map . values ( ) ) ) ) qreg = QuantumRegister ( size + 1 , edge_map [ ( k , 0 ) ] [ 0 ] . name ) add_regs . add ( qreg ) return add_regs", "nl": "Check that wiremap neither fragments nor leaves duplicate registers ."}}
{"translation": {"code": "def layers ( self ) : graph_layers = self . multigraph_layers ( ) try : next ( graph_layers ) # Remove input nodes except StopIteration : return def add_nodes_from ( layer , nodes ) : \"\"\" Convert DAGNodes into a format that can be added to a\n             multigraph and then add to graph\"\"\" layer . _multi_graph . add_nodes_from ( nodes ) for graph_layer in graph_layers : # Get the op nodes from the layer, removing any input and output nodes. op_nodes = [ node for node in graph_layer if node . type == \"op\" ] # Stop yielding once there are no more op_nodes in a layer. if not op_nodes : return # Construct a shallow copy of self new_layer = DAGCircuit ( ) new_layer . name = self . name for creg in self . cregs . values ( ) : new_layer . add_creg ( creg ) for qreg in self . qregs . values ( ) : new_layer . add_qreg ( qreg ) add_nodes_from ( new_layer , self . input_map . values ( ) ) add_nodes_from ( new_layer , self . output_map . values ( ) ) add_nodes_from ( new_layer , op_nodes ) # The quantum registers that have an operation in this layer. support_list = [ op_node . qargs for op_node in op_nodes if op_node . name not in { \"barrier\" , \"snapshot\" , \"save\" , \"load\" , \"noise\" } ] # Now add the edges to the multi_graph # By default we just wire inputs to the outputs. wires = { self . input_map [ wire ] : self . output_map [ wire ] for wire in self . wires } # Wire inputs to op nodes, and op nodes to outputs. for op_node in op_nodes : args = self . _bits_in_condition ( op_node . condition ) + op_node . cargs + op_node . qargs arg_ids = ( self . input_map [ ( arg [ 0 ] , arg [ 1 ] ) ] for arg in args ) for arg_id in arg_ids : wires [ arg_id ] , wires [ op_node ] = op_node , wires [ arg_id ] # Add wiring to/from the operations and between unused inputs & outputs. new_layer . _multi_graph . add_edges_from ( wires . items ( ) ) yield { \"graph\" : new_layer , \"partition\" : support_list }", "nl": "Yield a shallow view on a layer of this DAGCircuit for all d layers of this circuit ."}}
{"translation": {"code": "def _bits_in_condition ( self , cond ) : all_bits = [ ] if cond is not None : all_bits . extend ( [ ( cond [ 0 ] , j ) for j in range ( self . cregs [ cond [ 0 ] . name ] . size ) ] ) return all_bits", "nl": "Return a list of bits in the given condition ."}}
{"translation": {"code": "def remove_descendants_of ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove_descendants_of() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] desc = nx . descendants ( self . _multi_graph , node ) for desc_node in desc : if desc_node . type == \"op\" : self . remove_op_node ( desc_node )", "nl": "Remove all of the descendant operation nodes of node ."}}
{"translation": {"code": "def remove_ancestors_of ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove_ancestors_of() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] anc = nx . ancestors ( self . _multi_graph , node ) # TODO: probably better to do all at once using # multi_graph.remove_nodes_from; same for related functions ... for anc_node in anc : if anc_node . type == \"op\" : self . remove_op_node ( anc_node )", "nl": "Remove all of the ancestor operation nodes of node ."}}
{"translation": {"code": "def remove_op_node ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove_op_node() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] if node . type != 'op' : raise DAGCircuitError ( 'The method remove_op_node only works on op node types. An \"%s\" ' 'node type was wrongly provided.' % node . type ) pred_map , succ_map = self . _make_pred_succ_maps ( node ) # remove from graph and map self . _multi_graph . remove_node ( node ) for w in pred_map . keys ( ) : self . _multi_graph . add_edge ( pred_map [ w ] , succ_map [ w ] , name = \"%s[%s]\" % ( w [ 0 ] . name , w [ 1 ] ) , wire = w )", "nl": "Remove an operation node n ."}}
{"translation": {"code": "def _add_op_node ( self , op , qargs , cargs , condition = None ) : node_properties = { \"type\" : \"op\" , \"op\" : op , \"name\" : op . name , \"qargs\" : qargs , \"cargs\" : cargs , \"condition\" : condition } # Add a new operation node to the graph self . _max_node_id += 1 new_node = DAGNode ( data_dict = node_properties , nid = self . _max_node_id ) self . _multi_graph . add_node ( new_node ) self . _id_to_node [ self . _max_node_id ] = new_node", "nl": "Add a new operation node to the graph and assign properties ."}}
{"translation": {"code": "def _full_pred_succ_maps ( self , pred_map , succ_map , input_circuit , wire_map ) : full_pred_map = { } full_succ_map = { } for w in input_circuit . input_map : # If w is wire mapped, find the corresponding predecessor # of the node if w in wire_map : full_pred_map [ wire_map [ w ] ] = pred_map [ wire_map [ w ] ] full_succ_map [ wire_map [ w ] ] = succ_map [ wire_map [ w ] ] else : # Otherwise, use the corresponding output nodes of self # and compute the predecessor. full_succ_map [ w ] = self . output_map [ w ] full_pred_map [ w ] = self . _multi_graph . predecessors ( self . output_map [ w ] ) [ 0 ] if len ( list ( self . _multi_graph . predecessors ( self . output_map [ w ] ) ) ) != 1 : raise DAGCircuitError ( \"too many predecessors for %s[%d] \" \"output node\" % ( w [ 0 ] , w [ 1 ] ) ) return full_pred_map , full_succ_map", "nl": "Map all wires of the input circuit ."}}
{"translation": {"code": "def _check_condition ( self , name , condition ) : # Verify creg exists if condition is not None and condition [ 0 ] . name not in self . cregs : raise DAGCircuitError ( \"invalid creg in condition for %s\" % name )", "nl": "Verify that the condition is valid ."}}
{"translation": {"code": "def _add_wire ( self , wire ) : if wire not in self . wires : self . wires . append ( wire ) self . _max_node_id += 1 input_map_wire = self . input_map [ wire ] = self . _max_node_id self . _max_node_id += 1 output_map_wire = self . _max_node_id wire_name = \"%s[%s]\" % ( wire [ 0 ] . name , wire [ 1 ] ) inp_node = DAGNode ( data_dict = { 'type' : 'in' , 'name' : wire_name , 'wire' : wire } , nid = input_map_wire ) outp_node = DAGNode ( data_dict = { 'type' : 'out' , 'name' : wire_name , 'wire' : wire } , nid = output_map_wire ) self . _id_to_node [ input_map_wire ] = inp_node self . _id_to_node [ output_map_wire ] = outp_node self . input_map [ wire ] = inp_node self . output_map [ wire ] = outp_node self . _multi_graph . add_node ( inp_node ) self . _multi_graph . add_node ( outp_node ) self . _multi_graph . add_edge ( inp_node , outp_node ) self . _multi_graph . adj [ inp_node ] [ outp_node ] [ 0 ] [ \"name\" ] = \"%s[%s]\" % ( wire [ 0 ] . name , wire [ 1 ] ) self . _multi_graph . adj [ inp_node ] [ outp_node ] [ 0 ] [ \"wire\" ] = wire else : raise DAGCircuitError ( \"duplicate wire %s\" % ( wire , ) )", "nl": "Add a qubit or bit to the circuit ."}}
{"translation": {"code": "def remove_nondescendants_of ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove_nondescendants_of() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] dec = nx . descendants ( self . _multi_graph , node ) comp = list ( set ( self . _multi_graph . nodes ( ) ) - set ( dec ) ) for n in comp : if n . type == \"op\" : self . remove_op_node ( n )", "nl": "Remove all of the non - descendants operation nodes of node ."}}
{"translation": {"code": "def _check_wires_list ( self , wires , node ) : if len ( set ( wires ) ) != len ( wires ) : raise DAGCircuitError ( \"duplicate wires\" ) wire_tot = len ( node . qargs ) + len ( node . cargs ) if node . condition is not None : wire_tot += node . condition [ 0 ] . size if len ( wires ) != wire_tot : raise DAGCircuitError ( \"expected %d wires, got %d\" % ( wire_tot , len ( wires ) ) )", "nl": "Check that a list of wires is compatible with a node to be replaced ."}}
{"translation": {"code": "def compose_back ( self , input_circuit , edge_map = None ) : edge_map = edge_map or { } # Check the wire map for duplicate values if len ( set ( edge_map . values ( ) ) ) != len ( edge_map ) : raise DAGCircuitError ( \"duplicates in wire_map\" ) add_qregs = self . _check_edgemap_registers ( edge_map , input_circuit . qregs , self . qregs ) for qreg in add_qregs : self . add_qreg ( qreg ) add_cregs = self . _check_edgemap_registers ( edge_map , input_circuit . cregs , self . cregs ) for creg in add_cregs : self . add_creg ( creg ) self . _check_wiremap_validity ( edge_map , input_circuit . input_map , self . output_map ) # Compose for nd in input_circuit . topological_nodes ( ) : if nd . type == \"in\" : # if in wire_map, get new name, else use existing name m_wire = edge_map . get ( nd . wire , nd . wire ) # the mapped wire should already exist if m_wire not in self . output_map : raise DAGCircuitError ( \"wire %s[%d] not in self\" % ( m_wire [ 0 ] . name , m_wire [ 1 ] ) ) if nd . wire not in input_circuit . wires : raise DAGCircuitError ( \"inconsistent wire type for %s[%d] in input_circuit\" % ( nd . wire [ 0 ] . name , nd . wire [ 1 ] ) ) elif nd . type == \"out\" : # ignore output nodes pass elif nd . type == \"op\" : condition = self . _map_condition ( edge_map , nd . condition ) self . _check_condition ( nd . name , condition ) m_qargs = list ( map ( lambda x : edge_map . get ( x , x ) , nd . qargs ) ) m_cargs = list ( map ( lambda x : edge_map . get ( x , x ) , nd . cargs ) ) self . apply_operation_back ( nd . op , m_qargs , m_cargs , condition ) else : raise DAGCircuitError ( \"bad node type %s\" % nd . type )", "nl": "Apply the input circuit to the output of this circuit ."}}
{"translation": {"code": "def _map_condition ( self , wire_map , condition ) : if condition is None : new_condition = None else : # Map the register name, using fact that registers must not be # fragmented by the wire_map (this must have been checked # elsewhere) bit0 = ( condition [ 0 ] , 0 ) new_condition = ( wire_map . get ( bit0 , bit0 ) [ 0 ] , condition [ 1 ] ) return new_condition", "nl": "Use the wire_map dict to change the condition tuple s creg name ."}}
{"translation": {"code": "def remove_all_ops_named ( self , opname ) : for n in self . named_nodes ( opname ) : self . remove_op_node ( n )", "nl": "Remove all operation nodes with the given name ."}}
{"translation": {"code": "def _make_pred_succ_maps ( self , node ) : pred_map = { e [ 2 ] [ 'wire' ] : e [ 0 ] for e in self . _multi_graph . in_edges ( nbunch = node , data = True ) } succ_map = { e [ 2 ] [ 'wire' ] : e [ 1 ] for e in self . _multi_graph . out_edges ( nbunch = node , data = True ) } return pred_map , succ_map", "nl": "Return predecessor and successor dictionaries ."}}
{"translation": {"code": "def remove_nonancestors_of ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling remove_nonancestors_of() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] anc = nx . ancestors ( self . _multi_graph , node ) comp = list ( set ( self . _multi_graph . nodes ( ) ) - set ( anc ) ) for n in comp : if n . type == \"op\" : self . remove_op_node ( n )", "nl": "Remove all of the non - ancestors operation nodes of node ."}}
{"translation": {"code": "def _check_wiremap_validity ( self , wire_map , keymap , valmap ) : for k , v in wire_map . items ( ) : kname = \"%s[%d]\" % ( k [ 0 ] . name , k [ 1 ] ) vname = \"%s[%d]\" % ( v [ 0 ] . name , v [ 1 ] ) if k not in keymap : raise DAGCircuitError ( \"invalid wire mapping key %s\" % kname ) if v not in valmap : raise DAGCircuitError ( \"invalid wire mapping value %s\" % vname ) if type ( k ) is not type ( v ) : raise DAGCircuitError ( \"inconsistent wire_map at (%s,%s)\" % ( kname , vname ) )", "nl": "Check that the wiremap is consistent ."}}
{"translation": {"code": "def apply_operation_back ( self , op , qargs = None , cargs = None , condition = None ) : qargs = qargs or [ ] cargs = cargs or [ ] all_cbits = self . _bits_in_condition ( condition ) all_cbits . extend ( cargs ) self . _check_condition ( op . name , condition ) self . _check_bits ( qargs , self . output_map ) self . _check_bits ( all_cbits , self . output_map ) self . _add_op_node ( op , qargs , cargs , condition ) # Add new in-edges from predecessors of the output nodes to the # operation node while deleting the old in-edges of the output nodes # and adding new edges from the operation node to each output node al = [ qargs , all_cbits ] for q in itertools . chain ( * al ) : ie = list ( self . _multi_graph . predecessors ( self . output_map [ q ] ) ) if len ( ie ) != 1 : raise DAGCircuitError ( \"output node has multiple in-edges\" ) self . _multi_graph . add_edge ( ie [ 0 ] , self . _id_to_node [ self . _max_node_id ] , name = \"%s[%s]\" % ( q [ 0 ] . name , q [ 1 ] ) , wire = q ) self . _multi_graph . remove_edge ( ie [ 0 ] , self . output_map [ q ] ) self . _multi_graph . add_edge ( self . _id_to_node [ self . _max_node_id ] , self . output_map [ q ] , name = \"%s[%s]\" % ( q [ 0 ] . name , q [ 1 ] ) , wire = q ) return self . _id_to_node [ self . _max_node_id ]", "nl": "Apply an operation to the output of the circuit ."}}
{"translation": {"code": "def rename_register ( self , regname , newname ) : if regname == newname : return if newname in self . qregs or newname in self . cregs : raise DAGCircuitError ( \"duplicate register name %s\" % newname ) if regname not in self . qregs and regname not in self . cregs : raise DAGCircuitError ( \"no register named %s\" % regname ) if regname in self . qregs : reg = self . qregs [ regname ] reg . name = newname self . qregs [ newname ] = reg self . qregs . pop ( regname , None ) if regname in self . cregs : reg = self . cregs [ regname ] reg . name = newname self . qregs [ newname ] = reg self . qregs . pop ( regname , None ) for node in self . _multi_graph . nodes ( ) : if node . type == \"in\" or node . type == \"out\" : if node . name and regname in node . name : node . name = newname elif node . type == \"op\" : qa = [ ] for a in node . qargs : if a [ 0 ] == regname : a = ( newname , a [ 1 ] ) qa . append ( a ) node . qargs = qa ca = [ ] for a in node . cargs : if a [ 0 ] == regname : a = ( newname , a [ 1 ] ) ca . append ( a ) node . cargs = ca if node . condition is not None : if node . condition [ 0 ] == regname : node . condition = ( newname , node . condition [ 1 ] ) # eX = edge, d= data for _ , _ , edge_data in self . _multi_graph . edges ( data = True ) : if regname in edge_data [ 'name' ] : edge_data [ 'name' ] = re . sub ( regname , newname , edge_data [ 'name' ] )", "nl": "Rename a classical or quantum register throughout the circuit ."}}
{"translation": {"code": "def parse ( self ) : if self . _filename : with open ( self . _filename ) as ifile : self . _data = ifile . read ( ) with QasmParser ( self . _filename ) as qasm_p : qasm_p . parse_debug ( False ) return qasm_p . parse ( self . _data )", "nl": "Parse the data ."}}
{"translation": {"code": "def pauli_group ( number_of_qubits , case = 'weight' ) : if number_of_qubits < 5 : temp_set = [ ] if case == 'weight' : tmp = pauli_group ( number_of_qubits , case = 'tensor' ) # sort on the weight of the Pauli operator return sorted ( tmp , key = lambda x : - np . count_nonzero ( np . array ( x . to_label ( ) , 'c' ) == b'I' ) ) elif case == 'tensor' : # the Pauli set is in tensor order II IX IY IZ XI ... for k in range ( 4 ** number_of_qubits ) : z = np . zeros ( number_of_qubits , dtype = np . bool ) x = np . zeros ( number_of_qubits , dtype = np . bool ) # looping over all the qubits for j in range ( number_of_qubits ) : # making the Pauli for each j fill it in from the # end first element = ( k // ( 4 ** j ) ) % 4 if element == 1 : x [ j ] = True elif element == 2 : z [ j ] = True x [ j ] = True elif element == 3 : z [ j ] = True temp_set . append ( Pauli ( z , x ) ) return temp_set else : raise QiskitError ( \"Only support 'weight' or 'tensor' cases \" \"but you have {}.\" . format ( case ) ) raise QiskitError ( \"Only support number of qubits is less than 5\" )", "nl": "Return the Pauli group with 4^n elements ."}}
{"translation": {"code": "def update_z ( self , z , indices = None ) : z = _make_np_bool ( z ) if indices is None : if len ( self . _z ) != len ( z ) : raise QiskitError ( \"During updating whole z, you can not \" \"change the number of qubits.\" ) self . _z = z else : if not isinstance ( indices , list ) and not isinstance ( indices , np . ndarray ) : indices = [ indices ] for p , idx in enumerate ( indices ) : self . _z [ idx ] = z [ p ] return self", "nl": "Update partial or entire z ."}}
{"translation": {"code": "def serial_layers ( self ) : for next_node in self . topological_op_nodes ( ) : new_layer = DAGCircuit ( ) for qreg in self . qregs . values ( ) : new_layer . add_qreg ( qreg ) for creg in self . cregs . values ( ) : new_layer . add_creg ( creg ) # Save the support of the operation we add to the layer support_list = [ ] # Operation data op = copy . copy ( next_node . op ) qa = copy . copy ( next_node . qargs ) ca = copy . copy ( next_node . cargs ) co = copy . copy ( next_node . condition ) _ = self . _bits_in_condition ( co ) # Add node to new_layer new_layer . apply_operation_back ( op , qa , ca , co ) # Add operation to partition if next_node . name not in [ \"barrier\" , \"snapshot\" , \"save\" , \"load\" , \"noise\" ] : support_list . append ( list ( qa ) ) l_dict = { \"graph\" : new_layer , \"partition\" : support_list } yield l_dict", "nl": "Yield a layer for all gates of this circuit ."}}
{"translation": {"code": "def collect_runs ( self , namelist ) : group_list = [ ] # Iterate through the nodes of self in topological order # and form tuples containing sequences of gates # on the same qubit(s). topo_ops = list ( self . topological_op_nodes ( ) ) nodes_seen = dict ( zip ( topo_ops , [ False ] * len ( topo_ops ) ) ) for node in topo_ops : if node . name in namelist and node . condition is None and not nodes_seen [ node ] : group = [ node ] nodes_seen [ node ] = True s = list ( self . _multi_graph . successors ( node ) ) while len ( s ) == 1 and s [ 0 ] . type == \"op\" and s [ 0 ] . name in namelist : group . append ( s [ 0 ] ) nodes_seen [ s [ 0 ] ] = True s = list ( self . _multi_graph . successors ( s [ 0 ] ) ) if len ( group ) >= 1 : group_list . append ( tuple ( group ) ) return set ( group_list )", "nl": "Return a set of non - conditional runs of op nodes with the given names ."}}
{"translation": {"code": "def unmajority ( p , a , b , c ) : p . ccx ( a , b , c ) p . cx ( c , a ) p . cx ( a , b )", "nl": "Unmajority gate ."}}
{"translation": {"code": "def majority ( p , a , b , c ) : p . cx ( c , b ) p . cx ( c , a ) p . ccx ( a , b , c )", "nl": "Majority gate ."}}
{"translation": {"code": "def count_ops ( self ) : op_dict = { } for node in self . topological_op_nodes ( ) : name = node . name if name not in op_dict : op_dict [ name ] = 1 else : op_dict [ name ] += 1 return op_dict", "nl": "Count the occurrences of operation names ."}}
{"translation": {"code": "def plot_rb_data ( xdata , ydatas , yavg , yerr , fit , survival_prob , ax = None , show_plt = True ) : # pylint: disable=invalid-name if not HAS_MATPLOTLIB : raise ImportError ( 'The function plot_rb_data needs matplotlib. ' 'Run \"pip install matplotlib\" before.' ) if ax is None : plt . figure ( ) ax = plt . gca ( ) # Plot the result for each sequence for ydata in ydatas : ax . plot ( xdata , ydata , color = 'gray' , linestyle = 'none' , marker = 'x' ) # Plot the mean with error bars ax . errorbar ( xdata , yavg , yerr = yerr , color = 'r' , linestyle = '--' , linewidth = 3 ) # Plot the fit ax . plot ( xdata , survival_prob ( xdata , * fit ) , color = 'blue' , linestyle = '-' , linewidth = 2 ) ax . tick_params ( labelsize = 14 ) # ax.tick_params(axis='x',labelrotation=70) ax . set_xlabel ( 'Clifford Length' , fontsize = 16 ) ax . set_ylabel ( 'Z' , fontsize = 16 ) ax . grid ( True ) if show_plt : plt . show ( )", "nl": "Plot randomized benchmarking data ."}}
{"translation": {"code": "def delete_qubits ( self , indices ) : if not isinstance ( indices , list ) : indices = [ indices ] self . _z = np . delete ( self . _z , indices ) self . _x = np . delete ( self . _x , indices ) return self", "nl": "Delete pauli at the indices ."}}
{"translation": {"code": "def update_x ( self , x , indices = None ) : x = _make_np_bool ( x ) if indices is None : if len ( self . _x ) != len ( x ) : raise QiskitError ( \"During updating whole x, you can not change \" \"the number of qubits.\" ) self . _x = x else : if not isinstance ( indices , list ) and not isinstance ( indices , np . ndarray ) : indices = [ indices ] for p , idx in enumerate ( indices ) : self . _x [ idx ] = x [ p ] return self", "nl": "Update partial or entire x ."}}
{"translation": {"code": "def properties ( self ) : summary = { \"size\" : self . size ( ) , \"depth\" : self . depth ( ) , \"width\" : self . width ( ) , \"bits\" : self . num_cbits ( ) , \"factors\" : self . num_tensor_factors ( ) , \"operations\" : self . count_ops ( ) } return summary", "nl": "Return a dictionary of circuit properties ."}}
{"translation": {"code": "def _add_qasm_reset ( self , qubit ) : # get measure outcome outcome , probability = self . _get_measure_outcome ( qubit ) # update quantum state if outcome == '0' : update = [ [ 1 / np . sqrt ( probability ) , 0 ] , [ 0 , 0 ] ] self . _add_unitary_single ( update , qubit ) else : update = [ [ 0 , 1 / np . sqrt ( probability ) ] , [ 0 , 0 ] ] self . _add_unitary_single ( update , qubit )", "nl": "Apply a reset instruction to a qubit ."}}
{"translation": {"code": "def _add_qasm_measure ( self , qubit , cmembit , cregbit = None ) : # get measure outcome outcome , probability = self . _get_measure_outcome ( qubit ) # update classical state membit = 1 << cmembit self . _classical_memory = ( self . _classical_memory & ( ~ membit ) ) | ( int ( outcome ) << cmembit ) if cregbit is not None : regbit = 1 << cregbit self . _classical_register = ( self . _classical_register & ( ~ regbit ) ) | ( int ( outcome ) << cregbit ) # update quantum state if outcome == '0' : update_diag = [ [ 1 / np . sqrt ( probability ) , 0 ] , [ 0 , 0 ] ] else : update_diag = [ [ 0 , 0 ] , [ 0 , 1 / np . sqrt ( probability ) ] ] # update classical state self . _add_unitary_single ( update_diag , qubit )", "nl": "Apply a measure instruction to a qubit ."}}
{"translation": {"code": "def _get_measure_outcome ( self , qubit ) : # Axis for numpy.sum to compute probabilities axis = list ( range ( self . _number_of_qubits ) ) axis . remove ( self . _number_of_qubits - 1 - qubit ) probabilities = np . sum ( np . abs ( self . _statevector ) ** 2 , axis = tuple ( axis ) ) # Compute einsum index string for 1-qubit matrix multiplication random_number = self . _local_random . rand ( ) if random_number < probabilities [ 0 ] : return '0' , probabilities [ 0 ] # Else outcome was '1' return '1' , probabilities [ 1 ]", "nl": "Simulate the outcome of measurement of a qubit ."}}
{"translation": {"code": "def _validate_measure_sampling ( self , experiment ) : # If shots=1 we should disable measure sampling. # This is also required for statevector simulator to return the # correct final statevector without silently dropping final measurements. if self . _shots <= 1 : self . _sample_measure = False return # Check for config flag if hasattr ( experiment . config , 'allows_measure_sampling' ) : self . _sample_measure = experiment . config . allows_measure_sampling # If flag isn't found do a simple test to see if a circuit contains # no reset instructions, and no gates instructions after # the first measure. else : measure_flag = False for instruction in experiment . instructions : # If circuit contains reset operations we cannot sample if instruction . name == \"reset\" : self . _sample_measure = False return # If circuit contains a measure option then we can # sample only if all following operations are measures if measure_flag : # If we find a non-measure instruction # we cannot do measure sampling if instruction . name not in [ \"measure\" , \"barrier\" , \"id\" , \"u0\" ] : self . _sample_measure = False return elif instruction . name == \"measure\" : measure_flag = True # If we made it to the end of the circuit without returning # measure sampling is allowed self . _sample_measure = True", "nl": "Determine if measure sampling is allowed for an experiment"}}
{"translation": {"code": "def tomography_basis ( basis , prep_fun = None , meas_fun = None ) : ret = TomographyBasis ( basis ) ret . prep_fun = prep_fun ret . meas_fun = meas_fun return ret", "nl": "Generate a TomographyBasis object ."}}
{"translation": {"code": "def input_state ( circ , q , n ) : for j in range ( n ) : circ . h ( q [ j ] ) circ . u1 ( math . pi / float ( 2 ** ( j ) ) , q [ j ] ) . inverse ( )", "nl": "n - qubit input state for QFT that produces output 1 ."}}
{"translation": {"code": "def insert_paulis ( self , indices = None , paulis = None , pauli_labels = None ) : if pauli_labels is not None : if paulis is not None : raise QiskitError ( \"Please only provide either `paulis` or `pauli_labels`\" ) if isinstance ( pauli_labels , str ) : pauli_labels = list ( pauli_labels ) # since pauli label is in reversed order. paulis = Pauli . from_label ( pauli_labels [ : : - 1 ] ) if indices is None : # append self . _z = np . concatenate ( ( self . _z , paulis . z ) ) self . _x = np . concatenate ( ( self . _x , paulis . x ) ) else : if not isinstance ( indices , list ) : indices = [ indices ] self . _z = np . insert ( self . _z , indices , paulis . z ) self . _x = np . insert ( self . _x , indices , paulis . x ) return self", "nl": "Insert or append pauli to the targeted indices ."}}
{"translation": {"code": "def fit_tomography_data ( tomo_data , method = 'wizard' , options = None ) : if isinstance ( method , str ) and method . lower ( ) in [ 'wizard' , 'leastsq' ] : # get options trace = __get_option ( 'trace' , options ) beta = __get_option ( 'beta' , options ) # fit state rho = __leastsq_fit ( tomo_data , trace = trace , beta = beta ) if method == 'wizard' : # Use wizard method to constrain positivity epsilon = __get_option ( 'epsilon' , options ) rho = __wizard ( rho , epsilon = epsilon ) return rho else : raise Exception ( 'Invalid reconstruction method \"%s\"' % method )", "nl": "Reconstruct a density matrix or process - matrix from tomography data ."}}
{"translation": {"code": "def __tomo_linear_inv ( freqs , ops , weights = None , trace = None ) : # get weights matrix if weights is not None : W = np . array ( weights ) if W . ndim == 1 : W = np . diag ( W ) # Get basis S matrix S = np . array ( [ vectorize ( m ) . conj ( ) for m in ops ] ) . reshape ( len ( ops ) , ops [ 0 ] . size ) if weights is not None : S = np . dot ( W , S ) # W.S # get frequencies vec v = np . array ( freqs ) # |f> if weights is not None : v = np . dot ( W , freqs ) # W.|f> Sdg = S . T . conj ( ) # S^*.W^* inv = np . linalg . pinv ( np . dot ( Sdg , S ) ) # (S^*.W^*.W.S)^-1 # linear inversion of freqs ret = devectorize ( np . dot ( inv , np . dot ( Sdg , v ) ) ) # renormalize to input trace value if trace is not None : ret = trace * ret / np . trace ( ret ) return ret", "nl": "Reconstruct a matrix through linear inversion ."}}
{"translation": {"code": "def __wizard ( rho , epsilon = None ) : if epsilon is None : epsilon = 0. # default value dim = len ( rho ) rho_wizard = np . zeros ( [ dim , dim ] ) v , w = np . linalg . eigh ( rho ) # v eigenvecrors v[0] < v[1] <... for j in range ( dim ) : if v [ j ] < epsilon : tmp = v [ j ] v [ j ] = 0. # redistribute loop x = 0. for k in range ( j + 1 , dim ) : x += tmp / ( dim - ( j + 1 ) ) v [ k ] = v [ k ] + tmp / ( dim - ( j + 1 ) ) for j in range ( dim ) : rho_wizard = rho_wizard + v [ j ] * outer ( w [ : , j ] ) return rho_wizard", "nl": "Returns the nearest positive semidefinite operator to an operator ."}}
{"translation": {"code": "def __projector ( op_list , basis ) : ret = 1 # list is from qubit 0 to 1 for op in op_list : label , eigenstate = op ret = np . kron ( basis [ label ] [ eigenstate ] , ret ) return ret", "nl": "Returns a projectors ."}}
{"translation": {"code": "def create_tomography_circuits ( circuit , qreg , creg , tomoset ) : if not isinstance ( circuit , QuantumCircuit ) : raise QiskitError ( 'Input circuit must be a QuantumCircuit object' ) dics = tomoset [ 'circuits' ] labels = tomography_circuit_names ( tomoset , circuit . name ) tomography_circuits = [ ] for label , conf in zip ( labels , dics ) : tmp = circuit # Add prep circuits if 'prep' in conf : prep = QuantumCircuit ( qreg , creg , name = 'tmp_prep' ) for qubit , op in conf [ 'prep' ] . items ( ) : tomoset [ 'prep_basis' ] . prep_gate ( prep , qreg [ qubit ] , op ) prep . barrier ( qreg [ qubit ] ) tmp = prep + tmp # Add measurement circuits meas = QuantumCircuit ( qreg , creg , name = 'tmp_meas' ) for qubit , op in conf [ 'meas' ] . items ( ) : meas . barrier ( qreg [ qubit ] ) tomoset [ 'meas_basis' ] . meas_gate ( meas , qreg [ qubit ] , op ) meas . measure ( qreg [ qubit ] , creg [ qubit ] ) tmp = tmp + meas # Add label to the circuit tmp . name = label tomography_circuits . append ( tmp ) logger . info ( '>> created tomography circuits for \"%s\"' , circuit . name ) return tomography_circuits", "nl": "Add tomography measurement circuits to a QuantumProgram ."}}
{"translation": {"code": "def two_qubit_kak ( unitary_matrix , verify_gate_sequence = False ) : warnings . warn ( \"two_qubit_kak function is now accessible under \" \"qiskit.quantum_info.synthesis\" , DeprecationWarning ) return synthesis . two_qubit_kak ( unitary_matrix )", "nl": "Deprecated after 0 . 8"}}
{"translation": {"code": "def single_gate_matrix ( gate , params = None ) : # Converting sym to floats improves the performance of the simulator 10x. # This a is a probable a FIXME since it might show bugs in the simulator. ( theta , phi , lam ) = map ( float , single_gate_params ( gate , params ) ) return np . array ( [ [ np . cos ( theta / 2 ) , - np . exp ( 1j * lam ) * np . sin ( theta / 2 ) ] , [ np . exp ( 1j * phi ) * np . sin ( theta / 2 ) , np . exp ( 1j * phi + 1j * lam ) * np . cos ( theta / 2 ) ] ] )", "nl": "Get the matrix for a single qubit ."}}
{"translation": {"code": "def single_gate_params ( gate , params = None ) : if gate in ( 'U' , 'u3' ) : return params [ 0 ] , params [ 1 ] , params [ 2 ] elif gate == 'u2' : return np . pi / 2 , params [ 0 ] , params [ 1 ] elif gate == 'u1' : return 0 , 0 , params [ 0 ] elif gate == 'id' : return 0 , 0 , 0 raise QiskitError ( 'Gate is not among the valid types: %s' % gate )", "nl": "Apply a single qubit gate to the qubit ."}}
{"translation": {"code": "def outer ( vector1 , vector2 = None ) : if vector2 is None : vector2 = np . array ( vector1 ) . conj ( ) else : vector2 = np . array ( vector2 ) . conj ( ) return np . outer ( vector1 , vector2 )", "nl": "Construct the outer product of two vectors ."}}
{"translation": {"code": "def chop ( array , epsilon = 1e-10 ) : ret = np . array ( array ) if np . isrealobj ( ret ) : ret [ abs ( ret ) < epsilon ] = 0.0 else : ret . real [ abs ( ret . real ) < epsilon ] = 0.0 ret . imag [ abs ( ret . imag ) < epsilon ] = 0.0 return ret", "nl": "Truncate small values of a complex array ."}}
{"translation": {"code": "def devectorize ( vectorized_mat , method = 'col' ) : vectorized_mat = np . array ( vectorized_mat ) dimension = int ( np . sqrt ( vectorized_mat . size ) ) if len ( vectorized_mat ) != dimension * dimension : raise Exception ( 'Input is not a vectorized square matrix' ) if method == 'col' : return vectorized_mat . reshape ( dimension , dimension , order = 'F' ) elif method == 'row' : return vectorized_mat . reshape ( dimension , dimension , order = 'C' ) elif method in [ 'pauli' , 'pauli_weights' ] : num_qubits = int ( np . log2 ( dimension ) ) # number of qubits if dimension != 2 ** num_qubits : raise Exception ( 'Input state must be n-qubit state' ) if method == 'pauli_weights' : pgroup = pauli_group ( num_qubits , case = 'weight' ) else : pgroup = pauli_group ( num_qubits , case = 'tensor' ) pbasis = np . array ( [ p . to_matrix ( ) for p in pgroup ] ) / 2 ** num_qubits return np . tensordot ( vectorized_mat , pbasis , axes = 1 ) return None", "nl": "Devectorize a vectorized square matrix ."}}
{"translation": {"code": "def vectorize ( density_matrix , method = 'col' ) : density_matrix = np . array ( density_matrix ) if method == 'col' : return density_matrix . flatten ( order = 'F' ) elif method == 'row' : return density_matrix . flatten ( order = 'C' ) elif method in [ 'pauli' , 'pauli_weights' ] : num = int ( np . log2 ( len ( density_matrix ) ) ) # number of qubits if len ( density_matrix ) != 2 ** num : raise Exception ( 'Input state must be n-qubit state' ) if method == 'pauli_weights' : pgroup = pauli_group ( num , case = 'weight' ) else : pgroup = pauli_group ( num , case = 'tensor' ) vals = [ np . trace ( np . dot ( p . to_matrix ( ) , density_matrix ) ) for p in pgroup ] return np . array ( vals ) return None", "nl": "Flatten an operator to a vector in a specified basis ."}}
{"translation": {"code": "def process_tomography_set ( meas_qubits , meas_basis = 'Pauli' , prep_qubits = None , prep_basis = 'SIC' ) : return tomography_set ( meas_qubits , meas_basis = meas_basis , prep_qubits = prep_qubits , prep_basis = prep_basis )", "nl": "Generate a dictionary of process tomography experiment configurations ."}}
{"translation": {"code": "def concurrence ( state ) : rho = np . array ( state ) if rho . ndim == 1 : rho = outer ( state ) if len ( state ) != 4 : raise Exception ( \"Concurrence is only defined for more than two qubits\" ) YY = np . fliplr ( np . diag ( [ - 1 , 1 , 1 , - 1 ] ) ) A = rho . dot ( YY ) . dot ( rho . conj ( ) ) . dot ( YY ) w = la . eigh ( A , eigvals_only = True ) w = np . sqrt ( np . maximum ( w , 0 ) ) return max ( 0.0 , w [ - 1 ] - np . sum ( w [ 0 : - 1 ] ) )", "nl": "Calculate the concurrence ."}}
{"translation": {"code": "def choi_to_rauli ( choi , order = 1 ) : if order == 0 : order = 'weight' elif order == 1 : order = 'tensor' # get number of qubits' num_qubits = int ( np . log2 ( np . sqrt ( len ( choi ) ) ) ) pgp = pauli_group ( num_qubits , case = order ) rauli = [ ] for i in pgp : for j in pgp : pauliop = np . kron ( j . to_matrix ( ) . T , i . to_matrix ( ) ) rauli += [ np . trace ( np . dot ( choi , pauliop ) ) ] return np . array ( rauli ) . reshape ( 4 ** num_qubits , 4 ** num_qubits )", "nl": "Convert a Choi - matrix to a Pauli - basis superoperator ."}}
{"translation": {"code": "def __leastsq_fit ( tomo_data , weights = None , trace = None , beta = None ) : if trace is None : trace = 1. # default to unit trace data = tomo_data [ 'data' ] keys = data [ 0 ] [ 'circuit' ] . keys ( ) # Get counts and shots counts = [ ] shots = [ ] ops = [ ] for dat in data : for key in keys : counts . append ( dat [ 'counts' ] [ key ] ) shots . append ( dat [ 'shots' ] ) projectors = dat [ 'circuit' ] [ key ] op = __projector ( projectors [ 'meas' ] , tomo_data [ 'meas_basis' ] ) if 'prep' in projectors : op_prep = __projector ( projectors [ 'prep' ] , tomo_data [ 'prep_basis' ] ) op = np . kron ( op_prep . conj ( ) , op ) ops . append ( op ) # Convert counts to frequencies counts = np . array ( counts ) shots = np . array ( shots ) freqs = counts / shots # Use hedged frequencies to calculate least squares fitting weights if weights is None : if beta is None : beta = 0.50922 K = len ( keys ) freqs_hedged = ( counts + beta ) / ( shots + K * beta ) weights = np . sqrt ( shots / ( freqs_hedged * ( 1 - freqs_hedged ) ) ) return __tomo_linear_inv ( freqs , ops , weights , trace = trace )", "nl": "Reconstruct a state from unconstrained least - squares fitting ."}}
{"translation": {"code": "def osc_fit_fun ( x , a , tau , f , phi , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) * np . cos ( 2 * np . pi * f * x + phi ) + c", "nl": "Function used to fit the decay cosine ."}}
{"translation": {"code": "def plot_coherence ( xdata , ydata , std_error , fit , fit_function , xunit , exp_str , qubit_label ) : if not HAS_MATPLOTLIB : raise ImportError ( 'The function plot_coherence needs matplotlib. ' 'Run \"pip install matplotlib\" before.' ) plt . errorbar ( xdata , ydata , std_error , marker = '.' , markersize = 9 , c = 'b' , linestyle = '' ) plt . plot ( xdata , fit_function ( xdata , * fit ) , c = 'r' , linestyle = '--' , label = ( exp_str + '= %s %s' % ( str ( round ( fit [ 1 ] ) ) , xunit ) ) ) plt . xticks ( fontsize = 14 , rotation = 70 ) plt . yticks ( fontsize = 14 ) plt . xlabel ( 'time [%s]' % ( xunit ) , fontsize = 16 ) plt . ylabel ( 'P(1)' , fontsize = 16 ) plt . title ( exp_str + ' measurement of Q$_{%s}$' % ( str ( qubit_label ) ) , fontsize = 18 ) plt . legend ( fontsize = 12 ) plt . grid ( True ) plt . show ( )", "nl": "Plot coherence data ."}}
{"translation": {"code": "def exp_fit_fun ( x , a , tau , c ) : # pylint: disable=invalid-name return a * np . exp ( - x / tau ) + c", "nl": "Function used to fit the exponential decay ."}}
{"translation": {"code": "def tomography_set ( meas_qubits , meas_basis = 'Pauli' , prep_qubits = None , prep_basis = None ) : if not isinstance ( meas_qubits , list ) : raise QiskitError ( 'Qubits argument must be a list' ) num_of_qubits = len ( meas_qubits ) if prep_qubits is None : prep_qubits = meas_qubits if not isinstance ( prep_qubits , list ) : raise QiskitError ( 'prep_qubits argument must be a list' ) if len ( prep_qubits ) != len ( meas_qubits ) : raise QiskitError ( 'meas_qubits and prep_qubitsare different length' ) if isinstance ( meas_basis , str ) : if meas_basis . lower ( ) == 'pauli' : meas_basis = PAULI_BASIS if isinstance ( prep_basis , str ) : if prep_basis . lower ( ) == 'pauli' : prep_basis = PAULI_BASIS elif prep_basis . lower ( ) == 'sic' : prep_basis = SIC_BASIS circuits = [ ] circuit_labels = [ ] # add meas basis configs if prep_basis is None : # State Tomography for meas_product in product ( meas_basis . keys ( ) , repeat = num_of_qubits ) : meas = dict ( zip ( meas_qubits , meas_product ) ) circuits . append ( { 'meas' : meas } ) # Make label label = '_meas_' for qubit , op in meas . items ( ) : label += '%s(%d)' % ( op [ 0 ] , qubit ) circuit_labels . append ( label ) return { 'qubits' : meas_qubits , 'circuits' : circuits , 'circuit_labels' : circuit_labels , 'meas_basis' : meas_basis } # Process Tomography num_of_s = len ( list ( prep_basis . values ( ) ) [ 0 ] ) plst_single = [ ( b , s ) for b in prep_basis . keys ( ) for s in range ( num_of_s ) ] for plst_product in product ( plst_single , repeat = num_of_qubits ) : for meas_product in product ( meas_basis . keys ( ) , repeat = num_of_qubits ) : prep = dict ( zip ( prep_qubits , plst_product ) ) meas = dict ( zip ( meas_qubits , meas_product ) ) circuits . append ( { 'prep' : prep , 'meas' : meas } ) # Make label label = '_prep_' for qubit , op in prep . items ( ) : label += '%s%d(%d)' % ( op [ 0 ] , op [ 1 ] , qubit ) label += '_meas_' for qubit , op in meas . items ( ) : label += '%s(%d)' % ( op [ 0 ] , qubit ) circuit_labels . append ( label ) return { 'qubits' : meas_qubits , 'circuits' : circuits , 'circuit_labels' : circuit_labels , 'prep_basis' : prep_basis , 'meas_basis' : meas_basis }", "nl": "Generate a dictionary of tomography experiment configurations ."}}
{"translation": {"code": "def meas_gate ( self , circuit , qreg , op ) : if self . meas_fun is None : pass else : self . meas_fun ( circuit , qreg , op )", "nl": "Add measurement gates to a circuit ."}}
{"translation": {"code": "def marginal_counts ( counts , meas_qubits ) : # pylint: disable=cell-var-from-loop # Extract total number of qubits from count keys num_of_qubits = len ( list ( counts . keys ( ) ) [ 0 ] ) # keys for measured qubits only qs = sorted ( meas_qubits , reverse = True ) meas_keys = count_keys ( len ( qs ) ) # get regex match strings for summing outcomes of other qubits rgx = [ reduce ( lambda x , y : ( key [ qs . index ( y ) ] if y in qs else '\\\\d' ) + x , range ( num_of_qubits ) , '' ) for key in meas_keys ] # build the return list meas_counts = [ ] for m in rgx : c = 0 for key , val in counts . items ( ) : if match ( m , key ) : c += val meas_counts . append ( c ) # return as counts dict on measured qubits only return dict ( zip ( meas_keys , meas_counts ) )", "nl": "Compute the marginal counts for a subset of measured qubits ."}}
{"translation": {"code": "def tomography_data ( results , name , tomoset ) : labels = tomography_circuit_names ( tomoset , name ) circuits = tomoset [ 'circuits' ] data = [ ] prep = None for j , _ in enumerate ( labels ) : counts = marginal_counts ( results . get_counts ( labels [ j ] ) , tomoset [ 'qubits' ] ) shots = sum ( counts . values ( ) ) meas = circuits [ j ] [ 'meas' ] prep = circuits [ j ] . get ( 'prep' , None ) meas_qubits = sorted ( meas . keys ( ) ) if prep : prep_qubits = sorted ( prep . keys ( ) ) circuit = { } for c in counts . keys ( ) : circuit [ c ] = { } circuit [ c ] [ 'meas' ] = [ ( meas [ meas_qubits [ k ] ] , int ( c [ - 1 - k ] ) ) for k in range ( len ( meas_qubits ) ) ] if prep : circuit [ c ] [ 'prep' ] = [ prep [ prep_qubits [ k ] ] for k in range ( len ( prep_qubits ) ) ] data . append ( { 'counts' : counts , 'shots' : shots , 'circuit' : circuit } ) ret = { 'data' : data , 'meas_basis' : tomoset [ 'meas_basis' ] } if prep : ret [ 'prep_basis' ] = tomoset [ 'prep_basis' ] return ret", "nl": "Return a results dict for a state or process tomography experiment ."}}
{"translation": {"code": "def __partial_trace_vec ( vec , trace_systems , dimensions , reverse = True ) : # trace sys positions if reverse : dimensions = dimensions [ : : - 1 ] trace_systems = len ( dimensions ) - 1 - np . array ( trace_systems ) rho = vec . reshape ( dimensions ) rho = np . tensordot ( rho , rho . conj ( ) , axes = ( trace_systems , trace_systems ) ) d = int ( np . sqrt ( np . product ( rho . shape ) ) ) return rho . reshape ( d , d )", "nl": "Partial trace over subsystems of multi - partite vector ."}}
{"translation": {"code": "def qft ( circ , q , n ) : for j in range ( n ) : for k in range ( j ) : circ . cu1 ( math . pi / float ( 2 ** ( j - k ) ) , q [ j ] , q [ k ] ) circ . h ( q [ j ] )", "nl": "n - qubit QFT on q in circ ."}}
{"translation": {"code": "def initialize ( self , params , qubits ) : if isinstance ( qubits , QuantumRegister ) : qubits = qubits [ : ] else : qubits = _convert_to_bits ( [ qubits ] , [ qbit for qreg in self . qregs for qbit in qreg ] ) [ 0 ] return self . append ( Initialize ( params ) , qubits )", "nl": "Apply initialize to circuit ."}}
{"translation": {"code": "def _define ( self ) : # call to generate the circuit that takes the desired vector to zero disentangling_circuit = self . gates_to_uncompute ( ) # invert the circuit to create the desired vector from zero (assuming # the qubits are in the zero state) initialize_instr = disentangling_circuit . to_instruction ( ) . inverse ( ) q = QuantumRegister ( self . num_qubits , 'q' ) initialize_circuit = QuantumCircuit ( q , name = 'init_def' ) for qubit in q : initialize_circuit . append ( Reset ( ) , [ qubit ] ) initialize_circuit . append ( initialize_instr , q [ : ] ) self . definition = initialize_circuit . data", "nl": "Calculate a subcircuit that implements this initialization"}}
{"translation": {"code": "def gates_to_uncompute ( self ) : q = QuantumRegister ( self . num_qubits ) circuit = QuantumCircuit ( q , name = 'disentangler' ) # kick start the peeling loop, and disentangle one-by-one from LSB to MSB remaining_param = self . params for i in range ( self . num_qubits ) : # work out which rotations must be done to disentangle the LSB # qubit (we peel away one qubit at a time) ( remaining_param , thetas , phis ) = Initialize . _rotations_to_disentangle ( remaining_param ) # perform the required rotations to decouple the LSB qubit (so that # it can be \"factored\" out, leaving a shorter amplitude vector to peel away) rz_mult = self . _multiplex ( RZGate , phis ) ry_mult = self . _multiplex ( RYGate , thetas ) circuit . append ( rz_mult . to_instruction ( ) , q [ i : self . num_qubits ] ) circuit . append ( ry_mult . to_instruction ( ) , q [ i : self . num_qubits ] ) return circuit", "nl": "Call to create a circuit with gates that take the desired vector to zero ."}}
{"translation": {"code": "def _bloch_angles ( pair_of_complex ) : [ a_complex , b_complex ] = pair_of_complex # Force a and b to be complex, as otherwise numpy.angle might fail. a_complex = complex ( a_complex ) b_complex = complex ( b_complex ) mag_a = np . absolute ( a_complex ) final_r = float ( np . sqrt ( mag_a ** 2 + np . absolute ( b_complex ) ** 2 ) ) if final_r < _EPS : theta = 0 phi = 0 final_r = 0 final_t = 0 else : theta = float ( 2 * np . arccos ( mag_a / final_r ) ) a_arg = np . angle ( a_complex ) b_arg = np . angle ( b_complex ) final_t = a_arg + b_arg phi = b_arg - a_arg return final_r * np . exp ( 1.J * final_t / 2 ) , theta , phi", "nl": "Static internal method to work out rotation to create the passed in qubit from the zero vector ."}}
{"translation": {"code": "def _multiplex ( self , target_gate , list_of_angles ) : list_len = len ( list_of_angles ) local_num_qubits = int ( math . log2 ( list_len ) ) + 1 q = QuantumRegister ( local_num_qubits ) circuit = QuantumCircuit ( q , name = \"multiplex\" + local_num_qubits . __str__ ( ) ) lsb = q [ 0 ] msb = q [ local_num_qubits - 1 ] # case of no multiplexing: base case for recursion if local_num_qubits == 1 : circuit . append ( target_gate ( list_of_angles [ 0 ] ) , [ q [ 0 ] ] ) return circuit # calc angle weights, assuming recursion (that is the lower-level # requested angles have been correctly implemented by recursion angle_weight = scipy . kron ( [ [ 0.5 , 0.5 ] , [ 0.5 , - 0.5 ] ] , np . identity ( 2 ** ( local_num_qubits - 2 ) ) ) # calc the combo angles list_of_angles = angle_weight . dot ( np . array ( list_of_angles ) ) . tolist ( ) # recursive step on half the angles fulfilling the above assumption multiplex_1 = self . _multiplex ( target_gate , list_of_angles [ 0 : ( list_len // 2 ) ] ) circuit . append ( multiplex_1 . to_instruction ( ) , q [ 0 : - 1 ] ) # attach CNOT as follows, thereby flipping the LSB qubit circuit . append ( CnotGate ( ) , [ msb , lsb ] ) # implement extra efficiency from the paper of cancelling adjacent # CNOTs (by leaving out last CNOT and reversing (NOT inverting) the # second lower-level multiplex) multiplex_2 = self . _multiplex ( target_gate , list_of_angles [ ( list_len // 2 ) : ] ) if list_len > 1 : circuit . append ( multiplex_2 . to_instruction ( ) . mirror ( ) , q [ 0 : - 1 ] ) else : circuit . append ( multiplex_2 . to_instruction ( ) , q [ 0 : - 1 ] ) # attach a final CNOT circuit . append ( CnotGate ( ) , [ msb , lsb ] ) return circuit", "nl": "Return a recursive implementation of a multiplexor circuit where each instruction itself has a decomposition based on smaller multiplexors ."}}
{"translation": {"code": "def _run_job ( self , job_id , qobj ) : self . _validate ( qobj ) result_list = [ ] start = time . time ( ) for experiment in qobj . experiments : result_list . append ( self . run_experiment ( experiment ) ) end = time . time ( ) result = { 'backend_name' : self . name ( ) , 'backend_version' : self . _configuration . backend_version , 'qobj_id' : qobj . qobj_id , 'job_id' : job_id , 'results' : result_list , 'status' : 'COMPLETED' , 'success' : True , 'time_taken' : ( end - start ) , 'header' : qobj . header . as_dict ( ) } return Result . from_dict ( result )", "nl": "Run experiments in qobj ."}}
{"translation": {"code": "def _run_job ( self , job_id , qobj ) : self . _validate ( qobj ) result_list = [ ] self . _shots = qobj . config . shots self . _memory = getattr ( qobj . config , 'memory' , False ) self . _qobj_config = qobj . config start = time . time ( ) for experiment in qobj . experiments : result_list . append ( self . run_experiment ( experiment ) ) end = time . time ( ) result = { 'backend_name' : self . name ( ) , 'backend_version' : self . _configuration . backend_version , 'qobj_id' : qobj . qobj_id , 'job_id' : job_id , 'results' : result_list , 'status' : 'COMPLETED' , 'success' : True , 'time_taken' : ( end - start ) , 'header' : qobj . header . as_dict ( ) } return Result . from_dict ( result )", "nl": "Run experiments in qobj"}}
{"translation": {"code": "def unset_qiskit_logger ( ) : qiskit_logger = logging . getLogger ( 'qiskit' ) for handler in qiskit_logger . handlers : qiskit_logger . removeHandler ( handler )", "nl": "Remove the handlers for the qiskit logger ."}}
{"translation": {"code": "def shape_rb_data ( raw_rb ) : rb_data = [ ] rb_data . append ( np . mean ( raw_rb , 0 ) ) rb_data . append ( np . std ( raw_rb , 0 ) ) return rb_data", "nl": "Take the raw rb data and convert it into averages and std dev"}}
{"translation": {"code": "def wigner_data ( q_result , meas_qubits , labels , shots = None ) : num = len ( meas_qubits ) dim = 2 ** num p = [ 0.5 + 0.5 * np . sqrt ( 3 ) , 0.5 - 0.5 * np . sqrt ( 3 ) ] parity = 1 for i in range ( num ) : parity = np . kron ( parity , p ) w = [ 0 ] * len ( labels ) wpt = 0 counts = [ marginal_counts ( q_result . get_counts ( circ ) , meas_qubits ) for circ in labels ] for entry in counts : x = [ 0 ] * dim for i in range ( dim ) : if bin ( i ) [ 2 : ] . zfill ( num ) in entry : x [ i ] = float ( entry [ bin ( i ) [ 2 : ] . zfill ( num ) ] ) if shots is None : shots = np . sum ( x ) for i in range ( dim ) : w [ wpt ] = w [ wpt ] + ( x [ i ] / shots ) * parity [ i ] wpt += 1 return w", "nl": "Get the value of the Wigner function from measurement results ."}}
{"translation": {"code": "def _generate_latex_source ( circuit , filename = None , scale = 0.7 , style = None , reverse_bits = False , plot_barriers = True , justify = None ) : qregs , cregs , ops = utils . _get_layered_instructions ( circuit , reverse_bits = reverse_bits , justify = justify ) qcimg = _latex . QCircuitImage ( qregs , cregs , ops , scale , style = style , plot_barriers = plot_barriers , reverse_bits = reverse_bits ) latex = qcimg . latex ( ) if filename : with open ( filename , 'w' ) as latex_file : latex_file . write ( latex ) return latex", "nl": "Convert QuantumCircuit to LaTeX string ."}}
{"translation": {"code": "def entropy ( state ) : rho = np . array ( state ) if rho . ndim == 1 : return 0 evals = np . maximum ( np . linalg . eigvalsh ( state ) , 0. ) return shannon_entropy ( evals , base = np . e )", "nl": "Compute the von - Neumann entropy of a quantum state ."}}
{"translation": {"code": "def mutual_information ( state , d0 , d1 = None ) : if d1 is None : d1 = int ( len ( state ) / d0 ) mi = entropy ( partial_trace ( state , [ 0 ] , dimensions = [ d0 , d1 ] ) ) mi += entropy ( partial_trace ( state , [ 1 ] , dimensions = [ d0 , d1 ] ) ) mi -= entropy ( state ) return mi", "nl": "Compute the mutual information of a bipartite state ."}}
{"translation": {"code": "def entanglement_of_formation ( state , d0 , d1 = None ) : state = np . array ( state ) if d1 is None : d1 = int ( len ( state ) / d0 ) if state . ndim == 2 and len ( state ) == 4 and d0 == 2 and d1 == 2 : return __eof_qubit ( state ) elif state . ndim == 1 : # trace out largest dimension if d0 < d1 : tr = [ 1 ] else : tr = [ 0 ] state = partial_trace ( state , tr , dimensions = [ d0 , d1 ] ) return entropy ( state ) else : print ( 'Input must be a state-vector or 2-qubit density matrix.' ) return None", "nl": "Compute the entanglement of formation of quantum state ."}}
{"translation": {"code": "def __eof_qubit ( rho ) : c = concurrence ( rho ) c = 0.5 + 0.5 * np . sqrt ( 1 - c * c ) return shannon_entropy ( [ c , 1 - c ] )", "nl": "Compute the Entanglement of Formation of a 2 - qubit density matrix ."}}
{"translation": {"code": "def shannon_entropy ( pvec , base = 2 ) : # pylint: disable=missing-docstring if base == 2 : def logfn ( x ) : return - x * np . log2 ( x ) elif base == np . e : def logfn ( x ) : return - x * np . log ( x ) else : def logfn ( x ) : return - x * np . log ( x ) / np . log ( base ) h = 0. for x in pvec : if 0 < x < 1 : h += logfn ( x ) return h", "nl": "Compute the Shannon entropy of a probability vector ."}}
{"translation": {"code": "def __pauli_meas_gates ( circuit , qreg , op ) : if op not in [ 'X' , 'Y' , 'Z' ] : raise QiskitError ( \"There's no X, Y or Z basis for this Pauli \" \"measurement\" ) if op == \"X\" : circuit . u2 ( 0. , np . pi , qreg ) # H elif op == \"Y\" : circuit . u2 ( 0. , 0.5 * np . pi , qreg )", "nl": "Add state measurement gates to a circuit ."}}
{"translation": {"code": "def q_if ( self , * qregs ) : self . data = [ gate . q_if ( qregs ) for gate in self . data ] return self", "nl": "Add controls to this gate ."}}
{"translation": {"code": "def has_register ( self , register ) : has_reg = False if ( isinstance ( register , QuantumRegister ) and register in self . qregs ) : has_reg = True elif ( isinstance ( register , ClassicalRegister ) and register in self . cregs ) : has_reg = True return has_reg", "nl": "Test if this circuit has the register r ."}}
{"translation": {"code": "def add_register ( self , * regs ) : if not regs : return if any ( [ isinstance ( reg , int ) for reg in regs ] ) : # QuantumCircuit defined without registers if len ( regs ) == 1 and isinstance ( regs [ 0 ] , int ) : # QuantumCircuit with anonymous quantum wires e.g. QuantumCircuit(2) regs = ( QuantumRegister ( regs [ 0 ] , 'q' ) , ) elif len ( regs ) == 2 and all ( [ isinstance ( reg , int ) for reg in regs ] ) : # QuantumCircuit with anonymous wires e.g. QuantumCircuit(2, 3) regs = ( QuantumRegister ( regs [ 0 ] , 'q' ) , ClassicalRegister ( regs [ 1 ] , 'c' ) ) else : raise QiskitError ( \"QuantumCircuit parameters can be Registers or Integers.\" \" If Integers, up to 2 arguments. QuantumCircuit was called\" \" with %s.\" % ( regs , ) ) for register in regs : if register in self . qregs or register in self . cregs : raise QiskitError ( \"register name \\\"%s\\\" already exists\" % register . name ) if isinstance ( register , QuantumRegister ) : self . qregs . append ( register ) elif isinstance ( register , ClassicalRegister ) : self . cregs . append ( register ) else : raise QiskitError ( \"expected a register\" )", "nl": "Add registers ."}}
{"translation": {"code": "def qasm ( self ) : string_temp = self . header + \"\\n\" string_temp += self . extension_lib + \"\\n\" for register in self . qregs : string_temp += register . qasm ( ) + \"\\n\" for register in self . cregs : string_temp += register . qasm ( ) + \"\\n\" for instruction , qargs , cargs in self . data : if instruction . name == 'measure' : qubit = qargs [ 0 ] clbit = cargs [ 0 ] string_temp += \"%s %s[%d] -> %s[%d];\\n\" % ( instruction . qasm ( ) , qubit [ 0 ] . name , qubit [ 1 ] , clbit [ 0 ] . name , clbit [ 1 ] ) else : string_temp += \"%s %s;\\n\" % ( instruction . qasm ( ) , \",\" . join ( [ \"%s[%d]\" % ( j [ 0 ] . name , j [ 1 ] ) for j in qargs + cargs ] ) ) return string_temp", "nl": "Return OpenQASM string ."}}
{"translation": {"code": "def calls ( self ) : lst = [ ] for children in self . children : if children . type == \"custom_unitary\" : lst . append ( children . name ) return lst", "nl": "Return a list of custom gate names in this gate body ."}}
{"translation": {"code": "def cu1 ( self , theta , ctl , tgt ) : return self . append ( Cu1Gate ( theta ) , [ ctl , tgt ] , [ ] )", "nl": "Apply cu1 from ctl to tgt with angle theta ."}}
{"translation": {"code": "def inverse ( self ) : for index , instruction in enumerate ( self . instructions ) : self . instructions [ index ] = instruction . inverse ( ) return self", "nl": "Invert all instructions ."}}
{"translation": {"code": "def q_if ( self , * qregs ) : for gate in self . instructions : gate . q_if ( * qregs ) return self", "nl": "Add controls to all instructions ."}}
{"translation": {"code": "def c_if ( self , classical , val ) : for gate in self . instructions : gate . c_if ( classical , val ) return self", "nl": "Add classical control register to all instructions ."}}
{"translation": {"code": "def latex ( self , prec = 15 , nested_scope = None ) : if not nested_scope : return \"\\textrm{\" + self . name + \"}\" else : if self . name not in nested_scope [ - 1 ] : raise NodeException ( \"Expected local parameter name: \" , \"name=%s, \" % self . name , \"line=%s, \" % self . line , \"file=%s\" % self . file ) else : return nested_scope [ - 1 ] [ self . name ] . latex ( prec , nested_scope [ 0 : - 1 ] )", "nl": "Return the correspond math mode latex string ."}}
{"translation": {"code": "def crz ( self , theta , ctl , tgt ) : return self . append ( CrzGate ( theta ) , [ ctl , tgt ] , [ ] )", "nl": "Apply crz from ctl to tgt with angle theta ."}}
{"translation": {"code": "def update_symtab ( self , obj ) : if obj . name in self . current_symtab : prev = self . current_symtab [ obj . name ] raise QasmError ( \"Duplicate declaration for\" , obj . type + \" '\" + obj . name + \"' at line\" , str ( obj . line ) + ', file' , obj . file + '.\\nPrevious occurrence at line' , str ( prev . line ) + ', file' , prev . file ) self . current_symtab [ obj . name ] = obj", "nl": "Update a node in the symbol table ."}}
{"translation": {"code": "def ccx ( self , ctl1 , ctl2 , tgt ) : return self . append ( ToffoliGate ( ) , [ ctl1 , ctl2 , tgt ] , [ ] )", "nl": "Apply Toffoli to from ctl1 and ctl2 to tgt ."}}
{"translation": {"code": "def verify_exp_list ( self , obj ) : # A tad harder.  This is a list of expressions each of which could be # the head of a tree. We need to recursively walk each of these and # ensure that any Id elements resolve to the current stack. # # I believe we only have to look at the current symtab. if obj . children is not None : for children in obj . children : if isinstance ( children , node . Id ) : if children . name in self . external_functions : continue if children . name not in self . current_symtab : raise QasmError ( \"Argument '\" + children . name + \"' in expression cannot be \" + \"found, line\" , str ( children . line ) , \"file\" , children . file ) else : if hasattr ( children , \"children\" ) : self . verify_exp_list ( children )", "nl": "Verify each expression in a list ."}}
{"translation": {"code": "def verify_as_gate ( self , obj , bitlist , arglist = None ) : if obj . name not in self . global_symtab : raise QasmError ( \"Cannot find gate definition for '\" + obj . name + \"', line\" , str ( obj . line ) , 'file' , obj . file ) g_sym = self . global_symtab [ obj . name ] if not ( g_sym . type == 'gate' or g_sym . type == 'opaque' ) : raise QasmError ( \"'\" + obj . name + \"' is used as a gate \" + \"or opaque call but the symbol is neither;\" + \" it is a '\" + g_sym . type + \"' line\" , str ( obj . line ) , 'file' , obj . file ) if g_sym . n_bits ( ) != bitlist . size ( ) : raise QasmError ( \"Gate or opaque call to '\" + obj . name + \"' uses\" , str ( bitlist . size ( ) ) , \"qubits but is declared for\" , str ( g_sym . n_bits ( ) ) , \"qubits\" , \"line\" , str ( obj . line ) , 'file' , obj . file ) if arglist : if g_sym . n_args ( ) != arglist . size ( ) : raise QasmError ( \"Gate or opaque call to '\" + obj . name + \"' uses\" , str ( arglist . size ( ) ) , \"qubits but is declared for\" , str ( g_sym . n_args ( ) ) , \"qubits\" , \"line\" , str ( obj . line ) , 'file' , obj . file ) else : if g_sym . n_args ( ) > 0 : raise QasmError ( \"Gate or opaque call to '\" + obj . name + \"' has no arguments but is declared for\" , str ( g_sym . n_args ( ) ) , \"qubits\" , \"line\" , str ( obj . line ) , 'file' , obj . file )", "nl": "Verify a user defined gate call ."}}
{"translation": {"code": "def verify_reg ( self , obj , object_type ) : # How to verify: #    types must match #    indexes must be checked if obj . name not in self . global_symtab : raise QasmError ( 'Cannot find definition for' , object_type , \"'\" + obj . name + \"'\" , 'at line' , str ( obj . line ) , 'file' , obj . file ) g_sym = self . global_symtab [ obj . name ] if g_sym . type != object_type : raise QasmError ( \"Type for '\" + g_sym . name + \"' should be '\" + object_type + \"' but was found to be '\" + g_sym . type + \"'\" , \"line\" , str ( obj . line ) , \"file\" , obj . file ) if obj . type == 'indexed_id' : bound = g_sym . index ndx = obj . index if ndx < 0 or ndx >= bound : raise QasmError ( \"Register index for '\" + g_sym . name + \"' out of bounds. Index is\" , str ( ndx ) , \"bound is 0 <= index <\" , str ( bound ) , \"at line\" , str ( obj . line ) , \"file\" , obj . file )", "nl": "Verify a register ."}}
{"translation": {"code": "def verify_reg_list ( self , obj , object_type ) : # We expect the object to be a bitlist or an idlist, we don't care. # We will iterate it and ensure everything in it is declared as a bit, # and throw if not. for children in obj . children : self . verify_reg ( children , object_type )", "nl": "Verify a list of registers ."}}
{"translation": {"code": "def find_column ( self , input_ , token ) : if token is None : return 0 last_cr = input_ . rfind ( '\\n' , 0 , token . lexpos ) if last_cr < 0 : last_cr = 0 column = ( token . lexpos - last_cr ) + 1 return column", "nl": "Compute the column ."}}
{"translation": {"code": "def cu3 ( self , theta , phi , lam , ctl , tgt ) : return self . append ( Cu3Gate ( theta , phi , lam ) , [ ctl , tgt ] , [ ] )", "nl": "Apply cu3 from ctl to tgt with angle theta phi lam ."}}
{"translation": {"code": "def parse ( self , data ) : self . parser . parse ( data , lexer = self . lexer , debug = self . parse_deb ) if self . qasm is None : raise QasmError ( \"Uncaught exception in parser; \" + \"see previous messages for details.\" ) return self . qasm", "nl": "Parse some data ."}}
{"translation": {"code": "def push ( self , filename ) : self . lexer . qasm_file = self . filename self . lexer . qasm_line = self . lineno self . stack . append ( self . lexer ) self . __mklexer__ ( filename )", "nl": "Push a PLY lexer on the stack to parse filename ."}}
{"translation": {"code": "def pop ( self ) : self . lexer = self . stack . pop ( ) self . filename = self . lexer . qasm_file self . lineno = self . lexer . qasm_line", "nl": "Pop a PLY lexer off the stack ."}}
{"translation": {"code": "def input ( self , data ) : self . data = data self . lexer . input ( data )", "nl": "Set the input text data ."}}
{"translation": {"code": "def run ( self , data ) : ast = self . parser . parse ( data , debug = True ) self . parser . parse ( data , debug = True ) ast . to_string ( 0 )", "nl": "Parser runner ."}}
{"translation": {"code": "def to_string ( self , indent ) : ind = indent * ' ' print ( ind , 'qreg' ) self . children [ 0 ] . to_string ( indent + 3 )", "nl": "Print the node data with indent ."}}
{"translation": {"code": "def cswap ( self , ctl , tgt1 , tgt2 ) : return self . append ( FredkinGate ( ) , [ ctl , tgt1 , tgt2 ] , [ ] )", "nl": "Apply Fredkin to circuit ."}}
{"translation": {"code": "def inverse ( self ) : self . data = [ gate . inverse ( ) for gate in reversed ( self . data ) ] self . inverse_flag = not self . inverse_flag return self", "nl": "Invert this gate ."}}
{"translation": {"code": "def c_if ( self , classical , val ) : self . data = [ gate . c_if ( classical , val ) for gate in self . data ] return self", "nl": "Add classical control register ."}}
{"translation": {"code": "def parse_debug ( self , val ) : if val is True : self . parse_deb = True elif val is False : self . parse_deb = False else : raise QasmError ( \"Illegal debug value '\" + str ( val ) + \"' must be True or False.\" )", "nl": "Set the parse_deb field ."}}
{"translation": {"code": "def verify_declared_bit ( self , obj ) : # We are verifying gate args against the formal parameters of a # gate prototype. if obj . name not in self . current_symtab : raise QasmError ( \"Cannot find symbol '\" + obj . name + \"' in argument list for gate, line\" , str ( obj . line ) , 'file' , obj . file ) # This insures the thing is from the bitlist and not from the # argument list. sym = self . current_symtab [ obj . name ] if not ( sym . type == 'id' and sym . is_bit ) : raise QasmError ( \"Bit\" , obj . name , 'is not declared as a bit in the gate.' )", "nl": "Verify a qubit id against the gate prototype ."}}
{"translation": {"code": "def u3 ( self , theta , phi , lam , q ) : return self . append ( U3Gate ( theta , phi , lam ) , [ q ] , [ ] )", "nl": "Apply u3 to q ."}}
{"translation": {"code": "def check_range ( self , j ) : if isinstance ( j , int ) : if j < 0 or j >= self . size : raise QiskitIndexError ( \"register index out of range\" ) elif isinstance ( j , slice ) : if j . start < 0 or j . stop >= self . size or ( j . step is not None and j . step <= 0 ) : raise QiskitIndexError ( \"register index slice out of range\" )", "nl": "Check that j is a valid index into self ."}}
{"translation": {"code": "def barrier ( self , * qargs ) : qubits = [ ] qargs = _convert_to_bits ( qargs , [ qbit for qreg in self . qregs for qbit in qreg ] ) if not qargs : # None for qreg in self . qregs : for j in range ( qreg . size ) : qubits . append ( ( qreg , j ) ) for qarg in qargs : if isinstance ( qarg , ( QuantumRegister , list ) ) : if isinstance ( qarg , QuantumRegister ) : qubits . extend ( [ ( qarg , j ) for j in range ( qarg . size ) ] ) else : qubits . extend ( qarg ) else : qubits . append ( qarg ) return self . append ( Barrier ( len ( qubits ) ) , qubits , [ ] )", "nl": "Apply barrier to circuit . If qargs is None applies to all the qbits . Args is a list of QuantumRegister or single qubits . For QuantumRegister applies barrier to all the qubits in that register ."}}
{"translation": {"code": "def u_base ( self , theta , phi , lam , q ) : return self . append ( UBase ( theta , phi , lam ) , [ q ] , [ ] )", "nl": "Apply U to q ."}}
{"translation": {"code": "def _qasmif ( self , string ) : if self . control is None : return string return \"if(%s==%d) \" % ( self . control [ 0 ] . name , self . control [ 1 ] ) + string", "nl": "Print an if statement if needed ."}}
{"translation": {"code": "def c_if ( self , classical , val ) : if not isinstance ( classical , ClassicalRegister ) : raise QiskitError ( \"c_if must be used with a classical register\" ) if val < 0 : raise QiskitError ( \"control value should be non-negative\" ) self . control = ( classical , val ) return self", "nl": "Add classical control on register classical and value val ."}}
{"translation": {"code": "def rzz ( self , theta , qubit1 , qubit2 ) : return self . append ( RZZGate ( theta ) , [ qubit1 , qubit2 ] , [ ] )", "nl": "Apply RZZ to circuit ."}}
{"translation": {"code": "def _filter_deprecation_warnings ( ) : deprecation_filter = ( 'always' , None , DeprecationWarning , re . compile ( r'^qiskit\\.*' , re . UNICODE ) , 0 ) # Instead of using warnings.simple_filter() directly, the internal # _add_filter() function is used for being able to match against the # module. try : warnings . _add_filter ( * deprecation_filter , append = False ) except AttributeError : # ._add_filter is internal and not available in some Python versions. pass # Add a filter for ignoring ChangedInMarshmallow3Warning, as we depend on # marhsmallow 2 explicitly. 2.17.0 introduced new deprecation warnings that # are useful for eventually migrating, but too verbose for our purposes. warnings . simplefilter ( 'ignore' , category = ChangedInMarshmallow3Warning )", "nl": "Apply filters to deprecation warnings ."}}
{"translation": {"code": "def status ( self ) : return BackendStatus ( backend_name = self . name ( ) , backend_version = __version__ , operational = True , pending_jobs = 0 , status_msg = '' )", "nl": "Return backend status ."}}
{"translation": {"code": "def instruction_list ( self ) : instruction_list = [ ] for instruction in self . data : if isinstance ( instruction , CompositeGate ) : instruction_list . extend ( instruction . instruction_list ( ) ) else : instruction_list . append ( instruction ) return instruction_list", "nl": "Return a list of instructions for this CompositeGate ."}}
{"translation": {"code": "def transpile ( circuits , backend = None , basis_gates = None , coupling_map = None , initial_layout = None , seed_mapper = None , pass_manager = None ) : warnings . warn ( \"qiskit.transpiler.transpile() has been deprecated and will be \" \"removed in the 0.9 release. Use qiskit.compiler.transpile() instead.\" , DeprecationWarning ) return compiler . transpile ( circuits = circuits , backend = backend , basis_gates = basis_gates , coupling_map = coupling_map , initial_layout = initial_layout , seed_transpiler = seed_mapper , pass_manager = pass_manager )", "nl": "transpile one or more circuits ."}}
{"translation": {"code": "def _get_backend_instance ( self , backend_cls ) : # Verify that the backend can be instantiated. try : backend_instance = backend_cls ( provider = self ) except Exception as err : raise QiskitError ( 'Backend %s could not be instantiated: %s' % ( backend_cls , err ) ) return backend_instance", "nl": "Return an instance of a backend from its class ."}}
{"translation": {"code": "def inverse ( self ) : return Snapshot ( self . num_qubits , self . num_clbits , self . params [ 0 ] , self . params [ 1 ] )", "nl": "Special case . Return self ."}}
{"translation": {"code": "def _validate ( self , qobj ) : n_qubits = qobj . config . n_qubits max_qubits = self . configuration ( ) . n_qubits if n_qubits > max_qubits : raise BasicAerError ( 'Number of qubits {} ' . format ( n_qubits ) + 'is greater than maximum ({}) ' . format ( max_qubits ) + 'for \"{}\".' . format ( self . name ( ) ) ) for experiment in qobj . experiments : name = experiment . header . name if experiment . config . memory_slots == 0 : logger . warning ( 'No classical registers in circuit \"%s\", ' 'counts will be empty.' , name ) elif 'measure' not in [ op . name for op in experiment . instructions ] : logger . warning ( 'No measurements in circuit \"%s\", ' 'classical register will remain all zeros.' , name )", "nl": "Semantic validations of the qobj which cannot be done via schemas ."}}
{"translation": {"code": "def status ( self ) : # The order is important here if self . _future . running ( ) : _status = JobStatus . RUNNING elif self . _future . cancelled ( ) : _status = JobStatus . CANCELLED elif self . _future . done ( ) : _status = JobStatus . DONE if self . _future . exception ( ) is None else JobStatus . ERROR else : # Note: There is an undocumented Future state: PENDING, that seems to show up when # the job is enqueued, waiting for someone to pick it up. We need to deal with this # state but there's no public API for it, so we are assuming that if the job is not # in any of the previous states, is PENDING, ergo INITIALIZING for us. _status = JobStatus . INITIALIZING return _status", "nl": "Gets the status of the job by querying the Python s future"}}
{"translation": {"code": "def run ( self , qobj , backend_options = None ) : self . _set_options ( qobj_config = qobj . config , backend_options = backend_options ) job_id = str ( uuid . uuid4 ( ) ) job = BasicAerJob ( self , job_id , self . _run_job , qobj ) job . submit ( ) return job", "nl": "Run qobj asynchronously ."}}
{"translation": {"code": "def run ( self , dag ) : cx_runs = dag . collect_runs ( [ \"cx\" ] ) for cx_run in cx_runs : # Partition the cx_run into chunks with equal gate arguments partition = [ ] chunk = [ ] for i in range ( len ( cx_run ) - 1 ) : chunk . append ( cx_run [ i ] ) qargs0 = cx_run [ i ] . qargs qargs1 = cx_run [ i + 1 ] . qargs if qargs0 != qargs1 : partition . append ( chunk ) chunk = [ ] chunk . append ( cx_run [ - 1 ] ) partition . append ( chunk ) # Simplify each chunk in the partition for chunk in partition : if len ( chunk ) % 2 == 0 : for n in chunk : dag . remove_op_node ( n ) else : for n in chunk [ 1 : ] : dag . remove_op_node ( n ) return dag", "nl": "Run one pass of cx cancellation on the circuit"}}
{"translation": {"code": "def _matplotlib_circuit_drawer ( circuit , scale = 0.7 , filename = None , style = None , plot_barriers = True , reverse_bits = False , justify = None ) : qregs , cregs , ops = utils . _get_layered_instructions ( circuit , reverse_bits = reverse_bits , justify = justify ) qcd = _matplotlib . MatplotlibDrawer ( qregs , cregs , ops , scale = scale , style = style , plot_barriers = plot_barriers , reverse_bits = reverse_bits ) return qcd . draw ( filename )", "nl": "Draw a quantum circuit based on matplotlib . If %matplotlib inline is invoked in a Jupyter notebook it visualizes a circuit inline . We recommend %config InlineBackend . figure_format = svg for the inline visualization ."}}
{"translation": {"code": "def plot_state_paulivec ( rho , title = \"\" , figsize = None , color = None ) : if not HAS_MATPLOTLIB : raise ImportError ( 'Must have Matplotlib installed.' ) rho = _validate_input_state ( rho ) if figsize is None : figsize = ( 7 , 5 ) num = int ( np . log2 ( len ( rho ) ) ) labels = list ( map ( lambda x : x . to_label ( ) , pauli_group ( num ) ) ) values = list ( map ( lambda x : np . real ( np . trace ( np . dot ( x . to_matrix ( ) , rho ) ) ) , pauli_group ( num ) ) ) numelem = len ( values ) if color is None : color = \"#648fff\" ind = np . arange ( numelem ) # the x locations for the groups width = 0.5 # the width of the bars fig , ax = plt . subplots ( figsize = figsize ) ax . grid ( zorder = 0 , linewidth = 1 , linestyle = '--' ) ax . bar ( ind , values , width , color = color , zorder = 2 ) ax . axhline ( linewidth = 1 , color = 'k' ) # add some text for labels, title, and axes ticks ax . set_ylabel ( 'Expectation value' , fontsize = 14 ) ax . set_xticks ( ind ) ax . set_yticks ( [ - 1 , - 0.5 , 0 , 0.5 , 1 ] ) ax . set_xticklabels ( labels , fontsize = 14 , rotation = 70 ) ax . set_xlabel ( 'Pauli' , fontsize = 14 ) ax . set_ylim ( [ - 1 , 1 ] ) ax . set_facecolor ( '#eeeeee' ) for tick in ax . xaxis . get_major_ticks ( ) + ax . yaxis . get_major_ticks ( ) : tick . label . set_fontsize ( 14 ) ax . set_title ( title , fontsize = 16 ) plt . close ( fig ) return fig", "nl": "Plot the paulivec representation of a quantum state ."}}
{"translation": {"code": "def build_bell_circuit ( ) : q = QuantumRegister ( 2 ) c = ClassicalRegister ( 2 ) qc = QuantumCircuit ( q , c ) qc . h ( q [ 0 ] ) qc . cx ( q [ 0 ] , q [ 1 ] ) qc . measure ( q , c ) return qc", "nl": "Returns a circuit putting 2 qubits in the Bell state ."}}
{"translation": {"code": "def render ( self , title = '' ) : if self . _rendered : self . axes . clear ( ) self . _rendered = True # Figure instance for Bloch sphere plot if not self . _ext_fig : self . fig = plt . figure ( figsize = self . figsize ) if not self . _ext_axes : self . axes = Axes3D ( self . fig , azim = self . view [ 0 ] , elev = self . view [ 1 ] ) if self . background : self . axes . clear ( ) self . axes . set_xlim3d ( - 1.3 , 1.3 ) self . axes . set_ylim3d ( - 1.3 , 1.3 ) self . axes . set_zlim3d ( - 1.3 , 1.3 ) else : self . plot_axes ( ) self . axes . set_axis_off ( ) self . axes . set_xlim3d ( - 0.7 , 0.7 ) self . axes . set_ylim3d ( - 0.7 , 0.7 ) self . axes . set_zlim3d ( - 0.7 , 0.7 ) self . axes . grid ( False ) self . plot_back ( ) self . plot_points ( ) self . plot_vectors ( ) self . plot_front ( ) self . plot_axes_labels ( ) self . plot_annotations ( ) self . axes . set_title ( title , fontsize = self . font_size , y = 1.08 )", "nl": "Render the Bloch sphere and its data sets in on given figure and axes ."}}
{"translation": {"code": "def add_annotation ( self , state_or_vector , text , * * kwargs ) : if isinstance ( state_or_vector , ( list , np . ndarray , tuple ) ) and len ( state_or_vector ) == 3 : vec = state_or_vector else : raise Exception ( \"Position needs to be specified by a qubit \" + \"state or a 3D vector.\" ) self . annotations . append ( { 'position' : vec , 'text' : text , 'opts' : kwargs } )", "nl": "Add a text or LaTeX annotation to Bloch sphere parametrized by a qubit state or a vector ."}}
{"translation": {"code": "def set_label_convention ( self , convention ) : ketex = \"$\\\\left.|%s\\\\right\\\\rangle$\" # \\left.| is on purpose, so that every ket has the same size if convention == \"original\" : self . xlabel = [ '$x$' , '' ] self . ylabel = [ '$y$' , '' ] self . zlabel = [ '$\\\\left|0\\\\right>$' , '$\\\\left|1\\\\right>$' ] elif convention == \"xyz\" : self . xlabel = [ '$x$' , '' ] self . ylabel = [ '$y$' , '' ] self . zlabel = [ '$z$' , '' ] elif convention == \"sx sy sz\" : self . xlabel = [ '$s_x$' , '' ] self . ylabel = [ '$s_y$' , '' ] self . zlabel = [ '$s_z$' , '' ] elif convention == \"01\" : self . xlabel = [ '' , '' ] self . ylabel = [ '' , '' ] self . zlabel = [ '$\\\\left|0\\\\right>$' , '$\\\\left|1\\\\right>$' ] elif convention == \"polarization jones\" : self . xlabel = [ ketex % \"\\\\nearrow\\\\hspace{-1.46}\\\\swarrow\" , ketex % \"\\\\nwarrow\\\\hspace{-1.46}\\\\searrow\" ] self . ylabel = [ ketex % \"\\\\circlearrowleft\" , ketex % \"\\\\circlearrowright\" ] self . zlabel = [ ketex % \"\\\\leftrightarrow\" , ketex % \"\\\\updownarrow\" ] elif convention == \"polarization jones letters\" : self . xlabel = [ ketex % \"D\" , ketex % \"A\" ] self . ylabel = [ ketex % \"L\" , ketex % \"R\" ] self . zlabel = [ ketex % \"H\" , ketex % \"V\" ] elif convention == \"polarization stokes\" : self . ylabel = [ \"$\\\\nearrow\\\\hspace{-1.46}\\\\swarrow$\" , \"$\\\\nwarrow\\\\hspace{-1.46}\\\\searrow$\" ] self . zlabel = [ \"$\\\\circlearrowleft$\" , \"$\\\\circlearrowright$\" ] self . xlabel = [ \"$\\\\leftrightarrow$\" , \"$\\\\updownarrow$\" ] else : raise Exception ( \"No such convention.\" )", "nl": "Set x y and z labels according to one of conventions ."}}
{"translation": {"code": "def add_vectors ( self , vectors ) : if isinstance ( vectors [ 0 ] , ( list , np . ndarray ) ) : for vec in vectors : self . vectors . append ( vec ) else : self . vectors . append ( vectors )", "nl": "Add a list of vectors to Bloch sphere ."}}
{"translation": {"code": "def _hide_tick_lines_and_labels ( axis ) : for item in axis . get_ticklines ( ) + axis . get_ticklabels ( ) : item . set_visible ( False )", "nl": "Set visible property of ticklines and ticklabels of an axis to False"}}
{"translation": {"code": "def show ( self , title = '' ) : self . render ( title = title ) if self . fig : plt . show ( self . fig )", "nl": "Display Bloch sphere and corresponding data sets ."}}
{"translation": {"code": "def plot_front ( self ) : u_angle = np . linspace ( - np . pi , 0 , 25 ) v_angle = np . linspace ( 0 , np . pi , 25 ) x_dir = np . outer ( np . cos ( u_angle ) , np . sin ( v_angle ) ) y_dir = np . outer ( np . sin ( u_angle ) , np . sin ( v_angle ) ) z_dir = np . outer ( np . ones ( u_angle . shape [ 0 ] ) , np . cos ( v_angle ) ) self . axes . plot_surface ( x_dir , y_dir , z_dir , rstride = 2 , cstride = 2 , color = self . sphere_color , linewidth = 0 , alpha = self . sphere_alpha ) # wireframe self . axes . plot_wireframe ( x_dir , y_dir , z_dir , rstride = 5 , cstride = 5 , color = self . frame_color , alpha = self . frame_alpha ) # equator self . axes . plot ( 1.0 * np . cos ( u_angle ) , 1.0 * np . sin ( u_angle ) , zs = 0 , zdir = 'z' , lw = self . frame_width , color = self . frame_color ) self . axes . plot ( 1.0 * np . cos ( u_angle ) , 1.0 * np . sin ( u_angle ) , zs = 0 , zdir = 'x' , lw = self . frame_width , color = self . frame_color )", "nl": "front half of sphere"}}
{"translation": {"code": "def clear ( self ) : self . points = [ ] self . vectors = [ ] self . point_style = [ ] self . annotations = [ ]", "nl": "Resets Bloch sphere data sets to empty ."}}
{"translation": {"code": "def to_matrix ( self ) : w , x , y , z = self . normalize ( ) . data # pylint: disable=C0103 mat = np . array ( [ [ 1 - 2 * y ** 2 - 2 * z ** 2 , 2 * x * y - 2 * z * w , 2 * x * z + 2 * y * w ] , [ 2 * x * y + 2 * z * w , 1 - 2 * x ** 2 - 2 * z ** 2 , 2 * y * z - 2 * x * w ] , [ 2 * x * z - 2 * y * w , 2 * y * z + 2 * x * w , 1 - 2 * x ** 2 - 2 * y ** 2 ] ] , dtype = float ) return mat", "nl": "Converts a unit - length quaternion to a rotation matrix ."}}
{"translation": {"code": "def quaternion_from_euler ( angles , order = 'yzy' ) : angles = np . asarray ( angles , dtype = float ) quat = quaternion_from_axis_rotation ( angles [ 0 ] , order [ 0 ] ) * ( quaternion_from_axis_rotation ( angles [ 1 ] , order [ 1 ] ) * quaternion_from_axis_rotation ( angles [ 2 ] , order [ 2 ] ) ) quat . normalize ( inplace = True ) return quat", "nl": "Generate a quaternion from a set of Euler angles ."}}
{"translation": {"code": "def to_zyz ( self ) : mat = self . to_matrix ( ) euler = np . zeros ( 3 , dtype = float ) if mat [ 2 , 2 ] < 1 : if mat [ 2 , 2 ] > - 1 : euler [ 0 ] = math . atan2 ( mat [ 1 , 2 ] , mat [ 0 , 2 ] ) euler [ 1 ] = math . acos ( mat [ 2 , 2 ] ) euler [ 2 ] = math . atan2 ( mat [ 2 , 1 ] , - mat [ 2 , 0 ] ) else : euler [ 0 ] = - math . atan2 ( mat [ 1 , 0 ] , mat [ 1 , 1 ] ) euler [ 1 ] = np . pi else : euler [ 0 ] = math . atan2 ( mat [ 1 , 0 ] , mat [ 1 , 1 ] ) return euler", "nl": "Converts a unit - length quaternion to a sequence of ZYZ Euler angles ."}}
{"translation": {"code": "def normalize ( self , inplace = False ) : if inplace : nrm = self . norm ( ) self . data /= nrm return None nrm = self . norm ( ) data_copy = np . array ( self . data , copy = True ) data_copy /= nrm return Quaternion ( data_copy )", "nl": "Normalizes a Quaternion to unit length so that it represents a valid rotation ."}}
{"translation": {"code": "def quaternion_from_axis_rotation ( angle , axis ) : out = np . zeros ( 4 , dtype = float ) if axis == 'x' : out [ 1 ] = 1 elif axis == 'y' : out [ 2 ] = 1 elif axis == 'z' : out [ 3 ] = 1 else : raise ValueError ( 'Invalid axis input.' ) out *= math . sin ( angle / 2.0 ) out [ 0 ] = math . cos ( angle / 2.0 ) return Quaternion ( out )", "nl": "Return quaternion for rotation about given axis ."}}
{"translation": {"code": "def requires_submit ( func ) : @ functools . wraps ( func ) def _wrapper ( self , * args , * * kwargs ) : if self . _future is None : raise JobError ( \"Job not submitted yet!. You have to .submit() first!\" ) return func ( self , * args , * * kwargs ) return _wrapper", "nl": "Decorator to ensure that a submit has been performed before calling the method ."}}
{"translation": {"code": "def submit ( self ) : if self . _future is not None : raise JobError ( \"We have already submitted the job!\" ) validate_qobj_against_schema ( self . _qobj ) self . _future = self . _executor . submit ( self . _fn , self . _job_id , self . _qobj )", "nl": "Submit the job to the backend for execution ."}}
{"translation": {"code": "def lex_index ( n , k , lst ) : if len ( lst ) != k : raise VisualizationError ( \"list should have length k\" ) comb = list ( map ( lambda x : n - 1 - x , lst ) ) dualm = sum ( [ n_choose_k ( comb [ k - 1 - i ] , i + 1 ) for i in range ( k ) ] ) return int ( dualm )", "nl": "Return the lex index of a combination .."}}
{"translation": {"code": "def iplot_state_hinton ( rho , figsize = None ) : # HTML html_template = Template ( \"\"\"\n    <p>\n        <div id=\"hinton_$divNumber\"></div>\n    </p>\n    \"\"\" ) # JavaScript javascript_template = Template ( \"\"\"\n    <script>\n        requirejs.config({\n            paths: {\n                qVisualization: \"https://qvisualization.mybluemix.net/q-visualizations\"\n            }\n        });\n\n        require([\"qVisualization\"], function(qVisualizations) {\n            qVisualizations.plotState(\"hinton_$divNumber\",\n                                      \"hinton\",\n                                      $executions,\n                                      $options);\n        });\n    </script>\n    \"\"\" ) rho = _validate_input_state ( rho ) if figsize is None : options = { } else : options = { 'width' : figsize [ 0 ] , 'height' : figsize [ 1 ] } # Process data and execute div_number = str ( time . time ( ) ) div_number = re . sub ( '[.]' , '' , div_number ) # Process data and execute real = [ ] imag = [ ] for xvalue in rho : row_real = [ ] col_imag = [ ] for value_real in xvalue . real : row_real . append ( float ( value_real ) ) real . append ( row_real ) for value_imag in xvalue . imag : col_imag . append ( float ( value_imag ) ) imag . append ( col_imag ) html = html_template . substitute ( { 'divNumber' : div_number } ) javascript = javascript_template . substitute ( { 'divNumber' : div_number , 'executions' : [ { 'data' : real } , { 'data' : imag } ] , 'options' : options } ) display ( HTML ( html + javascript ) )", "nl": "Create a hinton representation ."}}
{"translation": {"code": "def process_data ( rho ) : result = dict ( ) num = int ( np . log2 ( len ( rho ) ) ) labels = list ( map ( lambda x : x . to_label ( ) , pauli_group ( num ) ) ) values = list ( map ( lambda x : np . real ( np . trace ( np . dot ( x . to_matrix ( ) , rho ) ) ) , pauli_group ( num ) ) ) for position , label in enumerate ( labels ) : result [ label ] = values [ position ] return result", "nl": "Sort rho data"}}
{"translation": {"code": "def iplot_bloch_multivector ( rho , figsize = None ) : # HTML html_template = Template ( \"\"\"\n    <p>\n        <div id=\"content_$divNumber\" style=\"position: absolute; z-index: 1;\">\n            <div id=\"bloch_$divNumber\"></div>\n        </div>\n    </p>\n    \"\"\" ) # JavaScript javascript_template = Template ( \"\"\"\n    <script>\n        requirejs.config({\n            paths: {\n                qVisualization: \"https://qvisualization.mybluemix.net/q-visualizations\"\n            }\n        });\n        data = $data;\n        dataValues = [];\n        for (var i = 0; i < data.length; i++) {\n            // Coordinates\n            var x = data[i][0];\n            var y = data[i][1];\n            var z = data[i][2];\n            var point = {'x': x,\n                        'y': y,\n                        'z': z};\n            dataValues.push(point);\n        }\n\n        require([\"qVisualization\"], function(qVisualizations) {\n            // Plot figure\n            qVisualizations.plotState(\"bloch_$divNumber\",\n                                      \"bloch\",\n                                      dataValues,\n                                      $options);\n        });\n    </script>\n    \"\"\" ) rho = _validate_input_state ( rho ) if figsize is None : options = { } else : options = { 'width' : figsize [ 0 ] , 'height' : figsize [ 1 ] } # Process data and execute num = int ( np . log2 ( len ( rho ) ) ) bloch_data = [ ] for i in range ( num ) : pauli_singles = [ Pauli . pauli_single ( num , i , 'X' ) , Pauli . pauli_single ( num , i , 'Y' ) , Pauli . pauli_single ( num , i , 'Z' ) ] bloch_state = list ( map ( lambda x : np . real ( np . trace ( np . dot ( x . to_matrix ( ) , rho ) ) ) , pauli_singles ) ) bloch_data . append ( bloch_state ) div_number = str ( time . time ( ) ) div_number = re . sub ( '[.]' , '' , div_number ) html = html_template . substitute ( { 'divNumber' : div_number } ) javascript = javascript_template . substitute ( { 'data' : bloch_data , 'divNumber' : div_number , 'options' : options } ) display ( HTML ( html + javascript ) )", "nl": "Create a bloch sphere representation ."}}
{"translation": {"code": "def iplot_state_paulivec ( rho , figsize = None , slider = False , show_legend = False ) : # HTML html_template = Template ( \"\"\"\n    <p>\n        <div id=\"paulivec_$divNumber\"></div>\n    </p>\n    \"\"\" ) # JavaScript javascript_template = Template ( \"\"\"\n    <script>\n        requirejs.config({\n            paths: {\n                qVisualization: \"https://qvisualization.mybluemix.net/q-visualizations\"\n            }\n        });\n\n        require([\"qVisualization\"], function(qVisualizations) {\n            qVisualizations.plotState(\"paulivec_$divNumber\",\n                                      \"paulivec\",\n                                      $executions,\n                                      $options);\n        });\n    </script>\n    \"\"\" ) rho = _validate_input_state ( rho ) # set default figure size if none given if figsize is None : figsize = ( 7 , 5 ) options = { 'width' : figsize [ 0 ] , 'height' : figsize [ 1 ] , 'slider' : int ( slider ) , 'show_legend' : int ( show_legend ) } # Process data and execute div_number = str ( time . time ( ) ) div_number = re . sub ( '[.]' , '' , div_number ) data_to_plot = [ ] rho_data = process_data ( rho ) data_to_plot . append ( dict ( data = rho_data ) ) html = html_template . substitute ( { 'divNumber' : div_number } ) javascript = javascript_template . substitute ( { 'divNumber' : div_number , 'executions' : data_to_plot , 'options' : options } ) display ( HTML ( html + javascript ) )", "nl": "Create a paulivec representation ."}}
{"translation": {"code": "def iplot_histogram ( data , figsize = None , number_to_keep = None , sort = 'asc' , legend = None ) : # HTML html_template = Template ( \"\"\"\n    <p>\n        <div id=\"histogram_$divNumber\"></div>\n    </p>\n    \"\"\" ) # JavaScript javascript_template = Template ( \"\"\"\n    <script>\n        requirejs.config({\n            paths: {\n                qVisualization: \"https://qvisualization.mybluemix.net/q-visualizations\"\n            }\n        });\n\n        require([\"qVisualization\"], function(qVisualizations) {\n            qVisualizations.plotState(\"histogram_$divNumber\",\n                                      \"histogram\",\n                                      $executions,\n                                      $options);\n        });\n    </script>\n    \"\"\" ) # Process data and execute div_number = str ( time . time ( ) ) div_number = re . sub ( '[.]' , '' , div_number ) # set default figure size if none provided if figsize is None : figsize = ( 7 , 5 ) options = { 'number_to_keep' : 0 if number_to_keep is None else number_to_keep , 'sort' : sort , 'show_legend' : 0 , 'width' : int ( figsize [ 0 ] ) , 'height' : int ( figsize [ 1 ] ) } if legend : options [ 'show_legend' ] = 1 data_to_plot = [ ] if isinstance ( data , dict ) : data = [ data ] if legend and len ( legend ) != len ( data ) : raise VisualizationError ( \"Length of legendL (%s) doesn't match number \" \"of input executions: %s\" % ( len ( legend ) , len ( data ) ) ) for item , execution in enumerate ( data ) : exec_data = process_data ( execution , options [ 'number_to_keep' ] ) out_dict = { 'data' : exec_data } if legend : out_dict [ 'name' ] = legend [ item ] data_to_plot . append ( out_dict ) html = html_template . substitute ( { 'divNumber' : div_number } ) javascript = javascript_template . substitute ( { 'divNumber' : div_number , 'executions' : data_to_plot , 'options' : options } ) display ( HTML ( html + javascript ) )", "nl": "Create a histogram representation ."}}
{"translation": {"code": "def iplot_state_qsphere ( rho , figsize = None ) : # HTML html_template = Template ( \"\"\"\n    <p>\n        <div id=\"content_$divNumber\" style=\"position: absolute; z-index: 1;\">\n            <div id=\"qsphere_$divNumber\"></div>\n        </div>\n    </p>\n    \"\"\" ) # JavaScript javascript_template = Template ( \"\"\"\n    <script>\n        requirejs.config({\n            paths: {\n                qVisualization: \"https://qvisualization.mybluemix.net/q-visualizations\"\n            }\n        });\n        require([\"qVisualization\"], function(qVisualizations) {\n            data = $data;\n            qVisualizations.plotState(\"qsphere_$divNumber\",\n                                      \"qsphere\",\n                                      data,\n                                      $options);\n        });\n    </script>\n\n    \"\"\" ) rho = _validate_input_state ( rho ) if figsize is None : options = { } else : options = { 'width' : figsize [ 0 ] , 'height' : figsize [ 1 ] } qspheres_data = [ ] # Process data and execute num = int ( np . log2 ( len ( rho ) ) ) # get the eigenvectors and eigenvalues weig , stateall = linalg . eigh ( rho ) for _ in range ( 2 ** num ) : # start with the max probmix = weig . max ( ) prob_location = weig . argmax ( ) if probmix > 0.001 : # print(\"The \" + str(k) + \"th eigenvalue = \" + str(probmix)) # get the max eigenvalue state = stateall [ : , prob_location ] loc = np . absolute ( state ) . argmax ( ) # get the element location closes to lowest bin representation. for j in range ( 2 ** num ) : test = np . absolute ( np . absolute ( state [ j ] ) - np . absolute ( state [ loc ] ) ) if test < 0.001 : loc = j break # remove the global phase angles = ( np . angle ( state [ loc ] ) + 2 * np . pi ) % ( 2 * np . pi ) angleset = np . exp ( - 1j * angles ) state = angleset * state state . flatten ( ) spherepoints = [ ] for i in range ( 2 ** num ) : # get x,y,z points element = bin ( i ) [ 2 : ] . zfill ( num ) weight = element . count ( \"1\" ) number_of_divisions = n_choose_k ( num , weight ) weight_order = bit_string_index ( element ) angle = weight_order * 2 * np . pi / number_of_divisions zvalue = - 2 * weight / num + 1 xvalue = np . sqrt ( 1 - zvalue ** 2 ) * np . cos ( angle ) yvalue = np . sqrt ( 1 - zvalue ** 2 ) * np . sin ( angle ) # get prob and angle - prob will be shade and angle color prob = np . real ( np . dot ( state [ i ] , state [ i ] . conj ( ) ) ) angles = ( np . angle ( state [ i ] ) + 2 * np . pi ) % ( 2 * np . pi ) qpoint = { 'x' : xvalue , 'y' : yvalue , 'z' : zvalue , 'prob' : prob , 'phase' : angles } spherepoints . append ( qpoint ) # Associate all points to one sphere sphere = { 'points' : spherepoints , 'eigenvalue' : probmix } # Add sphere to the spheres array qspheres_data . append ( sphere ) weig [ prob_location ] = 0 div_number = str ( time . time ( ) ) div_number = re . sub ( '[.]' , '' , div_number ) html = html_template . substitute ( { 'divNumber' : div_number } ) javascript = javascript_template . substitute ( { 'data' : qspheres_data , 'divNumber' : div_number , 'options' : options } ) display ( HTML ( html + javascript ) )", "nl": "Create a Q sphere representation ."}}
{"translation": {"code": "def n_choose_k ( n , k ) : if n == 0 : return 0 return reduce ( lambda x , y : x * y [ 0 ] / y [ 1 ] , zip ( range ( n - k + 1 , n + 1 ) , range ( 1 , k + 1 ) ) , 1 )", "nl": "Return the number of combinations for n choose k ."}}
{"translation": {"code": "def process_data ( data , number_to_keep ) : result = dict ( ) if number_to_keep != 0 : data_temp = dict ( Counter ( data ) . most_common ( number_to_keep ) ) data_temp [ 'rest' ] = sum ( data . values ( ) ) - sum ( data_temp . values ( ) ) data = data_temp labels = data values = np . array ( [ data [ key ] for key in labels ] , dtype = float ) pvalues = values / sum ( values ) for position , label in enumerate ( labels ) : result [ label ] = round ( pvalues [ position ] , 5 ) return result", "nl": "Prepare received data for representation ."}}
{"translation": {"code": "def _load_schema ( file_path , name = None ) : if name is None : # filename without extension name = os . path . splitext ( os . path . basename ( file_path ) ) [ 0 ] if name not in _SCHEMAS : with open ( file_path , 'r' ) as schema_file : _SCHEMAS [ name ] = json . load ( schema_file ) return _SCHEMAS [ name ]", "nl": "Loads the QObj schema for use in future validations ."}}
{"translation": {"code": "def validate_json_against_schema ( json_dict , schema , err_msg = None ) : try : if isinstance ( schema , str ) : schema_name = schema schema = _SCHEMAS [ schema_name ] validator = _get_validator ( schema_name ) validator . validate ( json_dict ) else : jsonschema . validate ( json_dict , schema ) except jsonschema . ValidationError as err : if err_msg is None : err_msg = \"JSON failed validation. Set Qiskit log level to DEBUG \" \"for further information.\" newerr = SchemaValidationError ( err_msg ) newerr . __cause__ = _SummaryValidationError ( err ) logger . debug ( '%s' , _format_causes ( err ) ) raise newerr", "nl": "Validates JSON dict against a schema ."}}
{"translation": {"code": "def _format_causes ( err , level = 0 ) : lines = [ ] def _print ( string , offset = 0 ) : lines . append ( _pad ( string , offset = offset ) ) def _pad ( string , offset = 0 ) : padding = '  ' * ( level + offset ) padded_lines = [ padding + line for line in string . split ( '\\n' ) ] return '\\n' . join ( padded_lines ) def _format_path ( path ) : def _format ( item ) : if isinstance ( item , str ) : return '.{}' . format ( item ) return '[{}]' . format ( item ) return '' . join ( [ '<root>' ] + list ( map ( _format , path ) ) ) _print ( '\\'{}\\' failed @ \\'{}\\' because of:' . format ( err . validator , _format_path ( err . absolute_path ) ) ) if not err . context : _print ( str ( err . message ) , offset = 1 ) else : for suberr in err . context : lines . append ( _format_causes ( suberr , level + 1 ) ) return '\\n' . join ( lines )", "nl": "Return a cascading explanation of the validation error ."}}
{"translation": {"code": "def _load_schemas_and_validators ( ) : schema_base_path = os . path . join ( os . path . dirname ( __file__ ) , '../..' ) for name , path in _DEFAULT_SCHEMA_PATHS . items ( ) : _load_schema ( os . path . join ( schema_base_path , path ) , name ) _get_validator ( name )", "nl": "Load all default schemas into _SCHEMAS ."}}
{"translation": {"code": "def _get_validator ( name , schema = None , check_schema = True , validator_class = None , * * validator_kwargs ) : if schema is None : try : schema = _SCHEMAS [ name ] except KeyError : raise SchemaValidationError ( \"Valid schema name or schema must \" \"be provided.\" ) if name not in _VALIDATORS : # Resolve JSON spec from schema if needed if validator_class is None : validator_class = jsonschema . validators . validator_for ( schema ) # Generate and store validator in _VALIDATORS _VALIDATORS [ name ] = validator_class ( schema , * * validator_kwargs ) validator = _VALIDATORS [ name ] if check_schema : validator . check_schema ( schema ) return validator", "nl": "Generate validator for JSON schema ."}}
{"translation": {"code": "def _has_connection ( hostname , port ) : try : host = socket . gethostbyname ( hostname ) socket . create_connection ( ( host , port ) , 2 ) return True except Exception : # pylint: disable=broad-except return False", "nl": "Checks if internet connection exists to host via specified port ."}}
{"translation": {"code": "def einsum_matmul_index ( gate_indices , number_of_qubits ) : mat_l , mat_r , tens_lin , tens_lout = _einsum_matmul_index_helper ( gate_indices , number_of_qubits ) # Right indices for the N-qubit input and output tensor tens_r = ascii_uppercase [ : number_of_qubits ] # Combine indices into matrix multiplication string format # for numpy.einsum function return \"{mat_l}{mat_r}, \" . format ( mat_l = mat_l , mat_r = mat_r ) + \"{tens_lin}{tens_r}->{tens_lout}{tens_r}\" . format ( tens_lin = tens_lin , tens_lout = tens_lout , tens_r = tens_r )", "nl": "Return the index string for Numpy . eignsum matrix - matrix multiplication ."}}
{"translation": {"code": "def _einsum_matmul_index_helper ( gate_indices , number_of_qubits ) : # Since we use ASCII alphabet for einsum index labels we are limited # to 26 total free left (lowercase) and 26 right (uppercase) indexes. # The rank of the contracted tensor reduces this as we need to use that # many characters for the contracted indices if len ( gate_indices ) + number_of_qubits > 26 : raise QiskitError ( \"Total number of free indexes limited to 26\" ) # Indicies for N-qubit input tensor tens_in = ascii_lowercase [ : number_of_qubits ] # Indices for the N-qubit output tensor tens_out = list ( tens_in ) # Left and right indices for the M-qubit multiplying tensor mat_left = \"\" mat_right = \"\" # Update left indices for mat and output for pos , idx in enumerate ( reversed ( gate_indices ) ) : mat_left += ascii_lowercase [ - 1 - pos ] mat_right += tens_in [ - 1 - idx ] tens_out [ - 1 - idx ] = ascii_lowercase [ - 1 - pos ] tens_out = \"\" . join ( tens_out ) # Combine indices into matrix multiplication string format # for numpy.einsum function return mat_left , mat_right , tens_in , tens_out", "nl": "Return the index string for Numpy . eignsum matrix multiplication ."}}
{"translation": {"code": "def local_hardware_info ( ) : results = { 'os' : platform . system ( ) , 'memory' : psutil . virtual_memory ( ) . total / ( 1024 ** 3 ) , 'cpus' : psutil . cpu_count ( logical = False ) or 1 } return results", "nl": "Basic hardware information about the local machine ."}}
{"translation": {"code": "def get_backend ( self , name = None , * * kwargs ) : backends = self . backends ( name , * * kwargs ) if len ( backends ) > 1 : raise QiskitBackendNotFoundError ( 'More than one backend matches the criteria' ) elif not backends : raise QiskitBackendNotFoundError ( 'No backend matches the criteria' ) return backends [ 0 ]", "nl": "Return a single backend matching the specified filtering ."}}
{"translation": {"code": "def filter_backends ( backends , filters = None , * * kwargs ) : def _match_all ( obj , criteria ) : \"\"\"Return True if all items in criteria matches items in obj.\"\"\" return all ( getattr ( obj , key_ , None ) == value_ for key_ , value_ in criteria . items ( ) ) # Inspect the backends to decide which filters belong to # backend.configuration and which ones to backend.status, as it does # not involve querying the API. configuration_filters = { } status_filters = { } for key , value in kwargs . items ( ) : if all ( key in backend . configuration ( ) for backend in backends ) : configuration_filters [ key ] = value else : status_filters [ key ] = value # 1. Apply backend.configuration filtering. if configuration_filters : backends = [ b for b in backends if _match_all ( b . configuration ( ) , configuration_filters ) ] # 2. Apply backend.status filtering (it involves one API call for # each backend). if status_filters : backends = [ b for b in backends if _match_all ( b . status ( ) , status_filters ) ] # 3. Apply acceptor filter. backends = list ( filter ( filters , backends ) ) return backends", "nl": "Return the backends matching the specified filtering ."}}
{"translation": {"code": "def resolve_backend_name ( name , backends , deprecated , aliased ) : available = [ backend . name ( ) for backend in backends ] resolved_name = deprecated . get ( name , aliased . get ( name , name ) ) if isinstance ( resolved_name , list ) : resolved_name = next ( ( b for b in resolved_name if b in available ) , \"\" ) if resolved_name not in available : raise LookupError ( \"backend '{}' not found.\" . format ( name ) ) if name in deprecated : logger . warning ( \"WARNING: '%s' is deprecated. Use '%s'.\" , name , resolved_name ) return resolved_name", "nl": "Resolve backend name from a deprecated name or an alias ."}}
{"translation": {"code": "def multigraph_layers ( self ) : predecessor_count = dict ( ) # Dict[node, predecessors not visited] cur_layer = [ node for node in self . input_map . values ( ) ] yield cur_layer next_layer = [ ] while cur_layer : for node in cur_layer : # Count multiedges with multiplicity. for successor in self . _multi_graph . successors ( node ) : multiplicity = self . _multi_graph . number_of_edges ( node , successor ) if successor in predecessor_count : predecessor_count [ successor ] -= multiplicity else : predecessor_count [ successor ] = self . _multi_graph . in_degree ( successor ) - multiplicity if predecessor_count [ successor ] == 0 : next_layer . append ( successor ) del predecessor_count [ successor ] yield next_layer cur_layer = next_layer next_layer = [ ]", "nl": "Yield layers of the multigraph ."}}
{"translation": {"code": "def _do_pass ( self , pass_ , dag , options ) : # First, do the requires of pass_ if not options [ \"ignore_requires\" ] : for required_pass in pass_ . requires : dag = self . _do_pass ( required_pass , dag , options ) # Run the pass itself, if not already run if pass_ not in self . valid_passes : if pass_ . is_transformation_pass : pass_ . property_set = self . fenced_property_set new_dag = pass_ . run ( dag ) if not isinstance ( new_dag , DAGCircuit ) : raise TranspilerError ( \"Transformation passes should return a transformed dag.\" \"The pass %s is returning a %s\" % ( type ( pass_ ) . __name__ , type ( new_dag ) ) ) dag = new_dag elif pass_ . is_analysis_pass : pass_ . property_set = self . property_set pass_ . run ( FencedDAGCircuit ( dag ) ) else : raise TranspilerError ( \"I dont know how to handle this type of pass\" ) # update the valid_passes property self . _update_valid_passes ( pass_ , options [ 'ignore_preserves' ] ) return dag", "nl": "Do a pass and its requires ."}}
{"translation": {"code": "def _check_if_fenced ( self , name ) : if name in object . __getattribute__ ( self , '_attributes_to_fence' ) : raise TranspilerAccessError ( \"The fenced %s has the property %s protected\" % ( type ( object . __getattribute__ ( self , '_wrapped' ) ) , name ) )", "nl": "Checks if the attribute name is in the list of attributes to protect . If so raises TranspilerAccessError ."}}
{"translation": {"code": "def controller_factory ( cls , passes , options , * * partial_controller ) : if None in partial_controller . values ( ) : raise TranspilerError ( 'The controller needs a condition.' ) if partial_controller : for registered_controller in cls . registered_controllers . keys ( ) : if registered_controller in partial_controller : return cls . registered_controllers [ registered_controller ] ( passes , options , * * partial_controller ) raise TranspilerError ( \"The controllers for %s are not registered\" % partial_controller ) else : return FlowControllerLinear ( passes , options )", "nl": "Constructs a flow controller based on the partially evaluated controller arguments ."}}
{"translation": {"code": "def params_for_label ( instruction ) : if not hasattr ( instruction . op , 'params' ) : return None if all ( [ isinstance ( param , ndarray ) for param in instruction . op . params ] ) : return None ret = [ ] for param in instruction . op . params : if isinstance ( param , ( sympy . Number , float ) ) : ret . append ( '%.5g' % param ) else : ret . append ( '%s' % param ) return ret", "nl": "Get the params and format them to add them to a label . None if there are no params of if the params are numpy . ndarrays ."}}
{"translation": {"code": "def bot ( self ) : ret = self . bot_format % self . bot_connect . center ( self . width , self . bot_pad ) if self . right_fill : ret = ret . ljust ( self . right_fill , self . bot_pad ) if self . left_fill : ret = ret . rjust ( self . left_fill , self . bot_pad ) ret = ret . center ( self . layer_width , self . bot_bck ) return ret", "nl": "Constructs the bottom line of the element"}}
{"translation": {"code": "def mid ( self ) : ret = self . mid_format % self . mid_content . center ( self . width , self . _mid_padding ) if self . right_fill : ret = ret . ljust ( self . right_fill , self . _mid_padding ) if self . left_fill : ret = ret . rjust ( self . left_fill , self . _mid_padding ) ret = ret . center ( self . layer_width , self . mid_bck ) return ret", "nl": "Constructs the middle line of the element"}}
{"translation": {"code": "def top ( self ) : ret = self . top_format % self . top_connect . center ( self . width , self . top_pad ) if self . right_fill : ret = ret . ljust ( self . right_fill , self . top_pad ) if self . left_fill : ret = ret . rjust ( self . left_fill , self . top_pad ) ret = ret . center ( self . layer_width , self . top_bck ) return ret", "nl": "Constructs the top line of the element"}}
{"translation": {"code": "def label_for_box ( instruction ) : label = instruction . name . capitalize ( ) params = TextDrawing . params_for_label ( instruction ) if params : label += \"(%s)\" % ',' . join ( params ) return label", "nl": "Creates the label for a box ."}}
{"translation": {"code": "def length ( self ) : return max ( len ( self . top ) , len ( self . mid ) , len ( self . bot ) )", "nl": "Returns the length of the element including the box around ."}}
{"translation": {"code": "def _trim ( image ) : background = PIL . Image . new ( image . mode , image . size , image . getpixel ( ( 0 , 0 ) ) ) diff = PIL . ImageChops . difference ( image , background ) diff = PIL . ImageChops . add ( diff , diff , 2.0 , - 100 ) bbox = diff . getbbox ( ) if bbox : image = image . crop ( bbox ) return image", "nl": "Trim a PIL image and remove white space ."}}
{"translation": {"code": "def _get_beamer_page ( self ) : # PIL python package limits image size to around a quarter gigabyte # this means the beamer image should be limited to < 50000 # if you want to avoid a \"warning\" too, set it to < 25000 PIL_limit = 40000 # the beamer latex template limits each dimension to < 19 feet # (i.e. 575cm) beamer_limit = 550 # columns are roughly twice as big as rows aspect_ratio = self . sum_row_heights / self . sum_column_widths # choose a page margin so circuit is not cropped margin_factor = 1.5 height = min ( self . sum_row_heights * margin_factor , beamer_limit ) width = min ( self . sum_column_widths * margin_factor , beamer_limit ) # if too large, make it fit if height * width > PIL_limit : height = min ( np . sqrt ( PIL_limit * aspect_ratio ) , beamer_limit ) width = min ( np . sqrt ( PIL_limit / aspect_ratio ) , beamer_limit ) # if too small, give it a minimum size height = max ( height , 10 ) width = max ( width , 10 ) return ( height , width , self . scale )", "nl": "Get height width & scale attributes for the beamer page ."}}
{"translation": {"code": "def _get_register_specs ( bit_labels ) : it = itertools . groupby ( bit_labels , operator . itemgetter ( 0 ) ) for register_name , sub_it in it : yield register_name , max ( ind [ 1 ] for ind in sub_it ) + 1", "nl": "Get the number and size of unique registers from bit_labels list ."}}
{"translation": {"code": "def _truncate_float ( matchobj , format_str = '0.2g' ) : if matchobj . group ( 0 ) : return format ( float ( matchobj . group ( 0 ) ) , format_str ) return ''", "nl": "Truncate long floats"}}
{"translation": {"code": "def latex ( self , aliases = None ) : self . _initialize_latex_array ( aliases ) self . _build_latex_array ( aliases ) header_1 = r\"\"\"% \\documentclass[preview]{standalone}\n% If the image is too large to fit on this documentclass use\n\\documentclass[draft]{beamer}\n\"\"\" beamer_line = \"\\\\usepackage[size=custom,height=%d,width=%d,scale=%.1f]{beamerposter}\\n\" header_2 = r\"\"\"% instead and customize the height and width (in cm) to fit.\n% Large images may run out of memory quickly.\n% To fix this use the LuaLaTeX compiler, which dynamically\n% allocates memory.\n\\usepackage[braket, qm]{qcircuit}\n\\usepackage{amsmath}\n\\pdfmapfile{+sansmathaccent.map}\n% \\usepackage[landscape]{geometry}\n% Comment out the above line if using the beamer documentclass.\n\\begin{document}\n\\begin{equation*}\"\"\" qcircuit_line = r\"\"\"\n    \\Qcircuit @C=%.1fem @R=%.1fem @!R {\n\"\"\" output = io . StringIO ( ) output . write ( header_1 ) output . write ( '%% img_width = %d, img_depth = %d\\n' % ( self . img_width , self . img_depth ) ) output . write ( beamer_line % self . _get_beamer_page ( ) ) output . write ( header_2 ) output . write ( qcircuit_line % ( self . column_separation , self . row_separation ) ) for i in range ( self . img_width ) : output . write ( \"\\t \\t\" ) for j in range ( self . img_depth + 1 ) : cell_str = self . _latex [ i ] [ j ] # Don't truncate offset float if drawing a barrier if 'barrier' in cell_str : output . write ( cell_str ) else : # floats can cause \"Dimension too large\" latex error in # xymatrix this truncates floats to avoid issue. cell_str = re . sub ( r'[-+]?\\d*\\.\\d{2,}|\\d{2,}' , _truncate_float , cell_str ) output . write ( cell_str ) if j != self . img_depth : output . write ( \" & \" ) else : output . write ( r'\\\\' + '\\n' ) output . write ( '\\t }\\n' ) output . write ( '\\\\end{equation*}\\n\\n' ) output . write ( '\\\\end{document}' ) contents = output . getvalue ( ) output . close ( ) return contents", "nl": "Return LaTeX string representation of circuit ."}}
{"translation": {"code": "def _get_image_depth ( self ) : max_column_widths = [ ] for layer in self . ops : # store the max width for the layer current_max = 0 for op in layer : # update current op width arg_str_len = 0 # the wide gates for arg in op . op . params : arg_str = re . sub ( r'[-+]?\\d*\\.\\d{2,}|\\d{2,}' , _truncate_float , str ( arg ) ) arg_str_len += len ( arg_str ) # the width of the column is the max of all the gates in the column current_max = max ( arg_str_len , current_max ) max_column_widths . append ( current_max ) # wires in the beginning and end columns = 2 # each layer is one column columns += len ( self . ops ) # every 3 characters is roughly one extra 'unit' of width in the cell # the gate name is 1 extra 'unit' # the qubit/cbit labels plus initial states is 2 more # the wires poking out at the ends is 2 more sum_column_widths = sum ( 1 + v / 3 for v in max_column_widths ) # could be a fraction so ceil return columns , math . ceil ( sum_column_widths ) + 4", "nl": "Get depth information for the circuit ."}}
{"translation": {"code": "def compile ( circuits , backend , config = None , basis_gates = None , coupling_map = None , initial_layout = None , shots = 1024 , max_credits = 10 , seed = None , qobj_id = None , seed_mapper = None , pass_manager = None , memory = False ) : warnings . warn ( 'qiskit.compile() is deprecated and will be removed in Qiskit Terra 0.9. ' 'Please use qiskit.compiler.transpile() to transform circuits ' 'and qiskit.compiler.assemble() to produce a runnable qobj.' , DeprecationWarning ) new_circuits = transpile ( circuits , basis_gates = basis_gates , coupling_map = coupling_map , initial_layout = initial_layout , seed_transpiler = seed_mapper , backend = backend , pass_manager = pass_manager ) qobj = assemble ( new_circuits , qobj_header = None , shots = shots , max_credits = max_credits , seed_simulator = seed , memory = memory , qobj_id = qobj_id , config = config ) # deprecated return qobj", "nl": "Compile a list of circuits into a qobj ."}}
{"translation": {"code": "def append ( self , instruction , qargs = None , cargs = None ) : qargs = qargs or [ ] cargs = cargs or [ ] # Convert input to instruction if not isinstance ( instruction , Instruction ) and hasattr ( instruction , 'to_instruction' ) : instruction = instruction . to_instruction ( ) if not isinstance ( instruction , Instruction ) : raise QiskitError ( 'object is not an Instruction.' ) # do some compatibility checks self . _check_dups ( qargs ) self . _check_qargs ( qargs ) self . _check_cargs ( cargs ) if instruction . num_qubits != len ( qargs ) or instruction . num_clbits != len ( cargs ) : raise QiskitError ( \"instruction %s with %d qubits and %d clbits \" \"cannot be appended onto %d qubits and %d clbits.\" % ( instruction . name , instruction . num_qubits , instruction . num_clbits , len ( qargs ) , len ( cargs ) ) ) # add the instruction onto the given wires instruction_context = instruction , qargs , cargs self . data . append ( instruction_context ) # track variable parameters in instruction for param_index , param in enumerate ( instruction . params ) : if isinstance ( param , Parameter ) : current_symbols = self . parameters if param in current_symbols : self . _parameter_table [ param ] . append ( ( instruction , param_index ) ) else : self . _parameter_table [ param ] = [ ( instruction , param_index ) ] return instruction", "nl": "Append an instruction to the end of the circuit modifying the circuit in place ."}}
{"translation": {"code": "def qasm ( self ) : name_param = self . name if self . params : name_param = \"%s(%s)\" % ( name_param , \",\" . join ( [ str ( i ) for i in self . params ] ) ) return self . _qasmif ( name_param )", "nl": "Return a default OpenQASM string for the instruction ."}}
{"translation": {"code": "def add_creg ( self , creg ) : if not isinstance ( creg , ClassicalRegister ) : raise DAGCircuitError ( \"not a ClassicalRegister instance.\" ) if creg . name in self . cregs : raise DAGCircuitError ( \"duplicate register %s\" % creg . name ) self . cregs [ creg . name ] = creg for j in range ( creg . size ) : self . _add_wire ( ( creg , j ) )", "nl": "Add all wires in a classical register ."}}
{"translation": {"code": "def add_qreg ( self , qreg ) : if not isinstance ( qreg , QuantumRegister ) : raise DAGCircuitError ( \"not a QuantumRegister instance.\" ) if qreg . name in self . qregs : raise DAGCircuitError ( \"duplicate register %s\" % qreg . name ) self . qregs [ qreg . name ] = qreg for j in range ( qreg . size ) : self . _add_wire ( ( qreg , j ) )", "nl": "Add all wires in a quantum register ."}}
{"translation": {"code": "def _funm_svd ( a , func ) : U , s , Vh = la . svd ( a , lapack_driver = 'gesvd' ) S = np . diag ( func ( s ) ) return U . dot ( S ) . dot ( Vh )", "nl": "Apply real scalar function to singular values of a matrix ."}}
{"translation": {"code": "def basis_state ( str_state , num ) : n = int ( str_state , 2 ) if num >= len ( str_state ) : state = np . zeros ( 1 << num , dtype = complex ) state [ n ] = 1 return state else : raise QiskitError ( 'size of bitstring is greater than num.' )", "nl": "Return a basis state ndarray ."}}
{"translation": {"code": "def state_fidelity ( state1 , state2 ) : # convert input to numpy arrays s1 = np . array ( state1 ) s2 = np . array ( state2 ) # fidelity of two state vectors if s1 . ndim == 1 and s2 . ndim == 1 : return np . abs ( s2 . conj ( ) . dot ( s1 ) ) ** 2 # fidelity of vector and density matrix elif s1 . ndim == 1 : # psi = s1, rho = s2 return np . abs ( s1 . conj ( ) . dot ( s2 ) . dot ( s1 ) ) elif s2 . ndim == 1 : # psi = s2, rho = s1 return np . abs ( s2 . conj ( ) . dot ( s1 ) . dot ( s2 ) ) # fidelity of two density matrices s1sq = _funm_svd ( s1 , np . sqrt ) s2sq = _funm_svd ( s2 , np . sqrt ) return np . linalg . norm ( s1sq . dot ( s2sq ) , ord = 'nuc' ) ** 2", "nl": "Return the state fidelity between two quantum states ."}}
{"translation": {"code": "def projector ( state , flatten = False ) : density_matrix = np . outer ( state . conjugate ( ) , state ) if flatten : return density_matrix . flatten ( order = 'F' ) return density_matrix", "nl": "maps a pure state to a state matrix"}}
{"translation": {"code": "def _check_compatible_regs ( self , rhs ) : list1 = self . qregs + self . cregs list2 = rhs . qregs + rhs . cregs for element1 in list1 : for element2 in list2 : if element2 . name == element1 . name : if element1 != element2 : raise QiskitError ( \"circuits are not compatible\" )", "nl": "Raise exception if the circuits are defined on incompatible registers"}}
{"translation": {"code": "def subscribe ( self , event , callback ) : if not callable ( callback ) : raise QiskitError ( \"Callback is not a callable!\" ) if event not in self . _subscribers : self . _subscribers [ event ] = [ ] new_subscription = self . _Subscription ( event , callback ) if new_subscription in self . _subscribers [ event ] : # We are not allowing double subscription return False self . _subscribers [ event ] . append ( new_subscription ) return True", "nl": "Subscribes to an event so when it s emitted all the callbacks subscribed will be executed . We are not allowing double registration ."}}
{"translation": {"code": "def dispatch ( self , event , * args , * * kwargs ) : # No event, no subscribers. if event not in self . _subscribers : return for subscriber in self . _subscribers [ event ] : subscriber . callback ( * args , * * kwargs )", "nl": "Emits an event if there are any subscribers ."}}
{"translation": {"code": "def publish ( self , event , * args , * * kwargs ) : return self . _broker . dispatch ( event , * args , * * kwargs )", "nl": "Triggers an event and associates some data to it so if there are any subscribers their callback will be called synchronously ."}}
{"translation": {"code": "def unsubscribe ( self , event , callback ) : try : self . _subscribers [ event ] . remove ( self . _Subscription ( event , callback ) ) except KeyError : return False return True", "nl": "Unsubscribe the specific callback to the event ."}}
{"translation": {"code": "def job_monitor ( job , interval = None , monitor_async = False , quiet = False , output = sys . stdout ) : if interval is None : _interval_set = False interval = 2 else : _interval_set = True if _NOTEBOOK_ENV : if monitor_async : try : import ipywidgets as widgets # pylint: disable=import-error except ImportError : raise ImportError ( 'These functions  need ipywidgets. ' 'Run \"pip install ipywidgets\" before.' ) from qiskit . tools . jupyter . jupyter_magics import _html_checker # pylint: disable=C0412 style = \"font-size:16px;\" header = \"<p style='{style}'>Job Status: %s </p>\" . format ( style = style ) status = widgets . HTML ( value = header % job . status ( ) . value ) display ( status ) thread = threading . Thread ( target = _html_checker , args = ( job , interval , status , header ) ) thread . start ( ) else : _text_checker ( job , interval , _interval_set , quiet = quiet , output = output ) else : if monitor_async : raise QiskitError ( 'monitor_async only available in Jupyter notebooks.' ) _text_checker ( job , interval , _interval_set , quiet = quiet , output = output )", "nl": "Monitor the status of a IBMQJob instance ."}}
{"translation": {"code": "def _text_checker ( job , interval , _interval_set = False , quiet = False , output = sys . stdout ) : status = job . status ( ) msg = status . value prev_msg = msg msg_len = len ( msg ) if not quiet : print ( '\\r%s: %s' % ( 'Job Status' , msg ) , end = '' , file = output ) while status . name not in [ 'DONE' , 'CANCELLED' , 'ERROR' ] : time . sleep ( interval ) status = job . status ( ) msg = status . value if status . name == 'QUEUED' : msg += ' (%s)' % job . queue_position ( ) if not _interval_set : interval = max ( job . queue_position ( ) , 2 ) else : if not _interval_set : interval = 2 # Adjust length of message so there are no artifacts if len ( msg ) < msg_len : msg += ' ' * ( msg_len - len ( msg ) ) elif len ( msg ) > msg_len : msg_len = len ( msg ) if msg != prev_msg and not quiet : print ( '\\r%s: %s' % ( 'Job Status' , msg ) , end = '' , file = output ) prev_msg = msg if not quiet : print ( '' , file = output )", "nl": "A text - based job status checker"}}
{"translation": {"code": "def _html_checker ( job_var , interval , status , header , _interval_set = False ) : job_status = job_var . status ( ) job_status_name = job_status . name job_status_msg = job_status . value status . value = header % ( job_status_msg ) while job_status_name not in [ 'DONE' , 'CANCELLED' ] : time . sleep ( interval ) job_status = job_var . status ( ) job_status_name = job_status . name job_status_msg = job_status . value if job_status_name == 'ERROR' : break else : if job_status_name == 'QUEUED' : job_status_msg += ' (%s)' % job_var . queue_position ( ) if not _interval_set : interval = max ( job_var . queue_position ( ) , 2 ) else : if not _interval_set : interval = 2 status . value = header % ( job_status_msg ) status . value = header % ( job_status_msg )", "nl": "Internal function that updates the status of a HTML job monitor ."}}
{"translation": {"code": "def sgn_prod ( p1 , p2 ) : phase = Pauli . _prod_phase ( p1 , p2 ) new_pauli = p1 * p2 return new_pauli , phase", "nl": "r Multiply two Paulis and track the phase ."}}
{"translation": {"code": "def pauli_single ( cls , num_qubits , index , pauli_label ) : tmp = Pauli . from_label ( pauli_label ) z = np . zeros ( num_qubits , dtype = np . bool ) x = np . zeros ( num_qubits , dtype = np . bool ) z [ index ] = tmp . z [ 0 ] x [ index ] = tmp . x [ 0 ] return cls ( z , x )", "nl": "Generate single qubit pauli at index with pauli_label with length num_qubits ."}}
{"translation": {"code": "def random ( cls , num_qubits , seed = None ) : if seed is not None : np . random . seed ( seed ) z = np . random . randint ( 2 , size = num_qubits ) . astype ( np . bool ) x = np . random . randint ( 2 , size = num_qubits ) . astype ( np . bool ) return cls ( z , x )", "nl": "Return a random Pauli on number of qubits ."}}
{"translation": {"code": "def append_paulis ( self , paulis = None , pauli_labels = None ) : return self . insert_paulis ( None , paulis = paulis , pauli_labels = pauli_labels )", "nl": "Append pauli at the end ."}}
{"translation": {"code": "def from_label ( cls , label ) : z = np . zeros ( len ( label ) , dtype = np . bool ) x = np . zeros ( len ( label ) , dtype = np . bool ) for i , char in enumerate ( label ) : if char == 'X' : x [ - i - 1 ] = True elif char == 'Z' : z [ - i - 1 ] = True elif char == 'Y' : z [ - i - 1 ] = True x [ - i - 1 ] = True elif char != 'I' : raise QiskitError ( \"Pauli string must be only consisted of 'I', 'X', \" \"'Y' or 'Z' but you have {}.\" . format ( char ) ) return cls ( z = z , x = x )", "nl": "r Take pauli string to construct pauli ."}}
{"translation": {"code": "def _init_from_bool ( self , z , x ) : if z is None : raise QiskitError ( \"z vector must not be None.\" ) if x is None : raise QiskitError ( \"x vector must not be None.\" ) if len ( z ) != len ( x ) : raise QiskitError ( \"length of z and x vectors must be \" \"the same. (z: {} vs x: {})\" . format ( len ( z ) , len ( x ) ) ) z = _make_np_bool ( z ) x = _make_np_bool ( x ) self . _z = z self . _x = x return self", "nl": "Construct pauli from boolean array ."}}
{"translation": {"code": "def _deserialize ( self , value , attr , data ) : try : return super ( ) . _deserialize ( value , attr , data ) except ValidationError as ex : if 'deserialization_schema_selector' in ex . messages [ 0 ] : ex . messages [ 0 ] = 'Cannot find a valid schema among the choices' raise", "nl": "Override _deserialize for customizing the exception raised ."}}
{"translation": {"code": "def _serialize ( self , value , key , obj ) : try : return super ( ) . _serialize ( value , key , obj ) except TypeError as ex : if 'serialization_schema_selector' in str ( ex ) : raise ValidationError ( 'Data from an invalid schema' ) raise", "nl": "Override _serialize for customizing the exception raised ."}}
{"translation": {"code": "def _validate_after_init ( init_method ) : @ wraps ( init_method ) def _decorated ( self , * * kwargs ) : try : _ = self . shallow_schema . validate ( kwargs ) except ValidationError as ex : raise ModelValidationError ( ex . messages , ex . field_names , ex . fields , ex . data , * * ex . kwargs ) from None init_method ( self , * * kwargs ) return _decorated", "nl": "Add validation after instantiation ."}}
{"translation": {"code": "def _validate ( instance ) : try : _ = instance . schema . validate ( instance . to_dict ( ) ) except ValidationError as ex : raise ModelValidationError ( ex . messages , ex . field_names , ex . fields , ex . data , * * ex . kwargs )", "nl": "Validate the internal representation of the instance ."}}
{"translation": {"code": "def _create_validation_schema ( schema_cls ) : validation_schema = schema_cls ( ) for _ , field in validation_schema . fields . items ( ) : if isinstance ( field , ModelTypeValidator ) : validate_function = field . __class__ . check_type field . _deserialize = MethodType ( validate_function , field ) return validation_schema", "nl": "Create a patched Schema for validating models ."}}
{"translation": {"code": "def load_additional_data ( self , valid_data , many , original_data ) : if many : for i , _ in enumerate ( valid_data ) : additional_keys = set ( original_data [ i ] ) - set ( valid_data [ i ] ) for key in additional_keys : valid_data [ i ] [ key ] = original_data [ i ] [ key ] else : additional_keys = set ( original_data ) - set ( valid_data ) for key in additional_keys : valid_data [ key ] = original_data [ key ] return valid_data", "nl": "Include unknown fields after load ."}}
{"translation": {"code": "def dump_additional_data ( self , valid_data , many , original_data ) : if many : for i , _ in enumerate ( valid_data ) : additional_keys = set ( original_data [ i ] . __dict__ ) - set ( valid_data [ i ] ) for key in additional_keys : valid_data [ i ] [ key ] = getattr ( original_data [ i ] , key ) else : additional_keys = set ( original_data . __dict__ ) - set ( valid_data ) for key in additional_keys : valid_data [ key ] = getattr ( original_data , key ) return valid_data", "nl": "Include unknown fields after dumping ."}}
{"translation": {"code": "def topological_nodes ( self ) : return nx . lexicographical_topological_sort ( self . _multi_graph , key = lambda x : str ( x . qargs ) )", "nl": "Yield nodes in topological order ."}}
{"translation": {"code": "def draw ( self , scale = 0.7 , filename = None , style = None , output = 'text' , interactive = False , line_length = None , plot_barriers = True , reverse_bits = False , justify = None ) : from qiskit . tools import visualization return visualization . circuit_drawer ( self , scale = scale , filename = filename , style = style , output = output , interactive = interactive , line_length = line_length , plot_barriers = plot_barriers , reverse_bits = reverse_bits , justify = justify )", "nl": "Draw the quantum circuit"}}
{"translation": {"code": "def check_type ( self , value , attr , data ) : for field in self . choices : if isinstance ( field , ModelTypeValidator ) : try : return field . check_type ( value , attr , data ) except ValidationError : pass raise self . _not_expected_type ( value , [ field . __class__ for field in self . choices ] , fields = [ self ] , field_names = attr , data = data )", "nl": "Check if at least one of the possible choices validates the value ."}}
{"translation": {"code": "def process_fidelity ( channel1 , channel2 , require_cptp = True ) : # First we must determine if input is to be interpreted as a unitary matrix # or as a channel. # If input is a raw numpy array we will interpret it as a unitary matrix. is_cptp1 = None is_cptp2 = None if isinstance ( channel1 , ( list , np . ndarray ) ) : channel1 = Operator ( channel1 ) if require_cptp : is_cptp1 = channel1 . is_unitary ( ) if isinstance ( channel2 , ( list , np . ndarray ) ) : channel2 = Operator ( channel2 ) if require_cptp : is_cptp2 = channel2 . is_unitary ( ) # Next we convert inputs SuperOp objects # This works for objects that also have a `to_operator` or `to_channel` method s1 = SuperOp ( channel1 ) s2 = SuperOp ( channel2 ) # Check inputs are CPTP if require_cptp : # Only check SuperOp if we didn't already check unitary inputs if is_cptp1 is None : is_cptp1 = s1 . is_cptp ( ) if not is_cptp1 : raise QiskitError ( 'channel1 is not CPTP' ) if is_cptp2 is None : is_cptp2 = s2 . is_cptp ( ) if not is_cptp2 : raise QiskitError ( 'channel2 is not CPTP' ) # Check dimensions match input_dim1 , output_dim1 = s1 . dim input_dim2 , output_dim2 = s2 . dim if input_dim1 != output_dim1 or input_dim2 != output_dim2 : raise QiskitError ( 'Input channels must have same size input and output dimensions.' ) if input_dim1 != input_dim2 : raise QiskitError ( 'Input channels have different dimensions.' ) # Compute process fidelity fidelity = np . trace ( s1 . compose ( s2 . adjoint ( ) ) . data ) / ( input_dim1 ** 2 ) return fidelity", "nl": "Return the process fidelity between two quantum channels ."}}
{"translation": {"code": "def count_ops ( self ) : count_ops = { } for instr , _ , _ in self . data : if instr . name in count_ops . keys ( ) : count_ops [ instr . name ] += 1 else : count_ops [ instr . name ] = 1 return count_ops", "nl": "Count each operation kind in the circuit ."}}
{"translation": {"code": "def width ( self ) : return sum ( reg . size for reg in self . qregs + self . cregs )", "nl": "Return number of qubits plus clbits in circuit ."}}
{"translation": {"code": "def size ( self ) : gate_ops = 0 for instr , _ , _ in self . data : if instr . name not in [ 'barrier' , 'snapshot' ] : gate_ops += 1 return gate_ops", "nl": "Returns total number of gate operations in circuit ."}}
{"translation": {"code": "def average_data ( counts , observable ) : if not isinstance ( observable , dict ) : observable = make_dict_observable ( observable ) temp = 0 tot = sum ( counts . values ( ) ) for key in counts : if key in observable : temp += counts [ key ] * observable [ key ] / tot return temp", "nl": "Compute the mean value of an diagonal observable ."}}
{"translation": {"code": "def gate_nodes ( self ) : nodes = [ ] for node in self . op_nodes ( ) : if isinstance ( node . op , Gate ) : nodes . append ( node ) return nodes", "nl": "Get the list of gate nodes in the dag ."}}
{"translation": {"code": "def op_nodes ( self , op = None ) : nodes = [ ] for node in self . _multi_graph . nodes ( ) : if node . type == \"op\" : if op is None or isinstance ( node . op , op ) : nodes . append ( node ) return nodes", "nl": "Get the list of op nodes in the dag ."}}
{"translation": {"code": "def _validate_input_state ( quantum_state ) : rho = np . asarray ( quantum_state ) if rho . ndim == 1 : rho = np . outer ( rho , np . conj ( rho ) ) # Check the shape of the input is a square matrix shape = np . shape ( rho ) if len ( shape ) != 2 or shape [ 0 ] != shape [ 1 ] : raise VisualizationError ( \"Input is not a valid quantum state.\" ) # Check state is an n-qubit state num = int ( np . log2 ( rho . shape [ 0 ] ) ) if 2 ** num != rho . shape [ 0 ] : raise VisualizationError ( \"Input is not a multi-qubit quantum state.\" ) return rho", "nl": "Validates the input to state visualization functions ."}}
{"translation": {"code": "def _validate ( self , qobj ) : n_qubits = qobj . config . n_qubits max_qubits = self . configuration ( ) . n_qubits if n_qubits > max_qubits : raise BasicAerError ( 'Number of qubits {} ' . format ( n_qubits ) + 'is greater than maximum ({}) ' . format ( max_qubits ) + 'for \"{}\".' . format ( self . name ( ) ) ) if hasattr ( qobj . config , 'shots' ) and qobj . config . shots != 1 : logger . info ( '\"%s\" only supports 1 shot. Setting shots=1.' , self . name ( ) ) qobj . config . shots = 1 for experiment in qobj . experiments : name = experiment . header . name if getattr ( experiment . config , 'shots' , 1 ) != 1 : logger . info ( '\"%s\" only supports 1 shot. ' 'Setting shots=1 for circuit \"%s\".' , self . name ( ) , name ) experiment . config . shots = 1 for operation in experiment . instructions : if operation . name in [ 'measure' , 'reset' ] : raise BasicAerError ( 'Unsupported \"%s\" instruction \"%s\" ' + 'in circuit \"%s\" ' , self . name ( ) , operation . name , name )", "nl": "Semantic validations of the qobj which cannot be done via schemas . Some of these may later move to backend schemas . 1 . No shots 2 . No measurements in the middle"}}
{"translation": {"code": "def circuit_to_dag ( circuit ) : dagcircuit = DAGCircuit ( ) dagcircuit . name = circuit . name for register in circuit . qregs : dagcircuit . add_qreg ( register ) for register in circuit . cregs : dagcircuit . add_creg ( register ) for instruction , qargs , cargs in circuit . data : # Get arguments for classical control (if any) if instruction . control is None : control = None else : control = ( instruction . control [ 0 ] , instruction . control [ 1 ] ) dagcircuit . apply_operation_back ( instruction . copy ( ) , qargs , cargs , control ) return dagcircuit", "nl": "Build a DAGCircuit object from a QuantumCircuit ."}}
{"translation": {"code": "def circuits_to_qobj ( circuits , qobj_header = None , qobj_id = None , backend_name = None , config = None , shots = None , max_credits = None , basis_gates = None , coupling_map = None , seed = None , memory = None ) : warnings . warn ( 'circuits_to_qobj is deprecated and will be removed in Qiskit Terra 0.9. ' 'Use qiskit.compiler.assemble() to serialize circuits into a qobj.' , DeprecationWarning ) qobj_header = qobj_header or QobjHeader ( ) if backend_name : qobj_header . backend_name = backend_name if basis_gates : warnings . warn ( 'basis_gates was unused and will be removed.' , DeprecationWarning ) if coupling_map : warnings . warn ( 'coupling_map was unused and will be removed.' , DeprecationWarning ) qobj = assemble ( experiments = circuits , qobj_id = qobj_id , qobj_header = qobj_header , shots = shots , memory = memory , max_credits = max_credits , seed_simulator = seed , config = config ) return qobj", "nl": "Convert a list of circuits into a qobj ."}}
{"translation": {"code": "def dag_to_circuit ( dag ) : qregs = collections . OrderedDict ( ) for qreg in dag . qregs . values ( ) : qreg_tmp = QuantumRegister ( qreg . size , name = qreg . name ) qregs [ qreg . name ] = qreg_tmp cregs = collections . OrderedDict ( ) for creg in dag . cregs . values ( ) : creg_tmp = ClassicalRegister ( creg . size , name = creg . name ) cregs [ creg . name ] = creg_tmp name = dag . name or None circuit = QuantumCircuit ( * qregs . values ( ) , * cregs . values ( ) , name = name ) for node in dag . topological_op_nodes ( ) : qubits = [ ] for qubit in node . qargs : qubits . append ( qregs [ qubit [ 0 ] . name ] [ qubit [ 1 ] ] ) clbits = [ ] for clbit in node . cargs : clbits . append ( cregs [ clbit [ 0 ] . name ] [ clbit [ 1 ] ] ) # Get arguments for classical control (if any) if node . condition is None : control = None else : control = ( node . condition [ 0 ] , node . condition [ 1 ] ) inst = node . op . copy ( ) inst . control = control circuit . append ( inst , qubits , clbits ) return circuit", "nl": "Build a QuantumCircuit object from a DAGCircuit ."}}
{"translation": {"code": "def format_unitary ( mat , decimals = None ) : num_basis = len ( mat ) mat_complex = np . zeros ( ( num_basis , num_basis ) , dtype = complex ) for i , vec in enumerate ( mat ) : mat_complex [ i ] = format_statevector ( vec , decimals ) return mat_complex", "nl": "Format unitary coming from the backend to present to the Qiskit user ."}}
{"translation": {"code": "def _separate_bitstring ( bitstring , creg_sizes ) : substrings = [ ] running_index = 0 for _ , size in reversed ( creg_sizes ) : substrings . append ( bitstring [ running_index : running_index + size ] ) running_index += size return ' ' . join ( substrings )", "nl": "Separate a bitstring according to the registers defined in the result header ."}}
{"translation": {"code": "def format_counts ( counts , header = None ) : counts_dict = { } for key , val in counts . items ( ) : key = format_counts_memory ( key , header ) counts_dict [ key ] = val return counts_dict", "nl": "Format a single experiment result coming from backend to present to the Qiskit user ."}}
{"translation": {"code": "def format_statevector ( vec , decimals = None ) : num_basis = len ( vec ) vec_complex = np . zeros ( num_basis , dtype = complex ) for i in range ( num_basis ) : vec_complex [ i ] = vec [ i ] [ 0 ] + 1j * vec [ i ] [ 1 ] if decimals : vec_complex = np . around ( vec_complex , decimals = decimals ) return vec_complex", "nl": "Format statevector coming from the backend to present to the Qiskit user ."}}
{"translation": {"code": "def check_type ( self , value , attr , data ) : if self . many and not is_collection ( value ) : raise self . _not_expected_type ( value , Iterable , fields = [ self ] , field_names = attr , data = data ) _check_type = super ( ) . check_type errors = [ ] values = value if self . many else [ value ] for idx , v in enumerate ( values ) : try : _check_type ( v , idx , values ) except ValidationError as err : errors . append ( err . messages ) if errors : errors = errors if self . many else errors [ 0 ] raise ValidationError ( errors ) return value", "nl": "Validate if the value is of the type of the schema s model ."}}
{"translation": {"code": "def check_type ( self , value , attr , data ) : expected_types = self . _expected_types ( ) if not isinstance ( value , expected_types ) : raise self . _not_expected_type ( value , expected_types , fields = [ self ] , field_names = attr , data = data ) return value", "nl": "Validates a value against the correct type of the field ."}}
{"translation": {"code": "def check_type ( self , value , attr , data ) : super ( ) . check_type ( value , attr , data ) errors = [ ] for idx , v in enumerate ( value ) : try : self . container . check_type ( v , idx , value ) except ValidationError as err : errors . append ( err . messages ) if errors : raise ValidationError ( errors ) return value", "nl": "Validate if it s a list of valid item - field values ."}}
{"translation": {"code": "def to_dict ( self ) : try : data , _ = self . schema . dump ( self ) except ValidationError as ex : raise ModelValidationError ( ex . messages , ex . field_names , ex . fields , ex . data , * * ex . kwargs ) from None return data", "nl": "Serialize the model into a Python dict of simple types ."}}
{"translation": {"code": "def from_dict ( cls , dict_ ) : try : data , _ = cls . schema . load ( dict_ ) except ValidationError as ex : raise ModelValidationError ( ex . messages , ex . field_names , ex . fields , ex . data , * * ex . kwargs ) from None return data", "nl": "Deserialize a dict of simple types into an instance of this class ."}}
{"translation": {"code": "def extend_back ( self , dag , edge_map = None ) : edge_map = edge_map or { } for qreg in dag . qregs . values ( ) : if qreg . name not in self . qregs : self . add_qreg ( QuantumRegister ( qreg . size , qreg . name ) ) edge_map . update ( [ ( qbit , qbit ) for qbit in qreg if qbit not in edge_map ] ) for creg in dag . cregs . values ( ) : if creg . name not in self . cregs : self . add_creg ( ClassicalRegister ( creg . size , creg . name ) ) edge_map . update ( [ ( cbit , cbit ) for cbit in creg if cbit not in edge_map ] ) self . compose_back ( dag , edge_map )", "nl": "Add dag at the end of self using edge_map ."}}
{"translation": {"code": "def run ( self , dag ) : # Walk through the DAG and expand each non-basis node for node in dag . op_nodes ( ) : basic_insts = [ 'measure' , 'reset' , 'barrier' , 'snapshot' ] if node . name in basic_insts : # TODO: this is legacy behavior.Basis_insts should be removed that these #  instructions should be part of the device-reported basis. Currently, no #  backend reports \"measure\", for example. continue if node . name in self . basis : # If already a base, ignore. continue # TODO: allow choosing other possible decompositions rule = node . op . definition if not rule : raise QiskitError ( \"Cannot unroll the circuit to the given basis, %s. \" \"No rule to expand instruction %s.\" % ( str ( self . basis ) , node . op . name ) ) # hacky way to build a dag on the same register as the rule is defined # TODO: need anonymous rules to address wires by index decomposition = DAGCircuit ( ) decomposition . add_qreg ( rule [ 0 ] [ 1 ] [ 0 ] [ 0 ] ) for inst in rule : decomposition . apply_operation_back ( * inst ) unrolled_dag = self . run ( decomposition ) # recursively unroll ops dag . substitute_node_with_dag ( node , unrolled_dag ) return dag", "nl": "Expand all op nodes to the given basis ."}}
{"translation": {"code": "def _process_if ( self , node ) : creg_name = node . children [ 0 ] . name creg = self . dag . cregs [ creg_name ] cval = node . children [ 1 ] . value self . condition = ( creg , cval ) self . _process_node ( node . children [ 2 ] ) self . condition = None", "nl": "Process an if node ."}}
{"translation": {"code": "def _process_measure ( self , node ) : id0 = self . _process_bit_id ( node . children [ 0 ] ) id1 = self . _process_bit_id ( node . children [ 1 ] ) if len ( id0 ) != len ( id1 ) : raise QiskitError ( \"internal error: reg size mismatch\" , \"line=%s\" % node . line , \"file=%s\" % node . file ) for idx , idy in zip ( id0 , id1 ) : self . dag . apply_operation_back ( Measure ( ) , [ idx ] , [ idy ] , self . condition )", "nl": "Process a measurement node ."}}
{"translation": {"code": "def _process_cnot ( self , node ) : id0 = self . _process_bit_id ( node . children [ 0 ] ) id1 = self . _process_bit_id ( node . children [ 1 ] ) if not ( len ( id0 ) == len ( id1 ) or len ( id0 ) == 1 or len ( id1 ) == 1 ) : raise QiskitError ( \"internal error: qreg size mismatch\" , \"line=%s\" % node . line , \"file=%s\" % node . file ) maxidx = max ( [ len ( id0 ) , len ( id1 ) ] ) for idx in range ( maxidx ) : if len ( id0 ) > 1 and len ( id1 ) > 1 : self . dag . apply_operation_back ( CXBase ( ) , [ id0 [ idx ] , id1 [ idx ] ] , [ ] , self . condition ) elif len ( id0 ) > 1 : self . dag . apply_operation_back ( CXBase ( ) , [ id0 [ idx ] , id1 [ 0 ] ] , [ ] , self . condition ) else : self . dag . apply_operation_back ( CXBase ( ) , [ id0 [ 0 ] , id1 [ idx ] ] , [ ] , self . condition )", "nl": "Process a CNOT gate node ."}}
{"translation": {"code": "def _process_gate ( self , node , opaque = False ) : self . gates [ node . name ] = { } de_gate = self . gates [ node . name ] de_gate [ \"print\" ] = True # default de_gate [ \"opaque\" ] = opaque de_gate [ \"n_args\" ] = node . n_args ( ) de_gate [ \"n_bits\" ] = node . n_bits ( ) if node . n_args ( ) > 0 : de_gate [ \"args\" ] = [ element . name for element in node . arguments . children ] else : de_gate [ \"args\" ] = [ ] de_gate [ \"bits\" ] = [ c . name for c in node . bitlist . children ] if opaque : de_gate [ \"body\" ] = None else : de_gate [ \"body\" ] = node . body", "nl": "Process a gate node ."}}
{"translation": {"code": "def _process_custom_unitary ( self , node ) : name = node . name if node . arguments is not None : args = self . _process_node ( node . arguments ) else : args = [ ] bits = [ self . _process_bit_id ( node_element ) for node_element in node . bitlist . children ] if name in self . gates : gargs = self . gates [ name ] [ \"args\" ] gbits = self . gates [ name ] [ \"bits\" ] # Loop over register arguments, if any. maxidx = max ( map ( len , bits ) ) for idx in range ( maxidx ) : self . arg_stack . append ( { gargs [ j ] : args [ j ] for j in range ( len ( gargs ) ) } ) # Only index into register arguments. element = [ idx * x for x in [ len ( bits [ j ] ) > 1 for j in range ( len ( bits ) ) ] ] self . bit_stack . append ( { gbits [ j ] : bits [ j ] [ element [ j ] ] for j in range ( len ( gbits ) ) } ) self . _create_dag_op ( name , [ self . arg_stack [ - 1 ] [ s ] . sym ( ) for s in gargs ] , [ self . bit_stack [ - 1 ] [ s ] for s in gbits ] ) self . arg_stack . pop ( ) self . bit_stack . pop ( ) else : raise QiskitError ( \"internal error undefined gate:\" , \"line=%s\" % node . line , \"file=%s\" % node . file )", "nl": "Process a custom unitary node ."}}
{"translation": {"code": "def _process_bit_id ( self , node ) : # pylint: disable=inconsistent-return-statements reg = None if node . name in self . dag . qregs : reg = self . dag . qregs [ node . name ] elif node . name in self . dag . cregs : reg = self . dag . cregs [ node . name ] else : raise QiskitError ( \"expected qreg or creg name:\" , \"line=%s\" % node . line , \"file=%s\" % node . file ) if node . type == \"indexed_id\" : # An indexed bit or qubit return [ ( reg , node . index ) ] elif node . type == \"id\" : # A qubit or qreg or creg if not self . bit_stack [ - 1 ] : # Global scope return [ ( reg , j ) for j in range ( reg . size ) ] else : # local scope if node . name in self . bit_stack [ - 1 ] : return [ self . bit_stack [ - 1 ] [ node . name ] ] raise QiskitError ( \"expected local bit name:\" , \"line=%s\" % node . line , \"file=%s\" % node . file ) return None", "nl": "Process an Id or IndexedId node as a bit or register type ."}}
{"translation": {"code": "def _create_dag_op ( self , name , params , qargs ) : if name == \"u0\" : op_class = U0Gate elif name == \"u1\" : op_class = U1Gate elif name == \"u2\" : op_class = U2Gate elif name == \"u3\" : op_class = U3Gate elif name == \"x\" : op_class = XGate elif name == \"y\" : op_class = YGate elif name == \"z\" : op_class = ZGate elif name == \"t\" : op_class = TGate elif name == \"tdg\" : op_class = TdgGate elif name == \"s\" : op_class = SGate elif name == \"sdg\" : op_class = SdgGate elif name == \"swap\" : op_class = SwapGate elif name == \"rx\" : op_class = RXGate elif name == \"ry\" : op_class = RYGate elif name == \"rz\" : op_class = RZGate elif name == \"rzz\" : op_class = RZZGate elif name == \"id\" : op_class = IdGate elif name == \"h\" : op_class = HGate elif name == \"cx\" : op_class = CnotGate elif name == \"cy\" : op_class = CyGate elif name == \"cz\" : op_class = CzGate elif name == \"ch\" : op_class = CHGate elif name == \"crz\" : op_class = CrzGate elif name == \"cu1\" : op_class = Cu1Gate elif name == \"cu3\" : op_class = Cu3Gate elif name == \"ccx\" : op_class = ToffoliGate elif name == \"cswap\" : op_class = FredkinGate else : raise QiskitError ( \"unknown operation for ast node name %s\" % name ) op = op_class ( * params ) self . dag . apply_operation_back ( op , qargs , [ ] , condition = self . condition )", "nl": "Create a DAG node out of a parsed AST op node ."}}
{"translation": {"code": "def _map_free_gates ( layout , gates , coupling_map ) : blocked_qubits = set ( ) mapped_gates = [ ] remaining_gates = [ ] for gate in gates : # Gates without a partition (barrier, snapshot, save, load, noise) may # still have associated qubits. Look for them in the qargs. if not gate [ 'partition' ] : qubits = [ n for n in gate [ 'graph' ] . nodes ( ) if n . type == 'op' ] [ 0 ] . qargs if not qubits : continue if blocked_qubits . intersection ( qubits ) : blocked_qubits . update ( qubits ) remaining_gates . append ( gate ) else : mapped_gate = _transform_gate_for_layout ( gate , layout ) mapped_gates . append ( mapped_gate ) continue qubits = gate [ 'partition' ] [ 0 ] if blocked_qubits . intersection ( qubits ) : blocked_qubits . update ( qubits ) remaining_gates . append ( gate ) elif len ( qubits ) == 1 : mapped_gate = _transform_gate_for_layout ( gate , layout ) mapped_gates . append ( mapped_gate ) elif coupling_map . distance ( * [ layout [ q ] for q in qubits ] ) == 1 : mapped_gate = _transform_gate_for_layout ( gate , layout ) mapped_gates . append ( mapped_gate ) else : blocked_qubits . update ( qubits ) remaining_gates . append ( gate ) return mapped_gates , remaining_gates", "nl": "Map all gates that can be executed with the current layout ."}}
{"translation": {"code": "def _calc_layout_distance ( gates , coupling_map , layout , max_gates = None ) : if max_gates is None : max_gates = 50 + 10 * len ( coupling_map . physical_qubits ) return sum ( coupling_map . distance ( * [ layout [ q ] for q in gate [ 'partition' ] [ 0 ] ] ) for gate in gates [ : max_gates ] if gate [ 'partition' ] and len ( gate [ 'partition' ] [ 0 ] ) == 2 )", "nl": "Return the sum of the distances of two - qubit pairs in each CNOT in gates according to the layout and the coupling ."}}
{"translation": {"code": "def _score_step ( step ) : # Each added swap will add 3 ops to gates_mapped, so subtract 3. return len ( [ g for g in step [ 'gates_mapped' ] if len ( g . qargs ) == 2 ] ) - 3 * step [ 'swaps_added' ]", "nl": "Count the mapped two - qubit gates less the number of added SWAPs ."}}
{"translation": {"code": "def _swap_ops_from_edge ( edge , layout ) : device_qreg = QuantumRegister ( len ( layout . get_physical_bits ( ) ) , 'q' ) qreg_edge = [ ( device_qreg , i ) for i in edge ] # TODO shouldn't be making other nodes not by the DAG!! return [ DAGNode ( { 'op' : SwapGate ( ) , 'qargs' : qreg_edge , 'cargs' : [ ] , 'type' : 'op' } ) ]", "nl": "Generate list of ops to implement a SWAP gate along a coupling edge ."}}
{"translation": {"code": "def _transform_gate_for_layout ( gate , layout ) : mapped_op_node = deepcopy ( [ n for n in gate [ 'graph' ] . nodes ( ) if n . type == 'op' ] [ 0 ] ) # Workaround until #1816, apply mapped to qargs to both DAGNode and op device_qreg = QuantumRegister ( len ( layout . get_physical_bits ( ) ) , 'q' ) mapped_qargs = [ ( device_qreg , layout [ a ] ) for a in mapped_op_node . qargs ] mapped_op_node . qargs = mapped_op_node . op . qargs = mapped_qargs mapped_op_node . pop ( 'name' ) return mapped_op_node", "nl": "Return op implementing a virtual gate on given layout ."}}
{"translation": {"code": "def run ( self , dag ) : coupling_map = self . _coupling_map ordered_virtual_gates = list ( dag . serial_layers ( ) ) if self . initial_layout is None : if self . property_set [ \"layout\" ] : self . initial_layout = self . property_set [ \"layout\" ] else : self . initial_layout = Layout . generate_trivial_layout ( * dag . qregs . values ( ) ) if len ( dag . qubits ( ) ) != len ( self . initial_layout ) : raise TranspilerError ( 'The layout does not match the amount of qubits in the DAG' ) if len ( self . _coupling_map . physical_qubits ) != len ( self . initial_layout ) : raise TranspilerError ( \"Mappers require to have the layout to be the same size as the coupling map\" ) mapped_gates = [ ] layout = self . initial_layout . copy ( ) gates_remaining = ordered_virtual_gates . copy ( ) while gates_remaining : best_step = _search_forward_n_swaps ( layout , gates_remaining , coupling_map ) layout = best_step [ 'layout' ] gates_mapped = best_step [ 'gates_mapped' ] gates_remaining = best_step [ 'gates_remaining' ] mapped_gates . extend ( gates_mapped ) # Preserve input DAG's name, regs, wire_map, etc. but replace the graph. mapped_dag = _copy_circuit_metadata ( dag , coupling_map ) for node in mapped_gates : mapped_dag . apply_operation_back ( op = node . op , qargs = node . qargs , cargs = node . cargs ) return mapped_dag", "nl": "Run one pass of the lookahead mapper on the provided DAG ."}}
{"translation": {"code": "def _copy_circuit_metadata ( source_dag , coupling_map ) : target_dag = DAGCircuit ( ) target_dag . name = source_dag . name for creg in source_dag . cregs . values ( ) : target_dag . add_creg ( creg ) device_qreg = QuantumRegister ( len ( coupling_map . physical_qubits ) , 'q' ) target_dag . add_qreg ( device_qreg ) return target_dag", "nl": "Return a copy of source_dag with metadata but empty . Generate only a single qreg in the output DAG matching the size of the coupling_map ."}}
{"translation": {"code": "def _search_forward_n_swaps ( layout , gates , coupling_map , depth = SEARCH_DEPTH , width = SEARCH_WIDTH ) : gates_mapped , gates_remaining = _map_free_gates ( layout , gates , coupling_map ) base_step = { 'layout' : layout , 'swaps_added' : 0 , 'gates_mapped' : gates_mapped , 'gates_remaining' : gates_remaining } if not gates_remaining or depth == 0 : return base_step possible_swaps = coupling_map . get_edges ( ) def _score_swap ( swap ) : \"\"\"Calculate the relative score for a given SWAP.\"\"\" trial_layout = layout . copy ( ) trial_layout . swap ( * swap ) return _calc_layout_distance ( gates , coupling_map , trial_layout ) ranked_swaps = sorted ( possible_swaps , key = _score_swap ) best_swap , best_step = None , None for swap in ranked_swaps [ : width ] : trial_layout = layout . copy ( ) trial_layout . swap ( * swap ) next_step = _search_forward_n_swaps ( trial_layout , gates_remaining , coupling_map , depth - 1 , width ) # ranked_swaps already sorted by distance, so distance is the tie-breaker. if best_swap is None or _score_step ( next_step ) > _score_step ( best_step ) : best_swap , best_step = swap , next_step best_swap_gate = _swap_ops_from_edge ( best_swap , layout ) return { 'layout' : best_step [ 'layout' ] , 'swaps_added' : 1 + best_step [ 'swaps_added' ] , 'gates_remaining' : best_step [ 'gates_remaining' ] , 'gates_mapped' : gates_mapped + best_swap_gate + best_step [ 'gates_mapped' ] , }", "nl": "Search for SWAPs which allow for application of largest number of gates ."}}
{"translation": {"code": "def _validate_initial_unitary ( self ) : # If initial unitary isn't set we don't need to validate if self . _initial_unitary is None : return # Check unitary is correct length for number of qubits shape = np . shape ( self . _initial_unitary ) required_shape = ( 2 ** self . _number_of_qubits , 2 ** self . _number_of_qubits ) if shape != required_shape : raise BasicAerError ( 'initial unitary is incorrect shape: ' + '{} != 2 ** {}' . format ( shape , required_shape ) )", "nl": "Validate an initial unitary matrix"}}
{"translation": {"code": "def _validate_initial_statevector ( self ) : # If initial statevector isn't set we don't need to validate if self . _initial_statevector is None : return # Check statevector is correct length for number of qubits length = len ( self . _initial_statevector ) required_dim = 2 ** self . _number_of_qubits if length != required_dim : raise BasicAerError ( 'initial statevector is incorrect length: ' + '{} != {}' . format ( length , required_dim ) )", "nl": "Validate an initial statevector"}}
{"translation": {"code": "def _initialize_unitary ( self ) : self . _validate_initial_unitary ( ) if self . _initial_unitary is None : # Set to identity matrix self . _unitary = np . eye ( 2 ** self . _number_of_qubits , dtype = complex ) else : self . _unitary = self . _initial_unitary . copy ( ) # Reshape to rank-N tensor self . _unitary = np . reshape ( self . _unitary , self . _number_of_qubits * [ 2 , 2 ] )", "nl": "Set the initial unitary for simulation"}}
{"translation": {"code": "def _get_unitary ( self ) : unitary = np . reshape ( self . _unitary , 2 * [ 2 ** self . _number_of_qubits ] ) # Expand complex numbers unitary = np . stack ( ( unitary . real , unitary . imag ) , axis = - 1 ) # Truncate small values unitary [ abs ( unitary ) < self . _chop_threshold ] = 0.0 return unitary", "nl": "Return the current unitary in JSON Result spec format"}}
{"translation": {"code": "def _initialize_statevector ( self ) : if self . _initial_statevector is None : # Set to default state of all qubits in |0> self . _statevector = np . zeros ( 2 ** self . _number_of_qubits , dtype = complex ) self . _statevector [ 0 ] = 1 else : self . _statevector = self . _initial_statevector . copy ( ) # Reshape to rank-N tensor self . _statevector = np . reshape ( self . _statevector , self . _number_of_qubits * [ 2 ] )", "nl": "Set the initial statevector for simulation"}}
{"translation": {"code": "def _get_statevector ( self ) : vec = np . reshape ( self . _statevector , 2 ** self . _number_of_qubits ) # Expand complex numbers vec = np . stack ( [ vec . real , vec . imag ] , axis = 1 ) # Truncate small values vec [ abs ( vec ) < self . _chop_threshold ] = 0.0 return vec", "nl": "Return the current statevector in JSON Result spec format"}}
{"translation": {"code": "def _add_sample_measure ( self , measure_params , num_samples ) : # Get unique qubits that are actually measured measured_qubits = list ( { qubit for qubit , cmembit in measure_params } ) num_measured = len ( measured_qubits ) # Axis for numpy.sum to compute probabilities axis = list ( range ( self . _number_of_qubits ) ) for qubit in reversed ( measured_qubits ) : # Remove from largest qubit to smallest so list position is correct # with respect to position from end of the list axis . remove ( self . _number_of_qubits - 1 - qubit ) probabilities = np . reshape ( np . sum ( np . abs ( self . _statevector ) ** 2 , axis = tuple ( axis ) ) , 2 ** num_measured ) # Generate samples on measured qubits samples = self . _local_random . choice ( range ( 2 ** num_measured ) , num_samples , p = probabilities ) # Convert to bit-strings memory = [ ] for sample in samples : classical_memory = self . _classical_memory for count , ( qubit , cmembit ) in enumerate ( sorted ( measure_params ) ) : qubit_outcome = int ( ( sample & ( 1 << count ) ) >> count ) membit = 1 << cmembit classical_memory = ( classical_memory & ( ~ membit ) ) | ( qubit_outcome << cmembit ) value = bin ( classical_memory ) [ 2 : ] memory . append ( hex ( int ( value , 2 ) ) ) return memory", "nl": "Generate memory samples from current statevector ."}}
{"translation": {"code": "def einsum_vecmul_index ( gate_indices , number_of_qubits ) : mat_l , mat_r , tens_lin , tens_lout = _einsum_matmul_index_helper ( gate_indices , number_of_qubits ) # Combine indices into matrix multiplication string format # for numpy.einsum function return \"{mat_l}{mat_r}, \" . format ( mat_l = mat_l , mat_r = mat_r ) + \"{tens_lin}->{tens_lout}\" . format ( tens_lin = tens_lin , tens_lout = tens_lout )", "nl": "Return the index string for Numpy . eignsum matrix - vector multiplication ."}}
{"translation": {"code": "def run ( self , dag ) : # Walk through the DAG and expand each non-basis node for node in dag . op_nodes ( self . gate ) : # opaque or built-in gates are not decomposable if not node . op . definition : continue # TODO: allow choosing among multiple decomposition rules rule = node . op . definition # hacky way to build a dag on the same register as the rule is defined # TODO: need anonymous rules to address wires by index decomposition = DAGCircuit ( ) decomposition . add_qreg ( rule [ 0 ] [ 1 ] [ 0 ] [ 0 ] ) if rule [ 0 ] [ 2 ] : decomposition . add_creg ( rule [ 0 ] [ 2 ] [ 0 ] [ 0 ] ) for inst in rule : decomposition . apply_operation_back ( * inst ) dag . substitute_node_with_dag ( node , decomposition ) return dag", "nl": "Expand a given gate into its decomposition ."}}
{"translation": {"code": "def update_backend_info ( self , interval = 60 ) : my_thread = threading . currentThread ( ) current_interval = 0 started = False all_dead = False stati = [ None ] * len ( self . _backends ) while getattr ( my_thread , \"do_run\" , True ) and not all_dead : if current_interval == interval or started is False : for ind , back in enumerate ( self . _backends ) : _value = self . children [ ind ] . children [ 2 ] . value _head = _value . split ( '<b>' ) [ 0 ] try : _status = back . status ( ) stati [ ind ] = _status except Exception : # pylint: disable=W0703 self . children [ ind ] . children [ 2 ] . value = _value . replace ( _head , \"<h5 style='color:#ff5c49'>\" ) self . children [ ind ] . _is_alive = False else : self . children [ ind ] . _is_alive = True self . children [ ind ] . children [ 2 ] . value = _value . replace ( _head , \"<h5>\" ) idx = list ( range ( len ( self . _backends ) ) ) pending = [ s . pending_jobs for s in stati ] _ , least_idx = zip ( * sorted ( zip ( pending , idx ) ) ) # Make sure least pending is operational for ind in least_idx : if stati [ ind ] . operational : least_pending_idx = ind break for var in idx : if var == least_pending_idx : self . children [ var ] . children [ 4 ] . value = \"<h5 style='color:#34bc6e'>True</h5>\" else : self . children [ var ] . children [ 4 ] . value = \"<h5 style='color:#dc267f'>False</h5>\" self . children [ var ] . children [ 3 ] . children [ 1 ] . value = pending [ var ] self . children [ var ] . children [ 3 ] . children [ 1 ] . max = max ( self . children [ var ] . children [ 3 ] . children [ 1 ] . max , pending [ var ] + 10 ) if stati [ var ] . operational : self . children [ var ] . children [ 5 ] . value = \"<h5 style='color:#34bc6e'>True</h5>\" else : self . children [ var ] . children [ 5 ] . value = \"<h5 style='color:#dc267f'>False</h5>\" started = True current_interval = 0 time . sleep ( 1 ) all_dead = not any ( [ wid . _is_alive for wid in self . children ] ) current_interval += 1", "nl": "Updates the monitor info Called from another thread ."}}
{"translation": {"code": "def dist_real ( self ) : x0 , y0 = self . ax . transAxes . transform ( # pylint: disable=invalid-name ( 0 , 0 ) ) x1 , y1 = self . ax . transAxes . transform ( # pylint: disable=invalid-name ( 1 , 1 ) ) value = x1 - x0 if self . x else y1 - y0 return value", "nl": "Compute distance ."}}
{"translation": {"code": "def plot_job_history ( jobs , interval = 'year' ) : def get_date ( job ) : \"\"\"Returns a datetime object from a IBMQJob instance.\n\n        Args:\n            job (IBMQJob): A job.\n\n        Returns:\n            dt: A datetime object.\n        \"\"\" return datetime . datetime . strptime ( job . creation_date ( ) , '%Y-%m-%dT%H:%M:%S.%fZ' ) current_time = datetime . datetime . now ( ) if interval == 'year' : bins = [ ( current_time - datetime . timedelta ( days = k * 365 / 12 ) ) for k in range ( 12 ) ] elif interval == 'month' : bins = [ ( current_time - datetime . timedelta ( days = k ) ) for k in range ( 30 ) ] elif interval == 'week' : bins = [ ( current_time - datetime . timedelta ( days = k ) ) for k in range ( 7 ) ] binned_jobs = [ 0 ] * len ( bins ) if interval == 'year' : for job in jobs : for ind , dat in enumerate ( bins ) : date = get_date ( job ) if date . month == dat . month : binned_jobs [ ind ] += 1 break else : continue else : for job in jobs : for ind , dat in enumerate ( bins ) : date = get_date ( job ) if date . day == dat . day and date . month == dat . month : binned_jobs [ ind ] += 1 break else : continue nz_bins = [ ] nz_idx = [ ] for ind , val in enumerate ( binned_jobs ) : if val != 0 : nz_idx . append ( ind ) nz_bins . append ( val ) total_jobs = sum ( binned_jobs ) colors = [ '#003f5c' , '#ffa600' , '#374c80' , '#ff764a' , '#7a5195' , '#ef5675' , '#bc5090' ] if interval == 'year' : labels = [ '{}-{}' . format ( str ( bins [ b ] . year ) [ 2 : ] , bins [ b ] . month ) for b in nz_idx ] else : labels = [ '{}-{}' . format ( bins [ b ] . month , bins [ b ] . day ) for b in nz_idx ] fig , ax = plt . subplots ( 1 , 1 , figsize = ( 5 , 5 ) ) # pylint: disable=invalid-name ax . pie ( nz_bins [ : : - 1 ] , labels = labels , colors = colors , textprops = { 'fontsize' : 14 } , rotatelabels = True , counterclock = False ) ax . add_artist ( Circle ( ( 0 , 0 ) , 0.7 , color = 'white' , zorder = 1 ) ) ax . text ( 0 , 0 , total_jobs , horizontalalignment = 'center' , verticalalignment = 'center' , fontsize = 26 ) fig . tight_layout ( ) return fig", "nl": "Plots the job history of the user from the given list of jobs ."}}
{"translation": {"code": "def generate_jobs_pending_widget ( ) : pbar = widgets . IntProgress ( value = 0 , min = 0 , max = 50 , description = '' , orientation = 'horizontal' , layout = widgets . Layout ( max_width = '180px' ) ) pbar . style . bar_color = '#71cddd' pbar_current = widgets . Label ( value = str ( pbar . value ) , layout = widgets . Layout ( min_width = 'auto' ) ) pbar_max = widgets . Label ( value = str ( pbar . max ) , layout = widgets . Layout ( min_width = 'auto' ) ) def _on_max_change ( change ) : pbar_max . value = str ( change [ 'new' ] ) def _on_val_change ( change ) : pbar_current . value = str ( change [ 'new' ] ) pbar . observe ( _on_max_change , names = 'max' ) pbar . observe ( _on_val_change , names = 'value' ) jobs_widget = widgets . HBox ( [ pbar_current , pbar , pbar_max ] , layout = widgets . Layout ( max_width = '250px' , min_width = '250px' , justify_content = 'center' ) ) return jobs_widget", "nl": "Generates a jobs_pending progress bar widget ."}}
{"translation": {"code": "def get_unique_backends ( ) : backends = IBMQ . backends ( ) unique_hardware_backends = [ ] unique_names = [ ] for back in backends : if back . name ( ) not in unique_names and not back . configuration ( ) . simulator : unique_hardware_backends . append ( back ) unique_names . append ( back . name ( ) ) if not unique_hardware_backends : raise QiskitError ( 'No backends available.' ) return unique_hardware_backends", "nl": "Gets the unique backends that are available ."}}
{"translation": {"code": "def qubits_tab ( backend ) : props = backend . properties ( ) . to_dict ( ) header_html = \"<div><font style='font-weight:bold'>{key}</font>: {value}</div>\" header_html = header_html . format ( key = 'last_update_date' , value = props [ 'last_update_date' ] ) update_date_widget = widgets . HTML ( value = header_html ) qubit_html = \"<table>\" qubit_html += \"\"\"<style>\ntable {\n    border-collapse: collapse;\n    width: auto;\n}\n\nth, td {\n    text-align: left;\n    padding: 8px;\n}\n\ntr:nth-child(even) {background-color: #f6f6f6;}\n</style>\"\"\" qubit_html += \"<tr><th></th><th>Frequency</th><th>T1</th><th>T2</th>\" qubit_html += \"<th>U1 gate error</th><th>U2 gate error</th><th>U3 gate error</th>\" qubit_html += \"<th>Readout error</th></tr>\" qubit_footer = \"</table>\" for qub in range ( len ( props [ 'qubits' ] ) ) : name = 'Q%s' % qub qubit_data = props [ 'qubits' ] [ qub ] gate_data = props [ 'gates' ] [ 3 * qub : 3 * qub + 3 ] t1_info = qubit_data [ 0 ] t2_info = qubit_data [ 1 ] freq_info = qubit_data [ 2 ] readout_info = qubit_data [ 3 ] freq = str ( round ( freq_info [ 'value' ] , 5 ) ) + ' ' + freq_info [ 'unit' ] T1 = str ( round ( t1_info [ 'value' ] , # pylint: disable=invalid-name 5 ) ) + ' ' + t1_info [ 'unit' ] T2 = str ( round ( t2_info [ 'value' ] , # pylint: disable=invalid-name 5 ) ) + ' ' + t2_info [ 'unit' ] # pylint: disable=invalid-name U1 = str ( round ( gate_data [ 0 ] [ 'parameters' ] [ 0 ] [ 'value' ] , 5 ) ) # pylint: disable=invalid-name U2 = str ( round ( gate_data [ 1 ] [ 'parameters' ] [ 0 ] [ 'value' ] , 5 ) ) # pylint: disable=invalid-name U3 = str ( round ( gate_data [ 2 ] [ 'parameters' ] [ 0 ] [ 'value' ] , 5 ) ) readout_error = round ( readout_info [ 'value' ] , 5 ) qubit_html += \"<tr><td><font style='font-weight:bold'>%s</font></td><td>%s</td>\" qubit_html += \"<td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\" qubit_html = qubit_html % ( name , freq , T1 , T2 , U1 , U2 , U3 , readout_error ) qubit_html += qubit_footer qubit_widget = widgets . HTML ( value = qubit_html ) out = widgets . VBox ( [ update_date_widget , qubit_widget ] ) return out", "nl": "The qubits properties widget"}}
{"translation": {"code": "def start ( self , iterations ) : self . touched = True self . iter = int ( iterations ) self . t_start = time . time ( )", "nl": "Start the progress bar ."}}
{"translation": {"code": "def job_history ( backend ) : year = widgets . Output ( layout = widgets . Layout ( display = 'flex-inline' , align_items = 'center' , min_height = '400px' ) ) month = widgets . Output ( layout = widgets . Layout ( display = 'flex-inline' , align_items = 'center' , min_height = '400px' ) ) week = widgets . Output ( layout = widgets . Layout ( display = 'flex-inline' , align_items = 'center' , min_height = '400px' ) ) tabs = widgets . Tab ( layout = widgets . Layout ( max_height = '620px' ) ) tabs . children = [ year , month , week ] tabs . set_title ( 0 , 'Year' ) tabs . set_title ( 1 , 'Month' ) tabs . set_title ( 2 , 'Week' ) tabs . selected_index = 1 _build_job_history ( tabs , backend ) return tabs", "nl": "Widget for displaying job history"}}
{"translation": {"code": "def backend_widget ( backend ) : config = backend . configuration ( ) . to_dict ( ) props = backend . properties ( ) . to_dict ( ) name = widgets . HTML ( value = \"<h4>{name}</h4>\" . format ( name = backend . name ( ) ) , layout = widgets . Layout ( ) ) n_qubits = config [ 'n_qubits' ] qubit_count = widgets . HTML ( value = \"<h5><b>{qubits}</b></h5>\" . format ( qubits = n_qubits ) , layout = widgets . Layout ( justify_content = 'center' ) ) cmap = widgets . Output ( layout = widgets . Layout ( min_width = '250px' , max_width = '250px' , max_height = '250px' , min_height = '250px' , justify_content = 'center' , align_items = 'center' , margin = '0px 0px 0px 0px' ) ) with cmap : _cmap_fig = plot_gate_map ( backend , plot_directed = False , label_qubits = False ) if _cmap_fig is not None : display ( _cmap_fig ) # Prevents plot from showing up twice. plt . close ( _cmap_fig ) pending = generate_jobs_pending_widget ( ) is_oper = widgets . HTML ( value = \"<h5></h5>\" , layout = widgets . Layout ( justify_content = 'center' ) ) least_busy = widgets . HTML ( value = \"<h5></h5>\" , layout = widgets . Layout ( justify_content = 'center' ) ) t1_units = props [ 'qubits' ] [ 0 ] [ 0 ] [ 'unit' ] avg_t1 = round ( sum ( [ q [ 0 ] [ 'value' ] for q in props [ 'qubits' ] ] ) / n_qubits , 1 ) t1_widget = widgets . HTML ( value = \"<h5>{t1} {units}</h5>\" . format ( t1 = avg_t1 , units = t1_units ) , layout = widgets . Layout ( ) ) t2_units = props [ 'qubits' ] [ 0 ] [ 1 ] [ 'unit' ] avg_t2 = round ( sum ( [ q [ 1 ] [ 'value' ] for q in props [ 'qubits' ] ] ) / n_qubits , 1 ) t2_widget = widgets . HTML ( value = \"<h5>{t2} {units}</h5>\" . format ( t2 = avg_t2 , units = t2_units ) , layout = widgets . Layout ( ) ) out = widgets . VBox ( [ name , cmap , qubit_count , pending , least_busy , is_oper , t1_widget , t2_widget ] , layout = widgets . Layout ( display = 'inline-flex' , flex_flow = 'column' , align_items = 'center' ) ) out . _is_alive = True return out", "nl": "Creates a backend widget ."}}
{"translation": {"code": "def time_remaining_est ( self , completed_iter ) : if completed_iter : t_r_est = ( time . time ( ) - self . t_start ) / completed_iter * ( self . iter - completed_iter ) else : t_r_est = 0 date_time = datetime . datetime ( 1 , 1 , 1 ) + datetime . timedelta ( seconds = t_r_est ) time_string = \"%02d:%02d:%02d:%02d\" % ( date_time . day - 1 , date_time . hour , date_time . minute , date_time . second ) return time_string", "nl": "Estimate the remaining time left ."}}
{"translation": {"code": "def yzy_to_zyz ( xi , theta1 , theta2 , eps = 1e-9 ) : # pylint: disable=invalid-name quaternion_yzy = quaternion_from_euler ( [ theta1 , xi , theta2 ] , 'yzy' ) euler = quaternion_yzy . to_zyz ( ) quaternion_zyz = quaternion_from_euler ( euler , 'zyz' ) # output order different than rotation order out_angles = ( euler [ 1 ] , euler [ 0 ] , euler [ 2 ] ) abs_inner = abs ( quaternion_zyz . data . dot ( quaternion_yzy . data ) ) if not np . allclose ( abs_inner , 1 , eps ) : raise TranspilerError ( 'YZY and ZYZ angles do not give same rotation matrix.' ) out_angles = tuple ( 0 if np . abs ( angle ) < _CHOP_THRESHOLD else angle for angle in out_angles ) return out_angles", "nl": "Express a Y . Z . Y single qubit gate as a Z . Y . Z gate ."}}
{"translation": {"code": "def compose_u3 ( theta1 , phi1 , lambda1 , theta2 , phi2 , lambda2 ) : # Careful with the factor of two in yzy_to_zyz thetap , phip , lambdap = Optimize1qGates . yzy_to_zyz ( ( lambda1 + phi2 ) , theta1 , theta2 ) ( theta , phi , lamb ) = ( thetap , phi1 + phip , lambda2 + lambdap ) return ( theta , phi , lamb )", "nl": "Return a triple theta phi lambda for the product ."}}
{"translation": {"code": "def quantum_successors ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling quantum_successors() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] successors = [ ] for successor in self . successors ( node ) : if isinstance ( self . _multi_graph . get_edge_data ( node , successor , key = 0 ) [ 'wire' ] [ 0 ] , QuantumRegister ) : successors . append ( successor ) return successors", "nl": "Returns list of the successors of a node that are connected by a quantum edge as DAGNodes ."}}
{"translation": {"code": "def run ( self , dag ) : # Collect DAG nodes which are followed only by barriers or other measures. final_op_types = [ 'measure' , 'barrier' ] final_ops = [ ] for candidate_node in dag . named_nodes ( * final_op_types ) : is_final_op = True for _ , child_successors in dag . bfs_successors ( candidate_node ) : if any ( suc . type == 'op' and suc . name not in final_op_types for suc in child_successors ) : is_final_op = False break if is_final_op : final_ops . append ( candidate_node ) if not final_ops : return dag # Create a layer with the barrier and add registers from the original dag. barrier_layer = DAGCircuit ( ) for qreg in dag . qregs . values ( ) : barrier_layer . add_qreg ( qreg ) for creg in dag . cregs . values ( ) : barrier_layer . add_creg ( creg ) final_qubits = set ( final_op . qargs [ 0 ] for final_op in final_ops ) barrier_layer . apply_operation_back ( Barrier ( len ( final_qubits ) ) , list ( final_qubits ) , [ ] ) # Preserve order of final ops collected earlier from the original DAG. ordered_final_nodes = [ node for node in dag . topological_op_nodes ( ) if node in set ( final_ops ) ] # Move final ops to the new layer and append the new layer to the DAG. for final_node in ordered_final_nodes : barrier_layer . apply_operation_back ( final_node . op , final_node . qargs , final_node . cargs ) for final_op in final_ops : dag . remove_op_node ( final_op ) dag . extend_back ( barrier_layer ) # Merge the new barrier into any other barriers adjacent_pass = MergeAdjacentBarriers ( ) return adjacent_pass . run ( dag )", "nl": "Return a circuit with a barrier before last measurements ."}}
{"translation": {"code": "def _layer_update ( self , i , first_layer , best_layout , best_depth , best_circuit , layer_list ) : layout = best_layout logger . debug ( \"layer_update: layout = %s\" , pformat ( layout ) ) logger . debug ( \"layer_update: self.initial_layout = %s\" , pformat ( self . initial_layout ) ) dagcircuit_output = DAGCircuit ( ) for register in layout . get_virtual_bits ( ) . keys ( ) : if register [ 0 ] not in dagcircuit_output . qregs . values ( ) : dagcircuit_output . add_qreg ( register [ 0 ] ) # If this is the first layer with multi-qubit gates, # output all layers up to this point and ignore any # swap gates. Set the initial layout. if first_layer : logger . debug ( \"layer_update: first multi-qubit gate layer\" ) # Output all layers up to this point for j in range ( i + 1 ) : # Make qubit edge map and extend by classical bits edge_map = layout . combine_into_edge_map ( self . initial_layout ) for bit in dagcircuit_output . clbits ( ) : edge_map [ bit ] = bit dagcircuit_output . compose_back ( layer_list [ j ] [ \"graph\" ] , edge_map ) # Otherwise, we output the current layer and the associated swap gates. else : # Output any swaps if best_depth > 0 : logger . debug ( \"layer_update: there are swaps in this layer, \" \"depth %d\" , best_depth ) dagcircuit_output . extend_back ( best_circuit ) else : logger . debug ( \"layer_update: there are no swaps in this layer\" ) # Make qubit edge map and extend by classical bits edge_map = layout . combine_into_edge_map ( self . initial_layout ) for bit in dagcircuit_output . clbits ( ) : edge_map [ bit ] = bit # Output this layer dagcircuit_output . compose_back ( layer_list [ i ] [ \"graph\" ] , edge_map ) return dagcircuit_output", "nl": "Provide a DAGCircuit for a new mapped layer ."}}
{"translation": {"code": "def run ( self , dag ) : if self . initial_layout is None : if self . property_set [ \"layout\" ] : self . initial_layout = self . property_set [ \"layout\" ] else : self . initial_layout = Layout . generate_trivial_layout ( * dag . qregs . values ( ) ) if len ( dag . qubits ( ) ) != len ( self . initial_layout ) : raise TranspilerError ( 'The layout does not match the amount of qubits in the DAG' ) if len ( self . coupling_map . physical_qubits ) != len ( self . initial_layout ) : raise TranspilerError ( \"Mappers require to have the layout to be the same size as the coupling map\" ) self . input_layout = self . initial_layout . copy ( ) self . qregs = dag . qregs if self . seed is None : self . seed = np . random . randint ( 0 , np . iinfo ( np . int32 ) . max ) self . rng = np . random . RandomState ( self . seed ) logger . debug ( \"StochasticSwap RandomState seeded with seed=%s\" , self . seed ) new_dag = self . _mapper ( dag , self . coupling_map , trials = self . trials ) # self.property_set[\"layout\"] = self.initial_layout return new_dag", "nl": "Run the StochasticSwap pass on dag ."}}
{"translation": {"code": "def run ( self , dag ) : # Initiate the commutation set self . property_set [ 'commutation_set' ] = defaultdict ( list ) # Build a dictionary to keep track of the gates on each qubit for wire in dag . wires : wire_name = \"{0}[{1}]\" . format ( str ( wire [ 0 ] . name ) , str ( wire [ 1 ] ) ) self . property_set [ 'commutation_set' ] [ wire_name ] = [ ] # Add edges to the dictionary for each qubit for node in dag . topological_op_nodes ( ) : for ( _ , _ , edge_data ) in dag . edges ( node ) : edge_name = edge_data [ 'name' ] self . property_set [ 'commutation_set' ] [ ( node , edge_name ) ] = - 1 for wire in dag . wires : wire_name = \"{0}[{1}]\" . format ( str ( wire [ 0 ] . name ) , str ( wire [ 1 ] ) ) for current_gate in dag . nodes_on_wire ( wire ) : current_comm_set = self . property_set [ 'commutation_set' ] [ wire_name ] if not current_comm_set : current_comm_set . append ( [ current_gate ] ) if current_gate not in current_comm_set [ - 1 ] : prev_gate = current_comm_set [ - 1 ] [ - 1 ] if _commute ( current_gate , prev_gate ) : current_comm_set [ - 1 ] . append ( current_gate ) else : current_comm_set . append ( [ current_gate ] ) temp_len = len ( current_comm_set ) self . property_set [ 'commutation_set' ] [ ( current_gate , wire_name ) ] = temp_len - 1", "nl": "Run the pass on the DAG and write the discovered commutation relations into the property_set ."}}
{"translation": {"code": "def named_nodes ( self , * names ) : named_nodes = [ ] for node in self . _multi_graph . nodes ( ) : if node . type == 'op' and node . op . name in names : named_nodes . append ( node ) return named_nodes", "nl": "Get the set of op nodes with the given name ."}}
{"translation": {"code": "def run ( self , dag ) : num_dag_qubits = sum ( [ qreg . size for qreg in dag . qregs . values ( ) ] ) if num_dag_qubits > self . coupling_map . size ( ) : raise TranspilerError ( 'Number of qubits greater than device.' ) self . property_set [ 'layout' ] = Layout . generate_trivial_layout ( * dag . qregs . values ( ) )", "nl": "Pick a layout by assigning n circuit qubits to device qubits 0 .. n - 1 ."}}
{"translation": {"code": "def _best_subset ( self , n_qubits ) : if n_qubits == 1 : return np . array ( [ 0 ] ) device_qubits = self . coupling_map . size ( ) cmap = np . asarray ( self . coupling_map . get_edges ( ) ) data = np . ones_like ( cmap [ : , 0 ] ) sp_cmap = sp . coo_matrix ( ( data , ( cmap [ : , 0 ] , cmap [ : , 1 ] ) ) , shape = ( device_qubits , device_qubits ) ) . tocsr ( ) best = 0 best_map = None # do bfs with each node as starting point for k in range ( sp_cmap . shape [ 0 ] ) : bfs = cs . breadth_first_order ( sp_cmap , i_start = k , directed = False , return_predecessors = False ) connection_count = 0 sub_graph = [ ] for i in range ( n_qubits ) : node_idx = bfs [ i ] for j in range ( sp_cmap . indptr [ node_idx ] , sp_cmap . indptr [ node_idx + 1 ] ) : node = sp_cmap . indices [ j ] for counter in range ( n_qubits ) : if node == bfs [ counter ] : connection_count += 1 sub_graph . append ( [ node_idx , node ] ) break if connection_count > best : best = connection_count best_map = bfs [ 0 : n_qubits ] # Return a best mapping that has reduced bandwidth mapping = { } for edge in range ( best_map . shape [ 0 ] ) : mapping [ best_map [ edge ] ] = edge new_cmap = [ [ mapping [ c [ 0 ] ] , mapping [ c [ 1 ] ] ] for c in sub_graph ] rows = [ edge [ 0 ] for edge in new_cmap ] cols = [ edge [ 1 ] for edge in new_cmap ] data = [ 1 ] * len ( rows ) sp_sub_graph = sp . coo_matrix ( ( data , ( rows , cols ) ) , shape = ( n_qubits , n_qubits ) ) . tocsr ( ) perm = cs . reverse_cuthill_mckee ( sp_sub_graph ) best_map = best_map [ perm ] return best_map", "nl": "Computes the qubit mapping with the best connectivity ."}}
{"translation": {"code": "def run ( self , dag ) : num_dag_qubits = sum ( [ qreg . size for qreg in dag . qregs . values ( ) ] ) if num_dag_qubits > self . coupling_map . size ( ) : raise TranspilerError ( 'Number of qubits greater than device.' ) best_sub = self . _best_subset ( num_dag_qubits ) layout = Layout ( ) map_iter = 0 for qreg in dag . qregs . values ( ) : for i in range ( qreg . size ) : layout [ ( qreg , i ) ] = int ( best_sub [ map_iter ] ) map_iter += 1 self . property_set [ 'layout' ] = layout", "nl": "Pick a convenient layout depending on the best matching qubit connectivity and set the property layout ."}}
{"translation": {"code": "def run ( self , dag ) : self . layout = self . layout or self . property_set [ 'layout' ] if self . layout is None : raise TranspilerError ( \"EnlargeWithAncilla requires property_set[\\\"layout\\\"] or\" \" \\\"layout\\\" parameter to run\" ) layout_virtual_qubits = self . layout . get_virtual_bits ( ) . keys ( ) new_qregs = set ( virtual_qubit [ 0 ] for virtual_qubit in layout_virtual_qubits if virtual_qubit not in dag . wires ) for qreg in new_qregs : dag . add_qreg ( qreg ) return dag", "nl": "Extends dag with virtual qubits that are in layout but not in the circuit yet ."}}
{"translation": {"code": "def run ( self , dag ) : for node in dag . threeQ_or_more_gates ( ) : # TODO: allow choosing other possible decompositions rule = node . op . definition if not rule : raise QiskitError ( \"Cannot unroll all 3q or more gates. \" \"No rule to expand instruction %s.\" % node . op . name ) # hacky way to build a dag on the same register as the rule is defined # TODO: need anonymous rules to address wires by index decomposition = DAGCircuit ( ) decomposition . add_qreg ( rule [ 0 ] [ 1 ] [ 0 ] [ 0 ] ) for inst in rule : decomposition . apply_operation_back ( * inst ) decomposition = self . run ( decomposition ) # recursively unroll dag . substitute_node_with_dag ( node , decomposition ) return dag", "nl": "Expand 3 + qubit gates using their decomposition rules ."}}
{"translation": {"code": "def ancestors ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling ancestors() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] return nx . ancestors ( self . _multi_graph , node )", "nl": "Returns set of the ancestors of a node as DAGNodes ."}}
{"translation": {"code": "def purity ( state ) : rho = np . array ( state ) if rho . ndim == 1 : return 1.0 return np . real ( np . trace ( rho . dot ( rho ) ) )", "nl": "Calculate the purity of a quantum state ."}}
{"translation": {"code": "def _is_bit ( obj ) : # If there is a bit type this could be replaced by isinstance. if isinstance ( obj , tuple ) and len ( obj ) == 2 : if isinstance ( obj [ 0 ] , Register ) and isinstance ( obj [ 1 ] , int ) and obj [ 1 ] < len ( obj [ 0 ] ) : return True return False", "nl": "Determine if obj is a bit"}}
{"translation": {"code": "def report ( self , branch , commit , infourl = None ) : issue_number = self . _get_report_issue_number ( ) if issue_number : self . _report_as_comment ( issue_number , branch , commit , infourl ) else : self . _report_as_issue ( branch , commit , infourl )", "nl": "Report on GitHub that the specified branch is failing to build at the specified commit . The method will open an issue indicating that the branch is failing . If there is an issue already open it will add a comment avoiding to report twice about the same failure ."}}
{"translation": {"code": "def _get_gate_span ( qregs , instruction ) : min_index = len ( qregs ) max_index = 0 for qreg in instruction . qargs : index = qregs . index ( qreg ) if index < min_index : min_index = index if index > max_index : max_index = index if instruction . cargs : return qregs [ min_index : ] return qregs [ min_index : max_index + 1 ]", "nl": "Get the list of qubits drawing this gate would cover"}}
{"translation": {"code": "def gates_to_idx ( gates , qregs ) : sizes = [ qr . size for qr in qregs . values ( ) ] reg_idx = np . cumsum ( [ 0 ] + sizes ) regint = { } for ind , qreg in enumerate ( qregs . values ( ) ) : regint [ qreg ] = ind out = np . zeros ( 2 * len ( gates ) , dtype = np . int32 ) for idx , gate in enumerate ( gates ) : out [ 2 * idx ] = reg_idx [ regint [ gate [ 0 ] [ 0 ] ] ] + gate [ 0 ] [ 1 ] out [ 2 * idx + 1 ] = reg_idx [ regint [ gate [ 1 ] [ 0 ] ] ] + gate [ 1 ] [ 1 ] return out", "nl": "Converts gate tuples into a nested list of integers ."}}
{"translation": {"code": "def twoQ_gates ( self ) : two_q_gates = [ ] for node in self . gate_nodes ( ) : if len ( node . qargs ) == 2 : two_q_gates . append ( node ) return two_q_gates", "nl": "Get list of 2 - qubit gates . Ignore snapshot barriers and the like ."}}
{"translation": {"code": "def make_dict_observable ( matrix_observable ) : dict_observable = { } observable = np . array ( matrix_observable ) observable_size = len ( observable ) observable_bits = int ( np . ceil ( np . log2 ( observable_size ) ) ) binary_formater = '0{}b' . format ( observable_bits ) if observable . ndim == 2 : observable = observable . diagonal ( ) for state_no in range ( observable_size ) : state_str = format ( state_no , binary_formater ) dict_observable [ state_str ] = observable [ state_no ] return dict_observable", "nl": "Convert an observable in matrix form to dictionary form ."}}
{"translation": {"code": "def draw ( self , * * kwargs ) : from qiskit . tools . visualization import pulse_drawer return pulse_drawer ( self . _samples , self . duration , * * kwargs )", "nl": "Plot the interpolated envelope of pulse ."}}
{"translation": {"code": "def pulse_drawer ( samples , duration , dt = None , interp_method = 'None' , filename = None , interactive = False , dpi = 150 , nop = 1000 , size = ( 6 , 5 ) ) : try : from matplotlib import pyplot as plt except ImportError : raise ImportError ( 'pulse_drawer need matplotlib. ' 'Run \"pip install matplotlib\" before.' ) if dt : _dt = dt else : _dt = 1 re_y = np . real ( samples ) im_y = np . imag ( samples ) image = plt . figure ( figsize = size ) ax0 = image . add_subplot ( 111 ) if interp_method == 'CubicSpline' : # spline interpolation, use mid-point of dt time = np . arange ( 0 , duration + 1 ) * _dt + 0.5 * _dt cs_ry = CubicSpline ( time [ : - 1 ] , re_y ) cs_iy = CubicSpline ( time [ : - 1 ] , im_y ) _time = np . linspace ( 0 , duration * _dt , nop ) _re_y = cs_ry ( _time ) _im_y = cs_iy ( _time ) elif interp_method == 'None' : # pseudo-DAC output time = np . arange ( 0 , duration + 1 ) * _dt _time = np . r_ [ time [ 0 ] , np . repeat ( time [ 1 : - 1 ] , 2 ) , time [ - 1 ] ] _re_y = np . repeat ( re_y , 2 ) _im_y = np . repeat ( im_y , 2 ) else : raise QiskitError ( 'Invalid interpolation method \"%s\"' % interp_method ) # plot ax0 . fill_between ( x = _time , y1 = _re_y , y2 = np . zeros_like ( _time ) , facecolor = 'red' , alpha = 0.3 , edgecolor = 'red' , linewidth = 1.5 , label = 'real part' ) ax0 . fill_between ( x = _time , y1 = _im_y , y2 = np . zeros_like ( _time ) , facecolor = 'blue' , alpha = 0.3 , edgecolor = 'blue' , linewidth = 1.5 , label = 'imaginary part' ) ax0 . set_xlim ( 0 , duration * _dt ) ax0 . grid ( b = True , linestyle = '-' ) ax0 . legend ( bbox_to_anchor = ( 0.5 , 1.00 ) , loc = 'lower center' , ncol = 2 , frameon = False , fontsize = 14 ) if filename : image . savefig ( filename , dpi = dpi , bbox_inches = 'tight' ) plt . close ( image ) if image and interactive : plt . show ( image ) return image", "nl": "Plot the interpolated envelope of pulse"}}
{"translation": {"code": "def _check_qargs ( self , qargs ) : if not all ( isinstance ( i , tuple ) and isinstance ( i [ 0 ] , QuantumRegister ) and isinstance ( i [ 1 ] , int ) for i in qargs ) : raise QiskitError ( \"qarg not (QuantumRegister, int) tuple\" ) if not all ( self . has_register ( i [ 0 ] ) for i in qargs ) : raise QiskitError ( \"register not in this circuit\" ) for qubit in qargs : qubit [ 0 ] . check_range ( qubit [ 1 ] )", "nl": "Raise exception if a qarg is not in this circuit or bad format ."}}
{"translation": {"code": "def _check_cargs ( self , cargs ) : if not all ( isinstance ( i , tuple ) and isinstance ( i [ 0 ] , ClassicalRegister ) and isinstance ( i [ 1 ] , int ) for i in cargs ) : raise QiskitError ( \"carg not (ClassicalRegister, int) tuple\" ) if not all ( self . has_register ( i [ 0 ] ) for i in cargs ) : raise QiskitError ( \"register not in this circuit\" ) for clbit in cargs : clbit [ 0 ] . check_range ( clbit [ 1 ] )", "nl": "Raise exception if clbit is not in this circuit or bad format ."}}
{"translation": {"code": "def execute ( experiments , backend , basis_gates = None , coupling_map = None , # circuit transpile options backend_properties = None , initial_layout = None , seed_transpiler = None , optimization_level = None , pass_manager = None , qobj_id = None , qobj_header = None , shots = 1024 , # common run options memory = False , max_credits = 10 , seed_simulator = None , default_qubit_los = None , default_meas_los = None , # schedule run options schedule_los = None , meas_level = 2 , meas_return = 'avg' , memory_slots = None , memory_slot_size = 100 , rep_time = None , parameter_binds = None , seed = None , seed_mapper = None , # deprecated config = None , circuits = None , * * run_config ) : if circuits is not None : experiments = circuits warnings . warn ( \"the `circuits` arg in `execute()` has been deprecated. \" \"please use `experiments`, which can handle both circuit \" \"and pulse Schedules\" , DeprecationWarning ) # transpiling the circuits using given transpile options experiments = transpile ( experiments , basis_gates = basis_gates , coupling_map = coupling_map , backend_properties = backend_properties , initial_layout = initial_layout , seed_transpiler = seed_transpiler , optimization_level = optimization_level , backend = backend , pass_manager = pass_manager , seed_mapper = seed_mapper , # deprecated ) # assembling the circuits into a qobj to be run on the backend qobj = assemble ( experiments , qobj_id = qobj_id , qobj_header = qobj_header , shots = shots , memory = memory , max_credits = max_credits , seed_simulator = seed_simulator , default_qubit_los = default_qubit_los , default_meas_los = default_meas_los , schedule_los = schedule_los , meas_level = meas_level , meas_return = meas_return , memory_slots = memory_slots , memory_slot_size = memory_slot_size , rep_time = rep_time , parameter_binds = parameter_binds , backend = backend , config = config , # deprecated seed = seed , # deprecated run_config = run_config ) # executing the circuits on the backend and returning the job return backend . run ( qobj , * * run_config )", "nl": "Execute a list of circuits or pulse schedules on a backend ."}}
{"translation": {"code": "def transpile ( circuits , backend = None , basis_gates = None , coupling_map = None , backend_properties = None , initial_layout = None , seed_transpiler = None , optimization_level = None , pass_manager = None , seed_mapper = None ) : # deprecated # Deprecation matter if seed_mapper : warnings . warn ( \"seed_mapper has been deprecated and will be removed in the \" \"0.9 release. Instead use seed_transpiler to set the seed \" \"for all stochastic parts of the.\" , DeprecationWarning ) seed_transpiler = seed_mapper # transpiling schedules is not supported yet. if isinstance ( circuits , Schedule ) or ( isinstance ( circuits , list ) and all ( isinstance ( c , Schedule ) for c in circuits ) ) : return circuits # Get TranspileConfig(s) to configure the circuit transpilation job(s) circuits = circuits if isinstance ( circuits , list ) else [ circuits ] transpile_configs = _parse_transpile_args ( circuits , backend , basis_gates , coupling_map , backend_properties , initial_layout , seed_transpiler , optimization_level , pass_manager ) # Transpile circuits in parallel circuits = parallel_map ( _transpile_circuit , list ( zip ( circuits , transpile_configs ) ) ) if len ( circuits ) == 1 : return circuits [ 0 ] return circuits", "nl": "transpile one or more circuits according to some desired transpilation targets ."}}
{"translation": {"code": "def check_type ( self , value , attr , data ) : # Check the type in the standard way first, in order to fail quickly # in case of invalid values. root_value = super ( InstructionParameter , self ) . check_type ( value , attr , data ) if is_collection ( value ) : _ = [ super ( InstructionParameter , self ) . check_type ( item , attr , data ) for item in value ] return root_value", "nl": "Customize check_type for handling containers ."}}
{"translation": {"code": "def op ( self ) : if 'type' not in self . data_dict or self . data_dict [ 'type' ] != 'op' : raise QiskitError ( \"The node %s is not an op node\" % ( str ( self ) ) ) return self . data_dict . get ( 'op' )", "nl": "Returns the Instruction object corresponding to the op for the node else None"}}
{"translation": {"code": "def predecessors ( self , node ) : if isinstance ( node , int ) : warnings . warn ( 'Calling predecessors() with a node id is deprecated,' ' use a DAGNode instead' , DeprecationWarning , 2 ) node = self . _id_to_node [ node ] return self . _multi_graph . predecessors ( node )", "nl": "Returns list of the predecessors of a node as DAGNodes ."}}
{"translation": {"code": "def nodes_on_wire ( self , wire , only_ops = False ) : current_node = self . input_map . get ( wire , None ) if not current_node : raise DAGCircuitError ( 'The given wire %s is not present in the circuit' % str ( wire ) ) more_nodes = True while more_nodes : more_nodes = False # allow user to just get ops on the wire - not the input/output nodes if current_node . type == 'op' or not only_ops : yield current_node # find the adjacent node that takes the wire being looked at as input for node , edges in self . _multi_graph . adj [ current_node ] . items ( ) : if any ( wire == edge [ 'wire' ] for edge in edges . values ( ) ) : current_node = node more_nodes = True break", "nl": "Iterator for nodes that affect a given wire"}}
{"translation": {"code": "def _choi_to_chi ( data , input_dim , output_dim ) : num_qubits = int ( np . log2 ( input_dim ) ) return _transform_to_pauli ( data , num_qubits )", "nl": "Transform Choi representation to the Chi representation ."}}
{"translation": {"code": "def _choi_to_superop ( data , input_dim , output_dim ) : shape = ( input_dim , output_dim , input_dim , output_dim ) return _reshuffle ( data , shape )", "nl": "Transform Choi to SuperOp representation ."}}
{"translation": {"code": "def _kraus_to_superop ( data , input_dim , output_dim ) : kraus_l , kraus_r = data superop = 0 if kraus_r is None : for i in kraus_l : superop += np . kron ( np . conj ( i ) , i ) else : for i , j in zip ( kraus_l , kraus_r ) : superop += np . kron ( np . conj ( j ) , i ) return superop", "nl": "Transform Kraus representation to SuperOp representation ."}}
{"translation": {"code": "def _check_nqubit_dim ( input_dim , output_dim ) : if input_dim != output_dim : raise QiskitError ( 'Not an n-qubit channel: input_dim' + ' ({}) != output_dim ({})' . format ( input_dim , output_dim ) ) num_qubits = int ( np . log2 ( input_dim ) ) if 2 ** num_qubits != input_dim : raise QiskitError ( 'Not an n-qubit channel: input_dim != 2 ** n' )", "nl": "Return true if dims correspond to an n - qubit channel ."}}
{"translation": {"code": "def _stinespring_to_kraus ( data , input_dim , output_dim ) : kraus_pair = [ ] for stine in data : if stine is None : kraus_pair . append ( None ) else : trace_dim = stine . shape [ 0 ] // output_dim iden = np . eye ( output_dim ) kraus = [ ] for j in range ( trace_dim ) : vec = np . zeros ( trace_dim ) vec [ j ] = 1 kraus . append ( np . kron ( iden , vec [ None , : ] ) . dot ( stine ) ) kraus_pair . append ( kraus ) return tuple ( kraus_pair )", "nl": "Transform Stinespring representation to Kraus representation ."}}
{"translation": {"code": "def _transform_from_pauli ( data , num_qubits ) : # Change basis: sum_{i=0}^3 =|\\sigma_i>><i| basis_mat = np . array ( [ [ 1 , 0 , 0 , 1 ] , [ 0 , 1 , 1j , 0 ] , [ 0 , 1 , - 1j , 0 ] , [ 1 , 0j , 0 , - 1 ] ] , dtype = complex ) # Note that we manually renormalized after change of basis # to avoid rounding errors from square-roots of 2. cob = basis_mat for _ in range ( num_qubits - 1 ) : dim = int ( np . sqrt ( len ( cob ) ) ) cob = np . reshape ( np . transpose ( np . reshape ( np . kron ( basis_mat , cob ) , ( 2 , 2 , dim , dim , 4 , dim * dim ) ) , ( 0 , 2 , 1 , 3 , 4 , 5 ) ) , ( 4 * dim * dim , 4 * dim * dim ) ) return np . dot ( np . dot ( cob , data ) , cob . conj ( ) . T ) / 2 ** num_qubits", "nl": "Change of basis of bipartite matrix represenation ."}}
{"translation": {"code": "def _choi_to_kraus ( data , input_dim , output_dim , atol = ATOL_DEFAULT ) : # Check if hermitian matrix if is_hermitian_matrix ( data , atol = atol ) : # Get eigen-decomposition of Choi-matrix w , v = la . eigh ( data ) # Check eigenvaleus are non-negative if len ( w [ w < - atol ] ) == 0 : # CP-map Kraus representation kraus = [ ] for val , vec in zip ( w , v . T ) : if abs ( val ) > atol : k = np . sqrt ( val ) * vec . reshape ( ( output_dim , input_dim ) , order = 'F' ) kraus . append ( k ) # If we are converting a zero matrix, we need to return a Kraus set # with a single zero-element Kraus matrix if not kraus : kraus . append ( np . zeros ( ( output_dim , input_dim ) , dtype = complex ) ) return ( kraus , None ) # Non-CP-map generalized Kraus representation mat_u , svals , mat_vh = la . svd ( data ) kraus_l = [ ] kraus_r = [ ] for val , vec_l , vec_r in zip ( svals , mat_u . T , mat_vh . conj ( ) ) : kraus_l . append ( np . sqrt ( val ) * vec_l . reshape ( ( output_dim , input_dim ) , order = 'F' ) ) kraus_r . append ( np . sqrt ( val ) * vec_r . reshape ( ( output_dim , input_dim ) , order = 'F' ) ) return ( kraus_l , kraus_r )", "nl": "Transform Choi representation to Kraus representation ."}}
{"translation": {"code": "def _reravel ( mat1 , mat2 , shape1 , shape2 ) : # Reshuffle indicies left_dims = shape1 [ : 2 ] + shape2 [ : 2 ] right_dims = shape1 [ 2 : ] + shape2 [ 2 : ] tensor_shape = left_dims + right_dims final_shape = ( np . product ( left_dims ) , np . product ( right_dims ) ) # Tensor product matrices data = np . kron ( mat1 , mat2 ) data = np . reshape ( np . transpose ( np . reshape ( data , tensor_shape ) , ( 0 , 2 , 1 , 3 , 4 , 6 , 5 , 7 ) ) , final_shape ) return data", "nl": "Reravel two bipartite matrices ."}}
{"translation": {"code": "def power ( self , n ) : if not isinstance ( n , ( int , np . integer ) ) : raise QiskitError ( \"Can only power with integer powers.\" ) if self . _input_dim != self . _output_dim : raise QiskitError ( \"Can only power with input_dim = output_dim.\" ) # Override base class power so we can implement more efficiently # using Numpy.matrix_power return SuperOp ( np . linalg . matrix_power ( self . _data , n ) , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Return the compose of a QuantumChannel with itself n times ."}}
{"translation": {"code": "def _kraus_to_choi ( data , input_dim , output_dim ) : choi = 0 kraus_l , kraus_r = data if kraus_r is None : for i in kraus_l : vec = i . ravel ( order = 'F' ) choi += np . outer ( vec , vec . conj ( ) ) else : for i , j in zip ( kraus_l , kraus_r ) : choi += np . outer ( i . ravel ( order = 'F' ) , j . ravel ( order = 'F' ) . conj ( ) ) return choi", "nl": "Transform Kraus representation to Choi representation ."}}
{"translation": {"code": "def _bipartite_shape ( self ) : return ( self . _input_dim , self . _output_dim , self . _input_dim , self . _output_dim )", "nl": "Return the shape for bipartite matrix"}}
{"translation": {"code": "def _superop_to_choi ( data , input_dim , output_dim ) : shape = ( output_dim , output_dim , input_dim , input_dim ) return _reshuffle ( data , shape )", "nl": "Transform SuperOp representation to Choi representation ."}}
{"translation": {"code": "def _stinespring_to_operator ( data , input_dim , output_dim ) : trace_dim = data [ 0 ] . shape [ 0 ] // output_dim if data [ 1 ] is not None or trace_dim != 1 : raise QiskitError ( 'Channel cannot be converted to Operator representation' ) return data [ 0 ]", "nl": "Transform Stinespring representation to Operator representation ."}}
{"translation": {"code": "def _from_operator ( rep , data , input_dim , output_dim ) : if rep == 'Operator' : return data if rep == 'SuperOp' : return np . kron ( np . conj ( data ) , data ) if rep == 'Choi' : vec = np . ravel ( data , order = 'F' ) return np . outer ( vec , np . conj ( vec ) ) if rep == 'Kraus' : return ( [ data ] , None ) if rep == 'Stinespring' : return ( data , None ) if rep == 'Chi' : _check_nqubit_dim ( input_dim , output_dim ) data = _from_operator ( 'Choi' , data , input_dim , output_dim ) return _choi_to_chi ( data , input_dim , output_dim ) if rep == 'PTM' : _check_nqubit_dim ( input_dim , output_dim ) data = _from_operator ( 'SuperOp' , data , input_dim , output_dim ) return _superop_to_ptm ( data , input_dim , output_dim ) raise QiskitError ( 'Invalid QuantumChannel {}' . format ( rep ) )", "nl": "Transform Operator representation to other representation ."}}
{"translation": {"code": "def _to_operator ( rep , data , input_dim , output_dim ) : if rep == 'Operator' : return data if rep == 'Stinespring' : return _stinespring_to_operator ( data , input_dim , output_dim ) # Convert via Kraus representation if rep != 'Kraus' : data = _to_kraus ( rep , data , input_dim , output_dim ) return _kraus_to_operator ( data , input_dim , output_dim )", "nl": "Transform a QuantumChannel to the Operator representation ."}}
{"translation": {"code": "def _to_stinespring ( rep , data , input_dim , output_dim ) : if rep == 'Stinespring' : return data if rep == 'Operator' : return _from_operator ( 'Stinespring' , data , input_dim , output_dim ) # Convert via Superoperator representation if rep != 'Kraus' : data = _to_kraus ( rep , data , input_dim , output_dim ) return _kraus_to_stinespring ( data , input_dim , output_dim )", "nl": "Transform a QuantumChannel to the Stinespring representation ."}}
{"translation": {"code": "def _to_ptm ( rep , data , input_dim , output_dim ) : if rep == 'PTM' : return data # Check valid n-qubit input _check_nqubit_dim ( input_dim , output_dim ) if rep == 'Operator' : return _from_operator ( 'PTM' , data , input_dim , output_dim ) # Convert via Superoperator representation if rep != 'SuperOp' : data = _to_superop ( rep , data , input_dim , output_dim ) return _superop_to_ptm ( data , input_dim , output_dim )", "nl": "Transform a QuantumChannel to the PTM representation ."}}
{"translation": {"code": "def _to_chi ( rep , data , input_dim , output_dim ) : if rep == 'Chi' : return data # Check valid n-qubit input _check_nqubit_dim ( input_dim , output_dim ) if rep == 'Operator' : return _from_operator ( 'Chi' , data , input_dim , output_dim ) # Convert via Choi representation if rep != 'Choi' : data = _to_choi ( rep , data , input_dim , output_dim ) return _choi_to_chi ( data , input_dim , output_dim )", "nl": "Transform a QuantumChannel to the Chi representation ."}}
{"translation": {"code": "def _to_kraus ( rep , data , input_dim , output_dim ) : if rep == 'Kraus' : return data if rep == 'Stinespring' : return _stinespring_to_kraus ( data , input_dim , output_dim ) if rep == 'Operator' : return _from_operator ( 'Kraus' , data , input_dim , output_dim ) # Convert via Choi and Kraus if rep != 'Choi' : data = _to_choi ( rep , data , input_dim , output_dim ) return _choi_to_kraus ( data , input_dim , output_dim )", "nl": "Transform a QuantumChannel to the Kraus representation ."}}
{"translation": {"code": "def _to_superop ( rep , data , input_dim , output_dim ) : if rep == 'SuperOp' : return data if rep == 'Operator' : return _from_operator ( 'SuperOp' , data , input_dim , output_dim ) if rep == 'Choi' : return _choi_to_superop ( data , input_dim , output_dim ) if rep == 'Kraus' : return _kraus_to_superop ( data , input_dim , output_dim ) if rep == 'Chi' : data = _chi_to_choi ( data , input_dim , output_dim ) return _choi_to_superop ( data , input_dim , output_dim ) if rep == 'PTM' : return _ptm_to_superop ( data , input_dim , output_dim ) if rep == 'Stinespring' : return _stinespring_to_superop ( data , input_dim , output_dim ) raise QiskitError ( 'Invalid QuantumChannel {}' . format ( rep ) )", "nl": "Transform a QuantumChannel to the SuperOp representation ."}}
{"translation": {"code": "def _to_choi ( rep , data , input_dim , output_dim ) : if rep == 'Choi' : return data if rep == 'Operator' : return _from_operator ( 'Choi' , data , input_dim , output_dim ) if rep == 'SuperOp' : return _superop_to_choi ( data , input_dim , output_dim ) if rep == 'Kraus' : return _kraus_to_choi ( data , input_dim , output_dim ) if rep == 'Chi' : return _chi_to_choi ( data , input_dim , output_dim ) if rep == 'PTM' : data = _ptm_to_superop ( data , input_dim , output_dim ) return _superop_to_choi ( data , input_dim , output_dim ) if rep == 'Stinespring' : return _stinespring_to_choi ( data , input_dim , output_dim ) raise QiskitError ( 'Invalid QuantumChannel {}' . format ( rep ) )", "nl": "Transform a QuantumChannel to the Choi representation ."}}
{"translation": {"code": "def is_unitary_matrix ( mat , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT mat = np . array ( mat ) # Compute A^dagger.A and see if it is identity matrix mat = np . conj ( mat . T ) . dot ( mat ) return is_identity_matrix ( mat , ignore_phase = False , rtol = rtol , atol = atol )", "nl": "Test if an array is a unitary matrix ."}}
{"translation": {"code": "def is_identity_matrix ( mat , ignore_phase = False , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT mat = np . array ( mat ) if mat . ndim != 2 : return False if ignore_phase : # If the matrix is equal to an identity up to a phase, we can # remove the phase by multiplying each entry by the complex # conjugate of the phase of the [0, 0] entry. theta = np . angle ( mat [ 0 , 0 ] ) mat = np . exp ( - 1j * theta ) * mat # Check if square identity iden = np . eye ( len ( mat ) ) return np . allclose ( mat , iden , rtol = rtol , atol = atol )", "nl": "Test if an array is an identity matrix ."}}
{"translation": {"code": "def is_positive_semidefinite_matrix ( mat , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT if not is_hermitian_matrix ( mat , rtol = rtol , atol = atol ) : return False # Check eigenvalues are all positive vals = np . linalg . eigvalsh ( mat ) for v in vals : if v < - atol : return False return True", "nl": "Test if a matrix is positive semidefinite"}}
{"translation": {"code": "def is_hermitian_matrix ( mat , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT mat = np . array ( mat ) if mat . ndim != 2 : return False return np . allclose ( mat , np . conj ( mat . T ) , rtol = rtol , atol = atol )", "nl": "Test if an array is a Hermitian matrix"}}
{"translation": {"code": "def is_symmetric_matrix ( op , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT mat = np . array ( op ) if mat . ndim != 2 : return False return np . allclose ( mat , mat . T , rtol = rtol , atol = atol )", "nl": "Test if an array is a symmetrix matrix"}}
{"translation": {"code": "def is_diagonal_matrix ( mat , rtol = RTOL_DEFAULT , atol = ATOL_DEFAULT ) : if atol is None : atol = ATOL_DEFAULT if rtol is None : rtol = RTOL_DEFAULT mat = np . array ( mat ) if mat . ndim != 2 : return False return np . allclose ( mat , np . diag ( np . diagonal ( mat ) ) , rtol = rtol , atol = atol )", "nl": "Test if an array is a diagonal matrix"}}
{"translation": {"code": "def is_square_matrix ( mat ) : mat = np . array ( mat ) if mat . ndim != 2 : return False shape = mat . shape return shape [ 0 ] == shape [ 1 ]", "nl": "Test if an array is a square matrix ."}}
{"translation": {"code": "def _chi_to_choi ( data , input_dim , output_dim ) : num_qubits = int ( np . log2 ( input_dim ) ) return _transform_from_pauli ( data , num_qubits )", "nl": "Transform Chi representation to a Choi representation ."}}
{"translation": {"code": "def _kraus_to_stinespring ( data , input_dim , output_dim ) : stine_pair = [ None , None ] for i , kraus in enumerate ( data ) : if kraus is not None : num_kraus = len ( kraus ) stine = np . zeros ( ( output_dim * num_kraus , input_dim ) , dtype = complex ) for j , mat in enumerate ( kraus ) : vec = np . zeros ( num_kraus ) vec [ j ] = 1 stine += np . kron ( mat , vec [ : , None ] ) stine_pair [ i ] = stine return tuple ( stine_pair )", "nl": "Transform Kraus representation to Stinespring representation ."}}
{"translation": {"code": "def _stinespring_to_choi ( data , input_dim , output_dim ) : trace_dim = data [ 0 ] . shape [ 0 ] // output_dim stine_l = np . reshape ( data [ 0 ] , ( output_dim , trace_dim , input_dim ) ) if data [ 1 ] is None : stine_r = stine_l else : stine_r = np . reshape ( data [ 1 ] , ( output_dim , trace_dim , input_dim ) ) return np . reshape ( np . einsum ( 'iAj,kAl->jilk' , stine_l , stine_r . conj ( ) ) , 2 * [ input_dim * output_dim ] )", "nl": "Transform Stinespring representation to Choi representation ."}}
{"translation": {"code": "def hamming_distance ( str1 , str2 ) : if len ( str1 ) != len ( str2 ) : raise VisualizationError ( 'Strings not same length.' ) return sum ( s1 != s2 for s1 , s2 in zip ( str1 , str2 ) )", "nl": "Calculate the Hamming distance between two bit strings"}}
{"translation": {"code": "def mirror ( self ) : if not self . _definition : return self . copy ( ) reverse_inst = self . copy ( name = self . name + '_mirror' ) reverse_inst . definition = [ ] for inst , qargs , cargs in reversed ( self . _definition ) : reverse_inst . _definition . append ( ( inst . mirror ( ) , qargs , cargs ) ) return reverse_inst", "nl": "For a composite instruction reverse the order of sub - gates ."}}
{"translation": {"code": "def mirror ( self ) : reverse_circ = self . copy ( name = self . name + '_mirror' ) reverse_circ . data = [ ] for inst , qargs , cargs in reversed ( self . data ) : reverse_circ . data . append ( ( inst . mirror ( ) , qargs , cargs ) ) return reverse_circ", "nl": "Mirror the circuit by reversing the instructions ."}}
{"translation": {"code": "def inverse ( self ) : inverse_circ = self . copy ( name = self . name + '_dg' ) inverse_circ . data = [ ] for inst , qargs , cargs in reversed ( self . data ) : inverse_circ . data . append ( ( inst . inverse ( ) , qargs , cargs ) ) return inverse_circ", "nl": "Invert this circuit ."}}
{"translation": {"code": "def _attach ( self , instruction , qargs , cargs ) : self . append ( instruction , qargs , cargs )", "nl": "DEPRECATED after 0 . 8"}}
{"translation": {"code": "def _check_dups ( self , qubits ) : squbits = set ( qubits ) if len ( squbits ) != len ( qubits ) : raise QiskitError ( \"duplicate qubit arguments\" )", "nl": "Raise exception if list of qubits contains duplicates ."}}
{"translation": {"code": "def copy ( self , name = None ) : cpy = copy . copy ( self ) if name : cpy . name = name return cpy", "nl": "shallow copy of the instruction ."}}
{"translation": {"code": "def inverse ( self ) : if not self . definition : raise QiskitError ( \"inverse() not implemented for %s.\" % self . name ) inverse_gate = self . copy ( name = self . name + '_dg' ) inverse_gate . _definition = [ ] for inst , qargs , cargs in reversed ( self . _definition ) : inverse_gate . _definition . append ( ( inst . inverse ( ) , qargs , cargs ) ) return inverse_gate", "nl": "Invert this instruction ."}}
{"translation": {"code": "def circuit_to_instruction ( circuit ) : instruction = Instruction ( name = circuit . name , num_qubits = sum ( [ qreg . size for qreg in circuit . qregs ] ) , num_clbits = sum ( [ creg . size for creg in circuit . cregs ] ) , params = [ ] ) instruction . control = None def find_bit_position ( bit ) : \"\"\"find the index of a given bit (Register, int) within\n        a flat ordered list of bits of the circuit\n        \"\"\" if isinstance ( bit [ 0 ] , QuantumRegister ) : ordered_regs = circuit . qregs else : ordered_regs = circuit . cregs reg_index = ordered_regs . index ( bit [ 0 ] ) return sum ( [ reg . size for reg in ordered_regs [ : reg_index ] ] ) + bit [ 1 ] definition = circuit . data . copy ( ) if instruction . num_qubits > 0 : q = QuantumRegister ( instruction . num_qubits , 'q' ) if instruction . num_clbits > 0 : c = ClassicalRegister ( instruction . num_clbits , 'c' ) definition = list ( map ( lambda x : ( x [ 0 ] , list ( map ( lambda y : ( q , find_bit_position ( y ) ) , x [ 1 ] ) ) , list ( map ( lambda y : ( c , find_bit_position ( y ) ) , x [ 2 ] ) ) ) , definition ) ) instruction . definition = definition return instruction", "nl": "Build an Instruction object from a QuantumCircuit ."}}
{"translation": {"code": "def _select_best_remaining_qubit ( self , prog_qubit ) : reliab_store = { } for hw_qubit in self . available_hw_qubits : reliab = 1 for n in self . prog_graph . neighbors ( prog_qubit ) : if n in self . prog2hw : reliab *= self . swap_costs [ self . prog2hw [ n ] ] [ hw_qubit ] reliab *= self . readout_errors [ hw_qubit ] reliab_store [ hw_qubit ] = reliab max_reliab = 0 best_hw_qubit = None for hw_qubit in reliab_store : if reliab_store [ hw_qubit ] > max_reliab : max_reliab = reliab_store [ hw_qubit ] best_hw_qubit = hw_qubit return best_hw_qubit", "nl": "Select the best remaining hardware qubit for the next program qubit ."}}
{"translation": {"code": "def _initialize_backend_prop ( self ) : backend_prop = self . backend_prop for ginfo in backend_prop . gates : if ginfo . gate == 'cx' : for item in ginfo . parameters : if item . name == 'gate_error' : g_reliab = 1.0 - item . value break else : g_reliab = 1.0 swap_reliab = - math . log ( pow ( g_reliab , 3 ) ) self . swap_graph . add_edge ( ginfo . qubits [ 0 ] , ginfo . qubits [ 1 ] , weight = swap_reliab ) self . swap_graph . add_edge ( ginfo . qubits [ 1 ] , ginfo . qubits [ 0 ] , weight = swap_reliab ) self . cx_errors [ ( ginfo . qubits [ 0 ] , ginfo . qubits [ 1 ] ) ] = g_reliab self . gate_list . append ( ( ginfo . qubits [ 0 ] , ginfo . qubits [ 1 ] ) ) idx = 0 for q in backend_prop . qubits : for nduv in q : if nduv . name == 'readout_error' : self . readout_errors [ idx ] = 1.0 - nduv . value self . available_hw_qubits . append ( idx ) idx += 1 for edge in self . cx_errors : self . gate_cost [ edge ] = self . cx_errors [ edge ] * self . readout_errors [ edge [ 0 ] ] * self . readout_errors [ edge [ 1 ] ] self . swap_paths , swap_costs_temp = nx . algorithms . shortest_paths . dense . floyd_warshall_predecessor_and_distance ( self . swap_graph , weight = 'weight' ) for i in swap_costs_temp : self . swap_costs [ i ] = { } for j in swap_costs_temp [ i ] : if ( i , j ) in self . cx_errors : self . swap_costs [ i ] [ j ] = self . cx_errors [ ( i , j ) ] elif ( j , i ) in self . cx_errors : self . swap_costs [ i ] [ j ] = self . cx_errors [ ( j , i ) ] else : best_reliab = 0.0 for n in self . swap_graph . neighbors ( j ) : if ( n , j ) in self . cx_errors : reliab = math . exp ( - swap_costs_temp [ i ] [ n ] ) * self . cx_errors [ ( n , j ) ] else : reliab = math . exp ( - swap_costs_temp [ i ] [ n ] ) * self . cx_errors [ ( j , n ) ] if reliab > best_reliab : best_reliab = reliab self . swap_costs [ i ] [ j ] = best_reliab", "nl": "Extract readout and CNOT errors and compute swap costs ."}}
{"translation": {"code": "def _create_program_graph ( self , dag ) : idx = 0 for q in dag . qubits ( ) : self . qarg_to_id [ q [ 0 ] . name + str ( q [ 1 ] ) ] = idx idx += 1 for gate in dag . twoQ_gates ( ) : qid1 = self . _qarg_to_id ( gate . qargs [ 0 ] ) qid2 = self . _qarg_to_id ( gate . qargs [ 1 ] ) min_q = min ( qid1 , qid2 ) max_q = max ( qid1 , qid2 ) edge_weight = 1 if self . prog_graph . has_edge ( min_q , max_q ) : edge_weight = self . prog_graph [ min_q ] [ max_q ] [ 'weight' ] + 1 self . prog_graph . add_edge ( min_q , max_q , weight = edge_weight ) return idx", "nl": "Program graph has virtual qubits as nodes . Two nodes have an edge if the corresponding virtual qubits participate in a 2 - qubit gate . The edge is weighted by the number of CNOTs between the pair ."}}
{"translation": {"code": "def _select_next_edge ( self ) : for edge in self . pending_program_edges : q1_mapped = edge [ 0 ] in self . prog2hw q2_mapped = edge [ 1 ] in self . prog2hw assert not ( q1_mapped and q2_mapped ) if q1_mapped or q2_mapped : return edge return self . pending_program_edges [ 0 ]", "nl": "If there is an edge with one endpoint mapped return it . Else return in the first edge"}}
{"translation": {"code": "def _select_best_remaining_cx ( self ) : candidates = [ ] for gate in self . gate_list : chk1 = gate [ 0 ] in self . available_hw_qubits chk2 = gate [ 1 ] in self . available_hw_qubits if chk1 and chk2 : candidates . append ( gate ) best_reliab = 0 best_item = None for item in candidates : if self . gate_cost [ item ] > best_reliab : best_reliab = self . gate_cost [ item ] best_item = item return best_item", "nl": "Select best remaining CNOT in the hardware for the next program edge ."}}
{"translation": {"code": "def run ( self , dag ) : self . _initialize_backend_prop ( ) num_qubits = self . _create_program_graph ( dag ) if num_qubits > len ( self . swap_graph ) : raise TranspilerError ( 'Number of qubits greater than device.' ) for end1 , end2 , _ in sorted ( self . prog_graph . edges ( data = True ) , key = lambda x : x [ 2 ] [ 'weight' ] , reverse = True ) : self . pending_program_edges . append ( ( end1 , end2 ) ) while self . pending_program_edges : edge = self . _select_next_edge ( ) q1_mapped = edge [ 0 ] in self . prog2hw q2_mapped = edge [ 1 ] in self . prog2hw if ( not q1_mapped ) and ( not q2_mapped ) : best_hw_edge = self . _select_best_remaining_cx ( ) self . prog2hw [ edge [ 0 ] ] = best_hw_edge [ 0 ] self . prog2hw [ edge [ 1 ] ] = best_hw_edge [ 1 ] self . available_hw_qubits . remove ( best_hw_edge [ 0 ] ) self . available_hw_qubits . remove ( best_hw_edge [ 1 ] ) elif not q1_mapped : best_hw_qubit = self . _select_best_remaining_qubit ( edge [ 0 ] ) self . prog2hw [ edge [ 0 ] ] = best_hw_qubit self . available_hw_qubits . remove ( best_hw_qubit ) else : best_hw_qubit = self . _select_best_remaining_qubit ( edge [ 1 ] ) self . prog2hw [ edge [ 1 ] ] = best_hw_qubit self . available_hw_qubits . remove ( best_hw_qubit ) new_edges = [ x for x in self . pending_program_edges if not ( x [ 0 ] in self . prog2hw and x [ 1 ] in self . prog2hw ) ] self . pending_program_edges = new_edges for qid in self . qarg_to_id . values ( ) : if qid not in self . prog2hw : self . prog2hw [ qid ] = self . available_hw_qubits [ 0 ] self . available_hw_qubits . remove ( self . prog2hw [ qid ] ) layout = Layout ( ) for q in dag . qubits ( ) : pid = self . _qarg_to_id ( q ) hwid = self . prog2hw [ pid ] layout [ ( q [ 0 ] , q [ 1 ] ) ] = hwid self . property_set [ 'layout' ] = layout", "nl": "Main run method for the noise adaptive layout ."}}
{"translation": {"code": "def acquire ( self ) -> AcquireChannel : if self . _acquires : return self . _acquires [ 0 ] else : raise PulseError ( \"No acquire channels in q[%d]\" % self . _index )", "nl": "Return the primary acquire channel of this qubit ."}}
{"translation": {"code": "def drive ( self ) -> DriveChannel : if self . _drives : return self . _drives [ 0 ] else : raise PulseError ( \"No drive channels in q[%d]\" % self . _index )", "nl": "Return the primary drive channel of this qubit ."}}
{"translation": {"code": "def control ( self ) -> ControlChannel : if self . _controls : return self . _controls [ 0 ] else : raise PulseError ( \"No control channels in q[%d]\" % self . _index )", "nl": "Return the primary control channel of this qubit ."}}
{"translation": {"code": "def measure ( self ) -> MeasureChannel : if self . _measures : return self . _measures [ 0 ] else : raise PulseError ( \"No measurement channels in q[%d]\" % self . _index )", "nl": "Return the primary measure channel of this qubit ."}}
{"translation": {"code": "def swap_mapper_layer_update ( self , i , first_layer , best_layout , best_d , best_circ , layer_list ) : layout = best_layout dagcircuit_output = DAGCircuit ( ) QR = QuantumRegister ( self . coupling_map . size ( ) , 'q' ) dagcircuit_output . add_qreg ( QR ) # Identity wire-map for composing the circuits identity_wire_map = { ( QR , j ) : ( QR , j ) for j in range ( self . coupling_map . size ( ) ) } # If this is the first layer with multi-qubit gates, # output all layers up to this point and ignore any # swap gates. Set the initial layout. if first_layer : # Output all layers up to this point for j in range ( i + 1 ) : dagcircuit_output . compose_back ( layer_list [ j ] [ \"graph\" ] , layout ) # Otherwise, we output the current layer and the associated swap gates. else : # Output any swaps if best_d > 0 : dagcircuit_output . compose_back ( best_circ , identity_wire_map ) # Output this layer dagcircuit_output . compose_back ( layer_list [ i ] [ \"graph\" ] , layout ) return dagcircuit_output", "nl": "Update the QASM string for an iteration of swap_mapper ."}}
{"translation": {"code": "def has_overlap ( self , interval : 'Interval' ) -> bool : if self . begin < interval . end and interval . begin < self . end : return True return False", "nl": "Check if self has overlap with interval ."}}
{"translation": {"code": "def ch_start_time ( self , * channels : List [ Channel ] ) -> int : intervals = list ( itertools . chain ( * ( self . _table [ chan ] for chan in channels if chan in self . _table ) ) ) if intervals : return min ( ( interval . begin for interval in intervals ) ) return 0", "nl": "Return earliest start time in this collection ."}}
{"translation": {"code": "def ch_stop_time ( self , * channels : List [ Channel ] ) -> int : intervals = list ( itertools . chain ( * ( self . _table [ chan ] for chan in channels if chan in self . _table ) ) ) if intervals : return max ( ( interval . end for interval in intervals ) ) return 0", "nl": "Return maximum time of timeslots over all channels ."}}
{"translation": {"code": "def shift ( self , time : int ) -> 'Interval' : return Interval ( self . _begin + time , self . _end + time )", "nl": "Return a new interval shifted by time from self"}}
{"translation": {"code": "def _compose_subsystem ( self , other , qargs , front = False ) : # Compute tensor contraction indices from qargs input_dims = list ( self . input_dims ( ) ) output_dims = list ( self . output_dims ( ) ) if front : num_indices = len ( self . input_dims ( ) ) shift = 2 * len ( self . output_dims ( ) ) right_mul = True for pos , qubit in enumerate ( qargs ) : input_dims [ qubit ] = other . _input_dims [ pos ] else : num_indices = len ( self . output_dims ( ) ) shift = 0 right_mul = False for pos , qubit in enumerate ( qargs ) : output_dims [ qubit ] = other . _output_dims [ pos ] # Reshape current matrix # Note that we must reverse the subsystem dimension order as # qubit 0 corresponds to the right-most position in the tensor # product, which is the last tensor wire index. tensor = np . reshape ( self . data , self . _shape ) mat = np . reshape ( other . data , other . _shape ) # Add first set of indicies indices = [ 2 * num_indices - 1 - qubit for qubit in qargs ] + [ num_indices - 1 - qubit for qubit in qargs ] final_shape = [ np . product ( output_dims ) ** 2 , np . product ( input_dims ) ** 2 ] data = np . reshape ( self . _einsum_matmul ( tensor , mat , indices , shift , right_mul ) , final_shape ) return SuperOp ( data , input_dims , output_dims )", "nl": "Return the composition channel ."}}
{"translation": {"code": "def _rtol ( self , rtol ) : # NOTE: that this overrides the class value so applies to all # instances of the class. max_tol = self . __class__ . MAX_TOL if rtol < 0 : raise QiskitError ( \"Invalid rtol: must be non-negative.\" ) if rtol > max_tol : raise QiskitError ( \"Invalid rtol: must be less than {}.\" . format ( max_tol ) ) self . __class__ . RTOL = rtol", "nl": "Set the relative tolerence parameter for float comparisons ."}}
{"translation": {"code": "def is_unitary ( self , atol = None , rtol = None ) : try : op = self . to_operator ( ) return op . is_unitary ( atol = atol , rtol = rtol ) except QiskitError : return False", "nl": "Return True if QuantumChannel is a unitary channel ."}}
{"translation": {"code": "def _reshape ( self , input_dims = None , output_dims = None ) : if input_dims is not None : if np . product ( input_dims ) != self . _input_dim : raise QiskitError ( \"Reshaped input_dims are incompatible with combined input dimension.\" ) self . _input_dims = tuple ( input_dims ) if output_dims is not None : if np . product ( output_dims ) != self . _output_dim : raise QiskitError ( \"Reshaped input_dims are incompatible with combined input dimension.\" ) self . _output_dims = tuple ( output_dims ) return self", "nl": "Reshape input and output dimensions of operator ."}}
{"translation": {"code": "def input_dims ( self , qargs = None ) : if qargs is None : return self . _input_dims return tuple ( self . _input_dims [ i ] for i in qargs )", "nl": "Return tuple of input dimension for specified subsystems ."}}
{"translation": {"code": "def output_dims ( self , qargs = None ) : if qargs is None : return self . _output_dims return tuple ( self . _output_dims [ i ] for i in qargs )", "nl": "Return tuple of output dimension for specified subsystems ."}}
{"translation": {"code": "def copy ( self ) : # pylint: disable=no-value-for-parameter # The constructor of subclasses from raw data should be a copy return self . __class__ ( self . data , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Make a copy of current operator ."}}
{"translation": {"code": "def power ( self , n ) : # NOTE: if a subclass can have negative or non-integer powers # this method should be overriden in that class. if not isinstance ( n , ( int , np . integer ) ) or n < 1 : raise QiskitError ( \"Can only power with positive integer powers.\" ) if self . _input_dim != self . _output_dim : raise QiskitError ( \"Can only power with input_dim = output_dim.\" ) ret = self . copy ( ) for _ in range ( 1 , n ) : ret = ret . compose ( self ) return ret", "nl": "Return the compose of a operator with itself n times ."}}
{"translation": {"code": "def _atol ( self , atol ) : # NOTE: that this overrides the class value so applies to all # instances of the class. max_tol = self . __class__ . MAX_TOL if atol < 0 : raise QiskitError ( \"Invalid atol: must be non-negative.\" ) if atol > max_tol : raise QiskitError ( \"Invalid atol: must be less than {}.\" . format ( max_tol ) ) self . __class__ . ATOL = atol", "nl": "Set the absolute tolerence parameter for float comparisons ."}}
{"translation": {"code": "def _einsum_matmul ( cls , tensor , mat , indices , shift = 0 , right_mul = False ) : rank = tensor . ndim rank_mat = mat . ndim if rank_mat % 2 != 0 : raise QiskitError ( \"Contracted matrix must have an even number of indices.\" ) # Get einsum indices for tensor indices_tensor = list ( range ( rank ) ) for j , index in enumerate ( indices ) : indices_tensor [ index + shift ] = rank + j # Get einsum indces for mat mat_contract = list ( reversed ( range ( rank , rank + len ( indices ) ) ) ) mat_free = [ index + shift for index in reversed ( indices ) ] if right_mul : indices_mat = mat_contract + mat_free else : indices_mat = mat_free + mat_contract return np . einsum ( tensor , indices_tensor , mat , indices_mat )", "nl": "Perform a contraction using Numpy . einsum"}}
{"translation": {"code": "def conjugate ( self ) : return Operator ( np . conj ( self . data ) , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Return the conjugate of the operator ."}}
{"translation": {"code": "def transpose ( self ) : return Operator ( np . transpose ( self . data ) , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Return the transpose of the operator ."}}
{"translation": {"code": "def power ( self , n ) : if not isinstance ( n , int ) : raise QiskitError ( \"Can only take integer powers of Operator.\" ) if self . input_dims ( ) != self . output_dims ( ) : raise QiskitError ( \"Can only power with input_dims = output_dims.\" ) # Override base class power so we can implement more efficiently # using Numpy.matrix_power return Operator ( np . linalg . matrix_power ( self . data , n ) , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Return the matrix power of the operator ."}}
{"translation": {"code": "def _automatic_dims ( cls , dims , size ) : if dims is None : dims = size elif np . product ( dims ) != size : raise QiskitError ( \"dimensions do not match size.\" ) if isinstance ( dims , ( int , np . integer ) ) : num_qubits = int ( np . log2 ( dims ) ) if 2 ** num_qubits == size : return num_qubits * ( 2 , ) return ( dims , ) return tuple ( dims )", "nl": "Check if input dimension corresponds to qubit subsystems ."}}
{"translation": {"code": "def to_operator ( self ) : mat = _to_operator ( self . rep , self . _data , * self . dim ) return Operator ( mat , self . input_dims ( ) , self . output_dims ( ) )", "nl": "Try to convert channel to a unitary representation Operator ."}}
{"translation": {"code": "def _shape ( self ) : return tuple ( reversed ( self . output_dims ( ) ) ) + tuple ( reversed ( self . input_dims ( ) ) )", "nl": "Return the tensor shape of the matrix operator"}}
{"translation": {"code": "def is_unitary ( self , atol = None , rtol = None ) : if atol is None : atol = self . _atol if rtol is None : rtol = self . _rtol return is_unitary_matrix ( self . _data , rtol = rtol , atol = atol )", "nl": "Return True if operator is a unitary matrix ."}}