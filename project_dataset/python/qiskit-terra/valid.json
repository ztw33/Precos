{"translation": {"code": "def dump_passes ( self ) : ret = { 'options' : self . options , 'passes' : [ ] , 'type' : type ( self ) } for pass_ in self . _passes : if isinstance ( pass_ , FlowController ) : ret [ 'passes' ] . append ( pass_ . dump_passes ( ) ) else : ret [ 'passes' ] . append ( pass_ ) return ret", "nl": "Fetches the passes added to this flow controller ."}}
{"translation": {"code": "def passes ( self ) : ret = [ ] for pass_ in self . working_list : ret . append ( pass_ . dump_passes ( ) ) return ret", "nl": "Returns a list structure of the appended passes and its options ."}}
{"translation": {"code": "def __random_density_bures ( N , rank = None , seed = None ) : P = np . eye ( N ) + random_unitary ( N ) . data G = P . dot ( __ginibre_matrix ( N , rank , seed ) ) G = G . dot ( G . conj ( ) . T ) return G / np . trace ( G )", "nl": "Generate a random density matrix from the Bures metric ."}}
{"translation": {"code": "def run ( self , circuit ) : name = circuit . name dag = circuit_to_dag ( circuit ) del circuit for passset in self . working_list : for pass_ in passset : dag = self . _do_pass ( pass_ , dag , passset . options ) circuit = dag_to_circuit ( dag ) circuit . name = name return circuit", "nl": "Run all the passes on a QuantumCircuit"}}
{"translation": {"code": "def random_density_matrix ( length , rank = None , method = 'Hilbert-Schmidt' , seed = None ) : if method == 'Hilbert-Schmidt' : return __random_density_hs ( length , rank , seed ) elif method == 'Bures' : return __random_density_bures ( length , rank , seed ) else : raise QiskitError ( 'Error: unrecognized method {}' . format ( method ) )", "nl": "Generate a random density matrix rho ."}}
{"translation": {"code": "def simplify_U ( theta , phi , lam ) : gate = U3Gate ( theta , phi , lam ) # Y rotation is 0 mod 2*pi, so the gate is a u1 if abs ( gate . params [ 0 ] % ( 2.0 * math . pi ) ) < _CUTOFF_PRECISION : gate = U1Gate ( gate . params [ 0 ] + gate . params [ 1 ] + gate . params [ 2 ] ) # Y rotation is pi/2 or -pi/2 mod 2*pi, so the gate is a u2 if isinstance ( gate , U3Gate ) : # theta = pi/2 + 2*k*pi if abs ( ( gate . params [ 0 ] - math . pi / 2 ) % ( 2.0 * math . pi ) ) < _CUTOFF_PRECISION : gate = U2Gate ( gate . params [ 1 ] , gate . params [ 2 ] + ( gate . params [ 0 ] - math . pi / 2 ) ) # theta = -pi/2 + 2*k*pi if abs ( ( gate . params [ 0 ] + math . pi / 2 ) % ( 2.0 * math . pi ) ) < _CUTOFF_PRECISION : gate = U2Gate ( gate . params [ 1 ] + math . pi , gate . params [ 2 ] - math . pi + ( gate . params [ 0 ] + math . pi / 2 ) ) # u1 and lambda is 0 mod 4*pi so gate is nop if isinstance ( gate , U1Gate ) and abs ( gate . params [ 0 ] % ( 4.0 * math . pi ) ) < _CUTOFF_PRECISION : gate = IdGate ( ) return gate", "nl": "Return the gate u1 u2 or u3 implementing U with the fewest pulses ."}}
{"translation": {"code": "def num_connected_components ( self , unitary_only = False ) : # Convert registers to ints (as done in depth). reg_offset = 0 reg_map = { } if unitary_only : regs = self . qregs else : regs = self . qregs + self . cregs for reg in regs : reg_map [ reg . name ] = reg_offset reg_offset += reg . size # Start with each qubit or cbit being its own subgraph. sub_graphs = [ [ bit ] for bit in range ( reg_offset ) ] num_sub_graphs = len ( sub_graphs ) # Here we are traversing the gates and looking to see # which of the sub_graphs the gate joins together. for instr , qargs , cargs in self . data : if unitary_only : args = qargs num_qargs = len ( args ) else : args = qargs + cargs num_qargs = len ( args ) + ( 1 if instr . control else 0 ) if num_qargs >= 2 and instr . name not in [ 'barrier' , 'snapshot' ] : graphs_touched = [ ] num_touched = 0 # Controls necessarily join all the cbits in the # register that they use. if instr . control and not unitary_only : creg = instr . control [ 0 ] creg_int = reg_map [ creg . name ] for coff in range ( creg . size ) : temp_int = creg_int + coff for k in range ( num_sub_graphs ) : if temp_int in sub_graphs [ k ] : graphs_touched . append ( k ) num_touched += 1 break for item in args : reg_int = reg_map [ item [ 0 ] . name ] + item [ 1 ] for k in range ( num_sub_graphs ) : if reg_int in sub_graphs [ k ] : if k not in graphs_touched : graphs_touched . append ( k ) num_touched += 1 break # If the gate touches more than one subgraph # join those graphs together and return # reduced number of subgraphs if num_touched > 1 : connections = [ ] for idx in graphs_touched : connections . extend ( sub_graphs [ idx ] ) _sub_graphs = [ ] for idx in range ( num_sub_graphs ) : if idx not in graphs_touched : _sub_graphs . append ( sub_graphs [ idx ] ) _sub_graphs . append ( connections ) sub_graphs = _sub_graphs num_sub_graphs -= ( num_touched - 1 ) # Cannot go lower than one so break if num_sub_graphs == 1 : break return num_sub_graphs", "nl": "How many non - entangled subcircuits can the circuit be factored to ."}}
{"translation": {"code": "def format_level_0_memory ( memory ) : formatted_memory = _list_to_complex_array ( memory ) # infer meas_return from shape of returned data. if not 2 <= len ( formatted_memory . shape ) <= 3 : raise QiskitError ( 'Level zero memory is not of correct shape.' ) return formatted_memory", "nl": "Format an experiment result memory object for measurement level 0 ."}}
{"translation": {"code": "def format_level_2_memory ( memory , header = None ) : memory_list = [ ] for shot_memory in memory : memory_list . append ( format_counts_memory ( shot_memory , header ) ) return memory_list", "nl": "Format an experiment result memory object for measurement level 2 ."}}
{"translation": {"code": "def params ( self ) : # if params already defined don't attempt to get them from definition if self . _definition and not self . _params : self . _params = [ ] for sub_instr , _ , _ in self . _definition : self . _params . extend ( sub_instr . params ) # recursive call return self . _params else : return self . _params", "nl": "return instruction params"}}
{"translation": {"code": "def cos ( times : np . ndarray , amp : complex , freq : float , phase : float = 0 ) -> np . ndarray : return amp * np . cos ( 2 * np . pi * freq * times + phase ) . astype ( np . complex_ )", "nl": "Continuous cosine wave ."}}
{"translation": {"code": "def square ( times : np . ndarray , amp : complex , period : float , phase : float = 0 ) -> np . ndarray : x = times / period + phase / np . pi return amp * ( 2 * ( 2 * np . floor ( x ) - np . floor ( 2 * x ) ) + 1 ) . astype ( np . complex_ )", "nl": "Continuous square wave ."}}
{"translation": {"code": "def sawtooth ( duration : int , amp : complex , period : float = None , phase : float = 0 , name : str = None ) -> SamplePulse : if period is None : period = duration return _sampled_sawtooth_pulse ( duration , amp , period , phase = phase , name = name )", "nl": "Generates sawtooth wave SamplePulse ."}}
{"translation": {"code": "def gaussian ( duration : int , amp : complex , sigma : float , name : str = None ) -> SamplePulse : center = duration / 2 zeroed_width = duration + 2 return _sampled_gaussian_pulse ( duration , amp , center , sigma , zeroed_width = zeroed_width , rescale_amp = True , name = name )", "nl": "r Generates unnormalized gaussian SamplePulse ."}}
{"translation": {"code": "def gaussian_deriv ( duration : int , amp : complex , sigma : float , name : str = None ) -> SamplePulse : center = duration / 2 return _sampled_gaussian_deriv_pulse ( duration , amp , center , sigma , name = name )", "nl": "r Generates unnormalized gaussian derivative SamplePulse ."}}
{"translation": {"code": "def gaussian_square ( duration : int , amp : complex , sigma : float , risefall : int , name : str = None ) -> SamplePulse : center = duration / 2 width = duration - 2 * risefall zeroed_width = duration + 2 return _sampled_gaussian_square_pulse ( duration , amp , center , width , sigma , zeroed_width = zeroed_width , name = name )", "nl": "Generates gaussian square SamplePulse ."}}
{"translation": {"code": "def gaussian_square ( times : np . ndarray , amp : complex , center : float , width : float , sigma : float , zeroed_width : Union [ None , float ] = None ) -> np . ndarray : square_start = center - width / 2 square_stop = center + width / 2 if zeroed_width : zeroed_width = min ( width , zeroed_width ) gauss_zeroed_width = zeroed_width - width else : gauss_zeroed_width = None funclist = [ functools . partial ( gaussian , amp = amp , center = square_start , sigma = sigma , zeroed_width = gauss_zeroed_width , rescale_amp = True ) , functools . partial ( gaussian , amp = amp , center = square_stop , sigma = sigma , zeroed_width = gauss_zeroed_width , rescale_amp = True ) , functools . partial ( constant , amp = amp ) ] condlist = [ times <= square_start , times >= square_stop ] return np . piecewise ( times . astype ( np . complex_ ) , condlist , funclist )", "nl": "r Continuous gaussian square pulse ."}}
{"translation": {"code": "def gaussian_deriv ( times : np . ndarray , amp : complex , center : float , sigma : float , ret_gaussian : bool = False ) -> np . ndarray : gauss , x = gaussian ( times , amp = amp , center = center , sigma = sigma , ret_x = True ) gauss_deriv = - x / sigma * gauss if ret_gaussian : return gauss_deriv , gauss return gauss_deriv", "nl": "Continuous unnormalized gaussian derivative pulse ."}}
{"translation": {"code": "def gaussian ( times : np . ndarray , amp : complex , center : float , sigma : float , zeroed_width : Union [ None , float ] = None , rescale_amp : bool = False , ret_x : bool = False ) -> Union [ np . ndarray , Tuple [ np . ndarray , np . ndarray ] ] : times = np . asarray ( times , dtype = np . complex_ ) x = ( times - center ) / sigma gauss = amp * np . exp ( - x ** 2 / 2 ) . astype ( np . complex_ ) if zeroed_width is not None : gauss = _fix_gaussian_width ( gauss , amp = amp , center = center , sigma = sigma , zeroed_width = zeroed_width , rescale_amp = rescale_amp ) if ret_x : return gauss , x return gauss", "nl": "r Continuous unnormalized gaussian pulse ."}}
{"translation": {"code": "def _fix_gaussian_width ( gaussian_samples , amp : float , center : float , sigma : float , zeroed_width : Union [ None , float ] = None , rescale_amp : bool = False , ret_scale_factor : bool = False ) -> np . ndarray : if zeroed_width is None : zeroed_width = 2 * ( center + 1 ) zero_offset = gaussian ( np . array ( [ - zeroed_width / 2 ] ) , amp , center , sigma ) gaussian_samples -= zero_offset amp_scale_factor = 1. if rescale_amp : amp_scale_factor = amp / ( amp - zero_offset ) gaussian_samples *= amp_scale_factor if ret_scale_factor : return gaussian_samples , amp_scale_factor return gaussian_samples", "nl": "r Enforce that the supplied gaussian pulse is zeroed at a specific width ."}}
{"translation": {"code": "def default_pass_manager ( basis_gates , coupling_map , initial_layout , seed_transpiler ) : pass_manager = PassManager ( ) pass_manager . property_set [ 'layout' ] = initial_layout pass_manager . append ( Unroller ( basis_gates ) ) # Use the trivial layout if no layout is found pass_manager . append ( TrivialLayout ( coupling_map ) , condition = lambda property_set : not property_set [ 'layout' ] ) # if the circuit and layout already satisfy the coupling_constraints, use that layout # otherwise layout on the most densely connected physical qubit subset pass_manager . append ( CheckMap ( coupling_map ) ) pass_manager . append ( DenseLayout ( coupling_map ) , condition = lambda property_set : not property_set [ 'is_swap_mapped' ] ) # Extend the the dag/layout with ancillas using the full coupling map pass_manager . append ( FullAncillaAllocation ( coupling_map ) ) pass_manager . append ( EnlargeWithAncilla ( ) ) # Circuit must only contain 1- or 2-qubit interactions for swapper to work pass_manager . append ( Unroll3qOrMore ( ) ) # Swap mapper pass_manager . append ( LegacySwap ( coupling_map , trials = 20 , seed = seed_transpiler ) ) # Expand swaps pass_manager . append ( Decompose ( SwapGate ) ) # Change CX directions pass_manager . append ( CXDirection ( coupling_map ) ) # Unroll to the basis pass_manager . append ( Unroller ( [ 'u1' , 'u2' , 'u3' , 'id' , 'cx' ] ) ) # Simplify single qubit gates and CXs simplification_passes = [ Optimize1qGates ( ) , CXCancellation ( ) , RemoveResetInZeroState ( ) ] pass_manager . append ( simplification_passes + [ Depth ( ) , FixedPoint ( 'depth' ) ] , do_while = lambda property_set : not property_set [ 'depth_fixed_point' ] ) return pass_manager", "nl": "The default pass manager that maps to the coupling map ."}}
{"translation": {"code": "def default_pass_manager_simulator ( basis_gates ) : pass_manager = PassManager ( ) pass_manager . append ( Unroller ( basis_gates ) ) pass_manager . append ( [ RemoveResetInZeroState ( ) , Depth ( ) , FixedPoint ( 'depth' ) ] , do_while = lambda property_set : not property_set [ 'depth_fixed_point' ] ) return pass_manager", "nl": "The default pass manager without a coupling map ."}}
{"translation": {"code": "def shift ( self , time : int ) -> 'TimeslotCollection' : slots = [ Timeslot ( slot . interval . shift ( time ) , slot . channel ) for slot in self . timeslots ] return TimeslotCollection ( * slots )", "nl": "Return a new TimeslotCollection shifted by time ."}}
{"translation": {"code": "def is_mergeable_with ( self , timeslots : 'TimeslotCollection' ) -> bool : for slot in timeslots . timeslots : for interval in self . _table [ slot . channel ] : if slot . interval . has_overlap ( interval ) : return False return True", "nl": "Return if self is mergeable with timeslots ."}}
{"translation": {"code": "def convert_persistent_value ( self , shift , instruction ) : command_dict = { 'name' : 'pv' , 't0' : shift + instruction . start_time , 'ch' : instruction . channels [ 0 ] . name , 'val' : instruction . command . value } return self . _qobj_model ( * * command_dict )", "nl": "Return converted PersistentValueInstruction ."}}
{"translation": {"code": "def includes ( self , lo_freq : float ) -> bool : if self . _lb <= lo_freq <= self . _ub : return True return False", "nl": "Whether lo_freq is within the LoRange ."}}
{"translation": {"code": "def convert_acquire ( self , shift , instruction ) : meas_level = self . _run_config . get ( 'meas_level' , 2 ) command_dict = { 'name' : 'acquire' , 't0' : shift + instruction . start_time , 'duration' : instruction . duration , 'qubits' : [ q . index for q in instruction . acquires ] , 'memory_slot' : [ m . index for m in instruction . mem_slots ] } if meas_level == 2 : # setup discriminators if instruction . command . discriminator : command_dict . update ( { 'discriminators' : [ QobjMeasurementOption ( name = instruction . command . discriminator . name , params = instruction . command . discriminator . params ) ] } ) # setup register_slots command_dict . update ( { 'register_slot' : [ regs . index for regs in instruction . reg_slots ] } ) if meas_level >= 1 : # setup kernels if instruction . command . kernel : command_dict . update ( { 'kernels' : [ QobjMeasurementOption ( name = instruction . command . kernel . name , params = instruction . command . kernel . params ) ] } ) return self . _qobj_model ( * * command_dict )", "nl": "Return converted AcquireInstruction ."}}
{"translation": {"code": "def edges ( self , nodes = None ) : for source_node , dest_node , edge_data in self . _multi_graph . edges ( nodes , data = True ) : yield source_node , dest_node , edge_data", "nl": "Iterator for node values ."}}
{"translation": {"code": "def insert ( parent : ScheduleComponent , time : int , child : ScheduleComponent , name : str = None ) -> Schedule : return union ( parent , ( time , child ) , name = name )", "nl": "Return a new schedule with the child schedule inserted into the parent at start_time ."}}
{"translation": {"code": "def append ( parent : ScheduleComponent , child : ScheduleComponent , name : str = None ) -> Schedule : common_channels = set ( parent . channels ) & set ( child . channels ) insertion_time = parent . ch_stop_time ( * common_channels ) return insert ( parent , insertion_time , child , name = name )", "nl": "r Return a new schedule with by appending child to parent at the last time of the parent schedule s channels over the intersection of the parent and child schedule s channels ."}}
{"translation": {"code": "def _instructions ( self , time : int = 0 ) -> Iterable [ Tuple [ int , 'Instruction' ] ] : for insert_time , child_sched in self . children : yield from child_sched . _instructions ( time + insert_time )", "nl": "Iterable for flattening Schedule tree ."}}
{"translation": {"code": "def ch_start_time ( self , * channels : List [ Channel ] ) -> int : return self . timeslots . ch_start_time ( * channels )", "nl": "Return minimum start time for supplied channels ."}}
{"translation": {"code": "def ch_duration ( self , * channels : List [ Channel ] ) -> int : return self . timeslots . ch_duration ( * channels )", "nl": "Return duration of supplied channels ."}}
{"translation": {"code": "def label ( self , name ) : if isinstance ( name , str ) : self . _label = name else : raise TypeError ( 'label expects a string' )", "nl": "Set snapshot label to name"}}
{"translation": {"code": "def subgraph ( self , nodelist ) : subcoupling = CouplingMap ( ) subcoupling . graph = self . graph . subgraph ( nodelist ) for node in nodelist : if node not in subcoupling . physical_qubits : subcoupling . add_physical_qubit ( node ) return subcoupling", "nl": "Return a CouplingMap object for a subgraph of self ."}}
{"translation": {"code": "def physical_qubits ( self ) : if self . _qubit_list is None : self . _qubit_list = sorted ( [ pqubit for pqubit in self . graph . nodes ] ) return self . _qubit_list", "nl": "Returns a sorted list of physical_qubits"}}
{"translation": {"code": "def is_connected ( self ) : try : return nx . is_weakly_connected ( self . graph ) except nx . exception . NetworkXException : return False", "nl": "Test if the graph is connected ."}}
{"translation": {"code": "def _compute_distance_matrix ( self ) : if not self . is_connected ( ) : raise CouplingError ( \"coupling graph not connected\" ) lengths = nx . all_pairs_shortest_path_length ( self . graph . to_undirected ( as_view = True ) ) lengths = dict ( lengths ) size = len ( lengths ) cmap = np . zeros ( ( size , size ) ) for idx in range ( size ) : cmap [ idx , np . fromiter ( lengths [ idx ] . keys ( ) , dtype = int ) ] = np . fromiter ( lengths [ idx ] . values ( ) , dtype = int ) self . _dist_matrix = cmap", "nl": "Compute the full distance matrix on pairs of nodes ."}}
{"translation": {"code": "def distance ( self , physical_qubit1 , physical_qubit2 ) : if physical_qubit1 not in self . physical_qubits : raise CouplingError ( \"%s not in coupling graph\" % ( physical_qubit1 , ) ) if physical_qubit2 not in self . physical_qubits : raise CouplingError ( \"%s not in coupling graph\" % ( physical_qubit2 , ) ) if self . _dist_matrix is None : self . _compute_distance_matrix ( ) return self . _dist_matrix [ physical_qubit1 , physical_qubit2 ]", "nl": "Returns the undirected distance between physical_qubit1 and physical_qubit2 ."}}
{"translation": {"code": "def copy ( self ) : layout_copy = type ( self ) ( ) layout_copy . _p2v = self . _p2v . copy ( ) layout_copy . _v2p = self . _v2p . copy ( ) return layout_copy", "nl": "Returns a copy of a Layout instance ."}}
{"translation": {"code": "def run ( self , dag ) : new_dag = DAGCircuit ( ) for qreg in dag . qregs . values ( ) : new_dag . add_qreg ( qreg ) for creg in dag . cregs . values ( ) : new_dag . add_creg ( creg ) # compute ordered indices for the global circuit wires global_index_map = { } for wire in dag . wires : if not isinstance ( wire [ 0 ] , QuantumRegister ) : continue global_qregs = list ( dag . qregs . values ( ) ) global_index_map [ wire ] = global_qregs . index ( wire [ 0 ] ) + wire [ 1 ] blocks = self . property_set [ 'block_list' ] nodes_seen = set ( ) for node in dag . topological_op_nodes ( ) : # skip already-visited nodes or input/output nodes if node in nodes_seen or node . type == 'in' or node . type == 'out' : continue # check if the node belongs to the next block if blocks and node in blocks [ 0 ] : block = blocks [ 0 ] # find the qubits involved in this block block_qargs = set ( ) for nd in block : block_qargs |= set ( nd . qargs ) # convert block to a sub-circuit, then simulate unitary and add block_width = len ( block_qargs ) q = QuantumRegister ( block_width ) subcirc = QuantumCircuit ( q ) block_index_map = self . _block_qargs_to_indices ( block_qargs , global_index_map ) for nd in block : nodes_seen . add ( nd ) subcirc . append ( nd . op , [ q [ block_index_map [ i ] ] for i in nd . qargs ] ) unitary = UnitaryGate ( Operator ( subcirc ) ) # simulates the circuit new_dag . apply_operation_back ( unitary , sorted ( block_qargs , key = lambda x : block_index_map [ x ] ) ) del blocks [ 0 ] else : # the node could belong to some future block, but in that case # we simply skip it. It is guaranteed that we will revisit that # future block, via its other nodes for block in blocks [ 1 : ] : if node in block : break # freestanding nodes can just be added else : nodes_seen . add ( node ) new_dag . apply_operation_back ( node . op , node . qargs , node . cargs ) return new_dag", "nl": "iterate over each block and replace it with an equivalent Unitary on the same wires ."}}
{"translation": {"code": "def _bind_parameter ( self , parameter , value ) : for ( instr , param_index ) in self . _parameter_table [ parameter ] : instr . params [ param_index ] = value", "nl": "Assigns a parameter value to matching instructions in - place ."}}
{"translation": {"code": "def _split_runs_on_parameters ( runs ) : def _is_dagnode_parameterized ( node ) : return any ( isinstance ( param , Parameter ) for param in node . op . params ) out = [ ] for run in runs : groups = groupby ( run , _is_dagnode_parameterized ) for group_is_parameterized , gates in groups : if not group_is_parameterized : out . append ( list ( gates ) ) return out", "nl": "Finds runs containing parameterized gates and splits them into sequential runs excluding the parameterized gates ."}}