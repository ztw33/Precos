{"translation": {"code": "def _read_response ( self , response , field = \"detail\" ) : try : message = json . loads ( response . _content . decode ( 'utf-8' ) ) [ field ] except : message = response . reason return message", "nl": "attempt to read the detail provided by the response . If none default to using the reason"}}
{"translation": {"code": "def get_bucket ( self ) : for attr in [ 'bucket_name' , 's3' ] : if not hasattr ( self , attr ) : bot . exit ( 'client is missing attribute %s' % ( attr ) ) # See if the bucket is already existing self . bucket = None for bucket in self . s3 . buckets . all ( ) : if bucket . name == self . bucket_name : self . bucket = bucket # If the bucket doesn't exist, create it if self . bucket is None : self . bucket = self . s3 . create_bucket ( Bucket = self . bucket_name ) bot . info ( 'Created bucket %s' % self . bucket . name ) return self . bucket", "nl": "given a bucket name and a client that is initialized get or create the bucket ."}}
{"translation": {"code": "def search ( self , query = None , args = None ) : if query is not None : return self . _container_search ( query ) # Search collections across all fields return self . _search_all ( )", "nl": "query a s3 endpoint for an image based on a string"}}
{"translation": {"code": "def get_build_template ( ) : base = get_installdir ( ) name = \"%s/main/templates/build/singularity-cloudbuild.json\" % base if os . path . exists ( name ) : bot . debug ( \"Found template %s\" % name ) return read_json ( name ) bot . warning ( \"Template %s not found.\" % name )", "nl": "get default build template ."}}
{"translation": {"code": "def _update_secrets ( self ) : env = 'GOOGLE_APPLICATION_CREDENTIALS' self . _secrets = self . _get_and_update_setting ( env ) if self . _secrets is None : bot . error ( 'You must export %s to use Google Storage client' % env ) sys . exit ( 1 )", "nl": "The user is required to have an application secrets file in his or her environment . The information isn t saved to the secrets file but the client exists with error if the variable isn t found ."}}
{"translation": {"code": "def run_build ( self , config , bucket , names ) : project = self . _get_project ( ) #          prefix,    message, color bot . custom ( 'PROJECT' , project , \"CYAN\" ) bot . custom ( 'BUILD  ' , config [ 'steps' ] [ 0 ] [ 'name' ] , \"CYAN\" ) response = self . _build_service . projects ( ) . builds ( ) . create ( body = config , projectId = project ) . execute ( ) build_id = response [ 'metadata' ] [ 'build' ] [ 'id' ] status = response [ 'metadata' ] [ 'build' ] [ 'status' ] bot . log ( \"build %s: %s\" % ( build_id , status ) ) start = time . time ( ) while status not in [ 'COMPLETE' , 'FAILURE' , 'SUCCESS' ] : time . sleep ( 15 ) response = self . _build_service . projects ( ) . builds ( ) . get ( id = build_id , projectId = project ) . execute ( ) build_id = response [ 'id' ] status = response [ 'status' ] bot . log ( \"build %s: %s\" % ( build_id , status ) ) end = time . time ( ) bot . log ( 'Total build time: %s seconds' % ( round ( end - start , 2 ) ) ) # If successful, update blob metadata and visibility if status == 'SUCCESS' : # Does the user want to keep the container private? env = 'SREGISTRY_GOOGLE_STORAGE_PRIVATE' blob = bucket . blob ( response [ 'artifacts' ] [ 'objects' ] [ 'paths' ] [ 0 ] ) # Make Public, if desired if self . _get_and_update_setting ( env ) == None : blob . make_public ( ) response [ 'public_url' ] = blob . public_url # Add the metadata directly to the object update_blob_metadata ( blob , response , config , bucket , names ) response [ 'media_link' ] = blob . media_link response [ 'size' ] = blob . size response [ 'file_hash' ] = blob . md5_hash return response", "nl": "run a build meaning creating a build . Retry if there is failure"}}
{"translation": {"code": "def get_file_hash ( filename ) : hasher = hashlib . sha256 ( ) with open ( filename , \"rb\" ) as f : for chunk in iter ( lambda : f . read ( 4096 ) , b\"\" ) : hasher . update ( chunk ) return hasher . hexdigest ( )", "nl": "find the SHA256 hash string of a file"}}
{"translation": {"code": "def create_build_package ( package_files ) : # Ensure package files all exist for package_file in package_files : if not os . path . exists ( package_file ) : bot . exit ( 'Cannot find %s.' % package_file ) bot . log ( 'Generating build package for %s files...' % len ( package_files ) ) build_dir = get_tmpdir ( prefix = \"sregistry-build\" ) build_tar = '%s/build.tar.gz' % build_dir tar = tarfile . open ( build_tar , \"w:gz\" ) # Create the tar.gz for package_file in package_files : tar . add ( package_file ) tar . close ( ) # Get hash (sha256), and rename file sha256 = get_file_hash ( build_tar ) hash_tar = \"%s/%s.tar.gz\" % ( build_dir , sha256 ) shutil . move ( build_tar , hash_tar ) return hash_tar", "nl": "given a list of files copy them to a temporary folder compress into a . tar . gz and rename based on the file hash . Return the full path to the . tar . gz in the temporary folder ."}}
{"translation": {"code": "def search_all ( self ) : results = self . _list_containers ( ) bot . info ( \"[gs://%s] Containers\" % self . _bucket_name ) rows = [ ] for i in results : size = round ( i . size / ( 1024 * 1024.0 ) ) size = ( \"%s MB\" % size ) . rjust ( 10 ) rows . append ( [ size , i . metadata [ 'name' ] ] ) bot . table ( rows ) return rows", "nl": "a list all search that doesn t require a query . Here we return to the user all objects that have custom metadata value of container"}}
{"translation": {"code": "def delete ( self , name ) : bot . debug ( \"DELETE %s\" % name ) for file_object in files : if isinstance ( file_object , dict ) : if \"kind\" in file_object : if file_object [ 'kind' ] == \"storage#object\" : object_name = \"/\" . join ( file_object [ 'id' ] . split ( '/' ) [ : - 1 ] ) object_name = re . sub ( '%s/' % self . _bucket [ 'name' ] , '' , object_name , 1 ) delete_object ( service = self . _bucket_service , bucket_name = bucket [ 'name' ] , object_name = object_name )", "nl": "delete an image from Google Storage ."}}
{"translation": {"code": "def destroy ( self , name ) : instances = self . _get_instances ( ) project = self . _get_project ( ) zone = self . _get_zone ( ) found = False if 'items' in instances : for instance in instances [ 'items' ] : if instance [ 'name' ] == name : found = True break if found : bot . info ( 'Killing instance %s' % name ) return self . _compute_service . instances ( ) . delete ( project = project , zone = zone , instance = name ) . execute ( )", "nl": "destroy an instance meaning take down the instance and stop the build ."}}