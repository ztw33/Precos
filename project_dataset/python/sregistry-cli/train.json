{"translation": {"code": "def useColor ( self ) : COLORIZE = get_user_color_preference ( ) if COLORIZE is not None : return COLORIZE streams = [ self . errorStream , self . outputStream ] for stream in streams : if not hasattr ( stream , 'isatty' ) : return False if not stream . isatty ( ) : return False return True", "nl": "useColor will determine if color should be added to a print . Will check if being run in a terminal and if has support for asci"}}
{"translation": {"code": "def get_reqs ( lookup = None , key = 'INSTALL_REQUIRES' ) : if lookup == None : lookup = get_lookup ( ) install_requires = [ ] for module in lookup [ key ] : module_name = module [ 0 ] module_meta = module [ 1 ] if \"exact_version\" in module_meta : dependency = \"%s==%s\" % ( module_name , module_meta [ 'exact_version' ] ) elif \"min_version\" in module_meta : if module_meta [ 'min_version' ] == None : dependency = module_name else : dependency = \"%s>=%s\" % ( module_name , module_meta [ 'min_version' ] ) install_requires . append ( dependency ) return install_requires", "nl": "get requirements mean reading in requirements and versions from the lookup obtained with get_lookup"}}
{"translation": {"code": "def check_install ( software = None , quiet = True ) : if software is None : software = \"singularity\" cmd = [ software , '--version' ] try : version = run_command ( cmd , software ) except : # FileNotFoundError return False if version is not None : if quiet is False and version [ 'return_code' ] == 0 : version = version [ 'message' ] bot . info ( \"Found %s version %s\" % ( software . upper ( ) , version ) ) return True return False", "nl": "check_install will attempt to run the singularity command and return True if installed . The command line utils will not run without this check ."}}
{"translation": {"code": "def get_installdir ( ) : return os . path . abspath ( os . path . dirname ( os . path . dirname ( __file__ ) ) )", "nl": "get_installdir returns the installation directory of the application"}}
{"translation": {"code": "def run_command ( cmd , sudo = False ) : if sudo is True : cmd = [ 'sudo' ] + cmd try : output = Popen ( cmd , stderr = STDOUT , stdout = PIPE ) except FileNotFoundError : cmd . pop ( 0 ) output = Popen ( cmd , stderr = STDOUT , stdout = PIPE ) t = output . communicate ( ) [ 0 ] , output . returncode output = { 'message' : t [ 0 ] , 'return_code' : t [ 1 ] } if isinstance ( output [ 'message' ] , bytes ) : output [ 'message' ] = output [ 'message' ] . decode ( 'utf-8' ) return output", "nl": "run_command uses subprocess to send a command to the terminal ."}}
{"translation": {"code": "def clean_up ( files ) : if not isinstance ( files , list ) : files = [ files ] for f in files : if os . path . exists ( f ) : bot . verbose3 ( \"Cleaning up %s\" % f ) os . remove ( f )", "nl": "clean up will delete a list of files only if they exist"}}
{"translation": {"code": "def emitError ( self , level ) : if level in [ ABORT , ERROR , WARNING , VERBOSE , VERBOSE1 , VERBOSE2 , VERBOSE3 , DEBUG ] : return True return False", "nl": "determine if a level should print to stderr includes all levels but INFO and QUIET"}}
{"translation": {"code": "def write ( self , stream , message ) : if isinstance ( message , bytes ) : message = message . decode ( 'utf-8' ) stream . write ( message )", "nl": "write will write a message to a stream first checking the encoding"}}
{"translation": {"code": "def format_container_name ( name , special_characters = None ) : if special_characters is None : special_characters = [ ] return '' . join ( e . lower ( ) for e in name if e . isalnum ( ) or e in special_characters )", "nl": "format_container_name will take a name supplied by the user remove all special characters ( except for those defined by special - characters and return the new image name ."}}
{"translation": {"code": "def find_single_recipe ( filename , pattern = \"Singularity\" , manifest = None ) : if pattern is None : pattern = \"Singularity*\" recipe = None file_basename = os . path . basename ( filename ) if fnmatch . fnmatch ( file_basename , pattern ) : recipe = { 'path' : os . path . abspath ( filename ) , 'modified' : os . path . getmtime ( filename ) } # If we already have the recipe, only add if more recent if manifest is not None and recipe is not None : container_uri = '/' . join ( filename . split ( '/' ) [ - 2 : ] ) if container_uri in manifest : if manifest [ container_uri ] [ 'modified' ] < os . path . getmtime ( filename ) : manifest [ container_uri ] = recipe else : manifest [ container_uri ] = recipe return manifest return recipe", "nl": "find_single_recipe will parse a single file and if valid return an updated manifest"}}
{"translation": {"code": "def _update_secrets ( self ) : self . secrets = read_client_secrets ( ) if self . secrets is not None : if \"registry\" in self . secrets : if \"base\" in self . secrets [ 'registry' ] : self . base = self . secrets [ 'registry' ] [ 'base' ] self . _update_base ( )", "nl": "update secrets will take a secrets credential file either located at . sregistry or the environment variable SREGISTRY_CLIENT_SECRETS and update the current client secrets as well as the associated API base ."}}
{"translation": {"code": "def table ( self , rows , col_width = 2 ) : labels = [ str ( x ) for x in range ( 1 , len ( rows ) + 1 ) ] if isinstance ( rows , dict ) : labels = list ( rows . keys ( ) ) rows = list ( rows . values ( ) ) for row in rows : label = labels . pop ( 0 ) label = label . ljust ( col_width ) message = \"\\t\" . join ( row ) self . custom ( prefix = label , message = message )", "nl": "table will print a table of entries . If the rows is a dictionary the keys are interpreted as column names . if not a numbered list is used ."}}
{"translation": {"code": "def get_lookup ( ) : lookup = dict ( ) version_file = os . path . join ( 'sregistry' , 'version.py' ) with open ( version_file ) as filey : exec ( filey . read ( ) , lookup ) return lookup", "nl": "get version by way of sregistry . version returns a lookup dictionary with several global variables without needing to import singularity"}}
{"translation": {"code": "def parse_header ( recipe , header = \"from\" , remove_header = True ) : parsed_header = None fromline = [ x for x in recipe . split ( '\\n' ) if \"%s:\" % header in x . lower ( ) ] # Case 1: We did not find the fromline if len ( fromline ) == 0 : return \"\" # Case 2: We found it! if len ( fromline ) > 0 : fromline = fromline [ 0 ] parsed_header = fromline . strip ( ) # Does the user want to clean it up? if remove_header is True : parsed_header = fromline . split ( ':' , 1 ) [ - 1 ] . strip ( ) return parsed_header", "nl": "take a recipe and return the complete header line . If remove_header is True only return the value ."}}
{"translation": {"code": "def push ( self , path , name , tag = None ) : path = os . path . abspath ( path ) image = os . path . basename ( path ) bot . debug ( \"PUSH %s\" % path ) if not os . path . exists ( path ) : bot . error ( '%s does not exist.' % path ) sys . exit ( 1 ) # Interaction with a registry requires secrets self . require_secrets ( ) # Extract the metadata names = parse_image_name ( remove_uri ( name ) , tag = tag ) image_size = os . path . getsize ( path ) >> 20 # COLLECTION ################################################################### # If the registry is provided in the uri, use it if names [ 'registry' ] == None : names [ 'registry' ] = self . base # If the base doesn't start with http or https, add it names = self . _add_https ( names ) # Prepare push request, this will return a collection ID if permission url = '%s/push/' % names [ 'registry' ] auth_url = '%s/upload/chunked_upload' % names [ 'registry' ] SREGISTRY_EVENT = self . authorize ( request_type = \"push\" , names = names ) # Data fields for collection fields = { 'collection' : names [ 'collection' ] , 'name' : names [ 'image' ] , 'tag' : names [ 'tag' ] } headers = { 'Authorization' : SREGISTRY_EVENT } r = requests . post ( auth_url , json = fields , headers = headers ) # Always tell the user what's going on! message = self . _read_response ( r ) print ( '\\n[1. Collection return status {0} {1}]' . format ( r . status_code , message ) ) # Get the collection id, if created, and continue with upload if r . status_code != 200 : sys . exit ( 1 ) # UPLOAD ####################################################################### url = '%s/upload' % names [ 'registry' ] . replace ( '/api' , '' ) bot . debug ( 'Seting upload URL to {0}' . format ( url ) ) cid = r . json ( ) [ 'cid' ] upload_to = os . path . basename ( names [ 'storage' ] ) SREGISTRY_EVENT = self . authorize ( request_type = \"upload\" , names = names ) encoder = MultipartEncoder ( fields = { 'SREGISTRY_EVENT' : SREGISTRY_EVENT , 'name' : names [ 'image' ] , 'collection' : str ( cid ) , 'tag' : names [ 'tag' ] , 'file1' : ( upload_to , open ( path , 'rb' ) , 'text/plain' ) } ) progress_callback = create_callback ( encoder , self . quiet ) monitor = MultipartEncoderMonitor ( encoder , progress_callback ) headers = { 'Content-Type' : monitor . content_type , 'Authorization' : SREGISTRY_EVENT } try : r = requests . post ( url , data = monitor , headers = headers ) r . raise_for_status ( ) message = r . json ( ) [ 'message' ] print ( '\\n[Return status {0} {1}]' . format ( r . status_code , message ) ) except requests . HTTPError as e : print ( '\\nUpload failed: {0}.' . format ( e ) ) except KeyboardInterrupt : print ( '\\nUpload cancelled.' ) except Exception as e : print ( e )", "nl": "push an image to Singularity Registry"}}
{"translation": {"code": "def authorize ( self , names , payload = None , request_type = \"push\" ) : if self . secrets is not None : if \"registry\" in self . secrets : # Use the payload to generate a digest   push|collection|name|tag|user timestamp = generate_timestamp ( ) credential = generate_credential ( self . secrets [ 'registry' ] [ 'username' ] ) credential = \"%s/%s/%s\" % ( request_type , credential , timestamp ) if payload is None : payload = \"%s|%s|%s|%s|%s|\" % ( request_type , names [ 'collection' ] , timestamp , names [ 'image' ] , names [ 'tag' ] ) signature = generate_signature ( payload , self . secrets [ 'registry' ] [ 'token' ] ) return \"SREGISTRY-HMAC-SHA256 Credential=%s,Signature=%s\" % ( credential , signature )", "nl": "Authorize a client based on encrypting the payload with the client token which should be matched on the receiving server"}}
{"translation": {"code": "def main ( args , parser , subparser ) : from sregistry . main import get_client cli = get_client ( quiet = args . quiet ) for query in args . query : if query in [ '' , '*' ] : query = None cli . ls ( query = query )", "nl": "the list command corresponds with listing images for an external resource . This is different from listing images that are local to the database which should be done with images"}}
{"translation": {"code": "def get_subparsers ( parser ) : actions = [ action for action in parser . _actions if isinstance ( action , argparse . _SubParsersAction ) ] subparsers = dict ( ) for action in actions : # get all subparsers and print help for choice , subparser in action . choices . items ( ) : subparsers [ choice ] = subparser return subparsers", "nl": "get_subparser will get a dictionary of subparsers to help with printing help"}}
{"translation": {"code": "def read_file ( filename , mode = \"r\" , readlines = True ) : with open ( filename , mode ) as filey : if readlines is True : content = filey . readlines ( ) else : content = filey . read ( ) return content", "nl": "write_file will open a file filename and write content content and properly close the file"}}
{"translation": {"code": "def read_json ( filename , mode = 'r' ) : with open ( filename , mode ) as filey : data = json . load ( filey ) return data", "nl": "read_json reads in a json file and returns the data structure as dict ."}}
{"translation": {"code": "def label_search ( self , key = None , value = None ) : if key is not None : key = key . lower ( ) if value is not None : value = value . lower ( ) show_details = True if key is None and value is None : url = '%s/labels/search' % ( self . base ) show_details = False elif key is not None and value is not None : url = '%s/labels/search/%s/key/%s/value' % ( self . base , key , value ) elif key is None : url = '%s/labels/search/%s/value' % ( self . base , value ) else : url = '%s/labels/search/%s/key' % ( self . base , key ) result = self . _get ( url ) if len ( result ) == 0 : bot . info ( \"No labels found.\" ) sys . exit ( 0 ) bot . info ( \"Labels\\n\" ) rows = [ ] for l in result : if show_details is True : entry = [ \"%s:%s\" % ( l [ 'key' ] , l [ 'value' ] ) , \"\\n%s\\n\\n\" % \"\\n\" . join ( l [ 'containers' ] ) ] else : entry = [ \"N=%s\" % len ( l [ 'containers' ] ) , \"%s:%s\" % ( l [ 'key' ] , l [ 'value' ] ) ] rows . append ( entry ) bot . table ( rows ) return rows", "nl": "search across labels"}}
{"translation": {"code": "def get_client ( image = None , quiet = False , * * kwargs ) : from sregistry . defaults import SREGISTRY_CLIENT # Give the user a warning: if not check_install ( ) : bot . warning ( 'Singularity is not installed, function might be limited.' ) # If an image is provided, use to determine client client_name = get_uri ( image ) if client_name is not None : SREGISTRY_CLIENT = client_name # If no obvious credential provided, we can use SREGISTRY_CLIENT if SREGISTRY_CLIENT == 'aws' : from . aws import Client elif SREGISTRY_CLIENT == 'docker' : from . docker import Client elif SREGISTRY_CLIENT == 'dropbox' : from . dropbox import Client elif SREGISTRY_CLIENT == 'gitlab' : from . gitlab import Client elif SREGISTRY_CLIENT == 'globus' : from . globus import Client elif SREGISTRY_CLIENT == 'nvidia' : from . nvidia import Client elif SREGISTRY_CLIENT == 'hub' : from . hub import Client elif SREGISTRY_CLIENT == 'google-drive' : from . google_drive import Client elif SREGISTRY_CLIENT == 'google-compute' : from . google_storage import Client elif SREGISTRY_CLIENT == 'google-storage' : from . google_storage import Client elif SREGISTRY_CLIENT == 'google-build' : from . google_build import Client elif SREGISTRY_CLIENT == 'registry' : from . registry import Client elif SREGISTRY_CLIENT == 's3' : from . s3 import Client elif SREGISTRY_CLIENT == 'swift' : from . swift import Client else : from . hub import Client Client . client_name = SREGISTRY_CLIENT Client . quiet = quiet # Create credentials cache, if it doesn't exist Client . _credential_cache = get_credential_cache ( ) # Add the database, if wanted if SREGISTRY_DATABASE is not None : # These are global functions used across modules from sregistry . database import ( init_db , add , cp , get , mv , rm , rmi , images , inspect , rename , get_container , get_collection , get_or_create_collection ) # Actions Client . _init_db = init_db Client . add = add Client . cp = cp Client . get = get Client . inspect = inspect Client . mv = mv Client . rename = rename Client . rm = rm Client . rmi = rmi Client . images = images # Collections Client . get_or_create_collection = get_or_create_collection Client . get_container = get_container Client . get_collection = get_collection # If no database, import dummy functions that return the equivalent else : from sregistry . database import ( add , init_db ) Client . add = add Client . _init_db = init_db # Initialize the database cli = Client ( ) if hasattr ( Client , '_init_db' ) : cli . _init_db ( SREGISTRY_DATABASE ) return cli", "nl": "get the correct client depending on the driver of interest . The selected client can be chosen based on the environment variable SREGISTRY_CLIENT and later changed based on the image uri parsed If there is no preference the default is to load the singularity hub client ."}}
{"translation": {"code": "def remove ( self , image , force = False ) : q = parse_image_name ( remove_uri ( image ) ) # If the registry is provided in the uri, use it if q [ 'registry' ] == None : q [ 'registry' ] = self . base # If the base doesn't start with http or https, add it q = self . _add_https ( q ) url = '%s/container/%s/%s:%s' % ( q [ 'registry' ] , q [ \"collection\" ] , q [ \"image\" ] , q [ \"tag\" ] ) SREGISTRY_EVENT = self . authorize ( request_type = \"delete\" , names = q ) headers = { 'Authorization' : SREGISTRY_EVENT } self . _update_headers ( fields = headers ) continue_delete = True if force is False : response = input ( \"Are you sure you want to delete %s?\" % q [ 'uri' ] ) while len ( response ) < 1 or response [ 0 ] . lower ( ) . strip ( ) not in \"ynyesno\" : response = input ( \"Please answer yes or no: \" ) if response [ 0 ] . lower ( ) . strip ( ) in \"no\" : continue_delete = False if continue_delete is True : response = self . _delete ( url ) message = self . _read_response ( response ) bot . info ( \"Response %s, %s\" % ( response . status_code , message ) ) else : bot . info ( \"Delete cancelled.\" )", "nl": "delete an image to Singularity Registry"}}
{"translation": {"code": "def get_singularity_version ( singularity_version = None ) : if singularity_version is None : singularity_version = os . environ . get ( \"SINGULARITY_VERSION\" ) if singularity_version is None : try : cmd = [ 'singularity' , '--version' ] output = run_command ( cmd ) if isinstance ( output [ 'message' ] , bytes ) : output [ 'message' ] = output [ 'message' ] . decode ( 'utf-8' ) singularity_version = output [ 'message' ] . strip ( '\\n' ) bot . info ( \"Singularity %s being used.\" % singularity_version ) except : singularity_version = None bot . warning ( \"Singularity version not found, so it's likely not installed.\" ) return singularity_version", "nl": "get_singularity_version will determine the singularity version for a build first an environmental variable is looked at followed by using the system version ."}}
{"translation": {"code": "def add ( self , image_path = None , image_uri = None , image_name = None , url = None , metadata = None , save = True , copy = False ) : from sregistry . database . models import ( Container , Collection ) # We can only save if the image is provided if image_path is not None : if not os . path . exists ( image_path ) and save is True : bot . error ( 'Cannot find %s' % image_path ) sys . exit ( 1 ) # An image uri is required for version, tag, etc. if image_uri is None : bot . error ( 'You must provide an image uri <collection>/<namespace>' ) sys . exit ( 1 ) names = parse_image_name ( remove_uri ( image_uri ) ) bot . debug ( 'Adding %s to registry' % names [ 'uri' ] ) # If Singularity is installed, inspect image for metadata metadata = self . get_metadata ( image_path , names = names ) collection = self . get_or_create_collection ( names [ 'collection' ] ) # Get a hash of the file for the version, or use provided version = names . get ( 'version' ) if version == None : if image_path != None : version = get_image_hash ( image_path ) else : version = '' # we can't determine a version, not in API/no file names = parse_image_name ( remove_uri ( image_uri ) , version = version ) # If save, move to registry storage first if save is True and image_path is not None : # If the user hasn't defined a custom name if image_name is None : image_name = self . _get_storage_name ( names ) if copy is True : copyfile ( image_path , image_name ) else : shutil . move ( image_path , image_name ) image_path = image_name # Just in case the client didn't provide it, see if we have in metadata if url is None and \"url\" in metadata : url = metadata [ 'url' ] # First check that we don't have one already! container = self . get_container ( name = names [ 'image' ] , collection_id = collection . id , tag = names [ 'tag' ] , version = version ) # The container did not exist, create it if container is None : action = \"new\" container = Container ( metrics = json . dumps ( metadata ) , name = names [ 'image' ] , image = image_path , client = self . client_name , tag = names [ 'tag' ] , version = version , url = url , uri = names [ 'uri' ] , collection_id = collection . id ) self . session . add ( container ) collection . containers . append ( container ) # The container existed, update it. else : action = \"update\" metrics = json . loads ( container . metrics ) metrics . update ( metadata ) container . url = url container . client = self . client_name if image_path is not None : container . image = image_path container . metrics = json . dumps ( metrics ) self . session . commit ( ) bot . info ( \"[container][%s] %s\" % ( action , names [ 'uri' ] ) ) return container", "nl": "get or create a container including the collection to add it to . This function can be used from a file on the local system or via a URL that has been downloaded . Either way if one of url version or image_file is not provided the model is created without it . If a version is not provided but a file path is then the file hash is used ."}}
{"translation": {"code": "def init_db ( self , db_path ) : # Database Setup, use default if uri not provided self . database = 'sqlite:///%s' % db_path self . storage = SREGISTRY_STORAGE bot . debug ( \"Database located at %s\" % self . database ) self . engine = create_engine ( self . database , convert_unicode = True ) self . session = scoped_session ( sessionmaker ( autocommit = False , autoflush = False , bind = self . engine ) ) Base . query = self . session . query_property ( ) # import all modules here that might define models so that # they will be registered properly on the metadata.  Otherwise # you will have to import them first before calling init_db() Base . metadata . create_all ( bind = self . engine ) self . Base = Base", "nl": "initialize the database with the default database path or custom of"}}
{"translation": {"code": "def rmi ( self , image_name ) : container = self . rm ( image_name , delete = True ) if container is not None : bot . info ( \"[rmi] %s\" % container )", "nl": "Remove an image from the database and filesystem ."}}
{"translation": {"code": "def images ( self , query = None ) : from sregistry . database . models import Collection , Container rows = [ ] if query is not None : like = \"%\" + query + \"%\" containers = Container . query . filter ( or_ ( Container . name == query , Container . tag . like ( like ) , Container . uri . like ( like ) , Container . name . like ( like ) ) ) . all ( ) else : containers = Container . query . all ( ) if len ( containers ) > 0 : message = \"  [date]   [client]\\t[uri]\" bot . custom ( prefix = 'Containers:' , message = message , color = \"RED\" ) for c in containers : uri = c . get_uri ( ) created_at = c . created_at . strftime ( '%B %d, %Y' ) rows . append ( [ created_at , \"   [%s]\" % c . client , uri ] ) bot . table ( rows ) return containers", "nl": "List local images in the database optionally with a query ."}}
{"translation": {"code": "def get_or_create_collection ( self , name ) : from sregistry . database . models import Collection collection = self . get_collection ( name ) # If it doesn't exist, create it if collection is None : collection = Collection ( name = name ) self . session . add ( collection ) self . session . commit ( ) return collection", "nl": "get a collection if it exists . If it doesn t exist create it first ."}}
{"translation": {"code": "def get_collection ( self , name ) : from sregistry . database . models import Collection return Collection . query . filter ( Collection . name == name ) . first ( )", "nl": "get a collection if it exists otherwise return None ."}}
{"translation": {"code": "def ipython ( args ) : # The client will announce itself (backend/database) unless it's get from sregistry . main import get_client client = get_client ( args . endpoint ) client . announce ( args . command ) from IPython import embed embed ( )", "nl": "give the user an ipython shell optionally with an endpoint of choice ."}}
{"translation": {"code": "def inspect ( self , name ) : print ( name ) container = self . get ( name ) if container is not None : collection = container . collection . name fields = container . __dict__ . copy ( ) fields [ 'collection' ] = collection fields [ 'metrics' ] = json . loads ( fields [ 'metrics' ] ) del fields [ '_sa_instance_state' ] fields [ 'created_at' ] = str ( fields [ 'created_at' ] ) print ( json . dumps ( fields , indent = 4 , sort_keys = True ) ) return fields", "nl": "Inspect a local image in the database which typically includes the basic fields in the model ."}}
{"translation": {"code": "def get_container ( self , name , collection_id , tag = \"latest\" , version = None ) : from sregistry . database . models import Container if version is None : container = Container . query . filter_by ( collection_id = collection_id , name = name , tag = tag ) . first ( ) else : container = Container . query . filter_by ( collection_id = collection_id , name = name , tag = tag , version = version ) . first ( ) return container", "nl": "get a container otherwise return None ."}}
{"translation": {"code": "def read_client_secrets ( ) : client_secrets = _default_client_secrets ( ) # If token file not provided, check environment secrets = get_secrets_file ( ) # If exists, load if secrets is not None : client_secrets = read_json ( secrets ) # Otherwise, initialize else : from sregistry . defaults import SREGISTRY_CLIENT_SECRETS write_json ( client_secrets , SREGISTRY_CLIENT_SECRETS ) return client_secrets", "nl": "for private or protected registries a client secrets file is required to be located at . sregistry . If no secrets are found we use default of Singularity Hub and return a dummy secrets ."}}
{"translation": {"code": "def _update_secrets ( self ) : # Get a setting for client myclient and some variable name VAR.  # returns None if not set setting = self . _get_setting ( 'SREGISTRY_MYCLIENT_VAR' ) # Get (and if found in environment (1) settings (2) update the variable # It will still return None if not set setting = self . _get_and_update_setting ( 'SREGISTRY_MYCLIENT_VAR' ) # If you have a setting that is required and not found, you should exit. # Here is how to read all client secrets self . secrets = read_client_secrets ( ) # If you don't want to use the shared settings file, you have your own. # Here is how to get if the user has a cache for you enabled, this # returns a path (enabled) or None (disabled) that you should honor # You can use this as a file path or folder and for both cases, you # need to create the file or folder if self . _credential_cache is not None : bot . info ( \"credential cache set to %s\" % self . _credential_cache )", "nl": "update secrets will take a secrets credential file either located at . sregistry or the environment variable SREGISTRY_CLIENT_SECRETS and update the current client secrets as well as the associated API base . This is where you should do any customization of the secrets flie or using it to update your client if needed ."}}
{"translation": {"code": "def _get_services ( self , version = 'v1' ) : self . _bucket_service = storage . Client ( ) creds = GoogleCredentials . get_application_default ( ) self . _storage_service = discovery_build ( 'storage' , version , credentials = creds ) self . _compute_service = discovery_build ( 'compute' , version , credentials = creds )", "nl": "get version 1 of the google compute and storage service"}}
{"translation": {"code": "def _update_secrets ( self ) : env = 'SREGISTRY_GOOGLE_DRIVE_CREDENTIALS' self . _secrets = self . _get_and_update_setting ( env ) self . _base = self . _get_and_update_setting ( 'SREGISTRY_GOOGLE_DRIVE_ROOT' ) if self . _base is None : self . _base = 'sregistry' if self . _secrets is None : bot . error ( 'You must export %s to use Google Drive client' % env ) bot . info ( \"https://singularityhub.github.io/sregistry-cli/client-google-drive\" ) sys . exit ( 1 )", "nl": "The user is required to have an application secrets file in his or her environment . The client exists with error if the variable isn t found ."}}
{"translation": {"code": "def search_all ( self ) : results = self . _list_containers ( ) matches = [ ] bot . info ( \"[drive://%s] Containers\" % self . _base ) rows = [ ] for i in results : # Fallback to the image name without the extension uri = i [ 'name' ] . replace ( '.simg' , '' ) # However the properties should include the uri if 'properties' in i : if 'uri' in i [ 'properties' ] : uri = i [ 'properties' ] [ 'uri' ] rows . append ( [ i [ 'id' ] , uri ] ) # Give the user back a uri i [ 'uri' ] = uri matches . append ( i ) bot . custom ( prefix = \"   [drive://%s]\" % self . _base , message = \"\\t\\t[id]\\t[uri]\" , color = \"PURPLE\" ) bot . table ( rows ) return matches", "nl": "a list all search that doesn t require a query . Here we return to the user all objects that have custom properties value type set to container which is set when the image is pushed ."}}
{"translation": {"code": "def get_thumbnail ( ) : from sregistry . defaults import SREGISTRY_THUMBNAIL if SREGISTRY_THUMBNAIL is not None : if os . path . exists ( SREGISTRY_THUMBNAIL ) : return SREGISTRY_THUMBNAIL return \"%s/database/robot.png\" % get_installdir ( )", "nl": "return the robot . png thumbnail from the database folder . if the user has exported a different image use that instead ."}}
{"translation": {"code": "def get_or_create_folder ( self , folder ) : q = \"mimeType='application/vnd.google-apps.folder' and name='%s'\" % folder response = self . _service . files ( ) . list ( q = q , spaces = 'drive' ) . execute ( ) . get ( 'files' , [ ] ) # If no folder is found, create it! if len ( response ) == 0 : folder = self . _create_folder ( folder ) else : folder = response [ 0 ] return folder", "nl": "create a folder at the drive root . If the folder already exists it is simply returned ."}}
{"translation": {"code": "def main ( args , parser , subparser ) : from sregistry . main import get_client images = args . image if not isinstance ( images , list ) : images = [ images ] for image in images : print ( image ) # Detect any uri, and refresh client if necessary cli = get_client ( image , quiet = args . quiet ) cli . announce ( args . command ) cli . share ( image , share_to = args . share_to )", "nl": "sharing an image means sending a remote share from an image you control to a contact usually an email ."}}
{"translation": {"code": "def delete ( self , url , headers = None , return_json = True , default_headers = True ) : bot . debug ( 'DELETE %s' % url ) return self . _call ( url , headers = headers , func = requests . delete , return_json = return_json , default_headers = default_headers )", "nl": "delete request use with caution"}}
{"translation": {"code": "def speak ( self ) : if self . quiet is False : bot . info ( '[client|%s] [database|%s]' % ( self . client_name , self . database ) ) self . _speak ( )", "nl": "a function for the client to announce him or herself depending on the level specified . If you want your client to have additional announced things here then implement the class _speak for your client ."}}
{"translation": {"code": "def update_headers ( self , fields = None ) : do_reset = True if hasattr ( self , 'headers' ) : if self . headers is not None : do_reset = False if do_reset is True : self . _reset_headers ( ) if fields is not None : for key , value in fields . items ( ) : self . headers [ key ] = value header_names = \",\" . join ( list ( self . headers . keys ( ) ) ) bot . debug ( \"Headers found: %s\" % header_names )", "nl": "update headers with a token & other fields"}}
{"translation": {"code": "def require_secrets ( self , params = None ) : name = self . client_name # Check 1: the client must have secrets, period has_secrets = True # Secrets file not asked for (incorrectly) but still wanted # The client shouldn't be calling this function if didn't init secrets if not hasattr ( self , 'secrets' ) : has_secrets = False # Secret file was not found, period elif hasattr ( self , 'secrets' ) : if self . secrets is None : has_secrets = False # The client isn't defined in the secrets file elif self . client_name not in self . secrets : has_secrets = False # Missing file or client secrets, fail if has_secrets is False : message = '%s requires client secrets.' % name bot . error ( message ) sys . exit ( 1 ) # Check 2: we have secrets and lookup, do we have all needed params? if params is not None : # Assume list so we can always parse through if not isinstance ( params , list ) : params = [ params ] for param in params : # The parameter is not a key for the client if param not in self . secrets [ name ] : has_secrets = False # The parameter is a key, but empty or undefined elif self . secrets [ name ] [ param ] in [ None , '' ] : has_secrets = False # Missing parameter, exit on fail if has_secrets is False : message = 'Missing %s in client secrets.' % param bot . error ( message ) sys . exit ( 1 )", "nl": "require secrets ensures that the client has the secrets file and specifically has one or more parameters defined . If params is None only a check is done for the file ."}}
{"translation": {"code": "def paginate_get ( self , url , headers = None , return_json = True , start_page = None ) : geturl = '%s&page=1' % ( url ) if start_page is not None : geturl = '%s&page=%s' % ( url , start_page ) results = [ ] while geturl is not None : result = self . _get ( url , headers = headers , return_json = return_json ) # If we have pagination: if isinstance ( result , dict ) : if 'results' in result : results = results + result [ 'results' ] geturl = result [ 'next' ] # No pagination is a list else : return result return results", "nl": "paginate_call is a wrapper for get to paginate results"}}
{"translation": {"code": "def basic_auth_header ( username , password ) : s = \"%s:%s\" % ( username , password ) if sys . version_info [ 0 ] >= 3 : s = bytes ( s , 'utf-8' ) credentials = base64 . b64encode ( s ) . decode ( 'utf-8' ) else : credentials = base64 . b64encode ( s ) auth = { \"Authorization\" : \"Basic %s\" % credentials } return auth", "nl": "generate a base64 encoded header to ask for a token . This means base64 encoding a username and password and adding to the Authorization header to identify the client ."}}
{"translation": {"code": "def get_download_cache ( self , destination , subfolder = 'docker' ) : # First priority after user specification is Singularity Cache if destination is None : destination = self . _get_setting ( 'SINGULARITY_CACHEDIR' , SINGULARITY_CACHE ) # If not set, the user has disabled (use tmp) destination = get_tmpdir ( destination ) if not destination . endswith ( subfolder ) : destination = \"%s/%s\" % ( destination , subfolder ) # Create subfolders, if don't exist mkdir_p ( destination ) return destination", "nl": "determine the user preference for atomic download of layers . If the user has set a singularity cache directory honor it . Otherwise use the Singularity default ."}}
{"translation": {"code": "def get_template ( name ) : name = name . lower ( ) templates = dict ( ) templates [ 'tarinfo' ] = { \"gid\" : 0 , \"uid\" : 0 , \"uname\" : \"root\" , \"gname\" : \"root\" , \"mode\" : 493 } if name in templates : bot . debug ( \"Found template for %s\" % ( name ) ) return templates [ name ] else : bot . warning ( \"Cannot find template %s\" % ( name ) )", "nl": "return a default template for some function in sregistry If there is no template None is returned ."}}
{"translation": {"code": "def extract_tar ( archive , output_folder , handle_whiteout = False ) : from . terminal import run_command # Do we want to remove whiteout files? if handle_whiteout is True : return _extract_tar ( archive , output_folder ) # If extension is .tar.gz, use -xzf args = '-xf' if archive . endswith ( \".tar.gz\" ) : args = '-xzf' # Just use command line, more succinct. command = [ \"tar\" , args , archive , \"-C\" , output_folder , \"--exclude=dev/*\" ] if not bot . is_quiet ( ) : print ( \"Extracting %s\" % archive ) return run_command ( command )", "nl": "extract a tar archive to a specified output folder"}}
{"translation": {"code": "def get_manifests ( self , repo_name , digest = None ) : if not hasattr ( self , 'manifests' ) : self . manifests = { } # Obtain schema version 1 (metadata) and 2, and image config schemaVersions = [ 'v1' , 'v2' , 'config' ] for schemaVersion in schemaVersions : manifest = self . _get_manifest ( repo_name , digest , schemaVersion ) if manifest is not None : # If we don't have a config yet, try to get from version 2 manifest if schemaVersion == \"v2\" and \"config\" in manifest : bot . debug ( 'Attempting to get config as blob in verison 2 manifest' ) url = self . _get_layerLink ( repo_name , manifest [ 'config' ] [ 'digest' ] ) headers = { 'Accept' : manifest [ 'config' ] [ 'mediaType' ] } self . manifests [ 'config' ] = self . _get ( url , headers = headers ) self . manifests [ schemaVersion ] = manifest return self . manifests", "nl": "get_manifests calls get_manifest for each of the schema versions including v2 and v1 . Version 1 includes image layers and metadata and version 2 must be parsed for a specific manifest and the 2nd call includes the layers . If a digest is not provided latest is used ."}}
{"translation": {"code": "def get_manifest ( self , repo_name , digest = None , version = \"v1\" ) : accepts = { 'config' : \"application/vnd.docker.container.image.v1+json\" , 'v1' : \"application/vnd.docker.distribution.manifest.v1+json\" , 'v2' : \"application/vnd.docker.distribution.manifest.v2+json\" } url = self . _get_manifest_selfLink ( repo_name , digest ) bot . verbose ( \"Obtaining manifest: %s %s\" % ( url , version ) ) headers = { 'Accept' : accepts [ version ] } try : manifest = self . _get ( url , headers = headers , quiet = True ) manifest [ 'selfLink' ] = url except : manifest = None return manifest", "nl": "get_manifest should return an image manifest for a particular repo and tag . The image details are extracted when the client is generated ."}}
{"translation": {"code": "def extract_env ( self ) : environ = self . _get_config ( 'Env' ) if environ is not None : if not isinstance ( environ , list ) : environ = [ environ ] lines = [ ] for line in environ : line = re . findall ( \"(?P<var_name>.+?)=(?P<var_value>.+)\" , line ) line = [ 'export %s=\"%s\"' % ( x [ 0 ] , x [ 1 ] ) for x in line ] lines = lines + line environ = \"\\n\" . join ( lines ) bot . verbose3 ( \"Found Docker container environment!\" ) return environ", "nl": "extract the environment from the manifest or return None . Used by functions env_extract_image and env_extract_tar"}}
{"translation": {"code": "def generate_signature ( payload , secret ) : payload = _encode ( payload ) secret = _encode ( secret ) return hmac . new ( secret , digestmod = hashlib . sha256 , msg = payload ) . hexdigest ( )", "nl": "use an endpoint specific payload and client secret to generate a signature for the request"}}
{"translation": {"code": "def generate_header_signature ( secret , payload , request_type ) : # Use the payload to generate a digest   push|collection|name|tag|user timestamp = generate_timestamp ( ) credential = \"%s/%s\" % ( request_type , timestamp ) signature = generate_signature ( payload , secret ) return \"SREGISTRY-HMAC-SHA256 Credential=%s,Signature=%s\" % ( credential , signature )", "nl": "Authorize a client based on encrypting the payload with the client secret timestamp and other metadata"}}
{"translation": {"code": "def verify ( self ) : from sregistry . defaults import DISABLE_SSL_CHECK if DISABLE_SSL_CHECK is True : bot . warning ( 'Verify of certificates disabled! ::TESTING USE ONLY::' ) return not DISABLE_SSL_CHECK", "nl": "verify will return a True or False to determine to verify the requests call or not . If False we should the user a warning message as this should not be done in production!"}}
{"translation": {"code": "def _update_secrets ( self ) : # Retrieve the user token. Exit if not found  token = self . _required_get_and_update ( 'SREGISTRY_DROPBOX_TOKEN' ) # Create the dropbox client self . dbx = Dropbox ( token ) # Verify that the account is valid try : self . account = self . dbx . users_get_current_account ( ) except AuthError as err : bot . error ( 'Account invalid. Exiting.' ) sys . exit ( 1 )", "nl": "update secrets will look for a dropbox token in the environment at SREGISTRY_DROPBOX_TOKEN and if found create a client . If not an error message is returned and the client exits ."}}
{"translation": {"code": "def _get_metadata ( self , image_file = None , dbx_metadata = None ) : metadata = dict ( ) if dbx_metadata is not None : for key in dbx_metadata . __dir__ ( ) : value = getattr ( dbx_metadata , key ) if type ( value ) in [ str , datetime . datetime , bool , int , float ] : metadata [ key . strip ( '_' ) ] = value return self . get_metadata ( image_file , names = metadata )", "nl": "this is a wrapper around the main client . get_metadata to first parse a Dropbox FileMetadata into a dicionary then pass it on to the primary get_metadata function ."}}
{"translation": {"code": "def share ( self , query , share_to = None ) : names = parse_image_name ( remove_uri ( query ) ) # Dropbox path is the path in storage with a slash dropbox_path = '/%s' % names [ 'storage' ] # First ensure that exists if self . exists ( dropbox_path ) is True : # Create new shared link try : share = self . dbx . sharing_create_shared_link_with_settings ( dropbox_path ) # Already exists! except ApiError as err : share = self . dbx . sharing_create_shared_link ( dropbox_path ) bot . info ( share . url ) return share . url", "nl": "share will use the client to get a shareable link for an image of choice . the functions returns a url of choice to send to a recipient ."}}
{"translation": {"code": "def announce ( self , command = None ) : if command is not None : if command not in [ 'get' ] and self . quiet is False : self . speak ( )", "nl": "the client will announce itself given that a command is not in a particular predefined list ."}}
{"translation": {"code": "def mv ( self , image_name , path ) : container = self . get ( image_name , quiet = True ) if container is not None : name = container . uri or container . get_uri ( ) image = container . image or '' # Only continue if image file exists if os . path . exists ( image ) : # Default assume directory, use image name and path fully filename = os . path . basename ( image ) filedir = os . path . abspath ( path ) # If it's a file, use filename provided if not os . path . isdir ( path ) : filename = os . path . basename ( path ) filedir = os . path . dirname ( path ) # If directory is empty, assume $PWD if filedir == '' : filedir = os . getcwd ( ) # Copy to the fullpath from the storage fullpath = os . path . abspath ( os . path . join ( filedir , filename ) ) return self . cp ( move_to = fullpath , container = container , command = \"move\" ) bot . warning ( '%s not found' % ( image_name ) )", "nl": "Move an image from it s current location to a new path . Removing the image from organized storage is not the recommended approach however is still a function wanted by some ."}}
{"translation": {"code": "def rename ( self , image_name , path ) : container = self . get ( image_name , quiet = True ) if container is not None : if container . image is not None : # The original directory for the container stays the same dirname = os . path . dirname ( container . image ) # But we derive a new filename and uri names = parse_image_name ( remove_uri ( path ) ) storage = os . path . join ( self . storage , os . path . dirname ( names [ 'storage' ] ) ) # This is the collection folder if not os . path . exists ( storage ) : os . mkdir ( storage ) # Here we get the new full path, rename the container file fullpath = os . path . abspath ( os . path . join ( dirname , names [ 'storage' ] ) ) container = self . cp ( move_to = fullpath , container = container , command = \"rename\" ) # On successful rename of file, update the uri if container is not None : container . uri = names [ 'uri' ] self . session . commit ( ) return container bot . warning ( '%s not found' % ( image_name ) )", "nl": "rename performs a move but ensures the path is maintained in storage"}}
{"translation": {"code": "def _update_base ( self , image ) : base = None # Google Container Cloud if \"gcr.io\" in image : base = 'gcr.io' self . _set_base ( default_base = base ) self . _update_secrets ( ) return base", "nl": "update a base based on an image name meaning detecting a particular registry and if necessary updating the self . base . When the image name is parsed the base will be given to remove the registry ."}}
{"translation": {"code": "def run_build ( self , config ) : project = self . _get_project ( ) zone = self . _get_zone ( ) bot . custom ( prefix = 'INSTANCE' , message = config [ 'name' ] , color = \"CYAN\" ) bot . info ( config [ 'description' ] ) response = self . _compute_service . instances ( ) . insert ( project = project , zone = zone , body = config ) . execute ( ) # Direct the user to the web portal with log ipaddress = self . _get_ipaddress ( config [ 'name' ] ) bot . info ( 'Robot Logger: http://%s' % ipaddress ) bot . info ( 'Allow a few minutes for web server install, beepboop!' ) return response", "nl": "run a build meaning inserting an instance . Retry if there is failure"}}
{"translation": {"code": "def head ( self , url ) : bot . debug ( 'HEAD %s' % url ) return self . _call ( url , func = requests . head )", "nl": "head request typically used for status code retrieval etc ."}}
{"translation": {"code": "def load_templates ( self , name ) : configs = self . _get_templates ( ) templates = [ ] # The user wants to retrieve a particular configuration matches = [ x for x in configs [ 'data' ] if name in x [ 'name' ] ] if len ( matches ) > 0 : for match in matches : response = self . _get ( match [ 'id' ] ) templates . append ( response ) return templates bot . info ( 'No matches found for %s' % name )", "nl": "load a particular template based on a name . We look for a name IN data so the query name can be a partial string of the full name ."}}
{"translation": {"code": "def get_settings ( self , client_name = None ) : settings = read_client_secrets ( ) if client_name is not None and client_name in settings : return settings [ client_name ] return settings", "nl": "get all settings either for a particular client if a name is provided or across clients ."}}
{"translation": {"code": "def get_build_template ( name = None , manager = 'apt' ) : base = get_installdir ( ) if name is None : name = \"%s/main/templates/build/singularity-builder-%s.sh\" % ( base , manager ) if os . path . exists ( name ) : bot . debug ( \"Found template %s\" % name ) return '' . join ( read_file ( name ) ) bot . warning ( \"Template %s not found.\" % name )", "nl": "get a particular build template by default we return templates that are based on package managers ."}}
{"translation": {"code": "def list_builders ( self , project = None , zone = 'us-west1-a' ) : builders = [ ] instances = self . _get_instances ( project , zone ) for instance in instances [ 'items' ] : builders . append ( [ instance [ 'name' ] , instance [ 'status' ] ] ) bot . info ( \"[google-compute] Found %s instances\" % ( len ( builders ) ) ) bot . table ( builders ) bot . newline ( )", "nl": "list builders or instances for the project . They should start with sregistry - builder"}}
{"translation": {"code": "def generate ( self , delim = '-' , length = 4 , chars = '0123456789' ) : descriptor = self . _select ( self . _descriptors ) noun = self . _select ( self . _nouns ) numbers = '' . join ( ( self . _select ( chars ) for _ in range ( length ) ) ) return delim . join ( [ descriptor , noun , numbers ] )", "nl": "Generate a robot name . Inspiration from Haikunator but much more poorly implemented ; )"}}
{"translation": {"code": "def get_ipaddress ( self , name , retries = 3 , delay = 3 ) : for rr in range ( retries ) : # Retrieve list of instances instances = self . _get_instances ( ) for instance in instances [ 'items' ] : if instance [ 'name' ] == name : # Iterate through network interfaces for network in instance [ 'networkInterfaces' ] : if network [ 'name' ] == 'nic0' : # Access configurations for subnet in network [ 'accessConfigs' ] : if subnet [ 'name' ] == 'External NAT' : if 'natIP' in subnet : return subnet [ 'natIP' ] sleep ( delay ) bot . warning ( 'Did not find IP address, check Cloud Console!' )", "nl": "get the ip_address of an inserted instance . Will try three times with delay to give the instance time to start up ."}}
{"translation": {"code": "def list_logs ( args , container_name = None ) : from sregistry . main import Client as cli if len ( args . commands ) > 0 : container_name = args . commands . pop ( 0 ) cli . logs ( container_name ) sys . exit ( 0 )", "nl": "list a specific log for a builder or the latest log if none provided"}}
{"translation": {"code": "def kill ( args ) : from sregistry . main import Client as cli if len ( args . commands ) > 0 : for name in args . commands : cli . destroy ( name ) sys . exit ( 0 )", "nl": "kill is a helper function to call the kill function of the client meaning we bring down an instance ."}}
{"translation": {"code": "def _extract_tar ( archive , output_folder ) : from . terminal import ( run_command , which ) result = which ( 'blob2oci' ) if result [ 'return_code' ] != 0 : bot . error ( 'Cannot find blob2oci script on path, exiting.' ) sys . exit ( 1 ) script = result [ 'message' ] command = [ 'exec' , script , '--layer' , archive , '--extract' , output_folder ] if not bot . is_quiet ( ) : print ( \"Extracting %s\" % archive ) return run_command ( command )", "nl": "use blob2oci to handle whiteout files for extraction . Credit for this script goes to docker2oci by Olivier Freyermouth and see script folder for license ."}}
{"translation": {"code": "def update_setting ( self , name , value ) : if value is not None : updates = { name : value } update_client_secrets ( backend = self . client_name , updates = updates )", "nl": "Just update a setting doesn t need to be returned ."}}
{"translation": {"code": "def search ( self , query = None , args = None ) : # No query is defined if query is None : # Option 1: No query or endpoints lists all shared and personal if args . endpoint is None : bot . info ( 'Listing shared endpoints. Add query to expand search.' ) return self . _list_endpoints ( ) # Option 2: An endpoint without query will just list containers there else : return self . _list_endpoint ( args . endpoint ) # Option 3: A query without an endpoint will search endpoints for it if args . endpoint is None : bot . info ( 'You must specify an endpoint id to query!' ) return self . _list_endpoints ( query ) # Option 4: A query with an endpoint will search the endpoint for pattern return self . _list_endpoint ( endpoint = args . endpoint , query = query )", "nl": "query will show images determined by the extension of img or simg ."}}
{"translation": {"code": "def list_endpoints ( self , query = None ) : bot . info ( 'Please select an endpoint id to query from' ) endpoints = self . _get_endpoints ( query ) # Iterate through endpoints to provide user a list bot . custom ( prefix = \"Globus\" , message = \"Endpoints\" , color = \"CYAN\" ) rows = [ ] for kind , eps in endpoints . items ( ) : for epid , epmeta in eps . items ( ) : rows . append ( [ epid , '[%s]' % kind , epmeta [ 'name' ] ] ) bot . table ( rows ) return rows", "nl": "list all endpoints providing a list of endpoints to the user to better filter the search . This function takes no arguments as the user has not provided an endpoint id or query ."}}
{"translation": {"code": "def list_endpoint ( self , endpoint , query = None ) : if not hasattr ( self , 'transfer_client' ) : self . _init_transfer_client ( ) # Separate endpoint id from the desired path endpoint , path = self . _parse_endpoint_name ( endpoint ) # Get a list of files at endpoint, under specific path try : result = self . transfer_client . operation_ls ( endpoint , path = path ) except TransferAPIError as err : # Tell the user what went wrong! bot . custom ( prefix = 'ERROR' , message = err , color = 'RED' ) sys . exit ( 1 ) rows = [ ] for filey in result : # Highlight container contenders with purple name = filey [ 'name' ] if query is None or query in name : if name . endswith ( 'img' ) : name = bot . addColor ( 'PURPLE' , name ) rows . append ( [ filey [ 'type' ] , filey [ 'permissions' ] , str ( filey [ 'size' ] ) , name ] ) if len ( rows ) > 0 : rows = [ [ \"type\" , \"[perm]\" , \"[size]\" , \"[name]\" ] ] + rows bot . custom ( prefix = \"Endpoint Listing %s\" % path , message = '' , color = \"CYAN\" ) bot . table ( rows ) else : bot . info ( 'No content was found at the selected endpoint.' ) return rows", "nl": "An endpoint is required here to list files within . Optionally we can take a path relative to the endpoint root ."}}
{"translation": {"code": "def _load_secrets ( self ) : # Second priority: load from cache self . auth = self . _get_and_update_setting ( 'GLOBUS_AUTH_RESPONSE' ) self . transfer = self . _get_and_update_setting ( 'GLOBUS_TRANSFER_RESPONSE' )", "nl": "load the secrets credentials file with the Globus OAuthTokenResponse"}}
{"translation": {"code": "def init_transfer_client ( self ) : if self . _tokens_need_update ( ) : self . _update_tokens ( ) access_token = self . transfer [ 'access_token' ] # Createe Refresh Token Authorizer authorizer = globus_sdk . RefreshTokenAuthorizer ( self . transfer [ 'refresh_token' ] , self . _client , access_token = self . transfer [ 'access_token' ] , expires_at = self . transfer [ 'expires_at_seconds' ] ) self . transfer_client = globus_sdk . TransferClient ( authorizer = authorizer )", "nl": "return a transfer client for the user"}}
{"translation": {"code": "def _init_clients ( self ) : self . _client = globus_sdk . NativeAppAuthClient ( self . _client_id ) self . _load_secrets ( )", "nl": "init_ cliends will obtain the tranfer and access tokens and then use them to create a transfer client ."}}
{"translation": {"code": "def push ( self , path , name , tag = None ) : # Split the name into endpoint and rest endpoint , remote = self . _parse_endpoint_name ( name ) path = os . path . abspath ( path ) image = os . path . basename ( path ) bot . debug ( \"PUSH %s\" % path ) # Flatten image uri into image name q = parse_image_name ( image ) if not os . path . exists ( path ) : bot . error ( '%s does not exist.' % path ) sys . exit ( 1 ) # Ensure we have a transfer client if not hasattr ( self , 'transfer_client' ) : self . _init_transfer_client ( ) # The user must have a personal endpoint endpoints = self . _get_endpoints ( ) if len ( endpoints [ 'my-endpoints' ] ) == 0 : bot . error ( 'You must have a personal endpoint to transfer the container' ) sys . exit ( 1 ) # Take the first endpoint that is active source_endpoint = None for eid , contender in endpoints [ 'my-endpoints' ] . items ( ) : if contender [ 'gcp_connected' ] is True : source_endpoint = contender break # Exit if none are active, required! if source_endpoint is None : bot . error ( 'No activated local endpoints online! Go online to transfer' ) sys . exit ( 1 ) # The destination endpoint should have an .singularity/shub folder set self . _create_endpoint_cache ( endpoint ) # SREGISTRY_STORAGE must be an endpoint # if the image isn't already there, add it first added = self . add ( image_path = path , image_uri = q [ 'uri' ] , copy = True ) label = \"Singularity Registry Transfer for %s\" % added . name tdata = globus_sdk . TransferData ( self . transfer_client , source_endpoint [ 'id' ] , endpoint , label = label , sync_level = \"checksum\" ) image = \".singularity/shub/%s\" % image tdata . add_item ( added . image , image ) bot . info ( 'Requesting transfer from local %s to %s:%s' % ( SREGISTRY_STORAGE , endpoint , image ) ) transfer_result = self . transfer_client . submit_transfer ( tdata ) bot . info ( transfer_result [ 'message' ] ) return transfer_result", "nl": "push an image to Globus endpoint . In this case the name is the globus endpoint id and path ."}}
{"translation": {"code": "def create_endpoint_folder ( self , endpoint_id , folder ) : try : res = self . transfer_client . operation_mkdir ( endpoint_id , folder ) bot . info ( \"%s --> %s\" % ( res [ 'message' ] , folder ) ) except TransferAPIError : bot . info ( '%s already exists at endpoint' % folder )", "nl": "create an endpoint folder catching the error if it exists ."}}
{"translation": {"code": "def delete_backend ( backend ) : settings = read_client_secrets ( ) if backend in settings : del settings [ backend ] # If the backend was the active client, remove too if 'SREGISTRY_CLIENT' in settings : if settings [ 'SREGISTRY_CLIENT' ] == backend : del settings [ 'SREGISTRY_CLIENT' ] update_secrets ( settings ) print ( '[delete] %s' % backend ) else : if backend is not None : print ( '%s is not a known client.' % backend ) else : print ( 'Please specify a backend to delete.' )", "nl": "delete a backend and update the secrets file"}}
{"translation": {"code": "def activate ( backend ) : settings = read_client_secrets ( ) if backend is not None : settings [ 'SREGISTRY_CLIENT' ] = backend update_secrets ( settings ) print ( '[activate] %s' % backend )", "nl": "activate a backend by adding it to the . sregistry configuration file ."}}
{"translation": {"code": "def status ( backend ) : print ( '[backend status]' ) settings = read_client_secrets ( ) print ( 'There are %s clients found in secrets.' % len ( settings ) ) if 'SREGISTRY_CLIENT' in settings : print ( 'active: %s' % settings [ 'SREGISTRY_CLIENT' ] ) update_secrets ( settings ) else : print ( 'There is no active client.' )", "nl": "print the status for all or one of the backends ."}}
{"translation": {"code": "def add ( backend , variable , value , force = False ) : print ( '[add]' ) settings = read_client_secrets ( ) # If the variable begins with the SREGISTRY_<CLIENT> don't add it prefix = 'SREGISTRY_%s_' % backend . upper ( ) if not variable . startswith ( prefix ) : variable = '%s%s' % ( prefix , variable ) # All must be uppercase variable = variable . upper ( ) bot . info ( \"%s %s\" % ( variable , value ) ) # Does the setting already exist? if backend in settings : if variable in settings [ backend ] and force is False : previous = settings [ backend ] [ variable ] bot . error ( '%s is already set as %s. Use --force to override.' % ( variable , previous ) ) sys . exit ( 1 ) if backend not in settings : settings [ backend ] = { } settings [ backend ] [ variable ] = value update_secrets ( settings )", "nl": "add the variable to the config"}}
{"translation": {"code": "def remove ( backend , variable ) : print ( '[remove]' ) settings = read_client_secrets ( ) # If the variable begins with the SREGISTRY_<CLIENT> don't add it prefixed = variable prefix = 'SREGISTRY_%s_' % backend . upper ( ) if not variable . startswith ( prefix ) : prefixed = '%s%s' % ( prefix , variable ) # All must be uppercase variable = variable . upper ( ) bot . info ( variable ) # Does the setting already exist? if backend in settings : if variable in settings [ backend ] : del settings [ backend ] [ variable ] if prefixed in settings [ backend ] : del settings [ backend ] [ prefixed ] update_secrets ( settings )", "nl": "remove a variable from the config if found ."}}
{"translation": {"code": "def update_token ( headers ) : try : from awscli . clidriver import create_clidriver except : bot . exit ( 'Please install pip install sregistry[aws]' ) driver = create_clidriver ( ) aws = driver . session . create_client ( 'ecr' ) tokens = aws . get_authorization_token ( ) token = tokens [ 'authorizationData' ] [ 0 ] [ 'authorizationToken' ] try : token = { \"Authorization\" : \"Basic %s\" % token } headers . update ( token ) except Exception : bot . error ( \"Error getting token.\" ) sys . exit ( 1 ) return headers", "nl": "update_token uses HTTP basic authentication to attempt to authenticate given a 401 response . We take as input previous headers and update them ."}}
{"translation": {"code": "def stream ( url , headers , stream_to = None , retry = True ) : bot . debug ( \"GET %s\" % url ) if DISABLE_SSL_CHECK is True : bot . warning ( 'Verify of certificates disabled! ::TESTING USE ONLY::' ) # Ensure headers are present, update if not response = requests . get ( url , headers = headers , verify = not DISABLE_SSL_CHECK , stream = True ) # If we get permissions error, one more try with updated token if response . status_code in [ 401 , 403 ] : headers = update_token ( headers ) return stream ( url , headers , stream_to , retry = False ) # Successful Response elif response . status_code == 200 : # Keep user updated with Progress Bar content_size = None if 'Content-Length' in response . headers : progress = 0 content_size = int ( response . headers [ 'Content-Length' ] ) bot . show_progress ( progress , content_size , length = 35 ) chunk_size = 1 << 20 with open ( stream_to , 'wb' ) as filey : for chunk in response . iter_content ( chunk_size = chunk_size ) : filey . write ( chunk ) if content_size is not None : progress += chunk_size bot . show_progress ( iteration = progress , total = content_size , length = 35 , carriage_return = False ) # Newline to finish download sys . stdout . write ( '\\n' ) return stream_to bot . error ( \"Problem with stream, response %s\" % ( response . status_code ) ) sys . exit ( 1 )", "nl": "stream is a get that will stream to file_name . Since this is a worker task it differs from the client provided version in that it requires headers ."}}
{"translation": {"code": "def download ( url , file_name , headers = None , show_progress = True ) : fd , tmp_file = tempfile . mkstemp ( prefix = ( \"%s.tmp.\" % file_name ) ) os . close ( fd ) if DISABLE_SSL_CHECK is True : bot . warning ( 'Verify of certificates disabled! ::TESTING USE ONLY::' ) verify = not DISABLE_SSL_CHECK response = stream ( url , headers = headers , stream_to = tmp_file ) shutil . move ( tmp_file , file_name ) return file_name", "nl": "stream to a temporary file rename on successful completion"}}
{"translation": {"code": "def get_manifest ( self , repo_name , tag ) : image = None repo = self . aws . describe_images ( repositoryName = repo_name ) if 'imageDetails' in repo : for contender in repo . get ( 'imageDetails' ) : if tag in contender [ 'imageTags' ] : image = contender break # if the image isn't found, we need to exit if image is None : bot . exit ( 'Cannot find %s:%s, is the uri correct?' % ( repo_name , digest ) ) digest = image [ 'imageDigest' ] digests = self . aws . batch_get_image ( repositoryName = repo_name , imageIds = [ { \"imageDigest\" : digest , \"imageTag\" : tag } ] ) self . manifest = json . loads ( digests [ 'images' ] [ 0 ] [ 'imageManifest' ] ) return self . manifest", "nl": "return the image manifest via the aws client saved in self . manifest"}}
{"translation": {"code": "def get_tmpdir ( requested_tmpdir = None , prefix = \"\" , create = True ) : from sregistry . defaults import SREGISTRY_TMPDIR # First priority for the base goes to the user requested. tmpdir = requested_tmpdir or SREGISTRY_TMPDIR prefix = prefix or \"sregistry-tmp\" prefix = \"%s.%s\" % ( prefix , next ( tempfile . _get_candidate_names ( ) ) ) tmpdir = os . path . join ( tmpdir , prefix ) if not os . path . exists ( tmpdir ) and create is True : os . mkdir ( tmpdir ) return tmpdir", "nl": "get a temporary directory for an operation . If SREGISTRY_TMPDIR is set return that . Otherwise return the output of tempfile . mkdtemp"}}
{"translation": {"code": "def _update_base ( self ) : self . base = self . _get_and_update_setting ( 'SREGISTRY_GITLAB_BASE' , \"https://gitlab.com/\" ) self . api_base = \"%s/api/v4\" % self . base . strip ( '/' ) self . artifacts = self . _get_and_update_setting ( 'SREGISTRY_GITLAB_FOLDER' , 'build' ) self . job = self . _get_and_update_setting ( 'SREGISTRY_GITLAB_JOB' , 'build' ) bot . debug ( '      Api: %s' % self . api_base ) bot . debug ( 'Artifacts: %s' % self . artifacts ) bot . debug ( '      Job: %s' % self . job )", "nl": "update the base including the URL for GitLab and the API endpoint ."}}
{"translation": {"code": "def _update_secrets ( self ) : self . token = self . _required_get_and_update ( 'SREGISTRY_GITLAB_TOKEN' ) self . headers [ \"Private-Token\" ] = self . token", "nl": "update secrets will update metadata needed for pull and search"}}
{"translation": {"code": "def search ( self , query = None , args = None ) : if query is None : bot . exit ( 'You must include a collection query, <collection>/<repo>' ) # or default to listing (searching) all things. return self . _search_all ( query )", "nl": "query a GitLab artifacts folder for a list of images . If query is None collections are listed ."}}
{"translation": {"code": "def search_all ( self , collection , job_id = None ) : results = [ [ 'job_id' , 'browser' ] ] url = \"%s/projects/%s/jobs\" % ( self . api_base , quote_plus ( collection . strip ( '/' ) ) ) response = requests . get ( url , headers = self . headers ) if response . status_code == 200 : jobs = response . json ( ) # We can't get a listing of artifacts # https://gitlab.com/gitlab-org/gitlab-ce/issues/51515 # Parse through jobs (each can have different tags for a collection): for job in jobs : # Only show jobs that are successful if job [ 'status' ] == 'success' : name = job [ 'name' ] for artifact in job [ 'artifacts' ] : if artifact [ 'filename' ] . endswith ( 'zip' ) : # The user must browse to see the names artifact_url = ( \"%s/%s/-/jobs/%s/artifacts/browse/%s\" % ( self . base , collection , job [ 'id' ] , name ) ) results . append ( [ str ( job [ 'id' ] ) , artifact_url ] ) if len ( results ) == 1 : bot . info ( \"No potential archives found in artifacts.\" ) sys . exit ( 0 ) bot . info ( \"Artifact Browsers (you will need path and job id for pull)\" ) bot . table ( results ) return results", "nl": "a show all search that doesn t require a query the user is shown URLs to"}}
{"translation": {"code": "def _get_metadata ( self ) : metadata = { 'SREGISTRY_GITLAB_FOLDER' : self . artifacts , 'api_base' : self . api_base , 'SREGISTRY_GITLAB_BASE' : self . base , 'SREGISTRY_GITLAB_JOB' : self . job } return metadata", "nl": "since the user needs a job id and other parameters save this for them ."}}