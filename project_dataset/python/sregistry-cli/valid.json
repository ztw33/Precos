{"translation": {"code": "def get_collections ( self ) : collections = [ ] for container in self . conn . get_account ( ) [ 1 ] : collections . append ( container [ 'name' ] ) return collections", "nl": "get a listing of collections that the user has access to ."}}
{"translation": {"code": "def _update_secrets ( self ) : # Get the swift authentication type first.  That will determine what we # will need to collect for proper authentication self . config [ 'SREGISTRY_SWIFT_AUTHTYPE' ] = self . _required_get_and_update ( 'SREGISTRY_SWIFT_AUTHTYPE' ) # Check what auth version is requested and setup the connection if self . config [ 'SREGISTRY_SWIFT_AUTHTYPE' ] == 'preauth' : # Pre-Authenticated Token/URL - Use OS_AUTH_TOKEN/OS_STORAGE_URL # Retrieve the user token, user, and base. Exit if not found  for envar in [ 'SREGISTRY_SWIFT_OS_AUTH_TOKEN' , 'SREGISTRY_SWIFT_OS_STORAGE_URL' ] : self . config [ envar ] = self . _required_get_and_update ( envar ) self . conn = swiftclient . Connection ( preauthurl = self . config [ 'SREGISTRY_SWIFT_OS_STORAGE_URL' ] , preauthtoken = self . config [ 'SREGISTRY_SWIFT_OS_AUTH_TOKEN' ] ) elif self . config [ 'SREGISTRY_SWIFT_AUTHTYPE' ] == 'keystonev3' : # Keystone v3 Authentication # Retrieve the user token, user, and base. Exit if not found  for envar in [ 'SREGISTRY_SWIFT_USER' , 'SREGISTRY_SWIFT_TOKEN' , 'SREGISTRY_SWIFT_URL' ] : self . config [ envar ] = self . _required_get_and_update ( envar ) auth_url = '%s/v3' % self . config [ 'SREGISTRY_SWIFT_URL' ] # Setting to default as a safety.  No v3 environment to test # May require ENV vars for real use. - M. Moore _os_options = { 'user_domain_name' : 'Default' , 'project_domain_name' : 'Default' , 'project_name' : 'Default' } # Save the connection to use for some command self . conn = swiftclient . Connection ( user = self . config [ 'SREGISTRY_SWIFT_USER' ] , key = self . config [ 'SREGISTRY_SWIFT_TOKEN' ] , os_options = _os_options , authurl = auth_url , auth_version = '3' ) elif self . config [ 'SREGISTRY_SWIFT_AUTHTYPE' ] == 'keystonev2' : # Keystone v2 Authentication # Retrieve the user token, user, and base. Exit if not found  for envar in [ 'SREGISTRY_SWIFT_USER' , 'SREGISTRY_SWIFT_TOKEN' , 'SREGISTRY_SWIFT_TENANT' , 'SREGISTRY_SWIFT_REGION' , 'SREGISTRY_SWIFT_URL' ] : self . config [ envar ] = self . _required_get_and_update ( envar ) # More human friendly to interact with auth_url = '%s/v2.0/' % self . config [ 'SREGISTRY_SWIFT_URL' ] # Set required OpenStack options for tenant/region _os_options = { 'tenant_name' : self . config [ 'SREGISTRY_SWIFT_TENANT' ] , 'region_name' : self . config [ 'SREGISTRY_SWIFT_REGION' ] } # Save the connection to use for some command self . conn = swiftclient . Connection ( user = self . config [ 'SREGISTRY_SWIFT_USER' ] , key = self . config [ 'SREGISTRY_SWIFT_TOKEN' ] , os_options = _os_options , authurl = auth_url , auth_version = '2' ) else : # Legacy Authentication # Retrieve the user token, user, and base. Exit if not found  for envar in [ 'SREGISTRY_SWIFT_USER' , 'SREGISTRY_SWIFT_TOKEN' , 'SREGISTRY_SWIFT_URL' ] : self . config [ envar ] = self . _required_get_and_update ( envar ) # More human friendly to interact with auth_url = '%s/auth/' % self . config [ 'SREGISTRY_SWIFT_URL' ] # Save the connection to use for some command self . conn = swiftclient . Connection ( user = self . config [ 'SREGISTRY_SWIFT_USER' ] , key = self . config [ 'SREGISTRY_SWIFT_TOKEN' ] , authurl = auth_url , )", "nl": "update secrets will look for a user and token in the environment If we find the values cache and continue . Otherwise exit with error"}}
{"translation": {"code": "def required_get_and_update ( self , name , default = None ) : setting = self . _get_and_update_setting ( name , default = None ) if setting in [ None , \"\" ] : bot . exit ( 'You must export %s' % name ) return setting", "nl": "a wrapper to get_and_update but if not successful will print an error and exit ."}}
{"translation": {"code": "def push ( self , path , name , tag = None ) : path = os . path . abspath ( path ) image = os . path . basename ( path ) bot . debug ( \"PUSH %s\" % path ) if not os . path . exists ( path ) : bot . error ( '%s does not exist.' % path ) sys . exit ( 1 ) # Extract the metadata names = parse_image_name ( remove_uri ( name ) , tag = tag ) image_size = os . path . getsize ( path ) >> 20 # Create extra metadata, this is how we identify the image later # *important* bug in boto3 will return these capitalized # see https://github.com/boto/boto3/issues/1709 metadata = { 'sizemb' : \"%s\" % image_size , 'client' : 'sregistry' } self . bucket . upload_file ( path , names [ 'storage_uri' ] , { \"Metadata\" : metadata } )", "nl": "push an image to an S3 endpoint"}}
{"translation": {"code": "def update_blob_metadata ( blob , response , config , bucket , names ) : manifest = os . path . basename ( response [ 'results' ] [ 'artifactManifest' ] ) manifest = json . loads ( bucket . blob ( manifest ) . download_as_string ( ) ) metadata = { 'file_hash' : manifest [ 'file_hash' ] [ 0 ] [ 'file_hash' ] [ 0 ] [ 'value' ] , 'artifactManifest' : response [ 'results' ] [ 'artifactManifest' ] , 'location' : manifest [ 'location' ] , 'storageSourceBucket' : config [ 'source' ] [ 'storageSource' ] [ 'bucket' ] , 'storageSourceObject' : config [ 'source' ] [ 'storageSource' ] [ 'object' ] , 'buildCommand' : ' ' . join ( config [ 'steps' ] [ 0 ] [ 'args' ] ) , 'builder' : config [ 'steps' ] [ 0 ] [ 'name' ] , 'media_link' : blob . media_link , 'self_link' : blob . self_link , 'size' : blob . size , 'name' : names [ 'tag_uri' ] , 'type' : \"container\" } # identifier that the blob is a container blob . metadata = metadata blob . _properties [ 'metadata' ] = metadata blob . patch ( )", "nl": "a specific function to take a blob along with a SUCCESS response from Google build the original config and update the blob metadata with the artifact file name dependencies and image hash ."}}
{"translation": {"code": "def list_containers ( self ) : results = [ ] for image in self . _bucket . list_blobs ( ) : if image . metadata is not None : if \"type\" in image . metadata : if image . metadata [ 'type' ] == \"container\" : results . append ( image ) if len ( results ) == 0 : bot . info ( \"No containers found, based on metadata type:container\" ) return results", "nl": "return a list of containers determined by finding the metadata field type with value container . We alert the user to no containers if results is empty and exit"}}
{"translation": {"code": "def list_logs ( self ) : results = [ ] for image in self . _bucket . list_blobs ( ) : if image . name . endswith ( 'log' ) : results . append ( image ) if len ( results ) == 0 : bot . info ( \"No containers found, based on extension .log\" ) return results", "nl": "return a list of logs . We return any file that ends in . log"}}
{"translation": {"code": "def logs ( self , name = None ) : content = None results = self . _list_logs ( ) print ( results ) # If we are searching for a name if name is not None : for result in results : matches = False # Case 1: the name is in the storage path if name in result . name : matches = True # Case 2: match in metadata for key , val in result . metadata . items ( ) : if name in val : matches = True if matches is True : content = self . _print_log ( result . name ) # Otherwise return the last else : if len ( results ) > 0 : latest = results [ 0 ] # Get the most recent for result in results : if result . time_created >= latest . time_created : latest = result content = self . _print_log ( result . name ) return content", "nl": "return logs for a particular container . The logs file is equivalent to the name but with extension . log . If there is no name the most recent log is returned ."}}
{"translation": {"code": "def delete_object ( service , bucket_name , object_name ) : try : operation = service . objects ( ) . delete ( bucket = bucket_name , object = object_name ) . execute ( ) except HttpError as e : pass operation = e return operation", "nl": "delete object will delete a file from a bucket"}}
{"translation": {"code": "def print_output ( response , output_file = None ) : # If successful built, show container uri if response [ 'status' ] == 'SUCCESS' : bucket = response [ 'artifacts' ] [ 'objects' ] [ 'location' ] obj = response [ 'artifacts' ] [ 'objects' ] [ 'paths' ] [ 0 ] bot . custom ( \"MD5HASH\" , response [ 'file_hash' ] , 'CYAN' ) bot . custom ( \"SIZE\" , response [ 'size' ] , 'CYAN' ) bot . custom ( response [ 'status' ] , bucket + obj , 'CYAN' ) else : bot . custom ( response [ 'status' ] , 'see logs for details' , 'CYAN' ) # Show the logs no matter what bot . custom ( \"LOGS\" , response [ 'logUrl' ] , 'CYAN' ) # Did the user make the container public? if \"public_url\" in response : bot . custom ( 'URL' , response [ 'public_url' ] , 'CYAN' ) # Does the user also need writing to an output file? if output_file != None : with open ( output_file , 'w' ) as filey : if response [ 'status' ] == 'SUCCESS' : filey . writelines ( 'MD5HASH %s\\n' % response [ 'file_hash' ] ) filey . writelines ( 'SIZE %s\\n' % response [ 'size' ] ) filey . writelines ( '%s %s%s\\n' % ( response [ 'status' ] , bucket , obj ) ) filey . writelines ( 'LOGS %s\\n' % response [ 'logUrl' ] ) if \"public_url\" in response : filey . writelines ( 'URL %s\\n' % response [ 'public_url' ] )", "nl": "print the output to the console for the user . If the user wants the content also printed to an output file do that ."}}