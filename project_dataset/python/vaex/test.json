{"translation": {"code": "def _root_nodes ( self ) : # these lists (~used as ordered set) keep track of leafes and root nodes # root nodes root_nodes = [ ] leafes = [ ] def walk ( node ) : # this function recursively walks the expression graph if isinstance ( node , six . string_types ) : # we end up at a leaf leafes . append ( node ) if node in root_nodes : # so it cannot be a root node root_nodes . remove ( node ) else : node_repr , fname , fobj , deps = node if node_repr in self . virtual_columns : # we encountered a virtual column, similar behaviour as leaf leafes . append ( node_repr ) if node_repr in root_nodes : root_nodes . remove ( node_repr ) # resursive part for dep in deps : walk ( dep ) for column in self . virtual_columns . keys ( ) : if column not in leafes : root_nodes . append ( column ) node = self [ column ] . _graph ( ) # we don't do the virtual column itself, just it's depedencies node_repr , fname , fobj , deps = node for dep in deps : walk ( dep ) return root_nodes", "nl": "Returns a list of string which are the virtual columns that are not used in any other virtual column ."}}
{"translation": {"code": "def _graphviz ( self , dot = None ) : from graphviz import Graph , Digraph node = self . _graph ( ) dot = dot or Digraph ( comment = self . expression ) def walk ( node ) : if isinstance ( node , six . string_types ) : dot . node ( node , node ) return node , node else : node_repr , fname , fobj , deps = node node_id = node_repr dot . node ( node_id , node_repr ) for dep in deps : dep_id , dep = walk ( dep ) dot . edge ( node_id , dep_id ) return node_id , node walk ( node ) return dot", "nl": "Return a graphviz . Digraph object with a graph of the expression"}}
{"translation": {"code": "def _graphviz ( self , dot = None ) : from graphviz import Digraph dot = dot or Digraph ( comment = 'whole dataframe' ) root_nodes = self . _root_nodes ( ) for column in root_nodes : self [ column ] . _graphviz ( dot = dot ) return dot", "nl": "Return a graphviz . Digraph object with a graph of all virtual columns"}}
{"translation": {"code": "def vrange ( start , stop , step = 1 , dtype = 'f8' ) : from . column import ColumnVirtualRange return ColumnVirtualRange ( start , stop , step , dtype )", "nl": "Creates a virtual column which is the equivalent of numpy . arange but uses 0 memory"}}
{"translation": {"code": "def str_strip ( x , to_strip = None ) : # in c++ we give empty string the same meaning as None sl = _to_string_sequence ( x ) . strip ( '' if to_strip is None else to_strip ) if to_strip != '' else x return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Removes leading and trailing characters ."}}
{"translation": {"code": "def str_lower ( x ) : sl = _to_string_sequence ( x ) . lower ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Converts string samples to lower case ."}}
{"translation": {"code": "def str_capitalize ( x ) : sl = _to_string_sequence ( x ) . capitalize ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Capitalize the first letter of a string sample ."}}
{"translation": {"code": "def str_contains ( x , pattern , regex = True ) : return _to_string_sequence ( x ) . search ( pattern , regex )", "nl": "Check if a string pattern or regex is contained within a sample of a string column ."}}
{"translation": {"code": "def register_function ( scope = None , as_property = False , name = None ) : prefix = '' if scope : prefix = scope + \"_\" if scope not in scopes : raise KeyError ( \"unknown scope\" ) def wrapper ( f , name = name ) : name = name or f . __name__ # remove possible prefix if name . startswith ( prefix ) : name = name [ len ( prefix ) : ] full_name = prefix + name if scope : def closure ( name = name , full_name = full_name , function = f ) : def wrapper ( self , * args , * * kwargs ) : lazy_func = getattr ( self . expression . ds . func , full_name ) args = ( self . expression , ) + args return lazy_func ( * args , * * kwargs ) return functools . wraps ( function ) ( wrapper ) if as_property : setattr ( scopes [ scope ] , name , property ( closure ( ) ) ) else : setattr ( scopes [ scope ] , name , closure ( ) ) else : def closure ( name = name , full_name = full_name , function = f ) : def wrapper ( self , * args , * * kwargs ) : lazy_func = getattr ( self . ds . func , full_name ) args = ( self , ) + args return lazy_func ( * args , * * kwargs ) return functools . wraps ( function ) ( wrapper ) setattr ( vaex . expression . Expression , name , closure ( ) ) vaex . expression . expression_namespace [ prefix + name ] = f return f # we leave the original function as is return wrapper", "nl": "Decorator to register a new function with vaex ."}}
{"translation": {"code": "def dt_is_leap_year ( x ) : import pandas as pd return pd . Series ( x ) . dt . is_leap_year . values", "nl": "Check whether a year is a leap year ."}}
{"translation": {"code": "def dt_day ( x ) : import pandas as pd return pd . Series ( x ) . dt . day . values", "nl": "Extracts the day from a datetime sample ."}}
{"translation": {"code": "def str_rindex ( x , sub , start = 0 , end = None ) : return str_rfind ( x , sub , start , end )", "nl": "Returns the highest indices in each string in a column where the provided substring is fully contained between within a sample . If the substring is not found - 1 is returned . Same as str . rfind ."}}
{"translation": {"code": "def str_repeat ( x , repeats ) : sl = _to_string_sequence ( x ) . repeat ( repeats ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Duplicate each string in a column ."}}
{"translation": {"code": "def str_pad ( x , width , side = 'left' , fillchar = ' ' ) : sl = _to_string_sequence ( x ) . pad ( width , fillchar , side in [ 'left' , 'both' ] , side in [ 'right' , 'both' ] ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Pad strings in a given column ."}}
{"translation": {"code": "def str_find ( x , sub , start = 0 , end = None ) : return _to_string_sequence ( x ) . find ( sub , start , 0 if end is None else end , end is None , True )", "nl": "Returns the lowest indices in each string in a column where the provided substring is fully contained between within a sample . If the substring is not found - 1 is returned ."}}
{"translation": {"code": "def str_index ( x , sub , start = 0 , end = None ) : return str_find ( x , sub , start , end )", "nl": "Returns the lowest indices in each string in a column where the provided substring is fully contained between within a sample . If the substring is not found - 1 is returned . It is the same as str . find ."}}