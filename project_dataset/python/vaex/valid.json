{"translation": {"code": "def str_lstrip ( x , to_strip = None ) : # in c++ we give empty string the same meaning as None sl = _to_string_sequence ( x ) . lstrip ( '' if to_strip is None else to_strip ) if to_strip != '' else x return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Remove leading characters from a string sample ."}}
{"translation": {"code": "def str_slice ( x , start = 0 , stop = None ) : # TODO: support n if stop is None : sll = _to_string_sequence ( x ) . slice_string_end ( start ) else : sll = _to_string_sequence ( x ) . slice_string ( start , stop ) return sll", "nl": "Slice substrings from each string element in a column ."}}
{"translation": {"code": "def str_rstrip ( x , to_strip = None ) : # in c++ we give empty string the same meaning as None sl = _to_string_sequence ( x ) . rstrip ( '' if to_strip is None else to_strip ) if to_strip != '' else x return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Remove trailing characters from a string sample ."}}
{"translation": {"code": "def str_upper ( x ) : sl = _to_string_sequence ( x ) . upper ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Converts all strings in a column to uppercase ."}}
{"translation": {"code": "def nop ( self , expression , progress = False , delay = False ) : expression = _ensure_string_from_expression ( expression ) def map ( ar ) : pass def reduce ( a , b ) : pass return self . map_reduce ( map , reduce , [ expression ] , delay = delay , progress = progress , name = 'nop' , to_numpy = False )", "nl": "Evaluates expression and drop the result usefull for benchmarking since vaex is usually lazy"}}
{"translation": {"code": "def str_count ( x , pat , regex = False ) : return _to_string_sequence ( x ) . count ( pat , regex )", "nl": "Count the occurences of a pattern in sample of a string column ."}}
{"translation": {"code": "def str_cat ( x , other ) : sl1 = _to_string_sequence ( x ) sl2 = _to_string_sequence ( other ) sl = sl1 . concat ( sl2 ) return column . ColumnStringArrow . from_string_sequence ( sl )", "nl": "Concatenate two string columns on a row - by - row basis ."}}
{"translation": {"code": "def dt_second ( x ) : import pandas as pd return pd . Series ( x ) . dt . second . values", "nl": "Extracts the second out of a datetime samples ."}}
{"translation": {"code": "def dt_month ( x ) : import pandas as pd return pd . Series ( x ) . dt . month . values", "nl": "Extracts the month out of a datetime sample ."}}
{"translation": {"code": "def dt_month_name ( x ) : import pandas as pd return pd . Series ( _pandas_dt_fix ( x ) ) . dt . month_name ( ) . values . astype ( str )", "nl": "Returns the month names of a datetime sample in English ."}}
{"translation": {"code": "def dt_day_name ( x ) : import pandas as pd return pd . Series ( _pandas_dt_fix ( x ) ) . dt . day_name ( ) . values . astype ( str )", "nl": "Returns the day names of a datetime sample in English ."}}
{"translation": {"code": "def dt_minute ( x ) : import pandas as pd return pd . Series ( x ) . dt . minute . values", "nl": "Extracts the minute out of a datetime samples ."}}
{"translation": {"code": "def str_title ( x ) : sl = _to_string_sequence ( x ) . title ( ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Converts all string samples to titlecase ."}}
{"translation": {"code": "def str_get ( x , i ) : x = _to_string_sequence ( x ) if i == - 1 : sl = x . slice_string_end ( - 1 ) else : sl = x . slice_string ( i , i + 1 ) return column . ColumnStringArrow ( sl . bytes , sl . indices , sl . length , sl . offset , string_sequence = sl )", "nl": "Extract a character from each sample at the specified position from a string column . Note that if the specified position is out of bound of the string sample this method returns while pandas retunrs nan ."}}
{"translation": {"code": "def str_rfind ( x , sub , start = 0 , end = None ) : return _to_string_sequence ( x ) . find ( sub , start , 0 if end is None else end , end is None , False )", "nl": "Returns the highest indices in each string in a column where the provided substring is fully contained between within a sample . If the substring is not found - 1 is returned ."}}